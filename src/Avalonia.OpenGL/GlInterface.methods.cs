
/*

    FUNCTION DOCUMENTATION FROM: https://github.com/KhronosGroup/OpenGL-Refpages/blob/master/gl4

    API DOCUMENTATION LICENSE:
    Copyright (C) 2010-2014 Khronos Group.
    This material may be distributed subject to the terms and conditions set forth in
    the Open Publication License, v 1.0, 8 June 1999.                    
    http://opencontent.org/openpub/

*/

                    
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Avalonia.OpenGL
{
    public unsafe partial class GlInterface
    {

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Accum(AccumOp op, float value) => _Accum(op, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AccumxOES(int op, float value) => _AccumxOES(op, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ActiveProgramEXT(uint program) => _ActiveProgramEXT(program);

        // ---

        /// <summary>
        /// glActiveShaderProgram sets the linked program named by program            to be the active program for the program pipeline object pipeline. The active            program in the active program pipeline object is the target of calls to glUniform            when no program has been made current through a call to glUseProgram.
        /// </summary>
        /// <param name="pipeline">Specifies the program pipeline object to set the active program object for.</param>
        /// <param name="program">Specifies the program object to set as the active program pipeline object pipeline.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ActiveShaderProgram(uint pipeline, uint program) => _ActiveShaderProgram(pipeline, program);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ActiveShaderProgramEXT(uint pipeline, uint program) => _ActiveShaderProgramEXT(pipeline, program);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ActiveStencilFaceEXT(StencilFaceDirection face) => _ActiveStencilFaceEXT(face);

        // ---

        /// <summary>
        /// glActiveTexture selects which texture unit subsequent texture state calls will            affect.  The number of texture units an implementation supports is            implementation dependent, but must be at least 80.
        /// </summary>
        /// <param name="texture">Specifies which texture unit to make active. The number                    of texture units is implementation dependent, but must                    be at least 80. texture must be                    one of                    GL_TEXTUREi,                    where i ranges from zero to the value                    of                    GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS                    minus one. The initial value is                    GL_TEXTURE0.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ActiveTexture(TextureUnit texture) => _ActiveTexture(texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ActiveTextureARB(TextureUnit texture) => _ActiveTextureARB(texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ActiveVaryingNV(uint program, string name) => _ActiveVaryingNV(program, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ActiveVaryingNV(uint program, void* name) => _ActiveVaryingNV_ptr(program, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ActiveVaryingNV(uint program, IntPtr name) => _ActiveVaryingNV_intptr(program, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AlphaFragmentOp1ATI(FragmentOpATI op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod) => _AlphaFragmentOp1ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AlphaFragmentOp2ATI(FragmentOpATI op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod) => _AlphaFragmentOp2ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AlphaFragmentOp3ATI(FragmentOpATI op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod) => _AlphaFragmentOp3ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AlphaFunc(AlphaFunction func, float @ref) => _AlphaFunc(func, @ref);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AlphaFuncQCOM(int func, float @ref) => _AlphaFuncQCOM(func, @ref);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AlphaFuncx(AlphaFunction func, float @ref) => _AlphaFuncx(func, @ref);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AlphaFuncxOES(AlphaFunction func, float @ref) => _AlphaFuncxOES(func, @ref);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AlphaToCoverageDitherControlNV(int mode) => _AlphaToCoverageDitherControlNV(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ApplyFramebufferAttachmentCMAAINTEL() => _ApplyFramebufferAttachmentCMAAINTEL();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ApplyTextureEXT(LightTextureModeEXT mode) => _ApplyTextureEXT(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool AcquireKeyedMutexWin32EXT(uint memory, UInt64 key, uint timeout) => _AcquireKeyedMutexWin32EXT(memory, key, timeout);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool AreProgramsResidentNV(int n, uint[] programs, bool[] residences) => _AreProgramsResidentNV(n, programs, residences);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool AreProgramsResidentNV(int n, void* programs, void* residences) => _AreProgramsResidentNV_ptr(n, programs, residences);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool AreProgramsResidentNV(int n, IntPtr programs, IntPtr residences) => _AreProgramsResidentNV_intptr(n, programs, residences);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool AreTexturesResident(int n, uint[] textures, bool[] residences) => _AreTexturesResident(n, textures, residences);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool AreTexturesResident(int n, void* textures, void* residences) => _AreTexturesResident_ptr(n, textures, residences);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool AreTexturesResident(int n, IntPtr textures, IntPtr residences) => _AreTexturesResident_intptr(n, textures, residences);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool AreTexturesResidentEXT(int n, uint[] textures, bool[] residences) => _AreTexturesResidentEXT(n, textures, residences);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool AreTexturesResidentEXT(int n, void* textures, void* residences) => _AreTexturesResidentEXT_ptr(n, textures, residences);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool AreTexturesResidentEXT(int n, IntPtr textures, IntPtr residences) => _AreTexturesResidentEXT_intptr(n, textures, residences);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ArrayElement(int i) => _ArrayElement(i);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ArrayElementEXT(int i) => _ArrayElementEXT(i);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ArrayObjectATI(EnableCap array, int size, ScalarType type, int stride, uint buffer, uint offset) => _ArrayObjectATI(array, size, type, stride, buffer, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, uint[] waitSemaphoreArray, UInt64[] fenceValueArray, uint readGpu, int writeGpuMask, uint readBuffer, uint writeBuffer, IntPtr readOffset, IntPtr writeOffset, IntPtr size, int signalSemaphoreCount, uint[] signalSemaphoreArray, UInt64[] signalValueArray) => _AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, void* waitSemaphoreArray, void* fenceValueArray, uint readGpu, int writeGpuMask, uint readBuffer, uint writeBuffer, IntPtr readOffset, IntPtr writeOffset, IntPtr size, int signalSemaphoreCount, void* signalSemaphoreArray, void* signalValueArray) => _AsyncCopyBufferSubDataNVX_ptr(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, IntPtr waitSemaphoreArray, IntPtr fenceValueArray, uint readGpu, int writeGpuMask, uint readBuffer, uint writeBuffer, IntPtr readOffset, IntPtr writeOffset, IntPtr size, int signalSemaphoreCount, IntPtr signalSemaphoreArray, IntPtr signalValueArray) => _AsyncCopyBufferSubDataNVX_intptr(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, uint[] waitSemaphoreArray, UInt64[] waitValueArray, uint srcGpu, int dstGpuMask, uint srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint[] signalSemaphoreArray, UInt64[] signalValueArray) => _AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, void* waitSemaphoreArray, void* waitValueArray, uint srcGpu, int dstGpuMask, uint srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, void* signalSemaphoreArray, void* signalValueArray) => _AsyncCopyImageSubDataNVX_ptr(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, IntPtr waitSemaphoreArray, IntPtr waitValueArray, uint srcGpu, int dstGpuMask, uint srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, IntPtr signalSemaphoreArray, IntPtr signalValueArray) => _AsyncCopyImageSubDataNVX_intptr(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AsyncMarkerSGIX(uint marker) => _AsyncMarkerSGIX(marker);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AttachObjectARB(int containerObj, int obj) => _AttachObjectARB(containerObj, obj);

        // ---

        /// <summary>
        /// In order to create a complete shader program, there must be a way to        specify the list of things that will be linked together. Program        objects provide this mechanism. Shaders that are to be linked        together in a program object must first be attached to that        program object. glAttachShader attaches the        shader object specified by shader to the        program object specified by program. This        indicates that shader will be included in        link operations that will be performed on        program.
        /// All operations that can be performed on a shader object        are valid whether or not the shader object is attached to a        program object. It is permissible to attach a shader object to a        program object before source code has been loaded into the        shader object or before the shader object has been compiled. It        is permissible to attach multiple shader objects of the same        type because each may contain a portion of the complete shader.        It is also permissible to attach a shader object to more than        one program object. If a shader object is deleted while it is        attached to a program object, it will be flagged for deletion,        and deletion will not occur until        glDetachShader        is called to detach it from all program objects to which it is        attached.
        /// </summary>
        /// <param name="program">Specifies the program object to which a shader                    object will be attached.</param>
        /// <param name="shader">Specifies the shader object that is to be attached.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AttachShader(uint program, uint shader) => _AttachShader(program, shader);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Begin(PrimitiveType mode) => _Begin(mode);

        // ---

        /// <summary>
        /// Conditional rendering is started using glBeginConditionalRender and ended using glEndConditionalRender.            During conditional rendering, all vertex array commands, as well as glClear and            glClearBuffer have no effect if the (GL_SAMPLES_PASSED) result            of the query object id is zero, or if the (GL_ANY_SAMPLES_PASSED) result is GL_FALSE.            The results of commands setting the current vertex state, such as glVertexAttrib are            undefined. If the (GL_SAMPLES_PASSED) result is non-zero or if the (GL_ANY_SAMPLES_PASSED) result is            GL_TRUE, such commands are not discarded. The id parameter to glBeginConditionalRender            must be the name of a query object previously returned from a call to glGenQueries.            mode specifies how the results of the query object are to be interpreted. If mode is            GL_QUERY_WAIT, the GL waits for the results of the query to be available and then uses the results to determine if subsequent            rendering commands are discarded. If mode is GL_QUERY_NO_WAIT, the GL may choose to unconditionally            execute the subsequent rendering commands without waiting for the query to complete.
        /// If mode is GL_QUERY_BY_REGION_WAIT, the GL will also wait for occlusion query results and discard            rendering commands if the result of the occlusion query is zero. If the query result is non-zero, subsequent rendering commands are executed,            but the GL may discard the results of the commands for any region of the framebuffer that did not contribute to the sample count in the specified            occlusion query. Any such discarding is done in an implementation-dependent manner, but the rendering command results may not be discarded for            any samples that contributed to the occlusion query sample count. If mode is GL_QUERY_BY_REGION_NO_WAIT,            the GL operates as in GL_QUERY_BY_REGION_WAIT, but may choose to unconditionally execute the subsequent rendering commands            without waiting for the query to complete.
        /// </summary>
        /// <param name="id">Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded.</param>
        /// <param name="mode">Specifies how glBeginConditionalRender interprets the results of the occlusion query.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginConditionalRender(uint id, ConditionalRenderMode mode) => _BeginConditionalRender(id, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginConditionalRenderNV(uint id, ConditionalRenderMode mode) => _BeginConditionalRenderNV(id, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginConditionalRenderNVX(uint id) => _BeginConditionalRenderNVX(id);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginFragmentShaderATI() => _BeginFragmentShaderATI();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginOcclusionQueryNV(uint id) => _BeginOcclusionQueryNV(id);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginPerfMonitorAMD(uint monitor) => _BeginPerfMonitorAMD(monitor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginPerfQueryINTEL(uint queryHandle) => _BeginPerfQueryINTEL(queryHandle);

        // ---

        /// <summary>
        /// glBeginQuery and glEndQuery delimit the            boundaries of a query object.  query must be a name previously returned from a call to            glGenQueries. If a query object with name id            does not yet exist it is created with the type determined by target. target must            be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED,            GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. The behavior of the query            object depends on its type and is as follows.
        /// If target is GL_SAMPLES_PASSED, id must be an unused name,            or the name of an existing occlusion query object.            When glBeginQuery is executed, the query object's samples-passed counter is reset to 0.  Subsequent            rendering will increment the counter for every sample that passes the depth test.  If the value of GL_SAMPLE_BUFFERS            is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of GL_SAMPLE_BUFFERS            is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their            discression may instead increase the samples-passed count by the value of GL_SAMPLES if any sample in the fragment            is covered. When glEndQuery            is executed, the samples-passed counter is assigned to the query object's result value.  This value can be queried by            calling glGetQueryObject with pnameGL_QUERY_RESULT.
        /// If target is GL_ANY_SAMPLES_PASSED or GL_ANY_SAMPLES_PASSED_CONSERVATIVE,            id must be an unused name, or the name of an existing boolean occlusion query object.            When glBeginQuery is executed, the query object's samples-passed flag is reset to GL_FALSE.            Subsequent rendering causes the flag to be set to GL_TRUE if any sample passes the depth test in the case of GL_ANY_SAMPLES_PASSED,            or if the implementation determines that any sample might pass the depth test in the case of GL_ANY_SAMPLES_PASSED_CONSERVATIVE.            The implementation may be able to provide a more efficient test in the case of GL_ANY_SAMPLES_PASSED_CONSERVATIVE            if some false positives are acceptable to the application.  When            glEndQuery is executed, the samples-passed flag is assigned to the query object's result value.  This value can            be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.
        /// If target is GL_PRIMITIVES_GENERATED, id must be an unused            name, or the name of an existing primitive query object previously bound to the GL_PRIMITIVES_GENERATED query binding.            When glBeginQuery is executed, the query object's primitives-generated counter is reset to 0.  Subsequent            rendering will increment the counter once for every vertex that is emitted from the geometry shader, or from the vertex shader if            no geometry shader is present.  When glEndQuery is executed, the primitives-generated counter is assigned to            the query object's result value.  This value can be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.
        /// If target is GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, id must be            an unused name, or the name of an existing primitive query object previously bound to the GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN            query binding. When glBeginQuery is executed, the query object's primitives-written counter is reset to 0.  Subsequent            rendering will increment the counter once for every vertex that is written into the bound transform feedback buffer(s).  If transform feedback            mode is not activated between the call to glBeginQuery and glEndQuery, the counter will not be            incremented.  When glEndQuery is executed, the primitives-written counter is assigned to            the query object's result value.  This value can be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.
        /// If target is GL_TIME_ELAPSED, id must be            an unused name, or the name of an existing timer query object previously bound to the GL_TIME_ELAPSED            query binding. When glBeginQuery is executed, the query object's time counter is reset to 0.  When glEndQuery            is executed, the elapsed server time that has passed since the call to glBeginQuery is written into the query object's            time counter.  This value can be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.
        /// Querying the GL_QUERY_RESULT implicitly flushes the GL pipeline until the rendering delimited by the            query object has completed and the result is available.  GL_QUERY_RESULT_AVAILABLE can be queried to            determine if the result is immediately available or if the rendering is not yet complete.
        /// </summary>
        /// <param name="target">Specifies the target type of query object established between                    glBeginQuery and the subsequent glEndQuery.                    The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,                    GL_ANY_SAMPLES_PASSED_CONSERVATIVE,                    GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or                    GL_TIME_ELAPSED.</param>
        /// <param name="id">Specifies the name of a query object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginQuery(QueryTarget target, uint id) => _BeginQuery(target, id);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginQueryARB(int target, uint id) => _BeginQueryARB(target, id);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginQueryEXT(QueryTarget target, uint id) => _BeginQueryEXT(target, id);

        // ---

        /// <summary>
        /// glBeginQueryIndexed and glEndQueryIndexed delimit the            boundaries of a query object.  query must be a name previously returned from a call to            glGenQueries. If a query object with name id            does not yet exist it is created with the type determined by target. target must            be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED,            GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED. The behavior of the query            object depends on its type and is as follows.
        /// index specifies the index of the query target and must be between a target-specific            maximum.
        /// If target is GL_SAMPLES_PASSED, id must be an unused name,            or the name of an existing occlusion query object.            When glBeginQueryIndexed is executed, the query object's samples-passed counter is reset to 0.  Subsequent            rendering will increment the counter for every sample that passes the depth test.  If the value of GL_SAMPLE_BUFFERS            is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of GL_SAMPLE_BUFFERS            is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their            discression may instead increase the samples-passed count by the value of GL_SAMPLES if any sample in the fragment            is covered. When glEndQueryIndexed            is executed, the samples-passed counter is assigned to the query object's result value.  This value can be queried by            calling glGetQueryObject with pnameGL_QUERY_RESULT.            When target is GL_SAMPLES_PASSED, index must be zero.
        /// If target is GL_ANY_SAMPLES_PASSED, id must be an unused name,            or the name of an existing boolean occlusion query object.            When glBeginQueryIndexed is executed, the query object's samples-passed flag is reset to GL_FALSE.            Subsequent rendering causes the flag to be set to GL_TRUE if any sample passes the depth test.  When            glEndQueryIndexed is executed, the samples-passed flag is assigned to the query object's result value.  This value can            be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.            When target is GL_ANY_SAMPLES_PASSED, index must be zero.
        /// If target is GL_PRIMITIVES_GENERATED, id must be an unused            name, or the name of an existing primitive query object previously bound to the GL_PRIMITIVES_GENERATED query binding.            When glBeginQueryIndexed is executed, the query object's primitives-generated counter is reset to 0.  Subsequent            rendering will increment the counter once for every vertex that is emitted from the geometry shader to the stream given by index,            or from the vertex shader if index is zero and no geometry shader is present.            When glEndQueryIndexed is executed, the primitives-generated counter for stream index is assigned to            the query object's result value.  This value can be queried by calling glGetQueryObject            with pnameGL_QUERY_RESULT.            When target is GL_PRIMITIVES_GENERATED, index must be            less than the value of GL_MAX_VERTEX_STREAMS.
        /// If target is GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, id must be            an unused name, or the name of an existing primitive query object previously bound to the GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN            query binding. When glBeginQueryIndexed is executed, the query object's primitives-written counter for the stream specified by            index is reset to 0.  Subsequent rendering will increment the counter once for every vertex that is written into the bound            transform feedback buffer(s) for stream index.  If transform feedback            mode is not activated between the call to glBeginQueryIndexed and glEndQueryIndexed, the counter will not be            incremented.  When glEndQueryIndexed is executed, the primitives-written counter for stream index is assigned to            the query object's result value.  This value can be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.            When target is GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, index must be            less than the value of GL_MAX_VERTEX_STREAMS.
        /// If target is GL_TIME_ELAPSED, id must be            an unused name, or the name of an existing timer query object previously bound to the GL_TIME_ELAPSED            query binding. When glBeginQueryIndexed is executed, the query object's time counter is reset to 0.  When glEndQueryIndexed            is executed, the elapsed server time that has passed since the call to glBeginQueryIndexed is written into the query object's            time counter.  This value can be queried by calling glGetQueryObject with pnameGL_QUERY_RESULT.            When target is GL_TIME_ELAPSED, index must be zero.
        /// Querying the GL_QUERY_RESULT implicitly flushes the GL pipeline until the rendering delimited by the            query object has completed and the result is available.  GL_QUERY_RESULT_AVAILABLE can be queried to            determine if the result is immediately available or if the rendering is not yet complete.
        /// </summary>
        /// <param name="target">Specifies the target type of query object established between                    glBeginQueryIndexed and the subsequent glEndQueryIndexed.                    The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,                    GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or                    GL_TIME_ELAPSED.</param>
        /// <param name="index">Specifies the index of the query target upon which to begin the query.</param>
        /// <param name="id">Specifies the name of a query object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginQueryIndexed(QueryTarget target, uint index, uint id) => _BeginQueryIndexed(target, index, id);

        // ---

        /// <summary>
        /// Transform feedback mode captures the values of varying variables written by the vertex shader (or, if active, the geometry shader).            Transform feedback is said to be active after a call to glBeginTransformFeedback            until a subsequent call to glEndTransformFeedback.            Transform feedback commands must be paired.
        /// If no geometry shader is present, while transform feedback is active the mode parameter to            glDrawArrays must match those specified            in the following table:
        /// Transform Feedback primitiveMode                                 Allowed Render Primitive modesGL_POINTSGL_POINTSGL_LINESGL_LINES,                            GL_LINE_LOOP,                            GL_LINE_STRIP,                            GL_LINES_ADJACENCY,                            GL_LINE_STRIP_ADJACENCYGL_TRIANGLESGL_TRIANGLES,                             GL_TRIANGLE_STRIP,                             GL_TRIANGLE_FAN,                            GL_TRIANGLES_ADJACENCY,                             GL_TRIANGLE_STRIP_ADJACENCY
        /// If a geometry shader is present, the output primitive type from the geometry shader must match those            provided in the following table:
        /// Transform Feedback primitiveMode                                Allowed Geometry Shader Output Primitive Type                            GL_POINTSpointsGL_LINESline_stripGL_TRIANGLEStriangle_strip
        /// </summary>
        /// <param name="primitiveMode">Specify the output type of the primitives that will be recorded into the                    buffer objects that are bound for transform feedback.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginTransformFeedback(PrimitiveType primitiveMode) => _BeginTransformFeedback(primitiveMode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginTransformFeedbackEXT(PrimitiveType primitiveMode) => _BeginTransformFeedbackEXT(primitiveMode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginTransformFeedbackNV(PrimitiveType primitiveMode) => _BeginTransformFeedbackNV(primitiveMode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginVertexShaderEXT() => _BeginVertexShaderEXT();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginVideoCaptureNV(uint video_capture_slot) => _BeginVideoCaptureNV(video_capture_slot);

        // ---

        /// <summary>
        /// glBindAttribLocation is used to    associate a user-defined attribute variable in the program    object specified by program with a    generic vertex attribute index. The name of the user-defined    attribute variable is passed as a null terminated string in    name. The generic vertex attribute index    to be bound to this variable is specified by    index. When    program is made part of current state,    values provided via the generic vertex attribute    index will modify the value of the    user-defined attribute variable specified by    name.
        /// If name refers to a matrix    attribute variable, index refers to the    first column of the matrix. Other matrix columns are then    automatically bound to locations index+1    for a matrix of type mat2; index+1 and    index+2 for a matrix of type mat3; and    index+1, index+2,    and index+3 for a matrix of type    mat4.
        /// This command makes it possible for vertex shaders to use    descriptive names for attribute variables rather than generic    variables that are numbered from zero to the value of    GL_MAX_VERTEX_ATTRIBS minus one. The values sent    to each generic attribute index are part of current state.    If a different program object is made current by calling    glUseProgram,    the generic vertex attributes are tracked in such a way that the    same values will be observed by attributes in the new program    object that are also bound to    index.
        /// Attribute variable    name-to-generic attribute index bindings for a program object    can be explicitly assigned at any time by calling    glBindAttribLocation. Attribute bindings do    not go into effect until    glLinkProgram    is called. After a program object has been linked successfully,    the index values for generic attributes remain fixed (and their    values can be queried) until the next link command    occurs.
        /// Any attribute binding that occurs after the program object has been linked will not take effect    until the next time the program object is linked.
        /// </summary>
        /// <param name="program">Specifies the handle of the program object in            which the association is to be made.</param>
        /// <param name="index">Specifies the index of the generic vertex            attribute to be bound.</param>
        /// <param name="name">Specifies a null terminated string containing            the name of the vertex shader attribute variable to            which index is to be            bound.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindAttribLocation(uint program, uint index, string name) => _BindAttribLocation(program, index, name);

        /// <summary>
        /// glBindAttribLocation is used to    associate a user-defined attribute variable in the program    object specified by program with a    generic vertex attribute index. The name of the user-defined    attribute variable is passed as a null terminated string in    name. The generic vertex attribute index    to be bound to this variable is specified by    index. When    program is made part of current state,    values provided via the generic vertex attribute    index will modify the value of the    user-defined attribute variable specified by    name.
        /// If name refers to a matrix    attribute variable, index refers to the    first column of the matrix. Other matrix columns are then    automatically bound to locations index+1    for a matrix of type mat2; index+1 and    index+2 for a matrix of type mat3; and    index+1, index+2,    and index+3 for a matrix of type    mat4.
        /// This command makes it possible for vertex shaders to use    descriptive names for attribute variables rather than generic    variables that are numbered from zero to the value of    GL_MAX_VERTEX_ATTRIBS minus one. The values sent    to each generic attribute index are part of current state.    If a different program object is made current by calling    glUseProgram,    the generic vertex attributes are tracked in such a way that the    same values will be observed by attributes in the new program    object that are also bound to    index.
        /// Attribute variable    name-to-generic attribute index bindings for a program object    can be explicitly assigned at any time by calling    glBindAttribLocation. Attribute bindings do    not go into effect until    glLinkProgram    is called. After a program object has been linked successfully,    the index values for generic attributes remain fixed (and their    values can be queried) until the next link command    occurs.
        /// Any attribute binding that occurs after the program object has been linked will not take effect    until the next time the program object is linked.
        /// </summary>
        /// <param name="program">Specifies the handle of the program object in            which the association is to be made.</param>
        /// <param name="index">Specifies the index of the generic vertex            attribute to be bound.</param>
        /// <param name="name">Specifies a null terminated string containing            the name of the vertex shader attribute variable to            which index is to be            bound.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindAttribLocation(uint program, uint index, void* name) => _BindAttribLocation_ptr(program, index, name);

        /// <summary>
        /// glBindAttribLocation is used to    associate a user-defined attribute variable in the program    object specified by program with a    generic vertex attribute index. The name of the user-defined    attribute variable is passed as a null terminated string in    name. The generic vertex attribute index    to be bound to this variable is specified by    index. When    program is made part of current state,    values provided via the generic vertex attribute    index will modify the value of the    user-defined attribute variable specified by    name.
        /// If name refers to a matrix    attribute variable, index refers to the    first column of the matrix. Other matrix columns are then    automatically bound to locations index+1    for a matrix of type mat2; index+1 and    index+2 for a matrix of type mat3; and    index+1, index+2,    and index+3 for a matrix of type    mat4.
        /// This command makes it possible for vertex shaders to use    descriptive names for attribute variables rather than generic    variables that are numbered from zero to the value of    GL_MAX_VERTEX_ATTRIBS minus one. The values sent    to each generic attribute index are part of current state.    If a different program object is made current by calling    glUseProgram,    the generic vertex attributes are tracked in such a way that the    same values will be observed by attributes in the new program    object that are also bound to    index.
        /// Attribute variable    name-to-generic attribute index bindings for a program object    can be explicitly assigned at any time by calling    glBindAttribLocation. Attribute bindings do    not go into effect until    glLinkProgram    is called. After a program object has been linked successfully,    the index values for generic attributes remain fixed (and their    values can be queried) until the next link command    occurs.
        /// Any attribute binding that occurs after the program object has been linked will not take effect    until the next time the program object is linked.
        /// </summary>
        /// <param name="program">Specifies the handle of the program object in            which the association is to be made.</param>
        /// <param name="index">Specifies the index of the generic vertex            attribute to be bound.</param>
        /// <param name="name">Specifies a null terminated string containing            the name of the vertex shader attribute variable to            which index is to be            bound.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindAttribLocation(uint program, uint index, IntPtr name) => _BindAttribLocation_intptr(program, index, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindAttribLocationARB(int programObj, uint index, string name) => _BindAttribLocationARB(programObj, index, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindAttribLocationARB(int programObj, uint index, void* name) => _BindAttribLocationARB_ptr(programObj, index, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindAttribLocationARB(int programObj, uint index, IntPtr name) => _BindAttribLocationARB_intptr(programObj, index, name);

        // ---

        /// <summary>
        /// glBindBuffer binds a buffer object to the specified buffer binding point. Calling glBindBuffer with            target set to one of the accepted symbolic constants and buffer set to the name            of a buffer object binds that buffer object name to the target. If no buffer object with name buffer            exists, one is created with that name. When a buffer object is bound to a target, the previous binding for that            target is automatically broken.
        /// Buffer object names are unsigned integers. The value zero is reserved, but            there is no default buffer object for each buffer object target. Instead, buffer set to zero            effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target (if supported for that target).            Buffer object names and the corresponding buffer object contents are local to            the shared object space of the current            GL rendering context;            two rendering contexts share buffer object names only if they            explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.
        /// glGenBuffers must be used to generate a set of unused buffer object names.
        /// The state of a buffer object immediately after it is first bound is an unmapped zero-sized memory buffer with            GL_READ_WRITE access and GL_STATIC_DRAW usage.
        /// While a non-zero buffer object name is bound, GL operations on the target to which it is            bound affect the bound buffer object, and queries of the target to which it is bound return state            from the bound buffer object. While buffer object name zero is bound, as in the initial state,            attempts to modify or query state on the target to which it is bound generates an            GL_INVALID_OPERATION error.
        /// When a non-zero buffer object is bound to the GL_ARRAY_BUFFER target,            the vertex array pointer parameter is interpreted as an offset within the            buffer object measured in basic machine units.
        /// When a non-zero buffer object is bound to the GL_DRAW_INDIRECT_BUFFER target,            parameters for draws issued through glDrawArraysIndirect            and glDrawElementsIndirect are sourced            from the specified offset in that buffer object's data store.
        /// When a non-zero buffer object is bound to the GL_DISPATCH_INDIRECT_BUFFER target,            the parameters for compute dispatches issued through glDispatchComputeIndirect            are sourced from the specified offset in that buffer object's data store.
        /// While a non-zero buffer object is bound to the GL_ELEMENT_ARRAY_BUFFER target,            the indices parameter of glDrawElements,            glDrawElementsInstanced,            glDrawElementsBaseVertex,            glDrawRangeElements,            glDrawRangeElementsBaseVertex,            glMultiDrawElements, or            glMultiDrawElementsBaseVertex is interpreted as an            offset within the buffer object measured in basic machine units.
        /// While a non-zero buffer object is bound to the GL_PIXEL_PACK_BUFFER target,            the following commands are affected: glGetCompressedTexImage,            glGetTexImage, and            glReadPixels. The pointer parameter is            interpreted as an offset within the buffer object measured in basic machine units.
        /// While a non-zero buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target,            the following commands are affected:            glCompressedTexImage1D,            glCompressedTexImage2D,            glCompressedTexImage3D,            glCompressedTexSubImage1D,            glCompressedTexSubImage2D,            glCompressedTexSubImage3D,            glTexImage1D,            glTexImage2D,            glTexImage3D,            glTexSubImage1D,            glTexSubImage2D, and            glTexSubImage3D. The pointer parameter is            interpreted as an offset within the buffer object measured in basic machine units.
        /// The buffer targets GL_COPY_READ_BUFFER and GL_COPY_WRITE_BUFFER            are provided to allow glCopyBufferSubData            to be used without disturbing the state of other bindings. However, glCopyBufferSubData            may be used with any pair of buffer binding points.
        /// The GL_TRANSFORM_FEEDBACK_BUFFER buffer binding point may be passed to glBindBuffer,            but will not directly affect transform feedback state. Instead, the indexed GL_TRANSFORM_FEEDBACK_BUFFER            bindings must be used through a call to glBindBufferBase            or glBindBufferRange. This will affect the generic            GL_TRANSFORM_FEEDBACK_BUFFER binding.
        /// Likewise, the GL_UNIFORM_BUFFER, GL_ATOMIC_COUNTER_BUFFER and GL_SHADER_STORAGE_BUFFER            buffer binding points may            be used, but do not directly affect uniform buffer, atomic counter buffer or shader storage buffer state, respectively.            glBindBufferBase            or glBindBufferRange must be used to bind a buffer to            an indexed uniform buffer, atomic counter buffer or shader storage buffer binding point.
        /// The GL_QUERY_BUFFER binding point is used to specify a buffer object that is to            receive the results of query objects through calls to the glGetQueryObject            family of commands.
        /// A buffer object binding created with glBindBuffer remains active until a different            buffer object name is bound to the same target, or until the bound buffer object is            deleted with glDeleteBuffers.
        /// Once created, a named buffer object may be re-bound to any target as often as needed. However,            the GL implementation may make choices about how to optimize the storage of a buffer object based            on its initial binding target.
        /// </summary>
        /// <param name="target">Specifies the target to which the buffer object is                    bound, which must be one of the buffer binding targets                    in the following table:</param>
        /// <param name="buffer">Specifies the name of a buffer object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBuffer(BufferTargetARB target, uint buffer) => _BindBuffer(target, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBufferARB(BufferTargetARB target, uint buffer) => _BindBufferARB(target, buffer);

        // ---

        /// <summary>
        /// glBindBufferBase binds the buffer object buffer            to the binding point at index index of the array of targets specified            by target. Each target represents an indexed            array of buffer binding points, as well as a single general binding point that can be used by            other buffer manipulation functions such as glBindBuffer            or glMapBuffer. In addition to binding            buffer to the indexed buffer binding target, glBindBufferBase            also binds buffer to the generic buffer binding point specified by target.
        /// </summary>
        /// <param name="target">Specify the target of the bind operation. target must be                    one of GL_ATOMIC_COUNTER_BUFFER,                    GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or                    GL_SHADER_STORAGE_BUFFER.</param>
        /// <param name="index">Specify the index of the binding point within the array specified by target.</param>
        /// <param name="buffer">The name of a buffer object to bind to the specified binding point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBufferBase(BufferTargetARB target, uint index, uint buffer) => _BindBufferBase(target, index, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBufferBaseEXT(BufferTargetARB target, uint index, uint buffer) => _BindBufferBaseEXT(target, index, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBufferBaseNV(BufferTargetARB target, uint index, uint buffer) => _BindBufferBaseNV(target, index, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBufferOffsetEXT(BufferTargetARB target, uint index, uint buffer, IntPtr offset) => _BindBufferOffsetEXT(target, index, buffer, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBufferOffsetNV(BufferTargetARB target, uint index, uint buffer, IntPtr offset) => _BindBufferOffsetNV(target, index, buffer, offset);

        // ---

        /// <summary>
        /// glBindBufferRange binds a range the buffer object buffer            represented by offset and size to the            binding point at index index of the array of targets specified by target.            Each target represents an indexed array of buffer binding points, as well            as a single general binding point that can be used by other buffer manipulation functions such as            glBindBuffer or            glMapBuffer. In addition to binding            a range of buffer to the indexed buffer binding target, glBindBufferRange            also binds the range to the generic buffer binding point specified by target.
        /// offset specifies the offset in basic machine units into the buffer object            buffer and size specifies the amount of data that            can be read from the buffer object while used as an indexed target.
        /// </summary>
        /// <param name="target">Specify the target of the bind operation. target must be                    one of GL_ATOMIC_COUNTER_BUFFER,                    GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER,                    or GL_SHADER_STORAGE_BUFFER.</param>
        /// <param name="index">Specify the index of the binding point within the array specified by target.</param>
        /// <param name="buffer">The name of a buffer object to bind to the specified binding point.</param>
        /// <param name="offset">The starting offset in basic machine units into the buffer object buffer.</param>
        /// <param name="size">The amount of data in machine units that can be read from the buffer object while used as an indexed target.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBufferRange(BufferTargetARB target, uint index, uint buffer, IntPtr offset, IntPtr size) => _BindBufferRange(target, index, buffer, offset, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBufferRangeEXT(BufferTargetARB target, uint index, uint buffer, IntPtr offset, IntPtr size) => _BindBufferRangeEXT(target, index, buffer, offset, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBufferRangeNV(BufferTargetARB target, uint index, uint buffer, IntPtr offset, IntPtr size) => _BindBufferRangeNV(target, index, buffer, offset, size);

        // ---

        /// <summary>
        /// glBindBuffersBase binds a set of count buffer objects whose names            are given in the array buffers to the count consecutive binding            points starting from index first of the array of targets specified            by target. If buffers is NULL then            glBindBuffersBase unbinds any buffers that are currently bound to the referenced binding points.            Assuming no errors are generated, it is equivalent to the following            pseudo-code, which calls glBindBufferBase,            with the exception that the non-indexed target is not changed by glBindBuffersBase:
        /// for (i = 0; i < count; i++) {        if (buffers != NULL) {            glBindBufferBase(target, first + i, buffers[i]);        } else {            glBindBufferBase(target, first + i, 0);        }    }
        /// Each entry in buffers will be checked individually and if found to be invalid, the state            for that buffer binding index will not be changed and an error will be generated. However, the state for            other buffer binding indices referenced by the command will still be updated.
        /// </summary>
        /// <param name="target">Specify the target of the bind operation. target must be                    one of GL_ATOMIC_COUNTER_BUFFER,                    GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or                    GL_SHADER_STORAGE_BUFFER.</param>
        /// <param name="first">Specify the index of the first binding point within the array specified by target.</param>
        /// <param name="count">Specify the number of contiguous binding points to which to bind buffers.</param>
        /// <param name="buffers">A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBuffersBase(BufferTargetARB target, uint first, int count, uint[] buffers) => _BindBuffersBase(target, first, count, buffers);

        /// <summary>
        /// glBindBuffersBase binds a set of count buffer objects whose names            are given in the array buffers to the count consecutive binding            points starting from index first of the array of targets specified            by target. If buffers is NULL then            glBindBuffersBase unbinds any buffers that are currently bound to the referenced binding points.            Assuming no errors are generated, it is equivalent to the following            pseudo-code, which calls glBindBufferBase,            with the exception that the non-indexed target is not changed by glBindBuffersBase:
        /// for (i = 0; i < count; i++) {        if (buffers != NULL) {            glBindBufferBase(target, first + i, buffers[i]);        } else {            glBindBufferBase(target, first + i, 0);        }    }
        /// Each entry in buffers will be checked individually and if found to be invalid, the state            for that buffer binding index will not be changed and an error will be generated. However, the state for            other buffer binding indices referenced by the command will still be updated.
        /// </summary>
        /// <param name="target">Specify the target of the bind operation. target must be                    one of GL_ATOMIC_COUNTER_BUFFER,                    GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or                    GL_SHADER_STORAGE_BUFFER.</param>
        /// <param name="first">Specify the index of the first binding point within the array specified by target.</param>
        /// <param name="count">Specify the number of contiguous binding points to which to bind buffers.</param>
        /// <param name="buffers">A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBuffersBase(BufferTargetARB target, uint first, int count, void* buffers) => _BindBuffersBase_ptr(target, first, count, buffers);

        /// <summary>
        /// glBindBuffersBase binds a set of count buffer objects whose names            are given in the array buffers to the count consecutive binding            points starting from index first of the array of targets specified            by target. If buffers is NULL then            glBindBuffersBase unbinds any buffers that are currently bound to the referenced binding points.            Assuming no errors are generated, it is equivalent to the following            pseudo-code, which calls glBindBufferBase,            with the exception that the non-indexed target is not changed by glBindBuffersBase:
        /// for (i = 0; i < count; i++) {        if (buffers != NULL) {            glBindBufferBase(target, first + i, buffers[i]);        } else {            glBindBufferBase(target, first + i, 0);        }    }
        /// Each entry in buffers will be checked individually and if found to be invalid, the state            for that buffer binding index will not be changed and an error will be generated. However, the state for            other buffer binding indices referenced by the command will still be updated.
        /// </summary>
        /// <param name="target">Specify the target of the bind operation. target must be                    one of GL_ATOMIC_COUNTER_BUFFER,                    GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or                    GL_SHADER_STORAGE_BUFFER.</param>
        /// <param name="first">Specify the index of the first binding point within the array specified by target.</param>
        /// <param name="count">Specify the number of contiguous binding points to which to bind buffers.</param>
        /// <param name="buffers">A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBuffersBase(BufferTargetARB target, uint first, int count, IntPtr buffers) => _BindBuffersBase_intptr(target, first, count, buffers);

        // ---

        /// <summary>
        /// glBindBuffersRange binds a set of count ranges from buffer objects whose names            are given in the array buffers to the count consecutive binding            points starting from index first of the array of targets specified            by target. offsets specifies the address of an array containing            count starting offsets within the buffers, and sizes specifies the            address of an array of count sizes of the ranges. If buffers is NULL then            offsets and sizes are ignored and glBindBuffersRange unbinds any            buffers that are currently bound to the referenced binding points. Assuming no errors are generated, it is equivalent to the following            pseudo-code, which calls glBindBufferRange,            with the exception that the non-indexed target is not changed by glBindBuffersRange:
        /// for (i = 0; i < count; i++) {        if (buffers != NULL) {            glBindBufferRange(target, first + i, buffers[i], offsets[i], sizes[i]);        } else {            glBindBufferRange(target, first + i, 0);        }    }
        /// Each entry in buffers, offsets, and sizes will be            checked individually and if found to be invalid, the state for that buffer binding index will not be changed and an            error will be generated. However, the state for other buffer binding indices referenced by the command will            still be updated.
        /// </summary>
        /// <param name="target">Specify the target of the bind operation. target must be                    one of GL_ATOMIC_COUNTER_BUFFER,                    GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or                    GL_SHADER_STORAGE_BUFFER.</param>
        /// <param name="first">Specify the index of the first binding point within the array specified by target.</param>
        /// <param name="count">Specify the number of contiguous binding points to which to bind buffers.</param>
        /// <param name="buffers">A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL.</param>
        /// <param name="offsets">A pointer to an array of offsets into the corresponding buffer in buffers to                        bind, or NULL if buffers is NULL.</param>
        /// <param name="sizes">A pointer to an array of sizes of the corresponding buffer in buffers to                        bind, or NULL if buffers is NULL.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBuffersRange(BufferTargetARB target, uint first, int count, uint[] buffers, IntPtr[] offsets, IntPtr[] sizes) => _BindBuffersRange(target, first, count, buffers, offsets, sizes);

        /// <summary>
        /// glBindBuffersRange binds a set of count ranges from buffer objects whose names            are given in the array buffers to the count consecutive binding            points starting from index first of the array of targets specified            by target. offsets specifies the address of an array containing            count starting offsets within the buffers, and sizes specifies the            address of an array of count sizes of the ranges. If buffers is NULL then            offsets and sizes are ignored and glBindBuffersRange unbinds any            buffers that are currently bound to the referenced binding points. Assuming no errors are generated, it is equivalent to the following            pseudo-code, which calls glBindBufferRange,            with the exception that the non-indexed target is not changed by glBindBuffersRange:
        /// for (i = 0; i < count; i++) {        if (buffers != NULL) {            glBindBufferRange(target, first + i, buffers[i], offsets[i], sizes[i]);        } else {            glBindBufferRange(target, first + i, 0);        }    }
        /// Each entry in buffers, offsets, and sizes will be            checked individually and if found to be invalid, the state for that buffer binding index will not be changed and an            error will be generated. However, the state for other buffer binding indices referenced by the command will            still be updated.
        /// </summary>
        /// <param name="target">Specify the target of the bind operation. target must be                    one of GL_ATOMIC_COUNTER_BUFFER,                    GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or                    GL_SHADER_STORAGE_BUFFER.</param>
        /// <param name="first">Specify the index of the first binding point within the array specified by target.</param>
        /// <param name="count">Specify the number of contiguous binding points to which to bind buffers.</param>
        /// <param name="buffers">A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL.</param>
        /// <param name="offsets">A pointer to an array of offsets into the corresponding buffer in buffers to                        bind, or NULL if buffers is NULL.</param>
        /// <param name="sizes">A pointer to an array of sizes of the corresponding buffer in buffers to                        bind, or NULL if buffers is NULL.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBuffersRange(BufferTargetARB target, uint first, int count, void* buffers, void* offsets, void* sizes) => _BindBuffersRange_ptr(target, first, count, buffers, offsets, sizes);

        /// <summary>
        /// glBindBuffersRange binds a set of count ranges from buffer objects whose names            are given in the array buffers to the count consecutive binding            points starting from index first of the array of targets specified            by target. offsets specifies the address of an array containing            count starting offsets within the buffers, and sizes specifies the            address of an array of count sizes of the ranges. If buffers is NULL then            offsets and sizes are ignored and glBindBuffersRange unbinds any            buffers that are currently bound to the referenced binding points. Assuming no errors are generated, it is equivalent to the following            pseudo-code, which calls glBindBufferRange,            with the exception that the non-indexed target is not changed by glBindBuffersRange:
        /// for (i = 0; i < count; i++) {        if (buffers != NULL) {            glBindBufferRange(target, first + i, buffers[i], offsets[i], sizes[i]);        } else {            glBindBufferRange(target, first + i, 0);        }    }
        /// Each entry in buffers, offsets, and sizes will be            checked individually and if found to be invalid, the state for that buffer binding index will not be changed and an            error will be generated. However, the state for other buffer binding indices referenced by the command will            still be updated.
        /// </summary>
        /// <param name="target">Specify the target of the bind operation. target must be                    one of GL_ATOMIC_COUNTER_BUFFER,                    GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or                    GL_SHADER_STORAGE_BUFFER.</param>
        /// <param name="first">Specify the index of the first binding point within the array specified by target.</param>
        /// <param name="count">Specify the number of contiguous binding points to which to bind buffers.</param>
        /// <param name="buffers">A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or NULL.</param>
        /// <param name="offsets">A pointer to an array of offsets into the corresponding buffer in buffers to                        bind, or NULL if buffers is NULL.</param>
        /// <param name="sizes">A pointer to an array of sizes of the corresponding buffer in buffers to                        bind, or NULL if buffers is NULL.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindBuffersRange(BufferTargetARB target, uint first, int count, IntPtr buffers, IntPtr offsets, IntPtr sizes) => _BindBuffersRange_intptr(target, first, count, buffers, offsets, sizes);

        // ---

        /// <summary>
        /// glBindFragDataLocation explicitly specifies the binding of the user-defined varying out variable            name to fragment shader color number colorNumber for program            program. If name was bound previously, its assigned binding is replaced            with colorNumber. name must be a null-terminated string. colorNumber            must be less than GL_MAX_DRAW_BUFFERS.
        /// The bindings specified by glBindFragDataLocation have no effect until program            is next linked. Bindings may be specified at any time after program has been created. Specifically,            they may be specified before shader objects are attached to the program. Therefore, any name may be specified in name,            including a name that is never used as a varying out variable in any fragment shader object. Names beginning with gl_ are            reserved by the GL.
        /// In addition to the errors generated by glBindFragDataLocation, the            program program will fail to link if:                                    The number of active outputs is greater than the value GL_MAX_DRAW_BUFFERS.                                            More than one varying out variable is bound to the same color number.
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to modify</param>
        /// <param name="colorNumber">The color number to bind the user-defined varying out variable to</param>
        /// <param name="name">The name of the user-defined varying out variable whose binding to modify</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFragDataLocation(uint program, uint color, string name) => _BindFragDataLocation(program, color, name);

        /// <summary>
        /// glBindFragDataLocation explicitly specifies the binding of the user-defined varying out variable            name to fragment shader color number colorNumber for program            program. If name was bound previously, its assigned binding is replaced            with colorNumber. name must be a null-terminated string. colorNumber            must be less than GL_MAX_DRAW_BUFFERS.
        /// The bindings specified by glBindFragDataLocation have no effect until program            is next linked. Bindings may be specified at any time after program has been created. Specifically,            they may be specified before shader objects are attached to the program. Therefore, any name may be specified in name,            including a name that is never used as a varying out variable in any fragment shader object. Names beginning with gl_ are            reserved by the GL.
        /// In addition to the errors generated by glBindFragDataLocation, the            program program will fail to link if:                                    The number of active outputs is greater than the value GL_MAX_DRAW_BUFFERS.                                            More than one varying out variable is bound to the same color number.
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to modify</param>
        /// <param name="colorNumber">The color number to bind the user-defined varying out variable to</param>
        /// <param name="name">The name of the user-defined varying out variable whose binding to modify</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFragDataLocation(uint program, uint color, void* name) => _BindFragDataLocation_ptr(program, color, name);

        /// <summary>
        /// glBindFragDataLocation explicitly specifies the binding of the user-defined varying out variable            name to fragment shader color number colorNumber for program            program. If name was bound previously, its assigned binding is replaced            with colorNumber. name must be a null-terminated string. colorNumber            must be less than GL_MAX_DRAW_BUFFERS.
        /// The bindings specified by glBindFragDataLocation have no effect until program            is next linked. Bindings may be specified at any time after program has been created. Specifically,            they may be specified before shader objects are attached to the program. Therefore, any name may be specified in name,            including a name that is never used as a varying out variable in any fragment shader object. Names beginning with gl_ are            reserved by the GL.
        /// In addition to the errors generated by glBindFragDataLocation, the            program program will fail to link if:                                    The number of active outputs is greater than the value GL_MAX_DRAW_BUFFERS.                                            More than one varying out variable is bound to the same color number.
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to modify</param>
        /// <param name="colorNumber">The color number to bind the user-defined varying out variable to</param>
        /// <param name="name">The name of the user-defined varying out variable whose binding to modify</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFragDataLocation(uint program, uint color, IntPtr name) => _BindFragDataLocation_intptr(program, color, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFragDataLocationEXT(uint program, uint color, string name) => _BindFragDataLocationEXT(program, color, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFragDataLocationEXT(uint program, uint color, void* name) => _BindFragDataLocationEXT_ptr(program, color, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFragDataLocationEXT(uint program, uint color, IntPtr name) => _BindFragDataLocationEXT_intptr(program, color, name);

        // ---

        /// <summary>
        /// glBindFragDataLocationIndexed specifies that the varying out variable name in            program should be bound to fragment color colorNumber when the program is next            linked. index may be zero or one to specify that the color be used as either the first or second color            input to the blend equation, respectively.
        /// The bindings specified by glBindFragDataLocationIndexed have no effect until program            is next linked. Bindings may be specified at any time after program has been created. Specifically,            they may be specified before shader objects are attached to the program. Therefore, any name may be specified in name,            including a name that is never used as a varying out variable in any fragment shader object. Names beginning with gl_ are            reserved by the GL.
        /// If name was bound previously, its assigned binding is replaced with colorNumber and            index. name must be a null-terminated string. index must be less than or equal to one,            and colorNumber must be less than the value of GL_MAX_DRAW_BUFFERS if index            is zero, and less than the value of GL_MAX_DUAL_SOURCE_DRAW_BUFFERS if index is greater than or equal to one.
        /// In addition to the errors generated by glBindFragDataLocationIndexed, the            program program will fail to link if:                                    The number of active outputs is greater than the value GL_MAX_DRAW_BUFFERS.                                            More than one varying out variable is bound to the same color number.
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to modify</param>
        /// <param name="colorNumber">The color number to bind the user-defined varying out variable to</param>
        /// <param name="index">The index of the color input to bind the user-defined varying out variable to</param>
        /// <param name="name">The name of the user-defined varying out variable whose binding to modify</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, string name) => _BindFragDataLocationIndexed(program, colorNumber, index, name);

        /// <summary>
        /// glBindFragDataLocationIndexed specifies that the varying out variable name in            program should be bound to fragment color colorNumber when the program is next            linked. index may be zero or one to specify that the color be used as either the first or second color            input to the blend equation, respectively.
        /// The bindings specified by glBindFragDataLocationIndexed have no effect until program            is next linked. Bindings may be specified at any time after program has been created. Specifically,            they may be specified before shader objects are attached to the program. Therefore, any name may be specified in name,            including a name that is never used as a varying out variable in any fragment shader object. Names beginning with gl_ are            reserved by the GL.
        /// If name was bound previously, its assigned binding is replaced with colorNumber and            index. name must be a null-terminated string. index must be less than or equal to one,            and colorNumber must be less than the value of GL_MAX_DRAW_BUFFERS if index            is zero, and less than the value of GL_MAX_DUAL_SOURCE_DRAW_BUFFERS if index is greater than or equal to one.
        /// In addition to the errors generated by glBindFragDataLocationIndexed, the            program program will fail to link if:                                    The number of active outputs is greater than the value GL_MAX_DRAW_BUFFERS.                                            More than one varying out variable is bound to the same color number.
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to modify</param>
        /// <param name="colorNumber">The color number to bind the user-defined varying out variable to</param>
        /// <param name="index">The index of the color input to bind the user-defined varying out variable to</param>
        /// <param name="name">The name of the user-defined varying out variable whose binding to modify</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, void* name) => _BindFragDataLocationIndexed_ptr(program, colorNumber, index, name);

        /// <summary>
        /// glBindFragDataLocationIndexed specifies that the varying out variable name in            program should be bound to fragment color colorNumber when the program is next            linked. index may be zero or one to specify that the color be used as either the first or second color            input to the blend equation, respectively.
        /// The bindings specified by glBindFragDataLocationIndexed have no effect until program            is next linked. Bindings may be specified at any time after program has been created. Specifically,            they may be specified before shader objects are attached to the program. Therefore, any name may be specified in name,            including a name that is never used as a varying out variable in any fragment shader object. Names beginning with gl_ are            reserved by the GL.
        /// If name was bound previously, its assigned binding is replaced with colorNumber and            index. name must be a null-terminated string. index must be less than or equal to one,            and colorNumber must be less than the value of GL_MAX_DRAW_BUFFERS if index            is zero, and less than the value of GL_MAX_DUAL_SOURCE_DRAW_BUFFERS if index is greater than or equal to one.
        /// In addition to the errors generated by glBindFragDataLocationIndexed, the            program program will fail to link if:                                    The number of active outputs is greater than the value GL_MAX_DRAW_BUFFERS.                                            More than one varying out variable is bound to the same color number.
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to modify</param>
        /// <param name="colorNumber">The color number to bind the user-defined varying out variable to</param>
        /// <param name="index">The index of the color input to bind the user-defined varying out variable to</param>
        /// <param name="name">The name of the user-defined varying out variable whose binding to modify</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, IntPtr name) => _BindFragDataLocationIndexed_intptr(program, colorNumber, index, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFragDataLocationIndexedEXT(uint program, uint colorNumber, uint index, string name) => _BindFragDataLocationIndexedEXT(program, colorNumber, index, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFragDataLocationIndexedEXT(uint program, uint colorNumber, uint index, void* name) => _BindFragDataLocationIndexedEXT_ptr(program, colorNumber, index, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFragDataLocationIndexedEXT(uint program, uint colorNumber, uint index, IntPtr name) => _BindFragDataLocationIndexedEXT_intptr(program, colorNumber, index, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFragmentShaderATI(uint id) => _BindFragmentShaderATI(id);

        // ---

        /// <summary>
        /// glBindFramebuffer binds the framebuffer object with name framebuffer to the framebuffer target specified            by target. target must be either GL_DRAW_FRAMEBUFFER,            GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER. If a framebuffer object is bound to            GL_DRAW_FRAMEBUFFER or GL_READ_FRAMEBUFFER, it becomes the target for            rendering or readback operations, respectively, until it is deleted or another framebuffer is bound to the corresponding bind point.            Calling glBindFramebuffer with target set to GL_FRAMEBUFFER binds            framebuffer to both the read and draw framebuffer targets. framebuffer is the name of a framebuffer            object previously returned from a call to glGenFramebuffers, or zero to break the existing            binding of a framebuffer object to target.
        /// </summary>
        /// <param name="target">Specifies the framebuffer target of the binding operation.</param>
        /// <param name="framebuffer">Specifies the name of the framebuffer object to bind.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFramebuffer(FramebufferTarget target, uint framebuffer) => _BindFramebuffer(target, framebuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFramebufferEXT(FramebufferTarget target, uint framebuffer) => _BindFramebufferEXT(target, framebuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindFramebufferOES(FramebufferTarget target, uint framebuffer) => _BindFramebufferOES(target, framebuffer);

        // ---

        /// <summary>
        /// glBindImageTexture binds a single level of a texture to an image unit for the purpose of            reading and writing it from shaders. unit specifies the zero-based index of the image            unit to which to bind the texture level. texture specifies the name of an existing texture            object to bind to the image unit. If texture is zero, then any existing binding to            the image unit is broken. level specifies the level of the texture to bind to the image            unit.
        /// If texture is the name of a one-, two-, or three-dimensional array texture, a cube map            or cube map array texture, or a two-dimensional multisample array texture, then it is possible to bind either            the entire array, or only a single layer of the array to the image unit. In such cases, if layered            is GL_TRUE, the entire array is attached to the image unit and layer            is ignored. However, if layered is GL_FALSE then layer            specifies the layer of the array to attach to the image unit.
        /// access specifies the access types to be performed by shaders and may be set to            GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE            to indicate read-only, write-only or read-write access, respectively. Violation of the access type specified in access            (for example, if a shader writes to an image bound with access set to GL_READ_ONLY)            will lead to undefined results, possibly including program termination.
        /// format specifies the format that is to be used when performing formatted stores into the            image from shaders. format must be compatible with the texture's internal format and must            be one of the formats listed in the following table.
        /// Internal Image Formats Image Unit Format  Format Qualifier GL_RGBA32Frgba32fGL_RGBA16Frgba16fGL_RG32Frg32fGL_RG16Frg16fGL_R11F_G11F_B10Fr11f_g11f_b10fGL_R32Fr32fGL_R16Fr16fGL_RGBA32UIrgba32uiGL_RGBA16UIrgba16uiGL_RGB10_A2UIrgb10_a2uiGL_RGBA8UIrgba8uiGL_RG32UIrg32uiGL_RG16UIrg16uiGL_RG8UIrg8uiGL_R32UIr32uiGL_R16UIr16uiGL_R8UIr8uiGL_RGBA32Irgba32iGL_RGBA16Irgba16iGL_RGBA8Irgba8iGL_RG32Irg32iGL_RG16Irg16iGL_RG8Irg8iGL_R32Ir32iGL_R16Ir16iGL_R8Ir8iGL_RGBA16rgba16GL_RGB10_A2rgb10_a2GL_RGBA8rgba8GL_RG16rg16GL_RG8rg8GL_R16r16GL_R8r8GL_RGBA16_SNORMrgba16_snormGL_RGBA8_SNORMrgba8_snormGL_RG16_SNORMrg16_snormGL_RG8_SNORMrg8_snormGL_R16_SNORMr16_snormGL_R8_SNORMr8_snorm
        /// When a texture is bound to an image unit, the format parameter for the image            unit need not exactly match the texture internal format as long as the formats are            considered compatible as defined in the OpenGL Specification. The matching criterion used            for a given texture may be determined by calling glGetTexParameter            with value            set to GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, with return values of GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE            and GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS, specifying matches by size and class, respectively.
        /// </summary>
        /// <param name="unit">Specifies the index of the image unit to which to bind the texture</param>
        /// <param name="texture">Specifies the name of the texture to bind to the image unit.</param>
        /// <param name="level">Specifies the level of the texture that is to be bound.</param>
        /// <param name="layered">Specifies whether a layered texture binding is to be established.</param>
        /// <param name="layer">If layered is GL_FALSE, specifies the layer of texture to be bound to the image unit. Ignored otherwise.</param>
        /// <param name="access">Specifies a token indicating the type of access that will be performed on the image.</param>
        /// <param name="format">Specifies the format that the elements of the image will be treated as for the purposes of formatted stores.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindImageTexture(uint unit, uint texture, int level, bool layered, int layer, BufferAccessARB access, InternalFormat format) => _BindImageTexture(unit, texture, level, layered, layer, access, format);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindImageTextureEXT(uint index, uint texture, int level, bool layered, int layer, BufferAccessARB access, int format) => _BindImageTextureEXT(index, texture, level, layered, layer, access, format);

        // ---

        /// <summary>
        /// glBindImageTextures binds images from an array of existing texture objects to a specified            number of consecutive image units. count specifies the number of texture            objects whose names are stored in the array textures. That number            of texture names are read from the array and bound to the count consecutive            texture units starting from first.            If the name zero appears in the textures array, any existing binding            to the image unit is reset. Any non-zero entry in textures must be the            name of an existing texture object. When a non-zero entry in textures is            present, the image at level zero is bound, the binding is considered layered, with the first            layer set to zero, and the image is bound for read-write access. The image unit format            parameter is taken from the internal format of the image at level zero of the texture object.            For cube map textures, the internal format of the positive X image of level zero is used.            If textures is NULL then it is as            if an appropriately sized array containing only zeros had been specified.
        /// glBindImageTextures is equivalent to the following pseudo code:
        /// for (i = 0; i < count; i++) {        if (textures == NULL || textures[i] = 0) {            glBindImageTexture(first + i, 0, 0, GL_FALSE, 0, GL_READ_ONLY, GL_R8);        } else {            glBindImageTexture(first + i, textures[i], 0, GL_TRUE, 0, GL_READ_WRITE, lookupInternalFormat(textures[i]));        }    }
        /// Each entry in textures will be checked individually and if found        to be invalid, the state for that image unit will not be changed and an error will be        generated. However, the state for other texture image units referenced by the command will still        be updated.
        /// </summary>
        /// <param name="first">Specifies the first image unit to which a texture is to be bound.</param>
        /// <param name="count">Specifies the number of textures to bind.</param>
        /// <param name="textures">Specifies the address of an array of names of existing texture objects.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindImageTextures(uint first, int count, uint[] textures) => _BindImageTextures(first, count, textures);

        /// <summary>
        /// glBindImageTextures binds images from an array of existing texture objects to a specified            number of consecutive image units. count specifies the number of texture            objects whose names are stored in the array textures. That number            of texture names are read from the array and bound to the count consecutive            texture units starting from first.            If the name zero appears in the textures array, any existing binding            to the image unit is reset. Any non-zero entry in textures must be the            name of an existing texture object. When a non-zero entry in textures is            present, the image at level zero is bound, the binding is considered layered, with the first            layer set to zero, and the image is bound for read-write access. The image unit format            parameter is taken from the internal format of the image at level zero of the texture object.            For cube map textures, the internal format of the positive X image of level zero is used.            If textures is NULL then it is as            if an appropriately sized array containing only zeros had been specified.
        /// glBindImageTextures is equivalent to the following pseudo code:
        /// for (i = 0; i < count; i++) {        if (textures == NULL || textures[i] = 0) {            glBindImageTexture(first + i, 0, 0, GL_FALSE, 0, GL_READ_ONLY, GL_R8);        } else {            glBindImageTexture(first + i, textures[i], 0, GL_TRUE, 0, GL_READ_WRITE, lookupInternalFormat(textures[i]));        }    }
        /// Each entry in textures will be checked individually and if found        to be invalid, the state for that image unit will not be changed and an error will be        generated. However, the state for other texture image units referenced by the command will still        be updated.
        /// </summary>
        /// <param name="first">Specifies the first image unit to which a texture is to be bound.</param>
        /// <param name="count">Specifies the number of textures to bind.</param>
        /// <param name="textures">Specifies the address of an array of names of existing texture objects.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindImageTextures(uint first, int count, void* textures) => _BindImageTextures_ptr(first, count, textures);

        /// <summary>
        /// glBindImageTextures binds images from an array of existing texture objects to a specified            number of consecutive image units. count specifies the number of texture            objects whose names are stored in the array textures. That number            of texture names are read from the array and bound to the count consecutive            texture units starting from first.            If the name zero appears in the textures array, any existing binding            to the image unit is reset. Any non-zero entry in textures must be the            name of an existing texture object. When a non-zero entry in textures is            present, the image at level zero is bound, the binding is considered layered, with the first            layer set to zero, and the image is bound for read-write access. The image unit format            parameter is taken from the internal format of the image at level zero of the texture object.            For cube map textures, the internal format of the positive X image of level zero is used.            If textures is NULL then it is as            if an appropriately sized array containing only zeros had been specified.
        /// glBindImageTextures is equivalent to the following pseudo code:
        /// for (i = 0; i < count; i++) {        if (textures == NULL || textures[i] = 0) {            glBindImageTexture(first + i, 0, 0, GL_FALSE, 0, GL_READ_ONLY, GL_R8);        } else {            glBindImageTexture(first + i, textures[i], 0, GL_TRUE, 0, GL_READ_WRITE, lookupInternalFormat(textures[i]));        }    }
        /// Each entry in textures will be checked individually and if found        to be invalid, the state for that image unit will not be changed and an error will be        generated. However, the state for other texture image units referenced by the command will still        be updated.
        /// </summary>
        /// <param name="first">Specifies the first image unit to which a texture is to be bound.</param>
        /// <param name="count">Specifies the number of textures to bind.</param>
        /// <param name="textures">Specifies the address of an array of names of existing texture objects.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindImageTextures(uint first, int count, IntPtr textures) => _BindImageTextures_intptr(first, count, textures);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint BindLightParameterEXT(LightName light, LightParameter value) => _BindLightParameterEXT(light, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint BindMaterialParameterEXT(MaterialFace face, MaterialParameter value) => _BindMaterialParameterEXT(face, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindMultiTextureEXT(TextureUnit texunit, TextureTarget target, uint texture) => _BindMultiTextureEXT(texunit, target, texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint BindParameterEXT(VertexShaderParameterEXT value) => _BindParameterEXT(value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindProgramARB(ProgramTarget target, uint program) => _BindProgramARB(target, program);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindProgramNV(VertexAttribEnumNV target, uint id) => _BindProgramNV(target, id);

        // ---

        /// <summary>
        /// glBindProgramPipeline binds a program pipeline object to the current            context. pipeline must be a name previously returned from a call            to glGenProgramPipelines. If            no program pipeline exists with name pipeline then a new pipeline object            is created with that name and initialized to the default state vector.
        /// When a program pipeline object is bound using glBindProgramPipeline, any previous            binding is broken and is replaced with a binding to the specified pipeline object. If pipeline            is zero, the previous binding is broken and is not replaced, leaving no pipeline object bound.            If no current program object has been established by glUseProgram,            the program objects used for each stage and for uniform updates are taken from the bound program            pipeline object, if any. If there is a current program object established by glUseProgram,            the bound program pipeline object has no effect on rendering or uniform updates. When a bound program            pipeline object is used for rendering, individual shader executables are taken from its program objects.
        /// </summary>
        /// <param name="pipeline">Specifies the name of the pipeline object to bind to the context.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindProgramPipeline(uint pipeline) => _BindProgramPipeline(pipeline);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindProgramPipelineEXT(uint pipeline) => _BindProgramPipelineEXT(pipeline);

        // ---

        /// <summary>
        /// glBindRenderbuffer binds the renderbuffer object with name renderbuffer to the renderbuffer target specified            by target. target must be GL_RENDERBUFFER. renderbuffer            is the name of a renderbuffer object previously returned from a call to glGenRenderbuffers,            or zero to break the existing binding of a renderbuffer object to target.
        /// </summary>
        /// <param name="target">Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER.</param>
        /// <param name="renderbuffer">Specifies the name of the renderbuffer object to bind.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindRenderbuffer(RenderbufferTarget target, uint renderbuffer) => _BindRenderbuffer(target, renderbuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindRenderbufferEXT(RenderbufferTarget target, uint renderbuffer) => _BindRenderbufferEXT(target, renderbuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindRenderbufferOES(RenderbufferTarget target, uint renderbuffer) => _BindRenderbufferOES(target, renderbuffer);

        // ---

        /// <summary>
        /// glBindSampler binds sampler to the texture unit at index unit.            sampler must be zero or the name of a sampler object previously returned from a call to            glGenSamplers. unit must be less than the value            of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS.
        /// When a sampler object is bound to a texture unit, its state supersedes that of            the texture object bound to that texture unit. If the sampler name zero is bound to            a texture unit, the currently bound texture's sampler state becomes active. A single            sampler object may be bound to multiple texture units simultaneously.
        /// </summary>
        /// <param name="unit">Specifies the index of the texture unit to which the sampler is bound.</param>
        /// <param name="sampler">Specifies the name of a sampler.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindSampler(uint unit, uint sampler) => _BindSampler(unit, sampler);

        // ---

        /// <summary>
        /// glBindSamplers binds samplers from an array of existing sampler objects to a specified            number of consecutive sampler units. count specifies the number of sampler            objects whose names are stored in the array samplers. That number            of sampler names is read from the array and bound to the count consecutive            sampler units starting from first.
        /// If the name zero appears in the samplers array, any existing binding            to the sampler unit is reset. Any non-zero entry in samplers must be the            name of an existing sampler object. When a non-zero entry in samplers is            present, that sampler object is bound to the corresponding sampler unit.            If samplers is NULL then it is as            if an appropriately sized array containing only zeros had been specified.
        /// glBindSamplers is equivalent to the following pseudo code:
        /// for (i = 0; i < count; i++) {        if (samplers == NULL) {            glBindSampler(first + i, 0);        } else {            glBindSampler(first + i, samplers[i]);        }    }
        /// Each entry in samplers will be checked individually and if found        to be invalid, the state for that sampler unit will not be changed and an error will be        generated. However, the state for other sampler units referenced by the command will still        be updated.
        /// </summary>
        /// <param name="first">Specifies the first sampler unit to which a sampler object is to be bound.</param>
        /// <param name="count">Specifies the number of samplers to bind.</param>
        /// <param name="samplers">Specifies the address of an array of names of existing sampler objects.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindSamplers(uint first, int count, uint[] samplers) => _BindSamplers(first, count, samplers);

        /// <summary>
        /// glBindSamplers binds samplers from an array of existing sampler objects to a specified            number of consecutive sampler units. count specifies the number of sampler            objects whose names are stored in the array samplers. That number            of sampler names is read from the array and bound to the count consecutive            sampler units starting from first.
        /// If the name zero appears in the samplers array, any existing binding            to the sampler unit is reset. Any non-zero entry in samplers must be the            name of an existing sampler object. When a non-zero entry in samplers is            present, that sampler object is bound to the corresponding sampler unit.            If samplers is NULL then it is as            if an appropriately sized array containing only zeros had been specified.
        /// glBindSamplers is equivalent to the following pseudo code:
        /// for (i = 0; i < count; i++) {        if (samplers == NULL) {            glBindSampler(first + i, 0);        } else {            glBindSampler(first + i, samplers[i]);        }    }
        /// Each entry in samplers will be checked individually and if found        to be invalid, the state for that sampler unit will not be changed and an error will be        generated. However, the state for other sampler units referenced by the command will still        be updated.
        /// </summary>
        /// <param name="first">Specifies the first sampler unit to which a sampler object is to be bound.</param>
        /// <param name="count">Specifies the number of samplers to bind.</param>
        /// <param name="samplers">Specifies the address of an array of names of existing sampler objects.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindSamplers(uint first, int count, void* samplers) => _BindSamplers_ptr(first, count, samplers);

        /// <summary>
        /// glBindSamplers binds samplers from an array of existing sampler objects to a specified            number of consecutive sampler units. count specifies the number of sampler            objects whose names are stored in the array samplers. That number            of sampler names is read from the array and bound to the count consecutive            sampler units starting from first.
        /// If the name zero appears in the samplers array, any existing binding            to the sampler unit is reset. Any non-zero entry in samplers must be the            name of an existing sampler object. When a non-zero entry in samplers is            present, that sampler object is bound to the corresponding sampler unit.            If samplers is NULL then it is as            if an appropriately sized array containing only zeros had been specified.
        /// glBindSamplers is equivalent to the following pseudo code:
        /// for (i = 0; i < count; i++) {        if (samplers == NULL) {            glBindSampler(first + i, 0);        } else {            glBindSampler(first + i, samplers[i]);        }    }
        /// Each entry in samplers will be checked individually and if found        to be invalid, the state for that sampler unit will not be changed and an error will be        generated. However, the state for other sampler units referenced by the command will still        be updated.
        /// </summary>
        /// <param name="first">Specifies the first sampler unit to which a sampler object is to be bound.</param>
        /// <param name="count">Specifies the number of samplers to bind.</param>
        /// <param name="samplers">Specifies the address of an array of names of existing sampler objects.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindSamplers(uint first, int count, IntPtr samplers) => _BindSamplers_intptr(first, count, samplers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindShadingRateImageNV(uint texture) => _BindShadingRateImageNV(texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint BindTexGenParameterEXT(TextureUnit unit, TextureCoordName coord, TextureGenParameter value) => _BindTexGenParameterEXT(unit, coord, value);

        // ---

        /// <summary>
        /// glBindTexture lets you create or use a named texture. Calling glBindTexture with            target set to            GL_TEXTURE_1D,            GL_TEXTURE_2D,            GL_TEXTURE_3D,            GL_TEXTURE_1D_ARRAY,            GL_TEXTURE_2D_ARRAY,            GL_TEXTURE_RECTANGLE,            GL_TEXTURE_CUBE_MAP,            GL_TEXTURE_CUBE_MAP_ARRAY,            GL_TEXTURE_BUFFER,            GL_TEXTURE_2D_MULTISAMPLE or            GL_TEXTURE_2D_MULTISAMPLE_ARRAY            and texture set to the name of the new texture binds the texture name to the target.            When a texture is bound to a target, the previous binding for that target is automatically broken.
        /// Texture names are unsigned integers. The value zero is reserved to            represent the default texture for each texture target.            Texture names and the corresponding texture contents are local to            the shared object space of the current GL rendering context;            two rendering contexts share texture names only if they            explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.
        /// You must use glGenTextures to generate a set of new texture names.
        /// When a texture is first bound, it assumes the specified target:            A texture first bound to GL_TEXTURE_1D becomes one-dimensional texture, a            texture first bound to GL_TEXTURE_2D becomes two-dimensional texture, a            texture first bound to GL_TEXTURE_3D becomes three-dimensional texture, a            texture first bound to GL_TEXTURE_1D_ARRAY becomes one-dimensional array texture, a            texture first bound to GL_TEXTURE_2D_ARRAY becomes two-dimensional array texture, a            texture first bound to GL_TEXTURE_RECTANGLE becomes rectangle texture, a            texture first bound to GL_TEXTURE_CUBE_MAP becomes a cube-mapped texture, a            texture first bound to GL_TEXTURE_CUBE_MAP_ARRAY becomes a cube-mapped array texture, a            texture first bound to GL_TEXTURE_BUFFER becomes a buffer texture, a            texture first bound to GL_TEXTURE_2D_MULTISAMPLE becomes a two-dimensional multisampled texture, and a            texture first bound to GL_TEXTURE_2D_MULTISAMPLE_ARRAY becomes a two-dimensional multisampled array texture.            The state of a one-dimensional texture immediately after it is first bound is equivalent to the state of the            default GL_TEXTURE_1D at GL initialization, and similarly for the other texture types.
        /// While a texture is bound, GL operations on the target to which it is            bound affect the bound texture, and queries of the target to which it            is bound return state from the bound texture.            In effect, the texture targets become aliases for the textures currently            bound to them, and the texture name zero refers to the default textures            that were bound to them at initialization.
        /// A texture binding created with glBindTexture remains active until a different            texture is bound to the same target, or until the bound texture is            deleted with glDeleteTextures.
        /// Once created, a named texture may be re-bound to its same original target as often as needed.            It is usually much faster to use glBindTexture to bind an existing named            texture to one of the texture targets than it is to reload the texture image            using glTexImage1D, glTexImage2D,            glTexImage3D or another similar function.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture is bound.                    Must be one of                    GL_TEXTURE_1D,                    GL_TEXTURE_2D,                    GL_TEXTURE_3D,                    GL_TEXTURE_1D_ARRAY,                    GL_TEXTURE_2D_ARRAY,                    GL_TEXTURE_RECTANGLE,                    GL_TEXTURE_CUBE_MAP,                    GL_TEXTURE_CUBE_MAP_ARRAY,                    GL_TEXTURE_BUFFER,                    GL_TEXTURE_2D_MULTISAMPLE or                    GL_TEXTURE_2D_MULTISAMPLE_ARRAY.</param>
        /// <param name="texture">Specifies the name of a texture.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindTexture(TextureTarget target, uint texture) => _BindTexture(target, texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindTextureEXT(TextureTarget target, uint texture) => _BindTextureEXT(target, texture);

        // ---

        /// <summary>
        /// glBindTextureUnit binds an existing texture object to the texture unit numbered unit.
        /// texture must be zero or the name of an existing texture object. When texture is the name of an existing texture object, that object is bound to the target, in the corresponding texture unit, that was specified when the object was created. When texture is zero, each of the targets enumerated at the beginning of this section is reset to its default texture for the corresponding texture image unit.
        /// </summary>
        /// <param name="unit">Specifies the texture unit, to which the texture object should be bound to.</param>
        /// <param name="texture">Specifies the name of a texture.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindTextureUnit(uint unit, uint texture) => _BindTextureUnit(unit, texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint BindTextureUnitParameterEXT(TextureUnit unit, VertexShaderTextureUnitParameter value) => _BindTextureUnitParameterEXT(unit, value);

        // ---

        /// <summary>
        /// glBindTextures binds an array of existing texture objects to a specified            number of consecutive texture units. count specifies the number of texture            objects whose names are stored in the array textures. That number            of texture names are read from the array and bound to the count consecutive            texture units starting from first. The target, or type of texture is            deduced from the texture object and each texture is bound to the corresponding target of the            texture unit. If the name zero appears in the textures array, any existing binding            to any target of the texture unit is reset and the default texture for that target is bound in            its place. Any non-zero entry in textures must be the name of an existing            texture object. If textures is NULL then it is as            if an appropriately sized array containing only zeros had been specified.
        /// With the exception that the active texture selector maintains its current value,            glBindTextures is equivalent to the following pseudo code:
        /// for (i = 0; i < count; i++) {        GLuint texture;        if (textures == NULL) {            texture = 0;        } else {            texture = textures[i];        }        glActiveTexture(GL_TEXTURE0 + first + i);        if (texture != 0) {            GLenum target = /* target of textures[i] */;            glBindTexture(target, textures[i]);        } else {            for (target in all supported targets) {                glBindTexture(target, 0);            }        }    }
        /// Each entry in textures will be checked individually and if found        to be invalid, the state for that texture unit will not be changed and an error will be        generated. However, the state for other texture units referenced by the command will still        be updated.
        /// </summary>
        /// <param name="first">Specifies the first texture unit to which a texture is to be bound.</param>
        /// <param name="count">Specifies the number of textures to bind.</param>
        /// <param name="textures">Specifies the address of an array of names of existing texture objects.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindTextures(uint first, int count, uint[] textures) => _BindTextures(first, count, textures);

        /// <summary>
        /// glBindTextures binds an array of existing texture objects to a specified            number of consecutive texture units. count specifies the number of texture            objects whose names are stored in the array textures. That number            of texture names are read from the array and bound to the count consecutive            texture units starting from first. The target, or type of texture is            deduced from the texture object and each texture is bound to the corresponding target of the            texture unit. If the name zero appears in the textures array, any existing binding            to any target of the texture unit is reset and the default texture for that target is bound in            its place. Any non-zero entry in textures must be the name of an existing            texture object. If textures is NULL then it is as            if an appropriately sized array containing only zeros had been specified.
        /// With the exception that the active texture selector maintains its current value,            glBindTextures is equivalent to the following pseudo code:
        /// for (i = 0; i < count; i++) {        GLuint texture;        if (textures == NULL) {            texture = 0;        } else {            texture = textures[i];        }        glActiveTexture(GL_TEXTURE0 + first + i);        if (texture != 0) {            GLenum target = /* target of textures[i] */;            glBindTexture(target, textures[i]);        } else {            for (target in all supported targets) {                glBindTexture(target, 0);            }        }    }
        /// Each entry in textures will be checked individually and if found        to be invalid, the state for that texture unit will not be changed and an error will be        generated. However, the state for other texture units referenced by the command will still        be updated.
        /// </summary>
        /// <param name="first">Specifies the first texture unit to which a texture is to be bound.</param>
        /// <param name="count">Specifies the number of textures to bind.</param>
        /// <param name="textures">Specifies the address of an array of names of existing texture objects.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindTextures(uint first, int count, void* textures) => _BindTextures_ptr(first, count, textures);

        /// <summary>
        /// glBindTextures binds an array of existing texture objects to a specified            number of consecutive texture units. count specifies the number of texture            objects whose names are stored in the array textures. That number            of texture names are read from the array and bound to the count consecutive            texture units starting from first. The target, or type of texture is            deduced from the texture object and each texture is bound to the corresponding target of the            texture unit. If the name zero appears in the textures array, any existing binding            to any target of the texture unit is reset and the default texture for that target is bound in            its place. Any non-zero entry in textures must be the name of an existing            texture object. If textures is NULL then it is as            if an appropriately sized array containing only zeros had been specified.
        /// With the exception that the active texture selector maintains its current value,            glBindTextures is equivalent to the following pseudo code:
        /// for (i = 0; i < count; i++) {        GLuint texture;        if (textures == NULL) {            texture = 0;        } else {            texture = textures[i];        }        glActiveTexture(GL_TEXTURE0 + first + i);        if (texture != 0) {            GLenum target = /* target of textures[i] */;            glBindTexture(target, textures[i]);        } else {            for (target in all supported targets) {                glBindTexture(target, 0);            }        }    }
        /// Each entry in textures will be checked individually and if found        to be invalid, the state for that texture unit will not be changed and an error will be        generated. However, the state for other texture units referenced by the command will still        be updated.
        /// </summary>
        /// <param name="first">Specifies the first texture unit to which a texture is to be bound.</param>
        /// <param name="count">Specifies the number of textures to bind.</param>
        /// <param name="textures">Specifies the address of an array of names of existing texture objects.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindTextures(uint first, int count, IntPtr textures) => _BindTextures_intptr(first, count, textures);

        // ---

        /// <summary>
        /// glBindTransformFeedback binds the transform feedback object with name id to the current            GL state. id must be a name previously returned from a call to            glGenTransformFeedbacks. If id has not            previously been bound, a new transform feedback object with name id and initialized with the            default transform state vector is created.
        /// In the initial state, a default transform feedback object is bound and treated as            a transform feedback object with a name of zero. If the name zero is subsequently bound, the default            transform feedback object is again bound to the GL state.
        /// While a transform feedback buffer object is bound, GL operations on the target            to which it is bound affect the bound transform feedback object, and queries of the            target to which a transform feedback object is bound return state from the bound            object. When buffer objects are bound for transform feedback, they are attached to            the currently bound transform feedback object. Buffer objects are used for trans-            form feedback only if they are attached to the currently bound transform feedback            object.
        /// </summary>
        /// <param name="target">Specifies the target to which to bind the transform feedback object id. target                    must be GL_TRANSFORM_FEEDBACK.</param>
        /// <param name="id">Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindTransformFeedback(BindTransformFeedbackTarget target, uint id) => _BindTransformFeedback(target, id);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindTransformFeedbackNV(BufferTargetARB target, uint id) => _BindTransformFeedbackNV(target, id);

        // ---

        /// <summary>
        /// glBindVertexArray binds the vertex array object with name array. array            is the name of a vertex array object previously returned from a call to glGenVertexArrays,            or zero to break the existing vertex array object binding.
        /// If no vertex array object with name array exists, one is created when array is first bound. If the bind            is successful no change is made to the state of the vertex array object, and any previous vertex array object binding is broken.
        /// </summary>
        /// <param name="array">Specifies the name of the vertex array to bind.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindVertexArray(uint array) => _BindVertexArray(array);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindVertexArrayAPPLE(uint array) => _BindVertexArrayAPPLE(array);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindVertexArrayOES(uint array) => _BindVertexArrayOES(array);

        // ---

        /// <summary>
        /// glBindVertexBuffer and    glVertexArrayVertexBuffer bind the buffer named    buffer to the vertex buffer binding point whose    index is given by bindingindex.    glBindVertexBuffer modifies the binding of the    currently bound vertex array object, whereas    glVertexArrayVertexBuffer allows the caller to    specify ID of the vertex array object with an argument named    vaobj, for which the binding should be modified.    offset and stride specify    the offset of the first element within the buffer and the distance between    elements within the buffer, respectively, and are both measured in basic    machine units. bindingindex must be less than the    value of GL_MAX_VERTEX_ATTRIB_BINDINGS.    offset and stride must be    greater than or equal to zero. If buffer is zero,    then any buffer currently bound to the specified binding point is    unbound.
        /// If buffer is not the name of an existing    buffer object, the GL first creates a new state vector, initialized with a    zero-sized memory buffer and comprising all the state and with the same    initial values as in case of glBindBuffer.    buffer is then attached to the specified    bindingindex of the vertex array object.
        /// </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object to be used by          glVertexArrayVertexBuffer function.</param>
        /// <param name="bindingindex">The index of the vertex buffer binding point to which to bind          the buffer.</param>
        /// <param name="buffer">The name of a buffer to bind to the vertex buffer binding          point.</param>
        /// <param name="offset">The offset of the first element of the buffer.</param>
        /// <param name="stride">The distance between elements within the buffer.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindVertexBuffer(uint bindingindex, uint buffer, IntPtr offset, int stride) => _BindVertexBuffer(bindingindex, buffer, offset, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindVertexBuffers(uint first, int count, uint[] buffers, IntPtr[] offsets, int[] strides) => _BindVertexBuffers(first, count, buffers, offsets, strides);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindVertexBuffers(uint first, int count, void* buffers, void* offsets, void* strides) => _BindVertexBuffers_ptr(first, count, buffers, offsets, strides);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindVertexBuffers(uint first, int count, IntPtr buffers, IntPtr offsets, IntPtr strides) => _BindVertexBuffers_intptr(first, count, buffers, offsets, strides);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindVertexShaderEXT(uint id) => _BindVertexShaderEXT(id);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindVideoCaptureStreamBufferNV(uint video_capture_slot, uint stream, int frame_region, IntPtr offset) => _BindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BindVideoCaptureStreamTextureNV(uint video_capture_slot, uint stream, int frame_region, int target, uint texture) => _BindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3bEXT(sbyte bx, sbyte by, sbyte bz) => _Binormal3bEXT(bx, by, bz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3bvEXT(sbyte[] v) => _Binormal3bvEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3bvEXT(void* v) => _Binormal3bvEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3bvEXT(IntPtr v) => _Binormal3bvEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3dEXT(double bx, double by, double bz) => _Binormal3dEXT(bx, by, bz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3dvEXT(double[] v) => _Binormal3dvEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3dvEXT(void* v) => _Binormal3dvEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3dvEXT(IntPtr v) => _Binormal3dvEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3fEXT(float bx, float by, float bz) => _Binormal3fEXT(bx, by, bz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3fvEXT(float[] v) => _Binormal3fvEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3fvEXT(void* v) => _Binormal3fvEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3fvEXT(IntPtr v) => _Binormal3fvEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3iEXT(int bx, int by, int bz) => _Binormal3iEXT(bx, by, bz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3ivEXT(int[] v) => _Binormal3ivEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3ivEXT(void* v) => _Binormal3ivEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3ivEXT(IntPtr v) => _Binormal3ivEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3sEXT(short bx, short by, short bz) => _Binormal3sEXT(bx, by, bz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3svEXT(short[] v) => _Binormal3svEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3svEXT(void* v) => _Binormal3svEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Binormal3svEXT(IntPtr v) => _Binormal3svEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BinormalPointerEXT(BinormalPointerTypeEXT type, int stride, IntPtr pointer) => _BinormalPointerEXT(type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Bitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, byte[] bitmap) => _Bitmap(width, height, xorig, yorig, xmove, ymove, bitmap);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Bitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, void* bitmap) => _Bitmap_ptr(width, height, xorig, yorig, xmove, ymove, bitmap);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Bitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, IntPtr bitmap) => _Bitmap_intptr(width, height, xorig, yorig, xmove, ymove, bitmap);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BitmapxOES(int width, int height, float xorig, float yorig, float xmove, float ymove, byte[] bitmap) => _BitmapxOES(width, height, xorig, yorig, xmove, ymove, bitmap);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BitmapxOES(int width, int height, float xorig, float yorig, float xmove, float ymove, void* bitmap) => _BitmapxOES_ptr(width, height, xorig, yorig, xmove, ymove, bitmap);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BitmapxOES(int width, int height, float xorig, float yorig, float xmove, float ymove, IntPtr bitmap) => _BitmapxOES_intptr(width, height, xorig, yorig, xmove, ymove, bitmap);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendBarrier() => _BlendBarrier();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendBarrierKHR() => _BlendBarrierKHR();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendBarrierNV() => _BlendBarrierNV();

        // ---

        /// <summary>
        /// The GL_BLEND_COLOR may be used to calculate the source and destination            blending factors. The color components are clamped to the range                        before being stored. See glBlendFunc for a complete description of the            blending operations.            Initially the GL_BLEND_COLOR is set to (0, 0, 0, 0).
        /// </summary>
        /// <param name="alpha">specify the components of GL_BLEND_COLOR</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendColor(float red, float green, float blue, float alpha) => _BlendColor(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendColorEXT(float red, float green, float blue, float alpha) => _BlendColorEXT(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendColorxOES(float red, float green, float blue, float alpha) => _BlendColorxOES(red, green, blue, alpha);

        // ---

        /// <summary>
        /// The blend equations determine how a new pixel (the ''source'' color)            is combined with a pixel already in the framebuffer (the ''destination''            color).  This function sets both the RGB blend equation and the alpha            blend equation to a single equation. glBlendEquationi            specifies the blend equation for a single draw buffer whereas glBlendEquation            sets the blend equation for all draw buffers.
        /// These equations use the source and destination blend factors            specified by either glBlendFunc or            glBlendFuncSeparate.            See glBlendFunc or glBlendFuncSeparate            for a description of the various blend factors.
        /// In the equations that follow, source and destination            color components are referred to as            .
        /// The GL_MIN and GL_MAX equations are useful for applications            that analyze image data (image thresholding against a constant color,            for example).            The GL_FUNC_ADD equation is useful            for antialiasing and transparency, among other things.
        /// Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.
        /// </summary>
        /// <param name="buf">for glBlendEquationi, specifies the index of the draw buffer                    for which to set the blend equation.</param>
        /// <param name="mode">specifies how source and destination colors are combined.                    It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT,                    GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquation(BlendEquationModeEXT mode) => _BlendEquation(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquationEXT(BlendEquationModeEXT mode) => _BlendEquationEXT(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquationIndexedAMD(uint buf, BlendEquationModeEXT mode) => _BlendEquationIndexedAMD(buf, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquationOES(BlendEquationModeEXT mode) => _BlendEquationOES(mode);

        // ---

        /// <summary>
        /// The blend equations determines how a new pixel (the ''source'' color)            is combined with a pixel already in the framebuffer (the ''destination''            color).  These functions specify one blend equation for the RGB-color            components and one blend equation for the alpha component. glBlendEquationSeparatei            specifies the blend equations for a single draw buffer whereas glBlendEquationSeparate            sets the blend equations for all draw buffers.
        /// The blend equations use the source and destination blend factors            specified by either glBlendFunc or            glBlendFuncSeparate.            See glBlendFunc or glBlendFuncSeparate            for a description of the various blend factors.
        /// In the equations that follow, source and destination            color components are referred to as            .
        /// The GL_MIN and GL_MAX equations are useful for applications            that analyze image data (image thresholding against a constant color,            for example).            The GL_FUNC_ADD equation is useful            for antialiasing and transparency, among other things.
        /// Initially, both the RGB blend equation and the alpha blend equation are set to GL_FUNC_ADD.
        /// </summary>
        /// <param name="buf">for glBlendEquationSeparatei, specifies the index of the draw buffer for which                    to set the blend equations.</param>
        /// <param name="modeRGB">specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined.                    It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT,                    GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.</param>
        /// <param name="modeAlpha">specifies the alpha blend equation, how the alpha component of the source and destination colors are combined.                    It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT,                    GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquationSeparate(BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => _BlendEquationSeparate(modeRGB, modeAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquationSeparateEXT(BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => _BlendEquationSeparateEXT(modeRGB, modeAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquationSeparateIndexedAMD(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => _BlendEquationSeparateIndexedAMD(buf, modeRGB, modeAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquationSeparateOES(BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => _BlendEquationSeparateOES(modeRGB, modeAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquationSeparatei(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => _BlendEquationSeparatei(buf, modeRGB, modeAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquationSeparateiARB(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => _BlendEquationSeparateiARB(buf, modeRGB, modeAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquationSeparateiEXT(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => _BlendEquationSeparateiEXT(buf, modeRGB, modeAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquationSeparateiOES(uint buf, BlendEquationModeEXT modeRGB, BlendEquationModeEXT modeAlpha) => _BlendEquationSeparateiOES(buf, modeRGB, modeAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquationi(uint buf, BlendEquationModeEXT mode) => _BlendEquationi(buf, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquationiARB(uint buf, BlendEquationModeEXT mode) => _BlendEquationiARB(buf, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquationiEXT(uint buf, BlendEquationModeEXT mode) => _BlendEquationiEXT(buf, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendEquationiOES(uint buf, BlendEquationModeEXT mode) => _BlendEquationiOES(buf, mode);

        // ---

        /// <summary>
        /// Pixels can be drawn using a function that blends            the incoming (source) RGBA values with the RGBA values            that are already in the frame buffer (the destination values).            Blending is initially disabled.            Use glEnable and glDisable with argument GL_BLEND            to enable and disable blending.
        /// glBlendFunc defines the operation of blending for all draw buffers when it is enabled.            glBlendFunci defines the operation of blending for a single draw buffer            specified by buf when enabled for that draw buffer.            sfactor specifies which method is used to scale the            source color components.            dfactor specifies which method is used to scale the            destination color components.            Both parameters must be one of the following symbolic constants:                    GL_ZERO,                    GL_ONE,                    GL_SRC_COLOR,                    GL_ONE_MINUS_SRC_COLOR,                    GL_DST_COLOR,                    GL_ONE_MINUS_DST_COLOR,                    GL_SRC_ALPHA,                    GL_ONE_MINUS_SRC_ALPHA,                    GL_DST_ALPHA,                    GL_ONE_MINUS_DST_ALPHA,                    GL_CONSTANT_COLOR,                    GL_ONE_MINUS_CONSTANT_COLOR,                    GL_CONSTANT_ALPHA,                    GL_ONE_MINUS_CONSTANT_ALPHA,                    GL_SRC_ALPHA_SATURATE,                    GL_SRC1_COLOR,                    GL_ONE_MINUS_SRC1_COLOR,                    GL_SRC1_ALPHA, and                    GL_ONE_MINUS_SRC1_ALPHA.            The possible methods are described in the following table.            Each method defines four scale factors,            one each for red, green, blue, and alpha.            In the table and in subsequent equations, first source, second source            and destination color components are referred to as            ),            representing complete opacity,            to 0.0 (0), representing complete            transparency.
        /// When more than one color buffer is enabled for drawing,            the GL performs blending separately for each enabled buffer,            using the contents of that buffer for destination color.            (See glDrawBuffer.)
        /// When dual source blending is enabled (i.e., one of the blend factors requiring            the second color input is used), the maximum number of enabled draw buffers            is given by GL_MAX_DUAL_SOURCE_DRAW_BUFFERS, which may            be lower than GL_MAX_DRAW_BUFFERS.
        /// </summary>
        /// <param name="buf">For glBlendFunci, specifies the index of the draw                    buffer for which to set the blend function.</param>
        /// <param name="sfactor">Specifies how the red, green, blue,                    and alpha source blending factors are computed.                    The initial value is GL_ONE.</param>
        /// <param name="dfactor">Specifies how the red, green, blue,                    and alpha destination blending factors are computed.                    The following symbolic constants are accepted:                    GL_ZERO,                    GL_ONE,                    GL_SRC_COLOR,                    GL_ONE_MINUS_SRC_COLOR,                    GL_DST_COLOR,                    GL_ONE_MINUS_DST_COLOR,                    GL_SRC_ALPHA,                    GL_ONE_MINUS_SRC_ALPHA,                    GL_DST_ALPHA,                    GL_ONE_MINUS_DST_ALPHA.                    GL_CONSTANT_COLOR,                    GL_ONE_MINUS_CONSTANT_COLOR,                    GL_CONSTANT_ALPHA, and                    GL_ONE_MINUS_CONSTANT_ALPHA.                    The initial value is GL_ZERO.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendFunc(BlendingFactor sfactor, BlendingFactor dfactor) => _BlendFunc(sfactor, dfactor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendFuncIndexedAMD(uint buf, int src, int dst) => _BlendFuncIndexedAMD(buf, src, dst);

        // ---

        /// <summary>
        /// Pixels can be drawn using a function that blends            the incoming (source) RGBA values with the RGBA values            that are already in the frame buffer (the destination values).            Blending is initially disabled.            Use glEnable and glDisable with argument GL_BLEND            to enable and disable blending.
        /// glBlendFuncSeparate defines the operation of blending for all draw buffers when it is enabled.            glBlendFuncSeparatei defines the operation of blending for a single draw buffer            specified by buf when enabled for that draw buffer.            srcRGB specifies which method is used to scale the            source RGB-color components.            dstRGB specifies which method is used to scale the            destination RGB-color components.            Likewise, srcAlpha specifies which method is used to scale the source alpha            color component, and dstAlpha specifies which method is used to scale the            destination alpha component.            The possible methods are described in the following table.            Each method defines four scale factors,            one each for red, green, blue, and alpha.
        /// In the table and in subsequent equations, first source, second source and destination            color components are referred to as            ),            representing complete opacity,            to 0.0 (0), representing complete            transparency.
        /// When more than one color buffer is enabled for drawing,            the GL performs blending separately for each enabled buffer,            using the contents of that buffer for destination color.            (See glDrawBuffer.)
        /// When dual source blending is enabled (i.e., one of the blend factors requiring            the second color input is used), the maximum number of enabled draw buffers            is given by GL_MAX_DUAL_SOURCE_DRAW_BUFFERS, which may            be lower than GL_MAX_DRAW_BUFFERS.
        /// </summary>
        /// <param name="buf">For glBlendFuncSeparatei, specifies the index of the draw                    buffer for which to set the blend functions.</param>
        /// <param name="srcRGB">Specifies how the red, green, and blue blending factors are computed.                    The initial value is GL_ONE.</param>
        /// <param name="dstRGB">Specifies how the red, green, and blue destination blending factors are                    computed.                    The initial value is GL_ZERO.</param>
        /// <param name="srcAlpha">Specified how the alpha source blending factor is computed.                    The initial value is GL_ONE.</param>
        /// <param name="dstAlpha">Specified how the alpha destination blending factor is computed.                    The initial value is GL_ZERO.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendFuncSeparate(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => _BlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendFuncSeparateEXT(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => _BlendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendFuncSeparateINGR(BlendingFactor sfactorRGB, BlendingFactor dfactorRGB, BlendingFactor sfactorAlpha, BlendingFactor dfactorAlpha) => _BlendFuncSeparateINGR(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendFuncSeparateIndexedAMD(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => _BlendFuncSeparateIndexedAMD(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendFuncSeparateOES(BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => _BlendFuncSeparateOES(srcRGB, dstRGB, srcAlpha, dstAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendFuncSeparatei(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => _BlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendFuncSeparateiARB(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => _BlendFuncSeparateiARB(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendFuncSeparateiEXT(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => _BlendFuncSeparateiEXT(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendFuncSeparateiOES(uint buf, BlendingFactor srcRGB, BlendingFactor dstRGB, BlendingFactor srcAlpha, BlendingFactor dstAlpha) => _BlendFuncSeparateiOES(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendFunci(uint buf, BlendingFactor src, BlendingFactor dst) => _BlendFunci(buf, src, dst);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendFunciARB(uint buf, BlendingFactor src, BlendingFactor dst) => _BlendFunciARB(buf, src, dst);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendFunciEXT(uint buf, BlendingFactor src, BlendingFactor dst) => _BlendFunciEXT(buf, src, dst);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendFunciOES(uint buf, BlendingFactor src, BlendingFactor dst) => _BlendFunciOES(buf, src, dst);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlendParameteriNV(int pname, int value) => _BlendParameteriNV(pname, value);

        // ---

        /// <summary>
        /// glBlitFramebuffer and            glBlitNamedFramebuffer transfer a rectangle            of pixel values from one region of a read framebuffer to another            region of a draw framebuffer.
        /// For glBlitFramebuffer, the read and draw            framebuffers are those bound to the            GL_READ_FRAMEBUFFER and            GL_DRAW_FRAMEBUFFER targets respectively.
        /// For glBlitNamedFramebuffer,            readFramebuffer and            drawFramebuffer are the names of the read            and draw framebuffer objects respectively. If            readFramebuffer or            drawFramebuffer is zero, then the default            read or draw framebuffer respectively is used.
        /// mask is the bitwise OR of a number of            values indicating which buffers are to be copied. The values are            GL_COLOR_BUFFER_BIT,            GL_DEPTH_BUFFER_BIT, and            GL_STENCIL_BUFFER_BIT. The pixels            corresponding to these buffers are copied from the source            rectangle bounded by the locations            (srcX0, srcY0) and            (srcX1, srcY1) to            the destination rectangle bounded by the locations            (dstX0, dstY0) and            (dstX1, dstY1).            The lower bounds of the rectangle are inclusive, while the upper            bounds are exclusive.
        /// The actual region taken from the read framebuffer is limited to            the intersection of the source buffers being transferred, which            may include the color buffer selected by the read buffer, the            depth buffer, and/or the stencil buffer depending on mask. The            actual region written to the draw framebuffer is limited to the            intersection of the destination buffers being written, which may            include multiple draw buffers, the depth buffer, and/or the            stencil buffer depending on mask. Whether or not the source or            destination regions are altered due to these limits, the scaling            and offset applied to pixels being transferred is performed as            though no such limits were present.
        /// If the sizes of the source and destination rectangles are not            equal, filter specifies the interpolation            method that will be applied to resize the source image , and            must be GL_NEAREST or            GL_LINEAR. GL_LINEAR            is only a valid interpolation method for the color buffer. If            filter is not            GL_NEAREST and mask            includes GL_DEPTH_BUFFER_BIT or            GL_STENCIL_BUFFER_BIT, no data is            transferred and a GL_INVALID_OPERATION            error is generated.
        /// If filter is            GL_LINEAR and the source rectangle would            require sampling outside the bounds of the source framebuffer,            values are read as if the GL_CLAMP_TO_EDGE            texture wrapping mode were applied.
        /// When the color buffer is transferred, values are taken from the            read buffer of the specified read framebuffer and written to            each of the draw buffers of the specified draw framebuffer.
        /// If the source and destination rectangles overlap or are the same, and the read and draw buffers are the same, the result of the operation            is undefined.
        /// </summary>
        /// <param name="readFramebuffer">Specifies the name of the source framebuffer object                    for glBlitNamedFramebuffer.</param>
        /// <param name="drawFramebuffer">Specifies the name of the destination framebuffer object                    for glBlitNamedFramebuffer.</param>
        /// <param name="srcY1">Specify the bounds of the source rectangle within the read buffer of the read framebuffer.</param>
        /// <param name="dstY1">Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.</param>
        /// <param name="mask">The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are                    GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT.</param>
        /// <param name="filter">Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, BlitFramebufferFilter filter) => _BlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlitFramebufferANGLE(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, BlitFramebufferFilter filter) => _BlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlitFramebufferEXT(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, BlitFramebufferFilter filter) => _BlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlitFramebufferNV(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, BlitFramebufferFilter filter) => _BlitFramebufferNV(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BlitNamedFramebuffer(uint readFramebuffer, uint drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, BlitFramebufferFilter filter) => _BlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BufferAddressRangeNV(int pname, uint index, UInt64 address, IntPtr length) => _BufferAddressRangeNV(pname, index, address, length);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BufferAttachMemoryNV(BufferTargetARB target, uint memory, UInt64 offset) => _BufferAttachMemoryNV(target, memory, offset);

        // ---

        /// <summary>
        /// glBufferData and    glNamedBufferData create a new data store for a    buffer object. In case of glBufferData, the buffer    object currently bound to target is used. For    glNamedBufferData, a buffer object associated with ID    specified by the caller in buffer will be used    instead.
        /// While creating the new storage, any pre-existing data store is    deleted. The new data store is created with the specified    size in bytes and usage. If    data is not NULL, the data    store is initialized with data from this pointer. In its initial state,    the new data store is not mapped, it has a NULL    mapped pointer, and its mapped access is    GL_READ_WRITE.
        /// usage is a hint to the GL implementation as    to how a buffer object's data store will be accessed. This enables the GL    implementation to make more intelligent decisions that may significantly    impact buffer object performance. It does not, however, constrain the    actual usage of the data store. usage can be broken    down into two parts: first, the frequency of access (modification and    usage), and second, the nature of that access. The frequency of access may    be one of these:
        /// STREAMThe data store contents will be modified once and used at most          a few times.STATICThe data store contents will be modified once and used many          times.DYNAMICThe data store contents will be modified repeatedly and used          many times.
        /// The nature of access may be one of these:
        /// DRAWThe data store contents are modified by the application, and          used as the source for GL drawing and image specification          commands.READThe data store contents are modified by reading data from the          GL, and used to return that data when queried by the          application.COPYThe data store contents are modified by reading data from the          GL, and used as the source for GL drawing and image specification          commands.
        /// </summary>
        /// <param name="target">Specifies the target to which the buffer object is bound for            glBufferData, which must be one of the            buffer binding targets in the following table:</param>
        /// <param name="buffer">Specifies the name of the buffer object for          glNamedBufferData function.</param>
        /// <param name="size">Specifies the size in bytes of the buffer object's new data          store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data          store for initialization, or NULL if no data is          to be copied.</param>
        /// <param name="usage">Specifies the expected usage pattern of the data store. The          symbolic constant must be GL_STREAM_DRAW,          GL_STREAM_READ,          GL_STREAM_COPY,          GL_STATIC_DRAW,          GL_STATIC_READ,          GL_STATIC_COPY,          GL_DYNAMIC_DRAW,          GL_DYNAMIC_READ, or          GL_DYNAMIC_COPY.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BufferData(BufferTargetARB target, IntPtr size, IntPtr data, BufferUsageARB usage) => _BufferData(target, size, data, usage);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BufferDataARB(BufferTargetARB target, IntPtr size, IntPtr data, BufferUsageARB usage) => _BufferDataARB(target, size, data, usage);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BufferPageCommitmentARB(int target, IntPtr offset, IntPtr size, bool commit) => _BufferPageCommitmentARB(target, offset, size, commit);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BufferParameteriAPPLE(int target, int pname, int param) => _BufferParameteriAPPLE(target, pname, param);

        // ---

        /// <summary>
        /// glBufferStorage and    glNamedBufferStorage create a new immutable data    store. For glBufferStorage, the buffer object    currently bound to target will be initialized. For    glNamedBufferStorage, buffer    is the name of the buffer object that will be configured. The size of the    data store is specified by size. If an initial data    is available, its address may be supplied in data.    Otherwise, to create an uninitialized data store,    data should be NULL.
        /// The flags parameters specifies the intended    usage of the buffer's data store. It must be a bitwise combination of a    subset of the following flags: GL_DYNAMIC_STORAGE_BITThe contents of the data store may be updated after creation            through calls to            glBufferSubData.            If this bit is not set, the buffer content may            not be directly updated by the client. The data argument may be            used to specify the initial content of the buffer's data store            regardless of the presence of the            GL_DYNAMIC_STORAGE_BIT. Regardless of the            presence of this bit, buffers may always be updated with            server-side calls such as            glCopyBufferSubData            and            glClearBufferSubData.            GL_MAP_READ_BITThe data store may be mapped by the client for read access            and a pointer in the client's address space obtained that may be            read from.GL_MAP_WRITE_BITThe data store may be mapped by the client for write access            and a pointer in the client's address space obtained that may be            written through.GL_MAP_PERSISTENT_BITThe client may request that the server read from or write to            the buffer while it is mapped. The client's pointer to the data            store remains valid so long as the data store is mapped, even            during execution of drawing or dispatch commands.GL_MAP_COHERENT_BITShared access to buffers that are simultaneously mapped for            client access and are used by the server will be coherent, so long            as that mapping is performed using            glMapBufferRange.            That is, data written to the store by either            the client or server will be immediately visible to the other with            no further action taken by the application. In particular,If GL_MAP_COHERENT_BIT is not set                and the client performs a write followed by a call to the                glMemoryBarrier                command with the                GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT set,                then in subsequent commands the server will see the                writes.If GL_MAP_COHERENT_BIT is set and                the client performs a write, then in subsequent commands the                server will see the writes.If GL_MAP_COHERENT_BIT is not set                and the server performs a write, the application must call                glMemoryBarrier                with the GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT set                and then call                glFenceSync                with GL_SYNC_GPU_COMMANDS_COMPLETE (or glFinish). Then the CPU will see the writes after the sync is complete.If GL_MAP_COHERENT_BIT is set and                the server does a write, the app must call glFenceSync with                GL_SYNC_GPU_COMMANDS_COMPLETE (or                glFinish).                Then the CPU will see the writes after the                sync is complete.GL_CLIENT_STORAGE_BITWhen all other criteria for the buffer storage allocation            are met, this bit may be used by an implementation to determine            whether to use storage that is local to the server or to the            client to serve as the backing store for the buffer.
        /// The allowed combinations of flags are subject to certain    restrictions. They are as follows: If flags contains          GL_MAP_PERSISTENT_BIT, it must also contain at          least one of GL_MAP_READ_BIT or          GL_MAP_WRITE_BIT.If flags contains          GL_MAP_COHERENT_BIT, it must also contain          GL_MAP_PERSISTENT_BIT.
        /// </summary>
        /// <param name="target">Specifies the target to which the buffer object is bound for            glBufferStorage, which must be one of the            buffer binding targets in the following table:</param>
        /// <param name="buffer">Specifies the name of the buffer object for          glNamedBufferStorage function.</param>
        /// <param name="size">Specifies the size in bytes of the buffer object's new data          store.</param>
        /// <param name="data">Specifies a pointer to data that will be copied into the data          store for initialization, or NULL if no data is          to be copied.</param>
        /// <param name="flags">Specifies the intended usage of the buffer's data store. Must          be a bitwise combination of the following flags.          GL_DYNAMIC_STORAGE_BIT,          GL_MAP_READ_BITGL_MAP_WRITE_BIT,          GL_MAP_PERSISTENT_BIT,          GL_MAP_COHERENT_BIT, and          GL_CLIENT_STORAGE_BIT.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BufferStorage(BufferStorageTarget target, IntPtr size, IntPtr data, int flags) => _BufferStorage(target, size, data, flags);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BufferStorageEXT(BufferStorageTarget target, IntPtr size, IntPtr data, int flags) => _BufferStorageEXT(target, size, data, flags);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BufferStorageExternalEXT(int target, IntPtr offset, IntPtr size, IntPtr clientBuffer, int flags) => _BufferStorageExternalEXT(target, offset, size, clientBuffer, flags);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BufferStorageMemEXT(BufferTargetARB target, IntPtr size, uint memory, UInt64 offset) => _BufferStorageMemEXT(target, size, memory, offset);

        // ---

        /// <summary>
        /// glBufferSubData and            glNamedBufferSubData redefine some or all            of the data store for the specified buffer object. Data starting            at byte offset offset and extending for            size bytes is copied to the data store            from the memory pointed to by data.            offset and size            must define a range lying entirely within the buffer object's            data store.
        /// </summary>
        /// <param name="target">Specifies the target to which the buffer object is bound                    for glBufferSubData, which must be                    one of the buffer binding targets in the following                    table:</param>
        /// <param name="buffer">Specifies the name of the buffer object                    for glNamedBufferSubData.</param>
        /// <param name="offset">Specifies the offset into the buffer object's data store                    where data replacement will begin, measured in bytes.</param>
        /// <param name="size">Specifies the size in bytes of the data store region                    being replaced.</param>
        /// <param name="data">Specifies a pointer to the new data that will be copied                    into the data store.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BufferSubData(BufferTargetARB target, IntPtr offset, IntPtr size, IntPtr data) => _BufferSubData(target, offset, size, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BufferSubDataARB(BufferTargetARB target, IntPtr offset, IntPtr size, IntPtr data) => _BufferSubDataARB(target, offset, size, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CallCommandListNV(uint list) => _CallCommandListNV(list);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CallList(uint list) => _CallList(list);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CallLists(int n, ListNameType type, IntPtr lists) => _CallLists(n, type, lists);

        // ---

        /// <summary>
        /// glCheckFramebufferStatus and            glCheckNamedFramebufferStatus return the            completeness status of a framebuffer object when treated as a            read or draw framebuffer, depending on the value of            target.
        /// For glCheckFramebufferStatus, the            framebuffer checked is that bound to            target, which must be            GL_DRAW_FRAMEBUFFER,            GL_READ_FRAMEBUFFER or            GL_FRAMEBUFFER.            GL_FRAMEBUFFER is equivalent to            GL_DRAW_FRAMEBUFFER.
        /// For glCheckNamedFramebufferStatus,            framebuffer is zero or the name of the            framebuffer object to check. If            framebuffer is zero, then the status of            the default read or draw framebuffer, as determined by            target, is returned.
        /// The return value is GL_FRAMEBUFFER_COMPLETE            if the specified framebuffer is complete. Otherwise, the return            value is determined as follows:            GL_FRAMEBUFFER_UNDEFINED is                        returned if the specified framebuffer is the default                        read or draw framebuffer, but the default                        framebuffer does not exist.                    GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT                        is returned if any of the framebuffer attachment                        points are framebuffer incomplete.                    GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT                        is returned if the framebuffer does not have at                        least one image attached to it.                    GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER                         is returned if the value of                         GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE                         is GL_NONE for any color                         attachment point(s) named by                         GL_DRAW_BUFFERi.                    GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER                        is returned if GL_READ_BUFFER                        is not GL_NONE and the value of                        GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE                        is GL_NONE for the color                        attachment point named by                        GL_READ_BUFFER.                    GL_FRAMEBUFFER_UNSUPPORTED is                        returned if the combination of internal formats of                        the attached images violates an                        implementation-dependent set of restrictions.                    GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE                        is returned if the value of                        GL_RENDERBUFFER_SAMPLES is not                        the same for all attached renderbuffers; if the                        value of GL_TEXTURE_SAMPLES is                        the not same for all attached textures; or, if the                        attached images are a mix of renderbuffers and                        textures, the value of                        GL_RENDERBUFFER_SAMPLES does                        not match the value of                        GL_TEXTURE_SAMPLES.                    GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE                        is also returned if the value of                        GL_TEXTURE_FIXED_SAMPLE_LOCATIONS                        is not the same for all attached textures; or, if                        the attached images are a mix of renderbuffers and                        textures, the value of                        GL_TEXTURE_FIXED_SAMPLE_LOCATIONS                        is not GL_TRUE for all attached                        textures.                    GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS                        is returned if any framebuffer attachment is                        layered, and any populated attachment is not                        layered, or if all populated color attachments are                        not from textures of the same target.
        /// Additionally, if an error occurs, zero is returned.
        /// </summary>
        /// <param name="target">Specify the target to which the framebuffer is bound for                    glCheckFramebufferStatus, and the                    target against which framebuffer completeness of                    framebuffer is checked for                    glCheckNamedFramebufferStatus.</param>
        /// <param name="framebuffer">Specifies the name of the framebuffer object                    for glCheckNamedFramebufferStatus</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int CheckFramebufferStatus(FramebufferTarget target) => _CheckFramebufferStatus(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int CheckFramebufferStatusEXT(FramebufferTarget target) => _CheckFramebufferStatusEXT(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int CheckFramebufferStatusOES(FramebufferTarget target) => _CheckFramebufferStatusOES(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int CheckNamedFramebufferStatus(uint framebuffer, FramebufferTarget target) => _CheckNamedFramebufferStatus(framebuffer, target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int CheckNamedFramebufferStatusEXT(uint framebuffer, FramebufferTarget target) => _CheckNamedFramebufferStatusEXT(framebuffer, target);

        // ---

        /// <summary>
        /// glClampColor controls color clamping that is performed during glReadPixels.            target must be GL_CLAMP_READ_COLOR. If clamp is GL_TRUE,            read color clamping is enabled; if clamp is GL_FALSE, read color clamping is disabled. If            clamp is GL_FIXED_ONLY, read color clamping is enabled only if the selected read buffer has            fixed point components and disabled otherwise.
        /// </summary>
        /// <param name="target">Target for color clamping. target must be GL_CLAMP_READ_COLOR.</param>
        /// <param name="clamp">Specifies whether to apply color clamping. clamp must be GL_TRUE or GL_FALSE.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClampColor(ClampColorTargetARB target, ClampColorModeARB clamp) => _ClampColor(target, clamp);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClampColorARB(ClampColorTargetARB target, ClampColorModeARB clamp) => _ClampColorARB(target, clamp);

        // ---

        /// <summary>
        /// glClear sets the bitplane area of the window to values previously selected            by glClearColor, glClearDepth, and            glClearStencil.            Multiple color buffers can be cleared simultaneously by selecting            more than one buffer at a time using glDrawBuffer.
        /// The pixel ownership test,            the scissor test,            dithering, and the buffer writemasks affect the operation of glClear.            The scissor box bounds the cleared region.            Alpha function,            blend function,            logical operation,            stenciling,            texture mapping,            and depth-buffering are ignored by glClear.
        /// glClear takes a single argument that is the bitwise OR of several            values indicating which buffer is to be cleared.
        /// The values are as follows:
        /// GL_COLOR_BUFFER_BIT                        Indicates the buffers currently enabled for color                        writing.                    GL_DEPTH_BUFFER_BIT                        Indicates the depth buffer.                    GL_STENCIL_BUFFER_BIT                        Indicates the stencil buffer.
        /// The value to which each buffer is cleared depends on the setting of the            clear value for that buffer.
        /// </summary>
        /// <param name="mask">Bitwise OR of masks that indicate the buffers to be cleared.                    The three masks are                    GL_COLOR_BUFFER_BIT,                    GL_DEPTH_BUFFER_BIT, and                    GL_STENCIL_BUFFER_BIT.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Clear(int mask) => _Clear(mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearAccum(float red, float green, float blue, float alpha) => _ClearAccum(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearAccumxOES(float red, float green, float blue, float alpha) => _ClearAccumxOES(red, green, blue, alpha);

        // ---

        /// <summary>
        /// glClearBufferData and            glClearNamedBufferData fill the entirety of            a buffer object's data store with data from client memory.
        /// Data, initially supplied in a format specified by            format in data type            type is read from the memory address            given by data and converted into the            internal representation given by            internalformat, which must be one of the            following sized internal formats:
        /// This converted data is then replicated throughout the buffer            object's data store. If data is NULL,            then the buffer's data store is filled with zeros.
        /// </summary>
        /// <param name="target">Specifies the target to which the buffer object is bound                    for glClearBufferData, which must                    be one of the buffer binding targets in the                    following table:</param>
        /// <param name="buffer">Specifies the name of the buffer object for                    glClearNamedBufferData.</param>
        /// <param name="internalformat">The internal format with which the data will be stored                    in the buffer object.</param>
        /// <param name="format">The format of the data in memory addressed by                    data.</param>
        /// <param name="type">The type of the data in memory addressed by                    data.</param>
        /// <param name="data">The address of a memory location storing the data to be                    replicated into the buffer's data store.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearBufferData(BufferStorageTarget target, InternalFormat internalformat, PixelFormat format, PixelType type, IntPtr data) => _ClearBufferData(target, internalformat, format, type, data);

        // ---

        /// <summary>
        /// glClearBufferSubData and            glClearNamedBufferSubData fill a specified            region of a buffer object's data store with data from client            memory.
        /// offset and size            specify the extent of the region within the data store of the            buffer object to fill with data. Data, initially supplied in a            format specified by format in data type            type is read from the memory address            given by data and converted into the            internal representation given by            internalformat, which must be one of the            following sized internal formats:
        /// This converted data is then replicated throughout the specified            region of the buffer object's data store. If            data is NULL, then the subrange of the            buffer's data store is filled with zeros.
        /// </summary>
        /// <param name="target">Specifies the target to which the buffer object is bound                    for glClearBufferSubData, which                    must be one of the buffer binding targets in the                    following table:</param>
        /// <param name="buffer">Specifies the name of the buffer object for                    glClearNamedBufferSubData.</param>
        /// <param name="internalformat">The internal format with which the data will be stored                    in the buffer object.</param>
        /// <param name="offset">The offset in basic machine units into the buffer                    object's data store at which to start filling.</param>
        /// <param name="size">The size in basic machine units of the range of the                    data store to fill.</param>
        /// <param name="format">The format of the data in memory addressed by                    data.</param>
        /// <param name="type">The type of the data in memory addressed by                    data.</param>
        /// <param name="data">The address of a memory location storing the data to be                    replicated into the buffer's data store.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearBufferSubData(BufferTargetARB target, InternalFormat internalformat, IntPtr offset, IntPtr size, PixelFormat format, PixelType type, IntPtr data) => _ClearBufferSubData(target, internalformat, offset, size, format, type, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearBufferfi(Buffer buffer, int drawbuffer, float depth, int stencil) => _ClearBufferfi(buffer, drawbuffer, depth, stencil);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearBufferfv(Buffer buffer, int drawbuffer, float[] value) => _ClearBufferfv(buffer, drawbuffer, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearBufferfv(Buffer buffer, int drawbuffer, void* value) => _ClearBufferfv_ptr(buffer, drawbuffer, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearBufferfv(Buffer buffer, int drawbuffer, IntPtr value) => _ClearBufferfv_intptr(buffer, drawbuffer, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearBufferiv(Buffer buffer, int drawbuffer, int[] value) => _ClearBufferiv(buffer, drawbuffer, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearBufferiv(Buffer buffer, int drawbuffer, void* value) => _ClearBufferiv_ptr(buffer, drawbuffer, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearBufferiv(Buffer buffer, int drawbuffer, IntPtr value) => _ClearBufferiv_intptr(buffer, drawbuffer, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearBufferuiv(Buffer buffer, int drawbuffer, uint[] value) => _ClearBufferuiv(buffer, drawbuffer, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearBufferuiv(Buffer buffer, int drawbuffer, void* value) => _ClearBufferuiv_ptr(buffer, drawbuffer, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearBufferuiv(Buffer buffer, int drawbuffer, IntPtr value) => _ClearBufferuiv_intptr(buffer, drawbuffer, value);

        // ---

        /// <summary>
        /// glClearColor specifies the red,            green,            blue,            and alpha values used by glClear to clear the color buffers.            Values specified by glClearColor are clamped to the range            .
        /// </summary>
        /// <param name="alpha">Specify the red, green, blue, and alpha values used when the                    color buffers are cleared.                    The initial values are all 0.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearColor(float red, float green, float blue, float alpha) => _ClearColor(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearColorIiEXT(int red, int green, int blue, int alpha) => _ClearColorIiEXT(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearColorIuiEXT(uint red, uint green, uint blue, uint alpha) => _ClearColorIuiEXT(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearColorx(float red, float green, float blue, float alpha) => _ClearColorx(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearColorxOES(float red, float green, float blue, float alpha) => _ClearColorxOES(red, green, blue, alpha);

        // ---

        /// <summary>
        /// glClearDepth specifies the depth value used by glClear to clear the depth buffer.            Values specified by glClearDepth are clamped to the range            .
        /// </summary>
        /// <param name="depth">Specifies the depth value used when the depth buffer is cleared. The                    initial value is 1.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearDepth(double depth) => _ClearDepth(depth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearDepthdNV(double depth) => _ClearDepthdNV(depth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearDepthf(float d) => _ClearDepthf(d);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearDepthfOES(float depth) => _ClearDepthfOES(depth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearDepthx(float depth) => _ClearDepthx(depth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearDepthxOES(float depth) => _ClearDepthxOES(depth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearIndex(float c) => _ClearIndex(c);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearNamedBufferData(uint buffer, InternalFormat internalformat, PixelFormat format, PixelType type, IntPtr data) => _ClearNamedBufferData(buffer, internalformat, format, type, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearNamedBufferDataEXT(uint buffer, InternalFormat internalformat, PixelFormat format, PixelType type, IntPtr data) => _ClearNamedBufferDataEXT(buffer, internalformat, format, type, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearNamedBufferSubData(uint buffer, InternalFormat internalformat, IntPtr offset, IntPtr size, PixelFormat format, PixelType type, IntPtr data) => _ClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearNamedBufferSubDataEXT(uint buffer, int internalformat, IntPtr offset, IntPtr size, PixelFormat format, PixelType type, IntPtr data) => _ClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, type, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearNamedFramebufferfi(uint framebuffer, Buffer buffer, int drawbuffer, float depth, int stencil) => _ClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearNamedFramebufferfv(uint framebuffer, Buffer buffer, int drawbuffer, float[] value) => _ClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearNamedFramebufferfv(uint framebuffer, Buffer buffer, int drawbuffer, void* value) => _ClearNamedFramebufferfv_ptr(framebuffer, buffer, drawbuffer, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearNamedFramebufferfv(uint framebuffer, Buffer buffer, int drawbuffer, IntPtr value) => _ClearNamedFramebufferfv_intptr(framebuffer, buffer, drawbuffer, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearNamedFramebufferiv(uint framebuffer, Buffer buffer, int drawbuffer, int[] value) => _ClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearNamedFramebufferiv(uint framebuffer, Buffer buffer, int drawbuffer, void* value) => _ClearNamedFramebufferiv_ptr(framebuffer, buffer, drawbuffer, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearNamedFramebufferiv(uint framebuffer, Buffer buffer, int drawbuffer, IntPtr value) => _ClearNamedFramebufferiv_intptr(framebuffer, buffer, drawbuffer, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearNamedFramebufferuiv(uint framebuffer, Buffer buffer, int drawbuffer, uint[] value) => _ClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearNamedFramebufferuiv(uint framebuffer, Buffer buffer, int drawbuffer, void* value) => _ClearNamedFramebufferuiv_ptr(framebuffer, buffer, drawbuffer, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearNamedFramebufferuiv(uint framebuffer, Buffer buffer, int drawbuffer, IntPtr value) => _ClearNamedFramebufferuiv_intptr(framebuffer, buffer, drawbuffer, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearPixelLocalStorageuiEXT(int offset, int n, uint[] values) => _ClearPixelLocalStorageuiEXT(offset, n, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearPixelLocalStorageuiEXT(int offset, int n, void* values) => _ClearPixelLocalStorageuiEXT_ptr(offset, n, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearPixelLocalStorageuiEXT(int offset, int n, IntPtr values) => _ClearPixelLocalStorageuiEXT_intptr(offset, n, values);

        // ---

        /// <summary>
        /// glClearStencil specifies the index used by glClear to clear the stencil buffer.            s is masked with                        is the number of bits in the stencil buffer.
        /// </summary>
        /// <param name="s">Specifies the index used when the stencil buffer is cleared.                    The initial value is 0.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearStencil(int s) => _ClearStencil(s);

        // ---

        /// <summary>
        /// glClearTexImage fills all an image contained in a            texture with an application supplied value. texture must be            the name of an existing texture. Further, texture may not be            the name of a buffer texture, nor may its internal format be compressed.
        /// format and type specify the format and type of the            source data and are interpreted as they are for glTexImage3D.            Textures with a base internal format of GL_DEPTH_COMPONENT, GL_STENCIL_INDEX, or GL_DEPTH_STENCIL            require depth component, stencil, or depth-stencil component data respectively.            Textures with other base internal formats require RGBA formats. Textures with integer            internal formats require integer data.
        /// data is a pointer to an array of between one and four components of texel            data that will be used as the source for the constant fill value. The elements of            data are converted by the GL into the internal format of the texture image (that            was specified when the level was defined by any of the glTexImage*, glTexStorage*            or glCopyTexImage* commands), and then            used to fill the specified range of the destination texture level. If data is NULL, then            the pointer is ignored and the sub-range of the texture image is filled with zeros. If            texture is a multisample texture, all the samples in a texel are cleared to the value            specified by data.
        /// </summary>
        /// <param name="texture">The name of an existing texture object containing the image to be cleared.</param>
        /// <param name="level">The level of texture containing the region to be cleared.</param>
        /// <param name="format">The format of the data whose address in memory is given by data.</param>
        /// <param name="type">The type of the data whose address in memory is given by data.</param>
        /// <param name="data">The address in memory of the data to be used to clear the specified region.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearTexImage(uint texture, int level, PixelFormat format, PixelType type, IntPtr data) => _ClearTexImage(texture, level, format, type, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearTexImageEXT(uint texture, int level, PixelFormat format, PixelType type, IntPtr data) => _ClearTexImageEXT(texture, level, format, type, data);

        // ---

        /// <summary>
        /// glClearTexSubImage fills all or part of an image contained in a            texture with an application supplied value. texture must be            the name of an existing texture. Further, texture may not be            the name of a buffer texture, nor may its internal format be compressed.
        /// Arguments xoffset, yoffset, and            zoffset specify the lower left texel coordinates of            a width-wide by height-high by depth-deep rectangular subregion of the texel array.
        /// For one-dimensional array textures, yoffset is interpreted as the first layer to            be cleared and height is the number of layers to clear. For two-dimensional array            textures, zoffset is interpreted as the first layer to be cleared and depth is the number            of layers to clear. Cube map textures are treated as an array of six slices in the z-dimension,            where the value of zoffset is interpreted as specifying the cube map face            for the corresponding layer and depth is the number of faces to clear.            For cube map array textures, zoffset is the first layer-face to clear,            and depth is the number of layer-faces to clear. Each layer-face is            translated into an array layer and a cube map face as described in the OpenGL Specification.
        /// Negative values of xoffset, yoffset, and zoffset correspond to the coordinates of            border texels. Taking                        to be the xoffset, yoffset,            zoffset, width, height, and depth argument values,            any of the following relationships generates a GL_INVALID_OPERATION error:            x<wbx+w>ws-wby<-hby+h>hs-hbz<-dbz+d>ds-db
        /// For texture types that do not have certain dimensions, this command treats those            dimensions as having a size of 1. For example, to clear a portion of a two-dimensional            texture, use zoffset equal to zero and depth equal to one.
        /// format and type specify the format and type of the            source data and are interpreted as they are for glTexImage3D.            Textures with a base internal format of GL_DEPTH_COMPONENT, GL_STENCIL_INDEX, or GL_DEPTH_STENCIL            require depth component, stencil, or depth-stencil component data respectively.            Textures with other base internal formats require RGBA formats. Textures with integer            internal formats require integer data.
        /// data is a pointer to an array of between one and four components of texel            data that will be used as the source for the constant fill value. The elements of            data are converted by the GL into the internal format of the texture image (that            was specified when the level was defined by any of the glTexImage*, glTexStorage*            or glCopyTexImage* commands), and then            used to fill the specified range of the destination texture level. If data is NULL, then            the pointer is ignored and the sub-range of the texture image is filled with zeros. If            texture is a multisample texture, all the samples in a texel are cleared to the value            specified by data.
        /// </summary>
        /// <param name="texture">The name of an existing texture object containing the image to be cleared.</param>
        /// <param name="level">The level of texture containing the region to be cleared.</param>
        /// <param name="xoffset">The coordinate of the left edge of the region to be cleared.</param>
        /// <param name="yoffset">The coordinate of the lower edge of the region to be cleared.</param>
        /// <param name="zoffset">The coordinate of the front of the region to be cleared.</param>
        /// <param name="width">The width of the region to be cleared.</param>
        /// <param name="height">The height of the region to be cleared.</param>
        /// <param name="depth">The depth of the region to be cleared.</param>
        /// <param name="format">The format of the data whose address in memory is given by data.</param>
        /// <param name="type">The type of the data whose address in memory is given by data.</param>
        /// <param name="data">The address in memory of the data to be used to clear the specified region.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr data) => _ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClearTexSubImageEXT(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr data) => _ClearTexSubImageEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClientActiveTexture(TextureUnit texture) => _ClientActiveTexture(texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClientActiveTextureARB(TextureUnit texture) => _ClientActiveTextureARB(texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClientActiveVertexStreamATI(VertexStreamATI stream) => _ClientActiveVertexStreamATI(stream);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClientAttribDefaultEXT(int mask) => _ClientAttribDefaultEXT(mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClientWaitSemaphoreui64NVX(int fenceObjectCount, uint[] semaphoreArray, UInt64[] fenceValueArray) => _ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray, fenceValueArray);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClientWaitSemaphoreui64NVX(int fenceObjectCount, void* semaphoreArray, void* fenceValueArray) => _ClientWaitSemaphoreui64NVX_ptr(fenceObjectCount, semaphoreArray, fenceValueArray);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClientWaitSemaphoreui64NVX(int fenceObjectCount, IntPtr semaphoreArray, IntPtr fenceValueArray) => _ClientWaitSemaphoreui64NVX_intptr(fenceObjectCount, semaphoreArray, fenceValueArray);

        // ---

        /// <summary>
        /// glClientWaitSync causes the client to block and wait for the sync object specified by sync to become signaled. If            sync is signaled when glClientWaitSync is called, glClientWaitSync returns immediately, otherwise            it will block and wait for up to timeout nanoseconds for sync to become signaled.
        /// The return value is one of four status values:            GL_ALREADY_SIGNALED indicates that sync was signaled at the time that glClientWaitSync                        was called.                    GL_TIMEOUT_EXPIRED indicates that at least timeout nanoseconds passed and sync did not                        become signaled.                    GL_CONDITION_SATISFIED indicates that sync was signaled before the timeout expired.                    GL_WAIT_FAILED indicates that an error occurred. Additionally, an OpenGL error will be generated.
        /// </summary>
        /// <param name="sync">The sync object whose status to wait on.</param>
        /// <param name="flags">A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT.</param>
        /// <param name="timeout">The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int ClientWaitSync(int sync, int flags, UInt64 timeout) => _ClientWaitSync(sync, flags, timeout);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int ClientWaitSyncAPPLE(int sync, int flags, UInt64 timeout) => _ClientWaitSyncAPPLE(sync, flags, timeout);

        // ---

        /// <summary>
        /// glClipControl controls the clipping volume            behavior and the clip coordinate to window coordinate            transformation behavior.
        /// The view volume is defined by                $$z_{min} \leq z_c \leq w_c$$            where $z_{min} = -w_c$ when depth is            GL_NEGATIVE_ONE_TO_ONE, and $z_{min} = 0$            when depth is            GL_ZERO_TO_ONE.
        /// The normalized device coordinate $y_d$ is given by                $$y_d = { { f \times y_c } \over w_c }$$            where $f = 1$ when origin is            GL_LOWER_LEFT, and $f = -1$ when            origin is            GL_UPPER_LEFT.
        /// The window coordinate $z_w$ is given by                $$z_w = s \times z_d + b$$            where $s = { { f - n } \over 2 }$ and $b = { {n + f} \over 2 }$ when            depth is            GL_NEGATIVE_ONE_TO_ONE, and $s = f - n$ and            $b = n$ when depth is            GL_ZERO_TO_ONE. $n$ and $f$ are the near            and far depth range values set with            glDepthRange.
        /// Finally, the polygon area computation defined by            gl_FrontFacing            to determine if a polygon is front- or back-facing has its sign            negated when origin is            GL_UPPER_LEFT.
        /// </summary>
        /// <param name="origin">Specifies the clip control origin. Must be one of                         GL_LOWER_LEFT or                         GL_UPPER_LEFT.</param>
        /// <param name="depth">Specifies the clip control depth mode. Must be one                        of GL_NEGATIVE_ONE_TO_ONE or                        GL_ZERO_TO_ONE.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipControl(ClipControlOrigin origin, ClipControlDepth depth) => _ClipControl(origin, depth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipControlEXT(int origin, int depth) => _ClipControlEXT(origin, depth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlane(ClipPlaneName plane, double[] equation) => _ClipPlane(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlane(ClipPlaneName plane, void* equation) => _ClipPlane_ptr(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlane(ClipPlaneName plane, IntPtr equation) => _ClipPlane_intptr(plane, equation);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanef(ClipPlaneName p, float[] eqn) => _ClipPlanef(p, eqn);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanef(ClipPlaneName p, void* eqn) => _ClipPlanef_ptr(p, eqn);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanef(ClipPlaneName p, IntPtr eqn) => _ClipPlanef_intptr(p, eqn);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanefIMG(ClipPlaneName p, float[] eqn) => _ClipPlanefIMG(p, eqn);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanefIMG(ClipPlaneName p, void* eqn) => _ClipPlanefIMG_ptr(p, eqn);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanefIMG(ClipPlaneName p, IntPtr eqn) => _ClipPlanefIMG_intptr(p, eqn);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanefOES(ClipPlaneName plane, float[] equation) => _ClipPlanefOES(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanefOES(ClipPlaneName plane, void* equation) => _ClipPlanefOES_ptr(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanefOES(ClipPlaneName plane, IntPtr equation) => _ClipPlanefOES_intptr(plane, equation);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanex(ClipPlaneName plane, float[] equation) => _ClipPlanex(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanex(ClipPlaneName plane, void* equation) => _ClipPlanex_ptr(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanex(ClipPlaneName plane, IntPtr equation) => _ClipPlanex_intptr(plane, equation);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanexIMG(ClipPlaneName p, float[] eqn) => _ClipPlanexIMG(p, eqn);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanexIMG(ClipPlaneName p, void* eqn) => _ClipPlanexIMG_ptr(p, eqn);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanexIMG(ClipPlaneName p, IntPtr eqn) => _ClipPlanexIMG_intptr(p, eqn);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanexOES(ClipPlaneName plane, float[] equation) => _ClipPlanexOES(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanexOES(ClipPlaneName plane, void* equation) => _ClipPlanexOES_ptr(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ClipPlanexOES(ClipPlaneName plane, IntPtr equation) => _ClipPlanexOES_intptr(plane, equation);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3b(sbyte red, sbyte green, sbyte blue) => _Color3b(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3bv(sbyte[] v) => _Color3bv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3bv(void* v) => _Color3bv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3bv(IntPtr v) => _Color3bv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3d(double red, double green, double blue) => _Color3d(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3dv(double[] v) => _Color3dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3dv(void* v) => _Color3dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3dv(IntPtr v) => _Color3dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3f(float red, float green, float blue) => _Color3f(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3fVertex3fSUN(float r, float g, float b, float x, float y, float z) => _Color3fVertex3fSUN(r, g, b, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3fVertex3fvSUN(float[] c, float[] v) => _Color3fVertex3fvSUN(c, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3fVertex3fvSUN(void* c, void* v) => _Color3fVertex3fvSUN_ptr(c, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3fVertex3fvSUN(IntPtr c, IntPtr v) => _Color3fVertex3fvSUN_intptr(c, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3fv(float[] v) => _Color3fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3fv(void* v) => _Color3fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3fv(IntPtr v) => _Color3fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3hNV(float red, float green, float blue) => _Color3hNV(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3hvNV(float[] v) => _Color3hvNV(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3hvNV(void* v) => _Color3hvNV_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3hvNV(IntPtr v) => _Color3hvNV_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3i(int red, int green, int blue) => _Color3i(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3iv(int[] v) => _Color3iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3iv(void* v) => _Color3iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3iv(IntPtr v) => _Color3iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3s(short red, short green, short blue) => _Color3s(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3sv(short[] v) => _Color3sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3sv(void* v) => _Color3sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3sv(IntPtr v) => _Color3sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3ub(byte red, byte green, byte blue) => _Color3ub(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3ubv(byte[] v) => _Color3ubv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3ubv(void* v) => _Color3ubv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3ubv(IntPtr v) => _Color3ubv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3ui(uint red, uint green, uint blue) => _Color3ui(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3uiv(uint[] v) => _Color3uiv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3uiv(void* v) => _Color3uiv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3uiv(IntPtr v) => _Color3uiv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3us(ushort red, ushort green, ushort blue) => _Color3us(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3usv(ushort[] v) => _Color3usv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3usv(void* v) => _Color3usv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3usv(IntPtr v) => _Color3usv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3xOES(float red, float green, float blue) => _Color3xOES(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3xvOES(float[] components) => _Color3xvOES(components);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3xvOES(void* components) => _Color3xvOES_ptr(components);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color3xvOES(IntPtr components) => _Color3xvOES_intptr(components);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4b(sbyte red, sbyte green, sbyte blue, sbyte alpha) => _Color4b(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4bv(sbyte[] v) => _Color4bv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4bv(void* v) => _Color4bv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4bv(IntPtr v) => _Color4bv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4d(double red, double green, double blue, double alpha) => _Color4d(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4dv(double[] v) => _Color4dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4dv(void* v) => _Color4dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4dv(IntPtr v) => _Color4dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4f(float red, float green, float blue, float alpha) => _Color4f(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4fNormal3fVertex3fSUN(float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => _Color4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4fNormal3fVertex3fvSUN(float[] c, float[] n, float[] v) => _Color4fNormal3fVertex3fvSUN(c, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4fNormal3fVertex3fvSUN(void* c, void* n, void* v) => _Color4fNormal3fVertex3fvSUN_ptr(c, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4fNormal3fVertex3fvSUN(IntPtr c, IntPtr n, IntPtr v) => _Color4fNormal3fVertex3fvSUN_intptr(c, n, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4fv(float[] v) => _Color4fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4fv(void* v) => _Color4fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4fv(IntPtr v) => _Color4fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4hNV(float red, float green, float blue, float alpha) => _Color4hNV(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4hvNV(float[] v) => _Color4hvNV(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4hvNV(void* v) => _Color4hvNV_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4hvNV(IntPtr v) => _Color4hvNV_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4i(int red, int green, int blue, int alpha) => _Color4i(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4iv(int[] v) => _Color4iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4iv(void* v) => _Color4iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4iv(IntPtr v) => _Color4iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4s(short red, short green, short blue, short alpha) => _Color4s(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4sv(short[] v) => _Color4sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4sv(void* v) => _Color4sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4sv(IntPtr v) => _Color4sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4ub(byte red, byte green, byte blue, byte alpha) => _Color4ub(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4ubVertex2fSUN(byte r, byte g, byte b, byte a, float x, float y) => _Color4ubVertex2fSUN(r, g, b, a, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4ubVertex2fvSUN(byte[] c, float[] v) => _Color4ubVertex2fvSUN(c, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4ubVertex2fvSUN(void* c, void* v) => _Color4ubVertex2fvSUN_ptr(c, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4ubVertex2fvSUN(IntPtr c, IntPtr v) => _Color4ubVertex2fvSUN_intptr(c, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4ubVertex3fSUN(byte r, byte g, byte b, byte a, float x, float y, float z) => _Color4ubVertex3fSUN(r, g, b, a, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4ubVertex3fvSUN(byte[] c, float[] v) => _Color4ubVertex3fvSUN(c, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4ubVertex3fvSUN(void* c, void* v) => _Color4ubVertex3fvSUN_ptr(c, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4ubVertex3fvSUN(IntPtr c, IntPtr v) => _Color4ubVertex3fvSUN_intptr(c, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4ubv(byte[] v) => _Color4ubv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4ubv(void* v) => _Color4ubv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4ubv(IntPtr v) => _Color4ubv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4ui(uint red, uint green, uint blue, uint alpha) => _Color4ui(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4uiv(uint[] v) => _Color4uiv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4uiv(void* v) => _Color4uiv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4uiv(IntPtr v) => _Color4uiv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4us(ushort red, ushort green, ushort blue, ushort alpha) => _Color4us(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4usv(ushort[] v) => _Color4usv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4usv(void* v) => _Color4usv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4usv(IntPtr v) => _Color4usv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4x(float red, float green, float blue, float alpha) => _Color4x(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4xOES(float red, float green, float blue, float alpha) => _Color4xOES(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4xvOES(float[] components) => _Color4xvOES(components);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4xvOES(void* components) => _Color4xvOES_ptr(components);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Color4xvOES(IntPtr components) => _Color4xvOES_intptr(components);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorFormatNV(int size, int type, int stride) => _ColorFormatNV(size, type, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorFragmentOp1ATI(FragmentOpATI op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod) => _ColorFragmentOp1ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorFragmentOp2ATI(FragmentOpATI op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod) => _ColorFragmentOp2ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorFragmentOp3ATI(FragmentOpATI op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod) => _ColorFragmentOp3ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);

        // ---

        /// <summary>
        /// glColorMask and glColorMaski specify whether the individual color components in the frame buffer            can or cannot be written. glColorMaski sets the mask for a specific draw buffer, whereas            glColorMask sets the mask for all draw buffers.            If red is GL_FALSE,            for example,            no change is made to the red component of any pixel in any of the            color buffers,            regardless of the drawing operation attempted.
        /// Changes to individual bits of components cannot be controlled.            Rather,            changes are either enabled or disabled for entire color components.
        /// </summary>
        /// <param name="buf">For glColorMaski, specifies the index of the                    draw buffer whose color mask to set.</param>
        /// <param name="alpha">Specify whether red, green, blue, and alpha are to be written                    into the frame buffer.                    The initial values are all GL_TRUE,                    indicating that the color components are written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorMask(bool red, bool green, bool blue, bool alpha) => _ColorMask(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorMaskIndexedEXT(uint index, bool r, bool g, bool b, bool a) => _ColorMaskIndexedEXT(index, r, g, b, a);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorMaski(uint index, bool r, bool g, bool b, bool a) => _ColorMaski(index, r, g, b, a);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorMaskiEXT(uint index, bool r, bool g, bool b, bool a) => _ColorMaskiEXT(index, r, g, b, a);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorMaskiOES(uint index, bool r, bool g, bool b, bool a) => _ColorMaskiOES(index, r, g, b, a);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorMaterial(MaterialFace face, ColorMaterialParameter mode) => _ColorMaterial(face, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorP3ui(ColorPointerType type, uint color) => _ColorP3ui(type, color);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorP3uiv(ColorPointerType type, uint[] color) => _ColorP3uiv(type, color);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorP3uiv(ColorPointerType type, void* color) => _ColorP3uiv_ptr(type, color);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorP3uiv(ColorPointerType type, IntPtr color) => _ColorP3uiv_intptr(type, color);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorP4ui(ColorPointerType type, uint color) => _ColorP4ui(type, color);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorP4uiv(ColorPointerType type, uint[] color) => _ColorP4uiv(type, color);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorP4uiv(ColorPointerType type, void* color) => _ColorP4uiv_ptr(type, color);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorP4uiv(ColorPointerType type, IntPtr color) => _ColorP4uiv_intptr(type, color);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorPointer(int size, ColorPointerType type, int stride, IntPtr pointer) => _ColorPointer(size, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorPointerEXT(int size, ColorPointerType type, int stride, int count, IntPtr pointer) => _ColorPointerEXT(size, type, stride, count, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorPointerListIBM(int size, ColorPointerType type, int stride, IntPtr* pointer, int ptrstride) => _ColorPointerListIBM(size, type, stride, pointer, ptrstride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorPointervINTEL(int size, VertexPointerType type, IntPtr* pointer) => _ColorPointervINTEL(size, type, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorSubTable(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, IntPtr data) => _ColorSubTable(target, start, count, format, type, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorSubTableEXT(ColorTableTarget target, int start, int count, PixelFormat format, PixelType type, IntPtr data) => _ColorSubTableEXT(target, start, count, format, type, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorTable(ColorTableTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, IntPtr table) => _ColorTable(target, internalformat, width, format, type, table);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorTableEXT(ColorTableTarget target, InternalFormat internalFormat, int width, PixelFormat format, PixelType type, IntPtr table) => _ColorTableEXT(target, internalFormat, width, format, type, table);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorTableParameterfv(ColorTableTarget target, ColorTableParameterPNameSGI pname, float[] @params) => _ColorTableParameterfv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorTableParameterfv(ColorTableTarget target, ColorTableParameterPNameSGI pname, void* @params) => _ColorTableParameterfv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorTableParameterfv(ColorTableTarget target, ColorTableParameterPNameSGI pname, IntPtr @params) => _ColorTableParameterfv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorTableParameterfvSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, float[] @params) => _ColorTableParameterfvSGI(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorTableParameterfvSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, void* @params) => _ColorTableParameterfvSGI_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorTableParameterfvSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, IntPtr @params) => _ColorTableParameterfvSGI_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorTableParameteriv(ColorTableTarget target, ColorTableParameterPNameSGI pname, int[] @params) => _ColorTableParameteriv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorTableParameteriv(ColorTableTarget target, ColorTableParameterPNameSGI pname, void* @params) => _ColorTableParameteriv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorTableParameteriv(ColorTableTarget target, ColorTableParameterPNameSGI pname, IntPtr @params) => _ColorTableParameteriv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorTableParameterivSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, int[] @params) => _ColorTableParameterivSGI(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorTableParameterivSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, void* @params) => _ColorTableParameterivSGI_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorTableParameterivSGI(ColorTableTargetSGI target, ColorTableParameterPNameSGI pname, IntPtr @params) => _ColorTableParameterivSGI_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ColorTableSGI(ColorTableTargetSGI target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, IntPtr table) => _ColorTableSGI(target, internalformat, width, format, type, table);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CombinerInputNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerRegisterNV input, CombinerMappingNV mapping, CombinerComponentUsageNV componentUsage) => _CombinerInputNV(stage, portion, variable, input, mapping, componentUsage);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CombinerOutputNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerRegisterNV abOutput, CombinerRegisterNV cdOutput, CombinerRegisterNV sumOutput, CombinerScaleNV scale, CombinerBiasNV bias, bool abDotProduct, bool cdDotProduct, bool muxSum) => _CombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CombinerParameterfNV(CombinerParameterNV pname, float param) => _CombinerParameterfNV(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CombinerParameterfvNV(CombinerParameterNV pname, float[] @params) => _CombinerParameterfvNV(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CombinerParameterfvNV(CombinerParameterNV pname, void* @params) => _CombinerParameterfvNV_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CombinerParameterfvNV(CombinerParameterNV pname, IntPtr @params) => _CombinerParameterfvNV_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CombinerParameteriNV(CombinerParameterNV pname, int param) => _CombinerParameteriNV(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CombinerParameterivNV(CombinerParameterNV pname, int[] @params) => _CombinerParameterivNV(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CombinerParameterivNV(CombinerParameterNV pname, void* @params) => _CombinerParameterivNV_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CombinerParameterivNV(CombinerParameterNV pname, IntPtr @params) => _CombinerParameterivNV_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, float[] @params) => _CombinerStageParameterfvNV(stage, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, void* @params) => _CombinerStageParameterfvNV_ptr(stage, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, IntPtr @params) => _CombinerStageParameterfvNV_intptr(stage, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CommandListSegmentsNV(uint list, uint segments) => _CommandListSegmentsNV(list, segments);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompileCommandListNV(uint list) => _CompileCommandListNV(list);

        // ---

        /// <summary>
        /// glCompileShader compiles the source    code strings that have been stored in the shader object    specified by shader.
        /// The compilation status will be stored as part of the    shader object's state. This value will be set to    GL_TRUE if the shader was compiled without    errors and is ready for use, and GL_FALSE    otherwise. It can be queried by calling    glGetShader    with arguments shader and    GL_COMPILE_STATUS.
        /// Compilation of a shader can fail for a number of reasons    as specified by the OpenGL Shading Language Specification.    Whether or not the compilation was successful, information about    the compilation can be obtained from the shader object's    information log by calling    glGetShaderInfoLog.
        /// </summary>
        /// <param name="shader">Specifies the shader object to be            compiled.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompileShader(uint shader) => _CompileShader(shader);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompileShaderARB(int shaderObj) => _CompileShaderARB(shaderObj);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompileShaderIncludeARB(uint shader, int count, string[] path, int[] length) => _CompileShaderIncludeARB(shader, count, path, length);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompileShaderIncludeARB(uint shader, int count, void* path, void* length) => _CompileShaderIncludeARB_ptr(shader, count, path, length);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompileShaderIncludeARB(uint shader, int count, IntPtr path, IntPtr length) => _CompileShaderIncludeARB_intptr(shader, count, path, length);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedMultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, IntPtr bits) => _CompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, bits);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedMultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, IntPtr bits) => _CompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedMultiTexImage3DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, IntPtr bits) => _CompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedMultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, PixelFormat format, int imageSize, IntPtr bits) => _CompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, bits);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedMultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, int imageSize, IntPtr bits) => _CompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedMultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, int imageSize, IntPtr bits) => _CompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);

        // ---

        /// <summary>
        /// Texturing allows elements of an image array to be read by shaders.
        /// glCompressedTexImage1D loads a previously defined, and retrieved, compressed            one-dimensional texture image if target is GL_TEXTURE_1D            (see glTexImage1D).
        /// If target is GL_PROXY_TEXTURE_1D, no data is read from data, but            all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities.  If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see glGetError). To query for an entire mipmap array, use an image array level greater than or equal to 1.
        /// internalformat must be an extension-specified compressed-texture format.            When a texture is loaded with            glTexImage1D using a generic compressed  texture format            (e.g., GL_COMPRESSED_RGB) the GL selects from one of            its extensions supporting compressed textures.  In order to load the            compressed texture image using glCompressedTexImage1D, query the compressed texture image's size and            format using glGetTexLevelParameter.
        /// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target            (see glBindBuffer) while a texture image is            specified, data is treated as a byte offset into the buffer object's data store.
        /// If the compressed data are arranged into fixed-size blocks of texels, the pixel            storage modes can be used to select a sub-rectangle from a larger containing rectangle.            These pixel storage modes operate in the same way as they do for glTexImage1D.            In the following description, denote by
        /// </summary>
        /// <param name="target">Specifies the target texture.                    Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number.                    Level 0 is the base image level.                    Level n is the nth mipmap reduction image.</param>
        /// <param name="internalformat">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="width">Specifies the width of the texture image.                    All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTexImage1D(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, IntPtr data) => _CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTexImage1DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, IntPtr data) => _CompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data);

        // ---

        /// <summary>
        /// Texturing allows elements of an image array to be read by shaders.
        /// glCompressedTexImage2D loads a previously defined, and retrieved, compressed two-dimensional            texture image if target is GL_TEXTURE_2D, or one of the            cube map faces such as GL_TEXTURE_CUBE_MAP_POSITIVE_X.            (see glTexImage2D).
        /// If target is GL_TEXTURE_1D_ARRAY, data            is treated as an array of compressed 1D textures.
        /// If target is GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY            or GL_PROXY_TEXTURE_CUBE_MAP, no data is read from data, but            all of the texture image state is recalculated, checked for consistency,            and checked against the implementation's capabilities.  If the            implementation cannot handle a texture of the requested texture size, it            sets all of the image state to 0, but does not generate an error (see            glGetError). To query for an entire mipmap array,            use an image array level greater than or equal to 1.
        /// internalformat must be a known compressed image format (such as GL_RGTC)            or an extension-specified compressed-texture format.            When a texture is loaded with glTexImage2D using a generic compressed            texture format (e.g., GL_COMPRESSED_RGB), the GL selects from one of            its extensions supporting compressed textures.  In order to load the            compressed texture image using glCompressedTexImage2D, query the compressed texture image's            size and format using glGetTexLevelParameter.
        /// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target            (see glBindBuffer) while a texture image is            specified, data is treated as a byte offset into the buffer object's data store.
        /// If the compressed data are arranged into fixed-size blocks of texels, the pixel            storage modes can be used to select a sub-rectangle from a larger containing rectangle.            These pixel storage modes operate in the same way as they do for glTexImage2D.            In the following description, denote by
        /// </summary>
        /// <param name="target">Specifies the target texture.                    Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D,                    GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY,                    GL_TEXTURE_CUBE_MAP_POSITIVE_X,                    GL_TEXTURE_CUBE_MAP_NEGATIVE_X,                    GL_TEXTURE_CUBE_MAP_POSITIVE_Y,                    GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,                    GL_TEXTURE_CUBE_MAP_POSITIVE_Z,                    GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or                    GL_PROXY_TEXTURE_CUBE_MAP.</param>
        /// <param name="level">Specifies the level-of-detail number.                    Level 0 is the base image level.                    Level n is the nth mipmap reduction image.</param>
        /// <param name="internalformat">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="width">Specifies the width of the texture image.                    All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.</param>
        /// <param name="height">Specifies the height of the texture image.                    All implementations support 2D texture and cube map texture images that are at least 16384 texels high.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the                    address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTexImage2D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, IntPtr data) => _CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTexImage2DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, IntPtr data) => _CompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data);

        // ---

        /// <summary>
        /// Texturing allows elements of an image array to be read by shaders.
        /// glCompressedTexImage3D loads a previously defined, and retrieved, compressed three-dimensional            texture image if target is GL_TEXTURE_3D (see glTexImage3D).
        /// If target is GL_TEXTURE_2D_ARRAY, data is            treated as an array of compressed 2D textures.
        /// If target is GL_PROXY_TEXTURE_3D or GL_PROXY_TEXTURE_2D_ARRAY,            no data is read from data, but            all of the texture image state is recalculated, checked for consistency,            and checked against the implementation's capabilities.  If the            implementation cannot handle a texture of the requested texture size, it            sets all of the image state to 0, but does not generate an error (see            glGetError). To query for an entire mipmap array, use an image array level            greater than or equal to 1.
        /// internalformat must be a known compressed image format (such as GL_RGTC)            or an extension-specified compressed-texture format.            When a texture is loaded with glTexImage2D using a generic compressed            texture format (e.g., GL_COMPRESSED_RGB), the GL selects from one of            its extensions supporting compressed textures.  In order to load the            compressed texture image using glCompressedTexImage3D, query the compressed texture image's            size and format using glGetTexLevelParameter.
        /// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target            (see glBindBuffer) while a texture image is            specified, data is treated as a byte offset into the buffer object's data store.
        /// If the compressed data are arranged into fixed-size blocks of texels, the pixel            storage modes can be used to select a sub-rectangle from a larger containing rectangle.            These pixel storage modes operate in the same way as they do for glTexImage1D.            In the following description, denote by
        /// </summary>
        /// <param name="target">Specifies the target texture.                    Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D,                    GL_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_2D_ARRAY.</param>
        /// <param name="level">Specifies the level-of-detail number.                    Level 0 is the base image level.                    Level n is the nth mipmap reduction image.</param>
        /// <param name="internalformat">Specifies the format of the compressed image data stored at address data.</param>
        /// <param name="width">Specifies the width of the texture image.                    All implementations support 3D texture images that are at least 16 texels wide.</param>
        /// <param name="height">Specifies the height of the texture image.                    All implementations support 3D texture images that are at least 16 texels                    high.</param>
        /// <param name="depth">Specifies the depth of the texture image.                    All implementations support 3D texture images that are at least 16 texels                    deep.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting at the                    address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in memory.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTexImage3D(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, IntPtr data) => _CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTexImage3DARB(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, IntPtr data) => _CompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTexImage3DOES(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, IntPtr data) => _CompressedTexImage3DOES(target, level, internalformat, width, height, depth, border, imageSize, data);

        // ---

        /// <summary>
        /// Texturing allows elements of an image array to be read by    shaders.
        /// glCompressedTexSubImage1D and    glCompressedTextureSubImage1D redefine a contiguous    subregion of an existing one-dimensional texture image. The texels    referenced by data replace the portion of the    existing texture array with x indices xoffset and            ,            inclusive.  This region may not include any texels    outside the range of the texture array as it was originally specified. It    is not an error to specify a subtexture with width of 0, but such a    specification has no effect.
        /// internalformat must be a known compressed        image format (such as GL_RGTC) or an        extension-specified compressed-texture format. The        format of the compressed texture image is selected        by the GL implementation that compressed it (see        glTexImage1D),        and should be queried at the time the texture was        compressed with        glGetTexLevelParameter.
        /// If a non-zero named buffer object is bound to the    GL_PIXEL_UNPACK_BUFFER target (see    glBindBuffer)    while a texture image is specified,    data is treated as a byte offset into the buffer    object's data store.
        /// </summary>
        /// <param name="target">Specifies the target, to which the texture is bound, for          glCompressedTexSubImage1D function. Must be          GL_TEXTURE_1D.</param>
        /// <param name="texture">Specifies the texture object name for          glCompressedTextureSubImage1D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base          image level. Level n is the          nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture          array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at          address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting          at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in          memory.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTexSubImage1D(TextureTarget target, int level, int xoffset, int width, PixelFormat format, int imageSize, IntPtr data) => _CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTexSubImage1DARB(TextureTarget target, int level, int xoffset, int width, PixelFormat format, int imageSize, IntPtr data) => _CompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data);

        // ---

        /// <summary>
        /// Texturing allows elements of an image array to be read by    shaders.
        /// glCompressedTexSubImage2D and    glCompressedTextureSubImage2D redefine a contiguous    subregion of an existing two-dimensional texture image. The texels    referenced by data replace the portion of the    existing texture array with x indices xoffset and            ,            inclusive.            This region may not include any texels    outside the range of the texture array as it was originally specified. It    is not an error to specify a subtexture with width of 0, but such a    specification has no effect.
        /// internalformat must be a known compressed    image format (such as GL_RGTC) or an    extension-specified compressed-texture format. The    format of the compressed texture image is selected    by the GL implementation that compressed it (see    glTexImage2D)    and should be queried at the time the texture was    compressed with    glGetTexLevelParameter.
        /// If a non-zero named buffer object is bound to the    GL_PIXEL_UNPACK_BUFFER target (see    glBindBuffer)    while a texture image is specified,    data is treated as a byte offset into the buffer    object's data store.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture is bound for          glCompressedTexSubImage2D function. Must be          GL_TEXTURE_1D_ARRAY,          GL_TEXTURE_2D,          GL_TEXTURE_CUBE_MAP_POSITIVE_X,          GL_TEXTURE_CUBE_MAP_NEGATIVE_X,          GL_TEXTURE_CUBE_MAP_POSITIVE_Y,          GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,          GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or          GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.</param>
        /// <param name="texture">Specifies the texture object name for          glCompressedTextureSubImage2D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base          image level. Level n is the          nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture          array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture          array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at          address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting          at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in          memory.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, int imageSize, IntPtr data) => _CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTexSubImage2DARB(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, int imageSize, IntPtr data) => _CompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data);

        // ---

        /// <summary>
        /// Texturing allows elements of an image array to be read by    shaders.
        /// glCompressedTexSubImage3D and    glCompressedTextureSubImage3D redefine a contiguous    subregion of an existing three-dimensional texture image. The texels    referenced by data replace the portion of the    existing texture array with x indices xoffset and            ,            inclusive.  This region may not include            any texels outside the range of the texture array as it was originally            specified.  It is not an error to specify a subtexture with width of 0,            but such a specification has no effect.
        /// internalformat must be a known compressed image format (such as GL_RGTC)            or an extension-specified compressed-texture format.            The format of the compressed texture            image is selected by the GL implementation that compressed it (see            glTexImage3D) and should be queried at the time the texture was            compressed with glGetTexLevelParameter.
        /// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target            (see glBindBuffer) while a texture image is            specified, data is treated as a byte offset into the buffer object's data store.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture is bound for          glCompressedTexSubImage3D function. Must be          GL_TEXTURE_2D_ARRAY,          GL_TEXTURE_3D, or          GL_TEXTURE_CUBE_MAP_ARRAY.</param>
        /// <param name="texture">Specifies the texture object name for          glCompressedTextureSubImage3D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base          image level. Level n is the          nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture          array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture          array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the compressed image data stored at          address data.</param>
        /// <param name="imageSize">Specifies the number of unsigned bytes of image data starting          at the address specified by data.</param>
        /// <param name="data">Specifies a pointer to the compressed image data in          memory.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, int imageSize, IntPtr data) => _CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTexSubImage3DARB(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, int imageSize, IntPtr data) => _CompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTexSubImage3DOES(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, int imageSize, IntPtr data) => _CompressedTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTextureImage1DEXT(uint texture, TextureTarget target, int level, InternalFormat internalformat, int width, int border, int imageSize, IntPtr bits) => _CompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTextureImage2DEXT(uint texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int border, int imageSize, IntPtr bits) => _CompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTextureImage3DEXT(uint texture, TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, int imageSize, IntPtr bits) => _CompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTextureSubImage1D(uint texture, int level, int xoffset, int width, PixelFormat format, int imageSize, IntPtr data) => _CompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTextureSubImage1DEXT(uint texture, TextureTarget target, int level, int xoffset, int width, PixelFormat format, int imageSize, IntPtr bits) => _CompressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, int imageSize, IntPtr data) => _CompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTextureSubImage2DEXT(uint texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, int imageSize, IntPtr bits) => _CompressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, int imageSize, IntPtr data) => _CompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CompressedTextureSubImage3DEXT(uint texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, int imageSize, IntPtr bits) => _CompressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConservativeRasterParameterfNV(int pname, float value) => _ConservativeRasterParameterfNV(pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConservativeRasterParameteriNV(int pname, int param) => _ConservativeRasterParameteriNV(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionFilter1D(ConvolutionTarget target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, IntPtr image) => _ConvolutionFilter1D(target, internalformat, width, format, type, image);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionFilter1DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int width, PixelFormat format, PixelType type, IntPtr image) => _ConvolutionFilter1DEXT(target, internalformat, width, format, type, image);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionFilter2D(ConvolutionTarget target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, IntPtr image) => _ConvolutionFilter2D(target, internalformat, width, height, format, type, image);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionFilter2DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, IntPtr image) => _ConvolutionFilter2DEXT(target, internalformat, width, height, format, type, image);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameterf(ConvolutionTarget target, ConvolutionParameterEXT pname, float @params) => _ConvolutionParameterf(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameterfEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float @params) => _ConvolutionParameterfEXT(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameterfv(ConvolutionTarget target, ConvolutionParameterEXT pname, float[] @params) => _ConvolutionParameterfv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameterfv(ConvolutionTarget target, ConvolutionParameterEXT pname, void* @params) => _ConvolutionParameterfv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameterfv(ConvolutionTarget target, ConvolutionParameterEXT pname, IntPtr @params) => _ConvolutionParameterfv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float[] @params) => _ConvolutionParameterfvEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, void* @params) => _ConvolutionParameterfvEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, IntPtr @params) => _ConvolutionParameterfvEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameteri(ConvolutionTarget target, ConvolutionParameterEXT pname, int @params) => _ConvolutionParameteri(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameteriEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int @params) => _ConvolutionParameteriEXT(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameteriv(ConvolutionTarget target, ConvolutionParameterEXT pname, int[] @params) => _ConvolutionParameteriv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameteriv(ConvolutionTarget target, ConvolutionParameterEXT pname, void* @params) => _ConvolutionParameteriv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameteriv(ConvolutionTarget target, ConvolutionParameterEXT pname, IntPtr @params) => _ConvolutionParameteriv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int[] @params) => _ConvolutionParameterivEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, void* @params) => _ConvolutionParameterivEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, IntPtr @params) => _ConvolutionParameterivEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameterxOES(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float param) => _ConvolutionParameterxOES(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameterxvOES(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float[] @params) => _ConvolutionParameterxvOES(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameterxvOES(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, void* @params) => _ConvolutionParameterxvOES_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ConvolutionParameterxvOES(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, IntPtr @params) => _ConvolutionParameterxvOES_intptr(target, pname, @params);

        // ---

        /// <summary>
        /// glCopyBufferSubData and            glCopyNamedBufferSubData copy part of the            data store attached to a source buffer object to the data store            attached to a destination buffer object. The number of basic            machine units indicated by size is copied            from the source at offset readOffset to            the destination at writeOffset.            readOffset,            writeOffset and            size are in terms of basic machine units.
        /// For glCopyBufferSubData,            readTarget and            writeTarget specify the targets to which            the source and destination buffer objects are bound, and must            each be one of the buffer binding targets in the following            table:
        /// Any of these targets may be used, but the targets            GL_COPY_READ_BUFFER and            GL_COPY_WRITE_BUFFER are provided            specifically to allow copies between buffers without disturbing            other GL state.
        /// readOffset,            writeOffset and            size must all be greater than or equal to            zero. Furthermore, $readOffset+size$ must not exceeed the size            of the source buffer object, and $writeOffset+size$ must not            exceeed the size of the buffer bound to            writeTarget. If the source and            destination are the same buffer object, then the source and            destination ranges must not overlap.
        /// </summary>
        /// <param name="readTarget">Specifies the target to which the source buffer object                    is bound for glCopyBufferSubData</param>
        /// <param name="writeTarget">Specifies the target to which the destination buffer                    object is bound for                    glCopyBufferSubData.</param>
        /// <param name="readBuffer">Specifies the name of the source buffer object for                    glCopyNamedBufferSubData.</param>
        /// <param name="writeBuffer">Specifies the name of the destination buffer object for                    glCopyNamedBufferSubData.</param>
        /// <param name="readOffset">Specifies the offset, in basic machine units, within the                    data store of the source buffer object at which data                    will be read.</param>
        /// <param name="writeOffset">Specifies the offset, in basic machine units, within the                    data store of the destination buffer object at which                    data will be written.</param>
        /// <param name="size">Specifies the size, in basic machine units, of the data                    to be copied from the source buffer object to the                    destination buffer object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyBufferSubData(CopyBufferSubDataTarget readTarget, CopyBufferSubDataTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, IntPtr size) => _CopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyBufferSubDataNV(CopyBufferSubDataTarget readTarget, CopyBufferSubDataTarget writeTarget, IntPtr readOffset, IntPtr writeOffset, IntPtr size) => _CopyBufferSubDataNV(readTarget, writeTarget, readOffset, writeOffset, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyColorSubTable(ColorTableTarget target, int start, int x, int y, int width) => _CopyColorSubTable(target, start, x, y, width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyColorSubTableEXT(ColorTableTarget target, int start, int x, int y, int width) => _CopyColorSubTableEXT(target, start, x, y, width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyColorTable(ColorTableTarget target, InternalFormat internalformat, int x, int y, int width) => _CopyColorTable(target, internalformat, x, y, width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyColorTableSGI(ColorTableTargetSGI target, InternalFormat internalformat, int x, int y, int width) => _CopyColorTableSGI(target, internalformat, x, y, width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyConvolutionFilter1D(ConvolutionTarget target, InternalFormat internalformat, int x, int y, int width) => _CopyConvolutionFilter1D(target, internalformat, x, y, width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyConvolutionFilter1DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int x, int y, int width) => _CopyConvolutionFilter1DEXT(target, internalformat, x, y, width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyConvolutionFilter2D(ConvolutionTarget target, InternalFormat internalformat, int x, int y, int width, int height) => _CopyConvolutionFilter2D(target, internalformat, x, y, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyConvolutionFilter2DEXT(ConvolutionTargetEXT target, InternalFormat internalformat, int x, int y, int width, int height) => _CopyConvolutionFilter2DEXT(target, internalformat, x, y, width, height);

        // ---

        /// <summary>
        /// glCopyImageSubData may be used to copy data from            one image (i.e. texture or renderbuffer) to another. glCopyImageSubData            does not perform general-purpose conversions            such as scaling, resizing, blending, color-space, or format            conversions. It should be considered to operate in a manner            similar to a CPU memcpy. CopyImageSubData can copy between            images with different internal formats, provided            the formats are compatible.
        /// glCopyImageSubData also allows copying between certain            types of compressed and uncompressed internal formats. This copy does not perform on-the-fly compression            or decompression. When copying from an uncompressed internal format            to a compressed internal format, each texel of uncompressed data            becomes a single block of compressed data. When copying from a            compressed internal format to an uncompressed internal format,            a block of compressed data becomes a single texel of uncompressed            data. The texel size of the uncompressed format must be the same            size the block size of the compressed formats. Thus it is permitted            to copy between a 128-bit uncompressed format and a compressed            format which uses 8-bit 4x4 blocks, or between a 64-bit uncompressed            format and a compressed format which uses 4-bit 4x4 blocks.
        /// The source object is identified by srcName and            srcTarget and the destination object is identified            by dstName and dstTarget.            The interpretation of the name depends on the value            of the corresponding target parameter.            If target is            GL_RENDERBUFFER, the name is interpreted as the name of a            renderbuffer object.  If the target parameter is a texture target,            the name is interpreted as a texture object.  All non-proxy            texture targets are accepted, with the exception of GL_TEXTURE_BUFFER            and the cubemap face selectors.
        /// srcLevel and dstLevel identify the source and destination            level of detail.  For textures, this must be a valid level of            detail in the texture object.  For renderbuffers, this value must            be zero.
        /// srcX, srcY, and srcZ specify the lower left texel            coordinates of a srcWidth-wide by srcHeight-high by            srcDepth-deep rectangular subregion of the source texel array.            Similarly, dstX, dstY and dstZ specify the coordinates of a subregion of the            destination texel array.  The source and destination subregions            must be contained entirely within the specified level of the            corresponding image objects.
        /// The dimensions are always specified in texels, even for compressed            texture formats. However, it should be noted that if only one of the            source and destination textures is compressed then the number of            texels touched in the compressed image will be a factor of the            block size larger than in the uncompressed image.
        /// Slices of a GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAYGL_TEXTURE_3D and faces of GL_TEXTURE_CUBE_MAP are all compatible provided            they share a compatible internal format, and multiple slices or faces            may be copied between these objects with a single call by specifying the            starting slice with srcZ and dstZ, and the number of slices to            be copied with srcDepth.  Cubemap textures always have six faces            which are selected by a zero-based face index.
        /// For the purposes of CopyImageSubData, two internal formats are considered compatible if            any of the following conditions are met:                                     the formats are the same,                                              the formats are considered compatible according                        to the compatibility rules used for texture                        views as defined in section 3.9.X. In                        particular, if both internal formats are listed                        in the same entry of Table 3.X.2, they are                        considered compatible, or                                             one format is compressed and the other is                        uncompressed and Table 4.X.1 lists the two                        formats in the same row.                                If the formats are not compatible, an INVALID_OPERATION error is generated.
        /// Sized Internal Formats Texel / Block Size  Uncompressed Internal Format  Compressed Internal Format(s) 64-bitGL_RGBA32UI, GL_RGBA32I, GL_RGBA32FGL_COMPRESSED_RGBA_S3TC_DXT3_EXT,                   GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,                   GL_COMPRESSED_RGBA_S3TC_DXT5_EXT,                   GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,                   GL_COMPRESSED_RG_RGTC2,                   GL_COMPRESSED_SIGNED_RG_RGTC2,                   GL_COMPRESSED_RGBA_BPTC_UNORM,                   GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM,                   GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT,                   GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT128-bitGL_RGBA16UI,                   GL_RGBA16I,                   GL_RGBA16F,                   GL_RG32F,                   GL_RG32UI,                   GL_RG32I,                   GL_RGBA16,                   GL_RGBA16_SNORMGL_COMPRESSED_RGB_S3TC_DXT1_EXT,                   GL_COMPRESSED_SRGB_S3TC_DXT1_EXT,                   GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,                   GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,                   GL_COMPRESSED_RED_RGTC1,                   GL_COMPRESSED_SIGNED_RED_RGTC1
        /// </summary>
        /// <param name="srcName">The name of a texture or renderbuffer object from which to copy.</param>
        /// <param name="srcTarget">The target representing the namespace of the source name srcName.</param>
        /// <param name="srcLevel">The mipmap level to read from the source.</param>
        /// <param name="srcX">The X coordinate of the left edge of the souce region to copy.</param>
        /// <param name="srcY">The Y coordinate of the top edge of the souce region to copy.</param>
        /// <param name="srcZ">The Z coordinate of the near edge of the souce region to copy.</param>
        /// <param name="dstName">The name of a texture or renderbuffer object to which to copy.</param>
        /// <param name="dstTarget">The target representing the namespace of the destination name dstName.</param>
        /// <param name="dstX">The X coordinate of the left edge of the destination region.</param>
        /// <param name="dstY">The Y coordinate of the top edge of the destination region.</param>
        /// <param name="dstZ">The Z coordinate of the near edge of the destination region.</param>
        /// <param name="srcWidth">The width of the region to be copied.</param>
        /// <param name="srcHeight">The height of the region to be copied.</param>
        /// <param name="srcDepth">The depth of the region to be copied.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyImageSubData(uint srcName, CopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => _CopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyImageSubDataEXT(uint srcName, CopyBufferSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyBufferSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => _CopyImageSubDataEXT(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyImageSubDataNV(uint srcName, CopyBufferSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyBufferSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) => _CopyImageSubDataNV(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyImageSubDataOES(uint srcName, CopyBufferSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, CopyBufferSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => _CopyImageSubDataOES(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyMultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => _CopyMultiTexImage1DEXT(texunit, target, level, internalformat, x, y, width, border);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyMultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => _CopyMultiTexImage2DEXT(texunit, target, level, internalformat, x, y, width, height, border);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyMultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int x, int y, int width) => _CopyMultiTexSubImage1DEXT(texunit, target, level, xoffset, x, y, width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyMultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => _CopyMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, x, y, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyMultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => _CopyMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyNamedBufferSubData(uint readBuffer, uint writeBuffer, IntPtr readOffset, IntPtr writeOffset, IntPtr size) => _CopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyPathNV(uint resultPath, uint srcPath) => _CopyPathNV(resultPath, srcPath);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyPixels(int x, int y, int width, int height, PixelCopyType type) => _CopyPixels(x, y, width, height, type);

        // ---

        /// <summary>
        /// glCopyTexImage1D defines a one-dimensional texture image with pixels from the current            GL_READ_BUFFER.
        /// The screen-aligned pixel row with left corner at                        is the returned value of GL_MAX_TEXTURE_SIZE.
        /// GL_INVALID_VALUE is generated if internalformat is not an allowable value.
        /// GL_INVALID_VALUE is generated if width is less than 0 or greater than            GL_MAX_TEXTURE_SIZE.
        /// GL_INVALID_VALUE is generated if border is not 0.
        /// GL_INVALID_OPERATION is generated if internalformat is            GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16,            GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32 and there is no depth            buffer.
        /// </summary>
        /// <param name="target">Specifies the target texture.                    Must be GL_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number.                    Level 0 is the base image level.                    Level n is the nth mipmap reduction image.</param>
        /// <param name="internalformat">Specifies the internal format of the texture.                    Must be one of the following symbolic constants:                    GL_COMPRESSED_RED,                    GL_COMPRESSED_RG,                    GL_COMPRESSED_RGB,                    GL_COMPRESSED_RGBA.                    GL_COMPRESSED_SRGB,                    GL_COMPRESSED_SRGB_ALPHA.                    GL_DEPTH_COMPONENT,                    GL_DEPTH_COMPONENT16,                    GL_DEPTH_COMPONENT24,                    GL_DEPTH_COMPONENT32,                    GL_STENCIL_INDEX8,                    GL_RED,                    GL_RG,                    GL_RGB,                    GL_R3_G3_B2,                    GL_RGB4,                    GL_RGB5,                    GL_RGB8,                    GL_RGB10,                    GL_RGB12,                    GL_RGB16,                    GL_RGBA,                    GL_RGBA2,                    GL_RGBA4,                    GL_RGB5_A1,                    GL_RGBA8,                    GL_RGB10_A2,                    GL_RGBA12,                    GL_RGBA16,                    GL_SRGB,                    GL_SRGB8,                    GL_SRGB_ALPHA, or                    GL_SRGB8_ALPHA8.</param>
        /// <param name="y">Specify the window coordinates of the left corner                    of the row of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture image.                    The height of the texture image is 1.</param>
        /// <param name="border">Must be 0.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTexImage1D(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => _CopyTexImage1D(target, level, internalformat, x, y, width, border);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTexImage1DEXT(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => _CopyTexImage1DEXT(target, level, internalformat, x, y, width, border);

        // ---

        /// <summary>
        /// glCopyTexImage2D defines a two-dimensional texture image, or cube-map texture image            with pixels from the current            GL_READ_BUFFER.
        /// The screen-aligned pixel rectangle with lower left corner at (x,            y) and with a width of                        is the returned value of GL_MAX_TEXTURE_SIZE.
        /// GL_INVALID_VALUE is generated if width is less than 0            or greater than            GL_MAX_TEXTURE_SIZE.
        /// GL_INVALID_VALUE is generated if border is not 0.
        /// GL_INVALID_VALUE is generated if internalformat is not an            accepted format.
        /// GL_INVALID_OPERATION is generated if internalformat is            GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16,            GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32 and there is no depth            buffer.
        /// </summary>
        /// <param name="target">Specifies the target texture.                    Must be GL_TEXTURE_2D,                    GL_TEXTURE_CUBE_MAP_POSITIVE_X,                    GL_TEXTURE_CUBE_MAP_NEGATIVE_X,                    GL_TEXTURE_CUBE_MAP_POSITIVE_Y,                    GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,                    GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or                    GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.</param>
        /// <param name="level">Specifies the level-of-detail number.                    Level 0 is the base image level.                    Level n is the nth mipmap reduction image.</param>
        /// <param name="internalformat">Specifies the internal format of the texture.                    Must be one of the following symbolic constants:                    GL_COMPRESSED_RED,                    GL_COMPRESSED_RG,                    GL_COMPRESSED_RGB,                    GL_COMPRESSED_RGBA.                    GL_COMPRESSED_SRGB,                    GL_COMPRESSED_SRGB_ALPHA.                    GL_DEPTH_COMPONENT,                    GL_DEPTH_COMPONENT16,                    GL_DEPTH_COMPONENT24,                    GL_DEPTH_COMPONENT32,                    GL_STENCIL_INDEX8,                    GL_RED,                    GL_RG,                    GL_RGB,                    GL_R3_G3_B2,                    GL_RGB4,                    GL_RGB5,                    GL_RGB8,                    GL_RGB10,                    GL_RGB12,                    GL_RGB16,                    GL_RGBA,                    GL_RGBA2,                    GL_RGBA4,                    GL_RGB5_A1,                    GL_RGBA8,                    GL_RGB10_A2,                    GL_RGBA12,                    GL_RGBA16,                    GL_SRGB,                    GL_SRGB8,                    GL_SRGB_ALPHA, or                    GL_SRGB8_ALPHA8.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner                    of the rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture image.</param>
        /// <param name="height">Specifies the height of the texture image.</param>
        /// <param name="border">Must be 0.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTexImage2D(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => _CopyTexImage2D(target, level, internalformat, x, y, width, height, border);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTexImage2DEXT(TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => _CopyTexImage2DEXT(target, level, internalformat, x, y, width, height, border);

        // ---

        /// <summary>
        /// glCopyTexSubImage1D and    glCopyTextureSubImage1D replace a portion of a    one-dimensional texture image with pixels from the current    GL_READ_BUFFER (rather than from main memory, as is    the case for    glTexSubImage1D).    For glCopyTexSubImage1D, the    texture object that is bound to target will be used    for the process. For glCopyTextureSubImage1D,    texture tells which texture object should be used    for the purpose of the call.
        /// The screen-aligned pixel row with left corner at    (x,\ y), and with length    width replaces the portion of the texture array    with x indices xoffset through is the GL_TEXTURE_WIDTH of the    texture image being modified.
        /// GL_INVALID_OPERATION is generated if:
        /// the read buffer is GL_NONE, orthe value of GL_READ_FRAMEBUFFER_BINDING          is non-zero, and:the read buffer selects an attachment that has no image                attached, orthe effective value of                GL_SAMPLE_BUFFERS for the read                framebuffer is one.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for          glCopyTexSubImage1D function. Must be          GL_TEXTURE_1D.</param>
        /// <param name="texture">Specifies the texture object name for          glCopyTextureSubImage1D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base          image level. Level n is the          nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies the texel offset within the texture array.</param>
        /// <param name="y">Specify the window coordinates of the left corner of the row          of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTexSubImage1D(TextureTarget target, int level, int xoffset, int x, int y, int width) => _CopyTexSubImage1D(target, level, xoffset, x, y, width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTexSubImage1DEXT(TextureTarget target, int level, int xoffset, int x, int y, int width) => _CopyTexSubImage1DEXT(target, level, xoffset, x, y, width);

        // ---

        /// <summary>
        /// glCopyTexSubImage2D and    glCopyTextureSubImage2D replace a rectangular portion    of a two-dimensional texture image, cube-map texture image, rectangular    image, or a linear portion of a number of slices of a one-dimensional    array texture with pixels from the current    GL_READ_BUFFER (rather than from main memory, as is    the case for    glTexSubImage2D).
        /// The screen-aligned pixel rectangle with lower left corner at                is the GL_TEXTURE_HEIGHT and            of the texture image being modified.
        /// GL_INVALID_OPERATION is generated if:
        /// the read buffer is GL_NONE, orthe value of GL_READ_FRAMEBUFFER_BINDING          is non-zero, and:the read buffer selects an attachment that has no image                attached, orthe effective value of                GL_SAMPLE_BUFFERS for the read                framebuffer is one.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for          glCopyTexSubImage2D function. Must be          GL_TEXTURE_1D_ARRAY,          GL_TEXTURE_2D,          GL_TEXTURE_CUBE_MAP_POSITIVE_X,          GL_TEXTURE_CUBE_MAP_NEGATIVE_X,          GL_TEXTURE_CUBE_MAP_POSITIVE_Y,          GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,          GL_TEXTURE_CUBE_MAP_POSITIVE_Z,          GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or          GL_TEXTURE_RECTANGLE.</param>
        /// <param name="texture">Specifies the texture object name for          glCopyTextureSubImage2D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base          image level. Level n is the          nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture          array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture          array.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the          rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => _CopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTexSubImage2DEXT(TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => _CopyTexSubImage2DEXT(target, level, xoffset, yoffset, x, y, width, height);

        // ---

        /// <summary>
        /// glCopyTexSubImage3D and    glCopyTextureSubImage3D functions replace a rectangular portion of a three-dimensional            or two-dimensional array texture image with pixels from the current GL_READ_BUFFER (rather            than from main memory, as is the case for glTexSubImage3D).
        /// The screen-aligned pixel rectangle with lower left corner at            (x, y) and with            width width and height height replaces the portion of the            texture array with x indices xoffset through                        include twice the border width.
        /// GL_INVALID_OPERATION is generated    if:the read buffer is GL_NONE, orthe value of GL_READ_FRAMEBUFFER_BINDING          is non-zero, and:the read buffer selects an attachment that has no image                attached, orthe effective value of                GL_SAMPLE_BUFFERS for the read                framebuffer is one.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture object is bound for          glCopyTexSubImage3D function. Must be          GL_TEXTURE_3D,          GL_TEXTURE_2D_ARRAY or          GL_TEXTURE_CUBE_MAP_ARRAY.</param>
        /// <param name="texture">Specifies the texture object name for          glCopyTextureSubImage3D function.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base          image level. Level n is the          nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture          array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture          array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture          array.</param>
        /// <param name="y">Specify the window coordinates of the lower left corner of the          rectangular region of pixels to be copied.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => _CopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTexSubImage3DEXT(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => _CopyTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, x, y, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTexSubImage3DOES(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => _CopyTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, x, y, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTextureImage1DEXT(uint texture, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int border) => _CopyTextureImage1DEXT(texture, target, level, internalformat, x, y, width, border);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTextureImage2DEXT(uint texture, TextureTarget target, int level, InternalFormat internalformat, int x, int y, int width, int height, int border) => _CopyTextureImage2DEXT(texture, target, level, internalformat, x, y, width, height, border);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTextureLevelsAPPLE(uint destinationTexture, uint sourceTexture, int sourceBaseLevel, int sourceLevelCount) => _CopyTextureLevelsAPPLE(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTextureSubImage1D(uint texture, int level, int xoffset, int x, int y, int width) => _CopyTextureSubImage1D(texture, level, xoffset, x, y, width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTextureSubImage1DEXT(uint texture, TextureTarget target, int level, int xoffset, int x, int y, int width) => _CopyTextureSubImage1DEXT(texture, target, level, xoffset, x, y, width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int x, int y, int width, int height) => _CopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTextureSubImage2DEXT(uint texture, TextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => _CopyTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, x, y, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => _CopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyTextureSubImage3DEXT(uint texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) => _CopyTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CoverFillPathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float[] transformValues) => _CoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CoverFillPathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, void* transformValues) => _CoverFillPathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CoverFillPathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, IntPtr transformValues) => _CoverFillPathInstancedNV_intptr(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CoverFillPathNV(uint path, PathCoverMode coverMode) => _CoverFillPathNV(path, coverMode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CoverStrokePathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, float[] transformValues) => _CoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CoverStrokePathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, void* transformValues) => _CoverStrokePathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CoverStrokePathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathCoverMode coverMode, PathTransformType transformType, IntPtr transformValues) => _CoverStrokePathInstancedNV_intptr(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CoverStrokePathNV(uint path, PathCoverMode coverMode) => _CoverStrokePathNV(path, coverMode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CoverageMaskNV(bool mask) => _CoverageMaskNV(mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CoverageModulationNV(int components) => _CoverageModulationNV(components);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CoverageModulationTableNV(int n, float[] v) => _CoverageModulationTableNV(n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CoverageModulationTableNV(int n, void* v) => _CoverageModulationTableNV_ptr(n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CoverageModulationTableNV(int n, IntPtr v) => _CoverageModulationTableNV_intptr(n, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CoverageOperationNV(int operation) => _CoverageOperationNV(operation);

        // ---

        /// <summary>
        /// glCreateBuffers returns            n previously unused buffer names in            buffers, each representing a new buffer            object initialized as if it had been bound to an unspecified            target.
        /// </summary>
        /// <param name="n">Specifies the number of buffer objects to create.</param>
        /// <param name="buffers">Specifies an array in which names of the new buffer                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateBuffers(int n, uint[] buffers) => _CreateBuffers(n, buffers);

        /// <summary>
        /// glCreateBuffers returns            n previously unused buffer names in            buffers, each representing a new buffer            object initialized as if it had been bound to an unspecified            target.
        /// </summary>
        /// <param name="n">Specifies the number of buffer objects to create.</param>
        /// <param name="buffers">Specifies an array in which names of the new buffer                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateBuffers(int n, void* buffers) => _CreateBuffers_ptr(n, buffers);

        /// <summary>
        /// glCreateBuffers returns            n previously unused buffer names in            buffers, each representing a new buffer            object initialized as if it had been bound to an unspecified            target.
        /// </summary>
        /// <param name="n">Specifies the number of buffer objects to create.</param>
        /// <param name="buffers">Specifies an array in which names of the new buffer                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateBuffers(int n, IntPtr buffers) => _CreateBuffers_intptr(n, buffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateCommandListsNV(int n, uint[] lists) => _CreateCommandListsNV(n, lists);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateCommandListsNV(int n, void* lists) => _CreateCommandListsNV_ptr(n, lists);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateCommandListsNV(int n, IntPtr lists) => _CreateCommandListsNV_intptr(n, lists);

        // ---

        /// <summary>
        /// glCreateFramebuffers            returns n previously unused framebuffer            names in framebuffers, each representing            a new framebuffer object initialized to the default state.
        /// </summary>
        /// <param name="n">Number of framebuffer objects to create.</param>
        /// <param name="framebuffers">Specifies an array in which names of the new                        framebuffer objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateFramebuffers(int n, uint[] framebuffers) => _CreateFramebuffers(n, framebuffers);

        /// <summary>
        /// glCreateFramebuffers            returns n previously unused framebuffer            names in framebuffers, each representing            a new framebuffer object initialized to the default state.
        /// </summary>
        /// <param name="n">Number of framebuffer objects to create.</param>
        /// <param name="framebuffers">Specifies an array in which names of the new                        framebuffer objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateFramebuffers(int n, void* framebuffers) => _CreateFramebuffers_ptr(n, framebuffers);

        /// <summary>
        /// glCreateFramebuffers            returns n previously unused framebuffer            names in framebuffers, each representing            a new framebuffer object initialized to the default state.
        /// </summary>
        /// <param name="n">Number of framebuffer objects to create.</param>
        /// <param name="framebuffers">Specifies an array in which names of the new                        framebuffer objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateFramebuffers(int n, IntPtr framebuffers) => _CreateFramebuffers_intptr(n, framebuffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateMemoryObjectsEXT(int n, uint[] memoryObjects) => _CreateMemoryObjectsEXT(n, memoryObjects);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateMemoryObjectsEXT(int n, void* memoryObjects) => _CreateMemoryObjectsEXT_ptr(n, memoryObjects);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateMemoryObjectsEXT(int n, IntPtr memoryObjects) => _CreateMemoryObjectsEXT_intptr(n, memoryObjects);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreatePerfQueryINTEL(uint queryId, uint[] queryHandle) => _CreatePerfQueryINTEL(queryId, queryHandle);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreatePerfQueryINTEL(uint queryId, void* queryHandle) => _CreatePerfQueryINTEL_ptr(queryId, queryHandle);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreatePerfQueryINTEL(uint queryId, IntPtr queryHandle) => _CreatePerfQueryINTEL_intptr(queryId, queryHandle);

        // ---

        /// <summary>
        /// glCreateProgram creates an empty        program object and returns a non-zero value by which it can be        referenced. A program object is an object to which shader        objects can be attached. This provides a mechanism to specify        the shader objects that will be linked to create a program. It        also provides a means for checking the compatibility of the        shaders that will be used to create a program (for instance,        checking the compatibility between a vertex shader and a        fragment shader). When no longer needed as part of a program        object, shader objects can be detached.
        /// One or more executables are created in a program object by        successfully attaching shader objects to it with        glAttachShader,        successfully compiling the shader objects with        glCompileShader,        and successfully linking the program object with        glLinkProgram.        These executables are made part of current state when        glUseProgram        is called. Program objects can be deleted by calling        glDeleteProgram.        The memory associated with the program object will be deleted        when it is no longer part of current rendering state for any        context.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint CreateProgram() => _CreateProgram();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int CreateProgramObjectARB() => _CreateProgramObjectARB();

        // ---

        /// <summary>
        /// glCreateProgramPipelines             returns n previously unused program pipeline            names in pipelines, each representing            a new program pipeline object initialized to the default state.
        /// </summary>
        /// <param name="n">Number of program pipeline objects to create.</param>
        /// <param name="pipelines">Specifies an array in which names of the new program                        pipeline objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateProgramPipelines(int n, uint[] pipelines) => _CreateProgramPipelines(n, pipelines);

        /// <summary>
        /// glCreateProgramPipelines             returns n previously unused program pipeline            names in pipelines, each representing            a new program pipeline object initialized to the default state.
        /// </summary>
        /// <param name="n">Number of program pipeline objects to create.</param>
        /// <param name="pipelines">Specifies an array in which names of the new program                        pipeline objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateProgramPipelines(int n, void* pipelines) => _CreateProgramPipelines_ptr(n, pipelines);

        /// <summary>
        /// glCreateProgramPipelines             returns n previously unused program pipeline            names in pipelines, each representing            a new program pipeline object initialized to the default state.
        /// </summary>
        /// <param name="n">Number of program pipeline objects to create.</param>
        /// <param name="pipelines">Specifies an array in which names of the new program                        pipeline objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateProgramPipelines(int n, IntPtr pipelines) => _CreateProgramPipelines_intptr(n, pipelines);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint CreateProgressFenceNVX() => _CreateProgressFenceNVX();

        // ---

        /// <summary>
        /// glCreateQueries             returns n previously unused query            object names in ids, each representing            a new query object with the specified target.
        /// target may be one of            GL_SAMPLES_PASSED,             GL_ANY_SAMPLES_PASSED,             GL_ANY_SAMPLES_PASSED_CONSERVATIVE,             GL_TIME_ELAPSED,             GL_TIMESTAMP,             GL_PRIMITIVES_GENERATED or            GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN.
        /// </summary>
        /// <param name="target">Specifies the target of each created query object.</param>
        /// <param name="n">Number of query objects to create.</param>
        /// <param name="ids">Specifies an array in which names of the new query                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateQueries(QueryTarget target, int n, uint[] ids) => _CreateQueries(target, n, ids);

        /// <summary>
        /// glCreateQueries             returns n previously unused query            object names in ids, each representing            a new query object with the specified target.
        /// target may be one of            GL_SAMPLES_PASSED,             GL_ANY_SAMPLES_PASSED,             GL_ANY_SAMPLES_PASSED_CONSERVATIVE,             GL_TIME_ELAPSED,             GL_TIMESTAMP,             GL_PRIMITIVES_GENERATED or            GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN.
        /// </summary>
        /// <param name="target">Specifies the target of each created query object.</param>
        /// <param name="n">Number of query objects to create.</param>
        /// <param name="ids">Specifies an array in which names of the new query                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateQueries(QueryTarget target, int n, void* ids) => _CreateQueries_ptr(target, n, ids);

        /// <summary>
        /// glCreateQueries             returns n previously unused query            object names in ids, each representing            a new query object with the specified target.
        /// target may be one of            GL_SAMPLES_PASSED,             GL_ANY_SAMPLES_PASSED,             GL_ANY_SAMPLES_PASSED_CONSERVATIVE,             GL_TIME_ELAPSED,             GL_TIMESTAMP,             GL_PRIMITIVES_GENERATED or            GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN.
        /// </summary>
        /// <param name="target">Specifies the target of each created query object.</param>
        /// <param name="n">Number of query objects to create.</param>
        /// <param name="ids">Specifies an array in which names of the new query                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateQueries(QueryTarget target, int n, IntPtr ids) => _CreateQueries_intptr(target, n, ids);

        // ---

        /// <summary>
        /// glCreateRenderbuffers             returns n previously unused renderbuffer            object names in renderbuffers, each representing            a new renderbuffer object initialized to the default state.
        /// </summary>
        /// <param name="n">Number of renderbuffer objects to create.</param>
        /// <param name="renderbuffers">Specifies an array in which names of the new renderbuffer                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateRenderbuffers(int n, uint[] renderbuffers) => _CreateRenderbuffers(n, renderbuffers);

        /// <summary>
        /// glCreateRenderbuffers             returns n previously unused renderbuffer            object names in renderbuffers, each representing            a new renderbuffer object initialized to the default state.
        /// </summary>
        /// <param name="n">Number of renderbuffer objects to create.</param>
        /// <param name="renderbuffers">Specifies an array in which names of the new renderbuffer                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateRenderbuffers(int n, void* renderbuffers) => _CreateRenderbuffers_ptr(n, renderbuffers);

        /// <summary>
        /// glCreateRenderbuffers             returns n previously unused renderbuffer            object names in renderbuffers, each representing            a new renderbuffer object initialized to the default state.
        /// </summary>
        /// <param name="n">Number of renderbuffer objects to create.</param>
        /// <param name="renderbuffers">Specifies an array in which names of the new renderbuffer                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateRenderbuffers(int n, IntPtr renderbuffers) => _CreateRenderbuffers_intptr(n, renderbuffers);

        // ---

        /// <summary>
        /// glCreateSamplers             returns n previously unused sampler names            in samplers, each representing a new            sampler object initialized to the default state.
        /// </summary>
        /// <param name="n">Number of sampler objects to create.</param>
        /// <param name="samplers">Specifies an array in which names of the new sampler                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateSamplers(int n, uint[] samplers) => _CreateSamplers(n, samplers);

        /// <summary>
        /// glCreateSamplers             returns n previously unused sampler names            in samplers, each representing a new            sampler object initialized to the default state.
        /// </summary>
        /// <param name="n">Number of sampler objects to create.</param>
        /// <param name="samplers">Specifies an array in which names of the new sampler                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateSamplers(int n, void* samplers) => _CreateSamplers_ptr(n, samplers);

        /// <summary>
        /// glCreateSamplers             returns n previously unused sampler names            in samplers, each representing a new            sampler object initialized to the default state.
        /// </summary>
        /// <param name="n">Number of sampler objects to create.</param>
        /// <param name="samplers">Specifies an array in which names of the new sampler                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateSamplers(int n, IntPtr samplers) => _CreateSamplers_intptr(n, samplers);

        // ---

        /// <summary>
        /// glCreateShader creates an empty        shader object and returns a non-zero value by which it can be        referenced. A shader object is used to maintain the source code        strings that define a shader. shaderType        indicates the type of shader to be created. Five types of shader        are supported. A shader of type        GL_COMPUTE_SHADER is a shader that is        intended to run on the programmable compute processor. A shader of type        GL_VERTEX_SHADER is a shader that is        intended to run on the programmable vertex processor.        A shader of type GL_TESS_CONTROL_SHADER is a shader that        is intended to run on the programmable tessellation processor in the control stage.        A shader of type GL_TESS_EVALUATION_SHADER is a shader that        is intended to run on the programmable tessellation processor in the evaluation stage.        A shader of type        GL_GEOMETRY_SHADER is a shader that is intended to        run on the programmable geometry processor. A shader of        type GL_FRAGMENT_SHADER is a shader that is        intended to run on the programmable fragment processor.
        /// When created, a shader object's        GL_SHADER_TYPE parameter is set to either        GL_COMPUTE_SHADER, GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER,        GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER        or GL_FRAGMENT_SHADER, depending on the value        of shaderType.
        /// </summary>
        /// <param name="shaderType">Specifies the type of shader to be created.                    Must be one of GL_COMPUTE_SHADER,                    GL_VERTEX_SHADER,                    GL_TESS_CONTROL_SHADER,                    GL_TESS_EVALUATION_SHADER,                    GL_GEOMETRY_SHADER,                    or GL_FRAGMENT_SHADER.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint CreateShader(ShaderType type) => _CreateShader(type);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int CreateShaderObjectARB(ShaderType shaderType) => _CreateShaderObjectARB(shaderType);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint CreateShaderProgramEXT(ShaderType type, string @string) => _CreateShaderProgramEXT(type, @string);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint CreateShaderProgramEXT(ShaderType type, void* @string) => _CreateShaderProgramEXT_ptr(type, @string);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint CreateShaderProgramEXT(ShaderType type, IntPtr @string) => _CreateShaderProgramEXT_intptr(type, @string);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint CreateShaderProgramv(ShaderType type, int count, string[] strings) => _CreateShaderProgramv(type, count, strings);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint CreateShaderProgramv(ShaderType type, int count, void* strings) => _CreateShaderProgramv_ptr(type, count, strings);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint CreateShaderProgramv(ShaderType type, int count, IntPtr strings) => _CreateShaderProgramv_intptr(type, count, strings);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint CreateShaderProgramvEXT(ShaderType type, int count, IntPtr* strings) => _CreateShaderProgramvEXT(type, count, strings);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateStatesNV(int n, uint[] states) => _CreateStatesNV(n, states);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateStatesNV(int n, void* states) => _CreateStatesNV_ptr(n, states);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateStatesNV(int n, IntPtr states) => _CreateStatesNV_intptr(n, states);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int CreateSyncFromCLeventARB(IntPtr[] context, IntPtr[] @event, int flags) => _CreateSyncFromCLeventARB(context, @event, flags);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int CreateSyncFromCLeventARB(void* context, void* @event, int flags) => _CreateSyncFromCLeventARB_ptr(context, @event, flags);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int CreateSyncFromCLeventARB(IntPtr context, IntPtr @event, int flags) => _CreateSyncFromCLeventARB_intptr(context, @event, flags);

        // ---

        /// <summary>
        /// glCreateTextures             returns n previously unused texture names            in textures, each representing a new            texture object of the dimensionality and type specified by             target and initialized to the default values            for that texture type.
        /// target must be one of            GL_TEXTURE_1D,            GL_TEXTURE_2D,            GL_TEXTURE_3D,            GL_TEXTURE_1D_ARRAY,            GL_TEXTURE_2D_ARRAY,            GL_TEXTURE_RECTANGLE,            GL_TEXTURE_CUBE_MAP,            GL_TEXTURE_CUBE_MAP_ARRAY,            GL_TEXTURE_BUFFER,            GL_TEXTURE_2D_MULTISAMPLE or            GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </summary>
        /// <param name="target">Specifies the effective texture target                        of each created texture.</param>
        /// <param name="n">Number of texture objects to create.</param>
        /// <param name="textures">Specifies an array in which names of the new texture                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateTextures(TextureTarget target, int n, uint[] textures) => _CreateTextures(target, n, textures);

        /// <summary>
        /// glCreateTextures             returns n previously unused texture names            in textures, each representing a new            texture object of the dimensionality and type specified by             target and initialized to the default values            for that texture type.
        /// target must be one of            GL_TEXTURE_1D,            GL_TEXTURE_2D,            GL_TEXTURE_3D,            GL_TEXTURE_1D_ARRAY,            GL_TEXTURE_2D_ARRAY,            GL_TEXTURE_RECTANGLE,            GL_TEXTURE_CUBE_MAP,            GL_TEXTURE_CUBE_MAP_ARRAY,            GL_TEXTURE_BUFFER,            GL_TEXTURE_2D_MULTISAMPLE or            GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </summary>
        /// <param name="target">Specifies the effective texture target                        of each created texture.</param>
        /// <param name="n">Number of texture objects to create.</param>
        /// <param name="textures">Specifies an array in which names of the new texture                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateTextures(TextureTarget target, int n, void* textures) => _CreateTextures_ptr(target, n, textures);

        /// <summary>
        /// glCreateTextures             returns n previously unused texture names            in textures, each representing a new            texture object of the dimensionality and type specified by             target and initialized to the default values            for that texture type.
        /// target must be one of            GL_TEXTURE_1D,            GL_TEXTURE_2D,            GL_TEXTURE_3D,            GL_TEXTURE_1D_ARRAY,            GL_TEXTURE_2D_ARRAY,            GL_TEXTURE_RECTANGLE,            GL_TEXTURE_CUBE_MAP,            GL_TEXTURE_CUBE_MAP_ARRAY,            GL_TEXTURE_BUFFER,            GL_TEXTURE_2D_MULTISAMPLE or            GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </summary>
        /// <param name="target">Specifies the effective texture target                        of each created texture.</param>
        /// <param name="n">Number of texture objects to create.</param>
        /// <param name="textures">Specifies an array in which names of the new texture                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateTextures(TextureTarget target, int n, IntPtr textures) => _CreateTextures_intptr(target, n, textures);

        // ---

        /// <summary>
        /// glCreateTransformFeedbacks             returns n previously unused transform            feedback object names in ids, each            representing a new transform feedback object initialized to the            default state.
        /// </summary>
        /// <param name="n">Number of transform feedback objects to create.</param>
        /// <param name="ids">Specifies an array in which names of the new                        transform feedback objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateTransformFeedbacks(int n, uint[] ids) => _CreateTransformFeedbacks(n, ids);

        /// <summary>
        /// glCreateTransformFeedbacks             returns n previously unused transform            feedback object names in ids, each            representing a new transform feedback object initialized to the            default state.
        /// </summary>
        /// <param name="n">Number of transform feedback objects to create.</param>
        /// <param name="ids">Specifies an array in which names of the new                        transform feedback objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateTransformFeedbacks(int n, void* ids) => _CreateTransformFeedbacks_ptr(n, ids);

        /// <summary>
        /// glCreateTransformFeedbacks             returns n previously unused transform            feedback object names in ids, each            representing a new transform feedback object initialized to the            default state.
        /// </summary>
        /// <param name="n">Number of transform feedback objects to create.</param>
        /// <param name="ids">Specifies an array in which names of the new                        transform feedback objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateTransformFeedbacks(int n, IntPtr ids) => _CreateTransformFeedbacks_intptr(n, ids);

        // ---

        /// <summary>
        /// glCreateVertexArrays             returns n previously unused vertex array            object names in arrays, each representing            a new vertex array object initialized to the default state.
        /// </summary>
        /// <param name="n">Number of vertex array objects to create.</param>
        /// <param name="arrays">Specifies an array in which names of the new vertex array                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateVertexArrays(int n, uint[] arrays) => _CreateVertexArrays(n, arrays);

        /// <summary>
        /// glCreateVertexArrays             returns n previously unused vertex array            object names in arrays, each representing            a new vertex array object initialized to the default state.
        /// </summary>
        /// <param name="n">Number of vertex array objects to create.</param>
        /// <param name="arrays">Specifies an array in which names of the new vertex array                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateVertexArrays(int n, void* arrays) => _CreateVertexArrays_ptr(n, arrays);

        /// <summary>
        /// glCreateVertexArrays             returns n previously unused vertex array            object names in arrays, each representing            a new vertex array object initialized to the default state.
        /// </summary>
        /// <param name="n">Number of vertex array objects to create.</param>
        /// <param name="arrays">Specifies an array in which names of the new vertex array                        objects are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CreateVertexArrays(int n, IntPtr arrays) => _CreateVertexArrays_intptr(n, arrays);

        // ---

        /// <summary>
        /// glCullFace specifies whether front- or back-facing facets are culled            (as specified by mode) when facet culling is enabled. Facet            culling is initially disabled.            To enable and disable facet culling, call the            glEnable and glDisable commands            with the argument GL_CULL_FACE.            Facets include triangles,            quadrilaterals,            polygons, and            rectangles.
        /// glFrontFace specifies which of the clockwise and counterclockwise facets            are front-facing and back-facing.            See glFrontFace.
        /// </summary>
        /// <param name="mode">Specifies whether front- or back-facing facets are candidates for culling.                    Symbolic constants                    GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK are accepted.                    The initial value is GL_BACK.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CullFace(CullFaceMode mode) => _CullFace(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CullParameterdvEXT(CullParameterEXT pname, double[] @params) => _CullParameterdvEXT(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CullParameterdvEXT(CullParameterEXT pname, void* @params) => _CullParameterdvEXT_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CullParameterdvEXT(CullParameterEXT pname, IntPtr @params) => _CullParameterdvEXT_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CullParameterfvEXT(CullParameterEXT pname, float[] @params) => _CullParameterfvEXT(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CullParameterfvEXT(CullParameterEXT pname, void* @params) => _CullParameterfvEXT_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CullParameterfvEXT(CullParameterEXT pname, IntPtr @params) => _CullParameterfvEXT_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CurrentPaletteMatrixARB(int index) => _CurrentPaletteMatrixARB(index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CurrentPaletteMatrixOES(uint matrixpaletteindex) => _CurrentPaletteMatrixOES(matrixpaletteindex);

        // ---

        /// <summary>
        /// glDebugMessageCallback sets the current debug output callback function to            the function whose address is given in callback. The callback function            should have the following prototype (in C), or be otherwise compatible with such a prototype:
        /// typedef void (APIENTRY *DEBUGPROC)(GLenum source,            GLenum type,            GLuint id,            GLenum severity,            GLsizei length,            const GLchar *message,            const void *userParam);
        /// This function is defined to have the same calling convention as            the GL API functions. In most cases this is defined as            APIENTRY, although it will vary depending on            platform, language and compiler.
        /// Each time a debug message is generated the debug callback            function will be invoked with source,            type, id, and            severity associated with the message, and            length set to the length of debug message            whose character string is in the array pointed to by            messageuserParam            will be set to the value passed in the            userParam parameter to the most recent            call to glDebugMessageCallback.
        /// </summary>
        /// <param name="callback">The address of a callback function that will be called when a debug message is generated.</param>
        /// <param name="userParam">A user supplied pointer that will be passed on each invocation of callback.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageCallback(GlDebugProc callback, IntPtr userParam) => _DebugMessageCallback(callback, userParam);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageCallbackAMD(GlDebugProc callback, IntPtr userParam) => _DebugMessageCallbackAMD(callback, userParam);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageCallbackARB(GlDebugProc callback, IntPtr userParam) => _DebugMessageCallbackARB(callback, userParam);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageCallbackKHR(GlDebugProc callback, IntPtr userParam) => _DebugMessageCallbackKHR(callback, userParam);

        // ---

        /// <summary>
        /// glDebugMessageControl controls the reporting of debug messages generated by a debug            context. The parameters source, type and severity            form a filter to select messages from the pool of potential messages generated by the GL.
        /// source may be GL_DEBUG_SOURCE_API, GL_DEBUG_SOURCE_WINDOW_SYSTEM_,            GL_DEBUG_SOURCE_SHADER_COMPILER, GL_DEBUG_SOURCE_THIRD_PARTY,            GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_SOURCE_OTHER to select messages generated by            usage of the GL API, the window system, the shader compiler, third party tools or libraries, explicitly by the application            or by some other source, respectively. It may also take the value GL_DONT_CARE. If source            is not GL_DONT_CARE then only messages whose source matches source will be referenced.
        /// type may be one of GL_DEBUG_TYPE_ERROR, GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR,            GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR, GL_DEBUG_TYPE_PORTABILITY,            GL_DEBUG_TYPE_PERFORMANCE, GL_DEBUG_TYPE_MARKER, GL_DEBUG_TYPE_PUSH_GROUP,            GL_DEBUG_TYPE_POP_GROUP, or GL_DEBUG_TYPE_OTHER to indicate the type of messages describing            GL errors, attempted use of deprecated features, triggering of undefined behavior, portability issues, performance notifications, markers,            group push and pop events, and other            types of messages, respectively. It may also take the value GL_DONT_CARE. If type is not GL_DONT_CARE            then only messages whose type matches type will be referenced.
        /// severity may be one of GL_DEBUG_SEVERITY_LOW, GL_DEBUG_SEVERITY_MEDIUM,            or GL_DEBUG_SEVERITY_HIGH to select messages of low, medium or high severity messages or to            GL_DEBUG_SEVERITY_NOTIFICATION for notifications. It may also take the            value GL_DONT_CARE. If severity is not GL_DONT_CARE then only            messages whose severity matches severity will be referenced.
        /// ids contains a list of count message identifiers to select specific messages from the pool            of available messages. If count is zero then the value of ids is ignored. Otherwise,            only messages appearing in this list are selected. In this case, source and type            may not be GL_DONT_CARE and severity must be GL_DONT_CARE.
        /// If enabled is GL_TRUE then messages that match the filter formed by            source, type, severity and ids            are enabled. Otherwise, those messages are disabled.
        /// </summary>
        /// <param name="source">The source of debug messages to enable or disable.</param>
        /// <param name="type">The type of debug messages to enable or disable.</param>
        /// <param name="severity">The severity of debug messages to enable or disable.</param>
        /// <param name="count">The length of the array ids.</param>
        /// <param name="ids">The address of an array of unsigned integers contianing the ids of the messages to enable or disable.</param>
        /// <param name="enabled">A Boolean flag determining whether the selected messages should be enabled or disabled.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, uint[] ids, bool enabled) => _DebugMessageControl(source, type, severity, count, ids, enabled);

        /// <summary>
        /// glDebugMessageControl controls the reporting of debug messages generated by a debug            context. The parameters source, type and severity            form a filter to select messages from the pool of potential messages generated by the GL.
        /// source may be GL_DEBUG_SOURCE_API, GL_DEBUG_SOURCE_WINDOW_SYSTEM_,            GL_DEBUG_SOURCE_SHADER_COMPILER, GL_DEBUG_SOURCE_THIRD_PARTY,            GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_SOURCE_OTHER to select messages generated by            usage of the GL API, the window system, the shader compiler, third party tools or libraries, explicitly by the application            or by some other source, respectively. It may also take the value GL_DONT_CARE. If source            is not GL_DONT_CARE then only messages whose source matches source will be referenced.
        /// type may be one of GL_DEBUG_TYPE_ERROR, GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR,            GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR, GL_DEBUG_TYPE_PORTABILITY,            GL_DEBUG_TYPE_PERFORMANCE, GL_DEBUG_TYPE_MARKER, GL_DEBUG_TYPE_PUSH_GROUP,            GL_DEBUG_TYPE_POP_GROUP, or GL_DEBUG_TYPE_OTHER to indicate the type of messages describing            GL errors, attempted use of deprecated features, triggering of undefined behavior, portability issues, performance notifications, markers,            group push and pop events, and other            types of messages, respectively. It may also take the value GL_DONT_CARE. If type is not GL_DONT_CARE            then only messages whose type matches type will be referenced.
        /// severity may be one of GL_DEBUG_SEVERITY_LOW, GL_DEBUG_SEVERITY_MEDIUM,            or GL_DEBUG_SEVERITY_HIGH to select messages of low, medium or high severity messages or to            GL_DEBUG_SEVERITY_NOTIFICATION for notifications. It may also take the            value GL_DONT_CARE. If severity is not GL_DONT_CARE then only            messages whose severity matches severity will be referenced.
        /// ids contains a list of count message identifiers to select specific messages from the pool            of available messages. If count is zero then the value of ids is ignored. Otherwise,            only messages appearing in this list are selected. In this case, source and type            may not be GL_DONT_CARE and severity must be GL_DONT_CARE.
        /// If enabled is GL_TRUE then messages that match the filter formed by            source, type, severity and ids            are enabled. Otherwise, those messages are disabled.
        /// </summary>
        /// <param name="source">The source of debug messages to enable or disable.</param>
        /// <param name="type">The type of debug messages to enable or disable.</param>
        /// <param name="severity">The severity of debug messages to enable or disable.</param>
        /// <param name="count">The length of the array ids.</param>
        /// <param name="ids">The address of an array of unsigned integers contianing the ids of the messages to enable or disable.</param>
        /// <param name="enabled">A Boolean flag determining whether the selected messages should be enabled or disabled.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, void* ids, bool enabled) => _DebugMessageControl_ptr(source, type, severity, count, ids, enabled);

        /// <summary>
        /// glDebugMessageControl controls the reporting of debug messages generated by a debug            context. The parameters source, type and severity            form a filter to select messages from the pool of potential messages generated by the GL.
        /// source may be GL_DEBUG_SOURCE_API, GL_DEBUG_SOURCE_WINDOW_SYSTEM_,            GL_DEBUG_SOURCE_SHADER_COMPILER, GL_DEBUG_SOURCE_THIRD_PARTY,            GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_SOURCE_OTHER to select messages generated by            usage of the GL API, the window system, the shader compiler, third party tools or libraries, explicitly by the application            or by some other source, respectively. It may also take the value GL_DONT_CARE. If source            is not GL_DONT_CARE then only messages whose source matches source will be referenced.
        /// type may be one of GL_DEBUG_TYPE_ERROR, GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR,            GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR, GL_DEBUG_TYPE_PORTABILITY,            GL_DEBUG_TYPE_PERFORMANCE, GL_DEBUG_TYPE_MARKER, GL_DEBUG_TYPE_PUSH_GROUP,            GL_DEBUG_TYPE_POP_GROUP, or GL_DEBUG_TYPE_OTHER to indicate the type of messages describing            GL errors, attempted use of deprecated features, triggering of undefined behavior, portability issues, performance notifications, markers,            group push and pop events, and other            types of messages, respectively. It may also take the value GL_DONT_CARE. If type is not GL_DONT_CARE            then only messages whose type matches type will be referenced.
        /// severity may be one of GL_DEBUG_SEVERITY_LOW, GL_DEBUG_SEVERITY_MEDIUM,            or GL_DEBUG_SEVERITY_HIGH to select messages of low, medium or high severity messages or to            GL_DEBUG_SEVERITY_NOTIFICATION for notifications. It may also take the            value GL_DONT_CARE. If severity is not GL_DONT_CARE then only            messages whose severity matches severity will be referenced.
        /// ids contains a list of count message identifiers to select specific messages from the pool            of available messages. If count is zero then the value of ids is ignored. Otherwise,            only messages appearing in this list are selected. In this case, source and type            may not be GL_DONT_CARE and severity must be GL_DONT_CARE.
        /// If enabled is GL_TRUE then messages that match the filter formed by            source, type, severity and ids            are enabled. Otherwise, those messages are disabled.
        /// </summary>
        /// <param name="source">The source of debug messages to enable or disable.</param>
        /// <param name="type">The type of debug messages to enable or disable.</param>
        /// <param name="severity">The severity of debug messages to enable or disable.</param>
        /// <param name="count">The length of the array ids.</param>
        /// <param name="ids">The address of an array of unsigned integers contianing the ids of the messages to enable or disable.</param>
        /// <param name="enabled">A Boolean flag determining whether the selected messages should be enabled or disabled.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageControl(DebugSource source, DebugType type, DebugSeverity severity, int count, IntPtr ids, bool enabled) => _DebugMessageControl_intptr(source, type, severity, count, ids, enabled);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageControlARB(DebugSource source, DebugType type, DebugSeverity severity, int count, uint[] ids, bool enabled) => _DebugMessageControlARB(source, type, severity, count, ids, enabled);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageControlARB(DebugSource source, DebugType type, DebugSeverity severity, int count, void* ids, bool enabled) => _DebugMessageControlARB_ptr(source, type, severity, count, ids, enabled);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageControlARB(DebugSource source, DebugType type, DebugSeverity severity, int count, IntPtr ids, bool enabled) => _DebugMessageControlARB_intptr(source, type, severity, count, ids, enabled);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageControlKHR(DebugSource source, DebugType type, DebugSeverity severity, int count, uint[] ids, bool enabled) => _DebugMessageControlKHR(source, type, severity, count, ids, enabled);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageControlKHR(DebugSource source, DebugType type, DebugSeverity severity, int count, void* ids, bool enabled) => _DebugMessageControlKHR_ptr(source, type, severity, count, ids, enabled);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageControlKHR(DebugSource source, DebugType type, DebugSeverity severity, int count, IntPtr ids, bool enabled) => _DebugMessageControlKHR_intptr(source, type, severity, count, ids, enabled);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageEnableAMD(int category, DebugSeverity severity, int count, uint[] ids, bool enabled) => _DebugMessageEnableAMD(category, severity, count, ids, enabled);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageEnableAMD(int category, DebugSeverity severity, int count, void* ids, bool enabled) => _DebugMessageEnableAMD_ptr(category, severity, count, ids, enabled);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageEnableAMD(int category, DebugSeverity severity, int count, IntPtr ids, bool enabled) => _DebugMessageEnableAMD_intptr(category, severity, count, ids, enabled);

        // ---

        /// <summary>
        /// glDebugMessageInsert inserts a user-supplied message into the            debug output queue. source specifies the source that will be            used to classify the message and must be GL_DEBUG_SOURCE_APPLICATION            or GL_DEBUG_SOURCE_THIRD_PARTY. All other sources are reserved for            use by the GL implementation. type indicates the type of the message            to be inserted and may be one of GL_DEBUG_TYPE_ERROR, GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR,            GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR, GL_DEBUG_TYPE_PORTABILITY,            GL_DEBUG_TYPE_PERFORMANCE, GL_DEBUG_TYPE_MARKER, GL_DEBUG_TYPE_PUSH_GROUP, GL_DEBUG_TYPE_POP_GROUP, or GL_DEBUG_TYPE_OTHER.            severity indicates the severity of the message and may be GL_DEBUG_SEVERITY_LOW,            GL_DEBUG_SEVERITY_MEDIUM, GL_DEBUG_SEVERITY_HIGH or GL_DEBUG_SEVERITY_NOTIFICATION.            id is available for application defined use and may be any value. This value            will be recorded and used to identify the message.
        /// length contains a count of the characters in the character array            whose address is given in message. If length            is negative then message is treated as a null-terminated string.            The length of the message, whether specified explicitly or implicitly, must be less than            or equal to the implementation defined constant GL_MAX_DEBUG_MESSAGE_LENGTH.
        /// </summary>
        /// <param name="source">The source of the debug message to insert.</param>
        /// <param name="type">The type of the debug message insert.</param>
        /// <param name="id">The user-supplied identifier of the message to insert.</param>
        /// <param name="severity">The severity of the debug messages to insert.</param>
        /// <param name="length">The length string contained in the character array whose address is given by message.</param>
        /// <param name="message">The address of a character array containing the message to insert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, string buf) => _DebugMessageInsert(source, type, id, severity, length, buf);

        /// <summary>
        /// glDebugMessageInsert inserts a user-supplied message into the            debug output queue. source specifies the source that will be            used to classify the message and must be GL_DEBUG_SOURCE_APPLICATION            or GL_DEBUG_SOURCE_THIRD_PARTY. All other sources are reserved for            use by the GL implementation. type indicates the type of the message            to be inserted and may be one of GL_DEBUG_TYPE_ERROR, GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR,            GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR, GL_DEBUG_TYPE_PORTABILITY,            GL_DEBUG_TYPE_PERFORMANCE, GL_DEBUG_TYPE_MARKER, GL_DEBUG_TYPE_PUSH_GROUP, GL_DEBUG_TYPE_POP_GROUP, or GL_DEBUG_TYPE_OTHER.            severity indicates the severity of the message and may be GL_DEBUG_SEVERITY_LOW,            GL_DEBUG_SEVERITY_MEDIUM, GL_DEBUG_SEVERITY_HIGH or GL_DEBUG_SEVERITY_NOTIFICATION.            id is available for application defined use and may be any value. This value            will be recorded and used to identify the message.
        /// length contains a count of the characters in the character array            whose address is given in message. If length            is negative then message is treated as a null-terminated string.            The length of the message, whether specified explicitly or implicitly, must be less than            or equal to the implementation defined constant GL_MAX_DEBUG_MESSAGE_LENGTH.
        /// </summary>
        /// <param name="source">The source of the debug message to insert.</param>
        /// <param name="type">The type of the debug message insert.</param>
        /// <param name="id">The user-supplied identifier of the message to insert.</param>
        /// <param name="severity">The severity of the debug messages to insert.</param>
        /// <param name="length">The length string contained in the character array whose address is given by message.</param>
        /// <param name="message">The address of a character array containing the message to insert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, void* buf) => _DebugMessageInsert_ptr(source, type, id, severity, length, buf);

        /// <summary>
        /// glDebugMessageInsert inserts a user-supplied message into the            debug output queue. source specifies the source that will be            used to classify the message and must be GL_DEBUG_SOURCE_APPLICATION            or GL_DEBUG_SOURCE_THIRD_PARTY. All other sources are reserved for            use by the GL implementation. type indicates the type of the message            to be inserted and may be one of GL_DEBUG_TYPE_ERROR, GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR,            GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR, GL_DEBUG_TYPE_PORTABILITY,            GL_DEBUG_TYPE_PERFORMANCE, GL_DEBUG_TYPE_MARKER, GL_DEBUG_TYPE_PUSH_GROUP, GL_DEBUG_TYPE_POP_GROUP, or GL_DEBUG_TYPE_OTHER.            severity indicates the severity of the message and may be GL_DEBUG_SEVERITY_LOW,            GL_DEBUG_SEVERITY_MEDIUM, GL_DEBUG_SEVERITY_HIGH or GL_DEBUG_SEVERITY_NOTIFICATION.            id is available for application defined use and may be any value. This value            will be recorded and used to identify the message.
        /// length contains a count of the characters in the character array            whose address is given in message. If length            is negative then message is treated as a null-terminated string.            The length of the message, whether specified explicitly or implicitly, must be less than            or equal to the implementation defined constant GL_MAX_DEBUG_MESSAGE_LENGTH.
        /// </summary>
        /// <param name="source">The source of the debug message to insert.</param>
        /// <param name="type">The type of the debug message insert.</param>
        /// <param name="id">The user-supplied identifier of the message to insert.</param>
        /// <param name="severity">The severity of the debug messages to insert.</param>
        /// <param name="length">The length string contained in the character array whose address is given by message.</param>
        /// <param name="message">The address of a character array containing the message to insert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageInsert(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, IntPtr buf) => _DebugMessageInsert_intptr(source, type, id, severity, length, buf);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageInsertAMD(int category, DebugSeverity severity, uint id, int length, string buf) => _DebugMessageInsertAMD(category, severity, id, length, buf);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageInsertAMD(int category, DebugSeverity severity, uint id, int length, void* buf) => _DebugMessageInsertAMD_ptr(category, severity, id, length, buf);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageInsertAMD(int category, DebugSeverity severity, uint id, int length, IntPtr buf) => _DebugMessageInsertAMD_intptr(category, severity, id, length, buf);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageInsertARB(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, string buf) => _DebugMessageInsertARB(source, type, id, severity, length, buf);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageInsertARB(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, void* buf) => _DebugMessageInsertARB_ptr(source, type, id, severity, length, buf);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageInsertARB(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, IntPtr buf) => _DebugMessageInsertARB_intptr(source, type, id, severity, length, buf);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageInsertKHR(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, string buf) => _DebugMessageInsertKHR(source, type, id, severity, length, buf);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageInsertKHR(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, void* buf) => _DebugMessageInsertKHR_ptr(source, type, id, severity, length, buf);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DebugMessageInsertKHR(DebugSource source, DebugType type, uint id, DebugSeverity severity, int length, IntPtr buf) => _DebugMessageInsertKHR_intptr(source, type, id, severity, length, buf);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeformSGIX(int mask) => _DeformSGIX(mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeformationMap3dSGIX(FfdTargetSGIX target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, double[] points) => _DeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeformationMap3dSGIX(FfdTargetSGIX target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, void* points) => _DeformationMap3dSGIX_ptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeformationMap3dSGIX(FfdTargetSGIX target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, IntPtr points) => _DeformationMap3dSGIX_intptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeformationMap3fSGIX(FfdTargetSGIX target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, float[] points) => _DeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeformationMap3fSGIX(FfdTargetSGIX target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, void* points) => _DeformationMap3fSGIX_ptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeformationMap3fSGIX(FfdTargetSGIX target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, IntPtr points) => _DeformationMap3fSGIX_intptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteAsyncMarkersSGIX(uint marker, int range) => _DeleteAsyncMarkersSGIX(marker, range);

        // ---

        /// <summary>
        /// glDeleteBuffers deletes n buffer objects named by the elements of the array buffers.            After a buffer object is deleted, it has no contents,            and its name is free for reuse (for example by glGenBuffers).            If a buffer object that is currently bound is deleted, the binding reverts            to 0 (the absence of any buffer object).
        /// glDeleteBuffers silently ignores 0's and names that do not correspond to            existing buffer objects.
        /// </summary>
        /// <param name="n">Specifies the number of buffer objects to be deleted.</param>
        /// <param name="buffers">Specifies an array of buffer objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteBuffers(int n, uint[] buffers) => _DeleteBuffers(n, buffers);

        /// <summary>
        /// glDeleteBuffers deletes n buffer objects named by the elements of the array buffers.            After a buffer object is deleted, it has no contents,            and its name is free for reuse (for example by glGenBuffers).            If a buffer object that is currently bound is deleted, the binding reverts            to 0 (the absence of any buffer object).
        /// glDeleteBuffers silently ignores 0's and names that do not correspond to            existing buffer objects.
        /// </summary>
        /// <param name="n">Specifies the number of buffer objects to be deleted.</param>
        /// <param name="buffers">Specifies an array of buffer objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteBuffers(int n, void* buffers) => _DeleteBuffers_ptr(n, buffers);

        /// <summary>
        /// glDeleteBuffers deletes n buffer objects named by the elements of the array buffers.            After a buffer object is deleted, it has no contents,            and its name is free for reuse (for example by glGenBuffers).            If a buffer object that is currently bound is deleted, the binding reverts            to 0 (the absence of any buffer object).
        /// glDeleteBuffers silently ignores 0's and names that do not correspond to            existing buffer objects.
        /// </summary>
        /// <param name="n">Specifies the number of buffer objects to be deleted.</param>
        /// <param name="buffers">Specifies an array of buffer objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteBuffers(int n, IntPtr buffers) => _DeleteBuffers_intptr(n, buffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteBuffersARB(int n, uint[] buffers) => _DeleteBuffersARB(n, buffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteBuffersARB(int n, void* buffers) => _DeleteBuffersARB_ptr(n, buffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteBuffersARB(int n, IntPtr buffers) => _DeleteBuffersARB_intptr(n, buffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteCommandListsNV(int n, uint[] lists) => _DeleteCommandListsNV(n, lists);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteCommandListsNV(int n, void* lists) => _DeleteCommandListsNV_ptr(n, lists);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteCommandListsNV(int n, IntPtr lists) => _DeleteCommandListsNV_intptr(n, lists);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFencesAPPLE(int n, uint[] fences) => _DeleteFencesAPPLE(n, fences);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFencesAPPLE(int n, void* fences) => _DeleteFencesAPPLE_ptr(n, fences);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFencesAPPLE(int n, IntPtr fences) => _DeleteFencesAPPLE_intptr(n, fences);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFencesNV(int n, uint[] fences) => _DeleteFencesNV(n, fences);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFencesNV(int n, void* fences) => _DeleteFencesNV_ptr(n, fences);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFencesNV(int n, IntPtr fences) => _DeleteFencesNV_intptr(n, fences);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFragmentShaderATI(uint id) => _DeleteFragmentShaderATI(id);

        // ---

        /// <summary>
        /// glDeleteFramebuffers deletes the n framebuffer objects whose names are stored in            the array addressed by framebuffers. The name zero is reserved by the GL and is silently ignored, should it            occur in framebuffers, as are other unused names. Once a framebuffer object is deleted, its name is again            unused and it has no attachments. If a framebuffer that is currently bound to one or more of the targets GL_DRAW_FRAMEBUFFER            or GL_READ_FRAMEBUFFER is deleted, it is as though glBindFramebuffer            had been executed with the corresponding target and framebuffer zero.
        /// </summary>
        /// <param name="n">Specifies the number of framebuffer objects to be deleted.</param>
        /// <param name="framebuffers">A pointer to an array containing n framebuffer objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFramebuffers(int n, uint[] framebuffers) => _DeleteFramebuffers(n, framebuffers);

        /// <summary>
        /// glDeleteFramebuffers deletes the n framebuffer objects whose names are stored in            the array addressed by framebuffers. The name zero is reserved by the GL and is silently ignored, should it            occur in framebuffers, as are other unused names. Once a framebuffer object is deleted, its name is again            unused and it has no attachments. If a framebuffer that is currently bound to one or more of the targets GL_DRAW_FRAMEBUFFER            or GL_READ_FRAMEBUFFER is deleted, it is as though glBindFramebuffer            had been executed with the corresponding target and framebuffer zero.
        /// </summary>
        /// <param name="n">Specifies the number of framebuffer objects to be deleted.</param>
        /// <param name="framebuffers">A pointer to an array containing n framebuffer objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFramebuffers(int n, void* framebuffers) => _DeleteFramebuffers_ptr(n, framebuffers);

        /// <summary>
        /// glDeleteFramebuffers deletes the n framebuffer objects whose names are stored in            the array addressed by framebuffers. The name zero is reserved by the GL and is silently ignored, should it            occur in framebuffers, as are other unused names. Once a framebuffer object is deleted, its name is again            unused and it has no attachments. If a framebuffer that is currently bound to one or more of the targets GL_DRAW_FRAMEBUFFER            or GL_READ_FRAMEBUFFER is deleted, it is as though glBindFramebuffer            had been executed with the corresponding target and framebuffer zero.
        /// </summary>
        /// <param name="n">Specifies the number of framebuffer objects to be deleted.</param>
        /// <param name="framebuffers">A pointer to an array containing n framebuffer objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFramebuffers(int n, IntPtr framebuffers) => _DeleteFramebuffers_intptr(n, framebuffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFramebuffersEXT(int n, uint[] framebuffers) => _DeleteFramebuffersEXT(n, framebuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFramebuffersEXT(int n, void* framebuffers) => _DeleteFramebuffersEXT_ptr(n, framebuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFramebuffersEXT(int n, IntPtr framebuffers) => _DeleteFramebuffersEXT_intptr(n, framebuffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFramebuffersOES(int n, uint[] framebuffers) => _DeleteFramebuffersOES(n, framebuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFramebuffersOES(int n, void* framebuffers) => _DeleteFramebuffersOES_ptr(n, framebuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteFramebuffersOES(int n, IntPtr framebuffers) => _DeleteFramebuffersOES_intptr(n, framebuffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteLists(uint list, int range) => _DeleteLists(list, range);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteMemoryObjectsEXT(int n, uint[] memoryObjects) => _DeleteMemoryObjectsEXT(n, memoryObjects);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteMemoryObjectsEXT(int n, void* memoryObjects) => _DeleteMemoryObjectsEXT_ptr(n, memoryObjects);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteMemoryObjectsEXT(int n, IntPtr memoryObjects) => _DeleteMemoryObjectsEXT_intptr(n, memoryObjects);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteNamedStringARB(int namelen, string name) => _DeleteNamedStringARB(namelen, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteNamedStringARB(int namelen, void* name) => _DeleteNamedStringARB_ptr(namelen, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteNamedStringARB(int namelen, IntPtr name) => _DeleteNamedStringARB_intptr(namelen, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteNamesAMD(int identifier, uint num, uint[] names) => _DeleteNamesAMD(identifier, num, names);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteNamesAMD(int identifier, uint num, void* names) => _DeleteNamesAMD_ptr(identifier, num, names);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteNamesAMD(int identifier, uint num, IntPtr names) => _DeleteNamesAMD_intptr(identifier, num, names);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteObjectARB(int obj) => _DeleteObjectARB(obj);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteOcclusionQueriesNV(int n, uint[] ids) => _DeleteOcclusionQueriesNV(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteOcclusionQueriesNV(int n, void* ids) => _DeleteOcclusionQueriesNV_ptr(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteOcclusionQueriesNV(int n, IntPtr ids) => _DeleteOcclusionQueriesNV_intptr(n, ids);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeletePathsNV(uint path, int range) => _DeletePathsNV(path, range);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeletePerfMonitorsAMD(int n, uint[] monitors) => _DeletePerfMonitorsAMD(n, monitors);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeletePerfMonitorsAMD(int n, void* monitors) => _DeletePerfMonitorsAMD_ptr(n, monitors);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeletePerfMonitorsAMD(int n, IntPtr monitors) => _DeletePerfMonitorsAMD_intptr(n, monitors);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeletePerfQueryINTEL(uint queryHandle) => _DeletePerfQueryINTEL(queryHandle);

        // ---

        /// <summary>
        /// glDeleteProgram frees the memory and    invalidates the name associated with the program object    specified by program. This command    effectively undoes the effects of a call to    glCreateProgram.
        /// If a program object is in use as part of current rendering    state, it will be flagged for deletion, but it will not be    deleted until it is no longer part of current state for any    rendering context. If a program object to be deleted has shader    objects attached to it, those shader objects will be    automatically detached but not deleted unless they have already    been flagged for deletion by a previous call to    glDeleteShader.    A value of 0 for program will be silently    ignored.
        /// To determine whether a program object has been flagged for    deletion, call    glGetProgram    with arguments program and    GL_DELETE_STATUS.
        /// </summary>
        /// <param name="program">Specifies the program object to be            deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteProgram(uint program) => _DeleteProgram(program);

        // ---

        /// <summary>
        /// glDeleteProgramPipelines deletes the n program pipeline objects            whose names are stored in the array pipelines. Unused names in pipelines are            ignored, as is the name zero. After a program pipeline object is deleted, its name is again unused and it            has no contents. If program pipeline object that is currently bound is deleted, the binding for that object reverts to            zero and no program pipeline object becomes current.
        /// </summary>
        /// <param name="n">Specifies the number of program pipeline objects to delete.</param>
        /// <param name="pipelines">Specifies an array of names of program pipeline objects to delete.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteProgramPipelines(int n, uint[] pipelines) => _DeleteProgramPipelines(n, pipelines);

        /// <summary>
        /// glDeleteProgramPipelines deletes the n program pipeline objects            whose names are stored in the array pipelines. Unused names in pipelines are            ignored, as is the name zero. After a program pipeline object is deleted, its name is again unused and it            has no contents. If program pipeline object that is currently bound is deleted, the binding for that object reverts to            zero and no program pipeline object becomes current.
        /// </summary>
        /// <param name="n">Specifies the number of program pipeline objects to delete.</param>
        /// <param name="pipelines">Specifies an array of names of program pipeline objects to delete.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteProgramPipelines(int n, void* pipelines) => _DeleteProgramPipelines_ptr(n, pipelines);

        /// <summary>
        /// glDeleteProgramPipelines deletes the n program pipeline objects            whose names are stored in the array pipelines. Unused names in pipelines are            ignored, as is the name zero. After a program pipeline object is deleted, its name is again unused and it            has no contents. If program pipeline object that is currently bound is deleted, the binding for that object reverts to            zero and no program pipeline object becomes current.
        /// </summary>
        /// <param name="n">Specifies the number of program pipeline objects to delete.</param>
        /// <param name="pipelines">Specifies an array of names of program pipeline objects to delete.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteProgramPipelines(int n, IntPtr pipelines) => _DeleteProgramPipelines_intptr(n, pipelines);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteProgramPipelinesEXT(int n, uint[] pipelines) => _DeleteProgramPipelinesEXT(n, pipelines);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteProgramPipelinesEXT(int n, void* pipelines) => _DeleteProgramPipelinesEXT_ptr(n, pipelines);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteProgramPipelinesEXT(int n, IntPtr pipelines) => _DeleteProgramPipelinesEXT_intptr(n, pipelines);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteProgramsARB(int n, uint[] programs) => _DeleteProgramsARB(n, programs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteProgramsARB(int n, void* programs) => _DeleteProgramsARB_ptr(n, programs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteProgramsARB(int n, IntPtr programs) => _DeleteProgramsARB_intptr(n, programs);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteProgramsNV(int n, uint[] programs) => _DeleteProgramsNV(n, programs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteProgramsNV(int n, void* programs) => _DeleteProgramsNV_ptr(n, programs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteProgramsNV(int n, IntPtr programs) => _DeleteProgramsNV_intptr(n, programs);

        // ---

        /// <summary>
        /// glDeleteQueries deletes n query objects named by the elements of the array ids.            After a query object is deleted, it has no contents,            and its name is free for reuse (for example by glGenQueries).
        /// glDeleteQueries silently ignores 0's and names that do not correspond to            existing query objects.
        /// </summary>
        /// <param name="n">Specifies the number of query objects to be deleted.</param>
        /// <param name="ids">Specifies an array of query objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteQueries(int n, uint[] ids) => _DeleteQueries(n, ids);

        /// <summary>
        /// glDeleteQueries deletes n query objects named by the elements of the array ids.            After a query object is deleted, it has no contents,            and its name is free for reuse (for example by glGenQueries).
        /// glDeleteQueries silently ignores 0's and names that do not correspond to            existing query objects.
        /// </summary>
        /// <param name="n">Specifies the number of query objects to be deleted.</param>
        /// <param name="ids">Specifies an array of query objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteQueries(int n, void* ids) => _DeleteQueries_ptr(n, ids);

        /// <summary>
        /// glDeleteQueries deletes n query objects named by the elements of the array ids.            After a query object is deleted, it has no contents,            and its name is free for reuse (for example by glGenQueries).
        /// glDeleteQueries silently ignores 0's and names that do not correspond to            existing query objects.
        /// </summary>
        /// <param name="n">Specifies the number of query objects to be deleted.</param>
        /// <param name="ids">Specifies an array of query objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteQueries(int n, IntPtr ids) => _DeleteQueries_intptr(n, ids);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteQueriesARB(int n, uint[] ids) => _DeleteQueriesARB(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteQueriesARB(int n, void* ids) => _DeleteQueriesARB_ptr(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteQueriesARB(int n, IntPtr ids) => _DeleteQueriesARB_intptr(n, ids);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteQueriesEXT(int n, uint[] ids) => _DeleteQueriesEXT(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteQueriesEXT(int n, void* ids) => _DeleteQueriesEXT_ptr(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteQueriesEXT(int n, IntPtr ids) => _DeleteQueriesEXT_intptr(n, ids);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteQueryResourceTagNV(int n, int[] tagIds) => _DeleteQueryResourceTagNV(n, tagIds);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteQueryResourceTagNV(int n, void* tagIds) => _DeleteQueryResourceTagNV_ptr(n, tagIds);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteQueryResourceTagNV(int n, IntPtr tagIds) => _DeleteQueryResourceTagNV_intptr(n, tagIds);

        // ---

        /// <summary>
        /// glDeleteRenderbuffers deletes the n renderbuffer objects whose names are stored in            the array addressed by renderbuffers. The name zero is reserved by the GL and is silently ignored, should it            occur in renderbuffers, as are other unused names. Once a renderbuffer object is deleted, its name is again            unused and it has no contents. If a renderbuffer that is currently bound to the target GL_RENDERBUFFER            is deleted, it is as though glBindRenderbuffer            had been executed with a target of GL_RENDERBUFFER and a name of zero.
        /// If a renderbuffer object is attached to one or more attachment points in the currently bound framebuffer, then it as if            glFramebufferRenderbuffer had been called, with a renderbuffer            of zero for each attachment point to which this image was attached in the currently bound framebuffer. In other words,            this renderbuffer object is first detached from all attachment ponits in the currently bound framebuffer. Note that the renderbuffer            image is specifically not detached from any non-bound framebuffers.
        /// </summary>
        /// <param name="n">Specifies the number of renderbuffer objects to be deleted.</param>
        /// <param name="renderbuffers">A pointer to an array containing n renderbuffer objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteRenderbuffers(int n, uint[] renderbuffers) => _DeleteRenderbuffers(n, renderbuffers);

        /// <summary>
        /// glDeleteRenderbuffers deletes the n renderbuffer objects whose names are stored in            the array addressed by renderbuffers. The name zero is reserved by the GL and is silently ignored, should it            occur in renderbuffers, as are other unused names. Once a renderbuffer object is deleted, its name is again            unused and it has no contents. If a renderbuffer that is currently bound to the target GL_RENDERBUFFER            is deleted, it is as though glBindRenderbuffer            had been executed with a target of GL_RENDERBUFFER and a name of zero.
        /// If a renderbuffer object is attached to one or more attachment points in the currently bound framebuffer, then it as if            glFramebufferRenderbuffer had been called, with a renderbuffer            of zero for each attachment point to which this image was attached in the currently bound framebuffer. In other words,            this renderbuffer object is first detached from all attachment ponits in the currently bound framebuffer. Note that the renderbuffer            image is specifically not detached from any non-bound framebuffers.
        /// </summary>
        /// <param name="n">Specifies the number of renderbuffer objects to be deleted.</param>
        /// <param name="renderbuffers">A pointer to an array containing n renderbuffer objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteRenderbuffers(int n, void* renderbuffers) => _DeleteRenderbuffers_ptr(n, renderbuffers);

        /// <summary>
        /// glDeleteRenderbuffers deletes the n renderbuffer objects whose names are stored in            the array addressed by renderbuffers. The name zero is reserved by the GL and is silently ignored, should it            occur in renderbuffers, as are other unused names. Once a renderbuffer object is deleted, its name is again            unused and it has no contents. If a renderbuffer that is currently bound to the target GL_RENDERBUFFER            is deleted, it is as though glBindRenderbuffer            had been executed with a target of GL_RENDERBUFFER and a name of zero.
        /// If a renderbuffer object is attached to one or more attachment points in the currently bound framebuffer, then it as if            glFramebufferRenderbuffer had been called, with a renderbuffer            of zero for each attachment point to which this image was attached in the currently bound framebuffer. In other words,            this renderbuffer object is first detached from all attachment ponits in the currently bound framebuffer. Note that the renderbuffer            image is specifically not detached from any non-bound framebuffers.
        /// </summary>
        /// <param name="n">Specifies the number of renderbuffer objects to be deleted.</param>
        /// <param name="renderbuffers">A pointer to an array containing n renderbuffer objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteRenderbuffers(int n, IntPtr renderbuffers) => _DeleteRenderbuffers_intptr(n, renderbuffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteRenderbuffersEXT(int n, uint[] renderbuffers) => _DeleteRenderbuffersEXT(n, renderbuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteRenderbuffersEXT(int n, void* renderbuffers) => _DeleteRenderbuffersEXT_ptr(n, renderbuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteRenderbuffersEXT(int n, IntPtr renderbuffers) => _DeleteRenderbuffersEXT_intptr(n, renderbuffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteRenderbuffersOES(int n, uint[] renderbuffers) => _DeleteRenderbuffersOES(n, renderbuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteRenderbuffersOES(int n, void* renderbuffers) => _DeleteRenderbuffersOES_ptr(n, renderbuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteRenderbuffersOES(int n, IntPtr renderbuffers) => _DeleteRenderbuffersOES_intptr(n, renderbuffers);

        // ---

        /// <summary>
        /// glDeleteSamplers deletes n sampler objects named by the elements of the array samplers.            After a sampler object is deleted, its name is again unused. If a sampler object that is currently bound to a sampler unit is deleted, it is as            though glBindSampler is called with unit set to the unit the sampler is bound to and            sampler zero. Unused names in samplers are silently ignored, as is the reserved name zero.
        /// </summary>
        /// <param name="n">Specifies the number of sampler objects to be deleted.</param>
        /// <param name="samplers">Specifies an array of sampler objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteSamplers(int count, uint[] samplers) => _DeleteSamplers(count, samplers);

        /// <summary>
        /// glDeleteSamplers deletes n sampler objects named by the elements of the array samplers.            After a sampler object is deleted, its name is again unused. If a sampler object that is currently bound to a sampler unit is deleted, it is as            though glBindSampler is called with unit set to the unit the sampler is bound to and            sampler zero. Unused names in samplers are silently ignored, as is the reserved name zero.
        /// </summary>
        /// <param name="n">Specifies the number of sampler objects to be deleted.</param>
        /// <param name="samplers">Specifies an array of sampler objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteSamplers(int count, void* samplers) => _DeleteSamplers_ptr(count, samplers);

        /// <summary>
        /// glDeleteSamplers deletes n sampler objects named by the elements of the array samplers.            After a sampler object is deleted, its name is again unused. If a sampler object that is currently bound to a sampler unit is deleted, it is as            though glBindSampler is called with unit set to the unit the sampler is bound to and            sampler zero. Unused names in samplers are silently ignored, as is the reserved name zero.
        /// </summary>
        /// <param name="n">Specifies the number of sampler objects to be deleted.</param>
        /// <param name="samplers">Specifies an array of sampler objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteSamplers(int count, IntPtr samplers) => _DeleteSamplers_intptr(count, samplers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteSemaphoresEXT(int n, uint[] semaphores) => _DeleteSemaphoresEXT(n, semaphores);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteSemaphoresEXT(int n, void* semaphores) => _DeleteSemaphoresEXT_ptr(n, semaphores);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteSemaphoresEXT(int n, IntPtr semaphores) => _DeleteSemaphoresEXT_intptr(n, semaphores);

        // ---

        /// <summary>
        /// glDeleteShader frees the memory and    invalidates the name associated with the shader object specified    by shader. This command effectively    undoes the effects of a call to    glCreateShader.
        /// If a shader object to be deleted is attached to a program    object, it will be flagged for deletion, but it will not be    deleted until it is no longer attached to any program object,    for any rendering context (i.e., it must be detached from    wherever it was attached before it will be deleted). A value of    0 for shader will be silently    ignored.
        /// To determine whether an object has been flagged for    deletion, call    glGetShader    with arguments shader and    GL_DELETE_STATUS.
        /// </summary>
        /// <param name="shader">Specifies the shader object to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteShader(uint shader) => _DeleteShader(shader);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteStatesNV(int n, uint[] states) => _DeleteStatesNV(n, states);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteStatesNV(int n, void* states) => _DeleteStatesNV_ptr(n, states);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteStatesNV(int n, IntPtr states) => _DeleteStatesNV_intptr(n, states);

        // ---

        /// <summary>
        /// glDeleteSync deletes the sync object specified by sync. If the fence command            corresponding to the specified sync object has completed, or if no glWaitSync            or glClientWaitSync commands are blocking on sync,            the object is deleted immediately. Otherwise, sync is flagged for deletion and will be deleted when            it is no longer associated with any fence command and is no longer blocking any glWaitSync            or glClientWaitSync command. In either case, after            glDeleteSync returns, the name sync is invalid and can no longer be used to            refer to the sync object.
        /// glDeleteSync will silently ignore a sync value of zero.
        /// </summary>
        /// <param name="sync">The sync object to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteSync(int sync) => _DeleteSync(sync);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteSyncAPPLE(int sync) => _DeleteSyncAPPLE(sync);

        // ---

        /// <summary>
        /// glDeleteTextures deletes n textures named by the elements of the array textures.            After a texture is deleted, it has no contents or dimensionality,            and its name is free for reuse (for example by glGenTextures).            If a texture that is currently bound is deleted, the binding reverts            to 0 (the default texture).
        /// glDeleteTextures silently ignores 0's and names that do not correspond to            existing textures.
        /// </summary>
        /// <param name="n">Specifies the number of textures to be deleted.</param>
        /// <param name="textures">Specifies an array of textures to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteTextures(int n, uint[] textures) => _DeleteTextures(n, textures);

        /// <summary>
        /// glDeleteTextures deletes n textures named by the elements of the array textures.            After a texture is deleted, it has no contents or dimensionality,            and its name is free for reuse (for example by glGenTextures).            If a texture that is currently bound is deleted, the binding reverts            to 0 (the default texture).
        /// glDeleteTextures silently ignores 0's and names that do not correspond to            existing textures.
        /// </summary>
        /// <param name="n">Specifies the number of textures to be deleted.</param>
        /// <param name="textures">Specifies an array of textures to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteTextures(int n, void* textures) => _DeleteTextures_ptr(n, textures);

        /// <summary>
        /// glDeleteTextures deletes n textures named by the elements of the array textures.            After a texture is deleted, it has no contents or dimensionality,            and its name is free for reuse (for example by glGenTextures).            If a texture that is currently bound is deleted, the binding reverts            to 0 (the default texture).
        /// glDeleteTextures silently ignores 0's and names that do not correspond to            existing textures.
        /// </summary>
        /// <param name="n">Specifies the number of textures to be deleted.</param>
        /// <param name="textures">Specifies an array of textures to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteTextures(int n, IntPtr textures) => _DeleteTextures_intptr(n, textures);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteTexturesEXT(int n, uint[] textures) => _DeleteTexturesEXT(n, textures);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteTexturesEXT(int n, void* textures) => _DeleteTexturesEXT_ptr(n, textures);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteTexturesEXT(int n, IntPtr textures) => _DeleteTexturesEXT_intptr(n, textures);

        // ---

        /// <summary>
        /// glDeleteTransformFeedbacks deletes the n transform feedback objects            whose names are stored in the array ids. Unused names in ids are            ignored, as is the name zero. After a transform feedback object is deleted, its name is again unused and it            has no contents. If an active transform feedback object is deleted, its name immediately becomes unused, but            the underlying object is not deleted until it is no longer active.
        /// </summary>
        /// <param name="n">Specifies the number of transform feedback objects to delete.</param>
        /// <param name="ids">Specifies an array of names of transform feedback objects to delete.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteTransformFeedbacks(int n, uint[] ids) => _DeleteTransformFeedbacks(n, ids);

        /// <summary>
        /// glDeleteTransformFeedbacks deletes the n transform feedback objects            whose names are stored in the array ids. Unused names in ids are            ignored, as is the name zero. After a transform feedback object is deleted, its name is again unused and it            has no contents. If an active transform feedback object is deleted, its name immediately becomes unused, but            the underlying object is not deleted until it is no longer active.
        /// </summary>
        /// <param name="n">Specifies the number of transform feedback objects to delete.</param>
        /// <param name="ids">Specifies an array of names of transform feedback objects to delete.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteTransformFeedbacks(int n, void* ids) => _DeleteTransformFeedbacks_ptr(n, ids);

        /// <summary>
        /// glDeleteTransformFeedbacks deletes the n transform feedback objects            whose names are stored in the array ids. Unused names in ids are            ignored, as is the name zero. After a transform feedback object is deleted, its name is again unused and it            has no contents. If an active transform feedback object is deleted, its name immediately becomes unused, but            the underlying object is not deleted until it is no longer active.
        /// </summary>
        /// <param name="n">Specifies the number of transform feedback objects to delete.</param>
        /// <param name="ids">Specifies an array of names of transform feedback objects to delete.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteTransformFeedbacks(int n, IntPtr ids) => _DeleteTransformFeedbacks_intptr(n, ids);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteTransformFeedbacksNV(int n, uint[] ids) => _DeleteTransformFeedbacksNV(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteTransformFeedbacksNV(int n, void* ids) => _DeleteTransformFeedbacksNV_ptr(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteTransformFeedbacksNV(int n, IntPtr ids) => _DeleteTransformFeedbacksNV_intptr(n, ids);

        // ---

        /// <summary>
        /// glDeleteVertexArrays deletes n vertex array objects whose names are stored in the            array addressed by arrays. Once a vertex array object is deleted it has no contents and its name is            again unused. If a vertex array object that is currently bound is deleted, the binding for that object reverts to zero            and the default vertex array becomes current. Unused names in arrays are silently ignored, as is the value zero.
        /// </summary>
        /// <param name="n">Specifies the number of vertex array objects to be deleted.</param>
        /// <param name="arrays">Specifies the address of an array containing the n names of the objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteVertexArrays(int n, uint[] arrays) => _DeleteVertexArrays(n, arrays);

        /// <summary>
        /// glDeleteVertexArrays deletes n vertex array objects whose names are stored in the            array addressed by arrays. Once a vertex array object is deleted it has no contents and its name is            again unused. If a vertex array object that is currently bound is deleted, the binding for that object reverts to zero            and the default vertex array becomes current. Unused names in arrays are silently ignored, as is the value zero.
        /// </summary>
        /// <param name="n">Specifies the number of vertex array objects to be deleted.</param>
        /// <param name="arrays">Specifies the address of an array containing the n names of the objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteVertexArrays(int n, void* arrays) => _DeleteVertexArrays_ptr(n, arrays);

        /// <summary>
        /// glDeleteVertexArrays deletes n vertex array objects whose names are stored in the            array addressed by arrays. Once a vertex array object is deleted it has no contents and its name is            again unused. If a vertex array object that is currently bound is deleted, the binding for that object reverts to zero            and the default vertex array becomes current. Unused names in arrays are silently ignored, as is the value zero.
        /// </summary>
        /// <param name="n">Specifies the number of vertex array objects to be deleted.</param>
        /// <param name="arrays">Specifies the address of an array containing the n names of the objects to be deleted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteVertexArrays(int n, IntPtr arrays) => _DeleteVertexArrays_intptr(n, arrays);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteVertexArraysAPPLE(int n, uint[] arrays) => _DeleteVertexArraysAPPLE(n, arrays);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteVertexArraysAPPLE(int n, void* arrays) => _DeleteVertexArraysAPPLE_ptr(n, arrays);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteVertexArraysAPPLE(int n, IntPtr arrays) => _DeleteVertexArraysAPPLE_intptr(n, arrays);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteVertexArraysOES(int n, uint[] arrays) => _DeleteVertexArraysOES(n, arrays);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteVertexArraysOES(int n, void* arrays) => _DeleteVertexArraysOES_ptr(n, arrays);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteVertexArraysOES(int n, IntPtr arrays) => _DeleteVertexArraysOES_intptr(n, arrays);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DeleteVertexShaderEXT(uint id) => _DeleteVertexShaderEXT(id);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthBoundsEXT(double zmin, double zmax) => _DepthBoundsEXT(zmin, zmax);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthBoundsdNV(double zmin, double zmax) => _DepthBoundsdNV(zmin, zmax);

        // ---

        /// <summary>
        /// glDepthFunc specifies the function used to compare each incoming pixel depth value            with the depth value present in the depth buffer.            The comparison is performed only if depth testing is enabled.            (See glEnable and glDisable of GL_DEPTH_TEST.)
        /// func specifies the conditions under which the pixel will be drawn.            The comparison functions are as follows:
        /// GL_NEVER                        Never passes.                    GL_LESS                        Passes if the incoming depth value is less than the stored depth value.                    GL_EQUAL                        Passes if the incoming depth value is equal to the stored depth value.                    GL_LEQUAL                        Passes if the incoming depth value is less than or equal to                        the stored depth value.                    GL_GREATER                        Passes if the incoming depth value is greater than the stored depth value.                    GL_NOTEQUAL                        Passes if the incoming depth value is not equal to the stored depth value.                    GL_GEQUAL                        Passes if the incoming depth value is greater than or equal to                        the stored depth value.                    GL_ALWAYS                        Always passes.
        /// The initial value of func is GL_LESS.            Initially, depth testing is disabled.  If depth testing is disabled or if no            depth buffer exists, it is as if the depth test always passes.
        /// </summary>
        /// <param name="func">Specifies the depth comparison function.                    Symbolic constants                    GL_NEVER,                    GL_LESS,                    GL_EQUAL,                    GL_LEQUAL,                    GL_GREATER,                    GL_NOTEQUAL,                    GL_GEQUAL, and                    GL_ALWAYS are accepted.                    The initial value is GL_LESS.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthFunc(DepthFunction func) => _DepthFunc(func);

        // ---

        /// <summary>
        /// glDepthMask specifies whether the depth buffer is enabled for writing.            If flag is GL_FALSE,            depth buffer writing is disabled.            Otherwise, it is enabled.            Initially, depth buffer writing is enabled.
        /// </summary>
        /// <param name="flag">Specifies whether the depth buffer is enabled for writing.                    If flag is GL_FALSE,                    depth buffer writing is disabled.                    Otherwise, it is enabled.                    Initially, depth buffer writing is enabled.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthMask(bool flag) => _DepthMask(flag);

        // ---

        /// <summary>
        /// After clipping and division by w,            depth coordinates range from                        are acceptable.
        /// The type of the nearVal and            farVal parameters was changed from            GLclampf to GLfloat for glDepthRangef            and from GLclampd to GLdouble for            glDepthRange. This change is            transparent to user code and is described in detail on the            removedTypes            page.
        /// </summary>
        /// <param name="nearVal">Specifies the mapping of the near clipping plane to window coordinates.                    The initial value is 0.</param>
        /// <param name="farVal">Specifies the mapping of the far clipping plane to window coordinates.                    The initial value is 1.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRange(double n, double f) => _DepthRange(n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeArraydvNV(uint first, int count, double[] v) => _DepthRangeArraydvNV(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeArraydvNV(uint first, int count, void* v) => _DepthRangeArraydvNV_ptr(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeArraydvNV(uint first, int count, IntPtr v) => _DepthRangeArraydvNV_intptr(first, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeArrayfvNV(uint first, int count, float[] v) => _DepthRangeArrayfvNV(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeArrayfvNV(uint first, int count, void* v) => _DepthRangeArrayfvNV_ptr(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeArrayfvNV(uint first, int count, IntPtr v) => _DepthRangeArrayfvNV_intptr(first, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeArrayfvOES(uint first, int count, float[] v) => _DepthRangeArrayfvOES(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeArrayfvOES(uint first, int count, void* v) => _DepthRangeArrayfvOES_ptr(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeArrayfvOES(uint first, int count, IntPtr v) => _DepthRangeArrayfvOES_intptr(first, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeArrayv(uint first, int count, double[] v) => _DepthRangeArrayv(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeArrayv(uint first, int count, void* v) => _DepthRangeArrayv_ptr(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeArrayv(uint first, int count, IntPtr v) => _DepthRangeArrayv_intptr(first, count, v);

        // ---

        /// <summary>
        /// After clipping and division by w,            depth coordinates range from                        are acceptable.
        /// The type of the nearVal and            farVal parameters was changed from            GLclampd to GLdouble. This change is transparent to user            code and is described in detail on the            removedTypes            page.
        /// </summary>
        /// <param name="index">Specifies the index of the viewport whose depth range to update.</param>
        /// <param name="nearVal">Specifies the mapping of the near clipping plane to window coordinates.                    The initial value is 0.</param>
        /// <param name="farVal">Specifies the mapping of the far clipping plane to window coordinates.                    The initial value is 1.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeIndexed(uint index, double n, double f) => _DepthRangeIndexed(index, n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeIndexeddNV(uint index, double n, double f) => _DepthRangeIndexeddNV(index, n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeIndexedfNV(uint index, float n, float f) => _DepthRangeIndexedfNV(index, n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangeIndexedfOES(uint index, float n, float f) => _DepthRangeIndexedfOES(index, n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangedNV(double zNear, double zFar) => _DepthRangedNV(zNear, zFar);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangef(float n, float f) => _DepthRangef(n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangefOES(float n, float f) => _DepthRangefOES(n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangex(float n, float f) => _DepthRangex(n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DepthRangexOES(float n, float f) => _DepthRangexOES(n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DetachObjectARB(int containerObj, int attachedObj) => _DetachObjectARB(containerObj, attachedObj);

        // ---

        /// <summary>
        /// glDetachShader detaches the shader    object specified by shader from the    program object specified by program. This    command can be used to undo the effect of the command    glAttachShader.
        /// If shader has already been flagged    for deletion by a call to    glDeleteShader    and it is not attached to any other program object, it will be    deleted after it has been detached.
        /// </summary>
        /// <param name="program">Specifies the program object from which to            detach the shader object.</param>
        /// <param name="shader">Specifies the shader object to be            detached.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DetachShader(uint program, uint shader) => _DetachShader(program, shader);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DetailTexFuncSGIS(TextureTarget target, int n, float[] points) => _DetailTexFuncSGIS(target, n, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DetailTexFuncSGIS(TextureTarget target, int n, void* points) => _DetailTexFuncSGIS_ptr(target, n, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DetailTexFuncSGIS(TextureTarget target, int n, IntPtr points) => _DetailTexFuncSGIS_intptr(target, n, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Disable(EnableCap cap) => _Disable(cap);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DisableClientState(EnableCap array) => _DisableClientState(array);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DisableClientStateIndexedEXT(EnableCap array, uint index) => _DisableClientStateIndexedEXT(array, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DisableClientStateiEXT(EnableCap array, uint index) => _DisableClientStateiEXT(array, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DisableDriverControlQCOM(uint driverControl) => _DisableDriverControlQCOM(driverControl);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DisableIndexedEXT(EnableCap target, uint index) => _DisableIndexedEXT(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DisableVariantClientStateEXT(uint id) => _DisableVariantClientStateEXT(id);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DisableVertexArrayAttrib(uint vaobj, uint index) => _DisableVertexArrayAttrib(vaobj, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DisableVertexArrayAttribEXT(uint vaobj, uint index) => _DisableVertexArrayAttribEXT(vaobj, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DisableVertexArrayEXT(uint vaobj, EnableCap array) => _DisableVertexArrayEXT(vaobj, array);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DisableVertexAttribAPPLE(uint index, int pname) => _DisableVertexAttribAPPLE(index, pname);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DisableVertexAttribArray(uint index) => _DisableVertexAttribArray(index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DisableVertexAttribArrayARB(uint index) => _DisableVertexAttribArrayARB(index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Disablei(EnableCap target, uint index) => _Disablei(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DisableiEXT(EnableCap target, uint index) => _DisableiEXT(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DisableiNV(EnableCap target, uint index) => _DisableiNV(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DisableiOES(EnableCap target, uint index) => _DisableiOES(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DiscardFramebufferEXT(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment[] attachments) => _DiscardFramebufferEXT(target, numAttachments, attachments);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DiscardFramebufferEXT(FramebufferTarget target, int numAttachments, void* attachments) => _DiscardFramebufferEXT_ptr(target, numAttachments, attachments);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DiscardFramebufferEXT(FramebufferTarget target, int numAttachments, IntPtr attachments) => _DiscardFramebufferEXT_intptr(target, numAttachments, attachments);

        // ---

        /// <summary>
        /// glDispatchCompute launches one or more compute            work groups. Each work group is processed by the active program object for the compute            shader stage. While the individual shader invocations within a work group are            executed as a unit, work groups are executed completely independently and in            unspecified order. num_groups_x, num_groups_y            and num_groups_z specify the number of local            work groups that will be dispatched in the X, Y and Z dimensions, respectively.
        /// </summary>
        /// <param name="num_groups_x">The number of work groups to be launched in the X dimension.</param>
        /// <param name="num_groups_y">The number of work groups to be launched in the Y dimension.</param>
        /// <param name="num_groups_z">The number of work groups to be launched in the Z dimension.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DispatchCompute(uint num_groups_x, uint num_groups_y, uint num_groups_z) => _DispatchCompute(num_groups_x, num_groups_y, num_groups_z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DispatchComputeGroupSizeARB(uint num_groups_x, uint num_groups_y, uint num_groups_z, uint group_size_x, uint group_size_y, uint group_size_z) => _DispatchComputeGroupSizeARB(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);

        // ---

        /// <summary>
        /// glDispatchComputeIndirect launches one or more compute            work groups using parameters stored in the buffer object currently bound            to the GL_DISPATCH_INDIRECT_BUFFER target.            Each work group is processed by the active program object for the compute            shader stage. While the individual shader invocations within a work group are            executed as a unit, work groups are executed completely independently and in            unspecified order. indirect contains the offset            into the data store of the buffer object bound to the GL_DISPATCH_INDIRECT_BUFFER            target at which the parameters are stored.
        /// The parameters addressed by indirect are packed a structure,            which takes the form (in C):                typedef  struct {        uint  num_groups_x;        uint  num_groups_y;        uint  num_groups_z;    } DispatchIndirectCommand;
        /// A call to glDispatchComputeIndirect is equivalent, assuming no            errors are generated, to:                cmd = (const DispatchIndirectCommand  *)indirect;    glDispatchCompute(cmd->num_groups_x, cmd->num_groups_y, cmd->num_groups_z);
        /// Unlike glDispatchCompute,            no error is generated if any of the num_groups_x,            num_groups_y or num_groups_z members            of the DispatchIndirectCommand is larger than the            value of GL_MAX_COMPUTE_WORK_GROUP_COUNT for the            corresponding dimension. In such circumstances, behavior is undefined and            may lead to application termination.
        /// </summary>
        /// <param name="indirect">The offset into the buffer object currently bound to the                    GL_DISPATCH_INDIRECT_BUFFER buffer target at                    which the dispatch parameters are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DispatchComputeIndirect(IntPtr indirect) => _DispatchComputeIndirect(indirect);

        // ---

        /// <summary>
        /// glDrawArrays specifies multiple geometric primitives            with very few subroutine calls. Instead of calling a GL procedure            to pass each individual vertex, normal, texture coordinate, edge            flag, or color, you can prespecify            separate arrays of vertices, normals, and colors and use them to            construct a sequence of primitives with a single            call to glDrawArrays.
        /// When glDrawArrays is called, it uses count sequential elements from each            enabled array to construct a sequence of geometric primitives,            beginning with element first. mode specifies what kind of            primitives are constructed and how the array elements            construct those primitives.
        /// Vertex attributes that are modified by glDrawArrays have an            unspecified value after glDrawArrays returns. Attributes that aren't            modified remain well defined.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="first">Specifies the starting index in the enabled arrays.</param>
        /// <param name="count">Specifies the number of indices to be rendered.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawArrays(PrimitiveType mode, int first, int count) => _DrawArrays(mode, first, count);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawArraysEXT(PrimitiveType mode, int first, int count) => _DrawArraysEXT(mode, first, count);

        // ---

        /// <summary>
        /// glDrawArraysIndirect specifies multiple geometric primitives            with very few subroutine calls. glDrawArraysIndirect behaves            similarly to glDrawArraysInstancedBaseInstance,            execept that the parameters to glDrawArraysInstancedBaseInstance            are stored in memory at the address given by indirect.
        /// The parameters addressed by indirect are packed into a structure            that takes the form (in C):                typedef  struct {        uint  count;        uint  primCount;        uint  first;        uint  baseInstance;    } DrawArraysIndirectCommand;    const DrawArraysIndirectCommand *cmd = (const DrawArraysIndirectCommand *)indirect;    glDrawArraysInstancedBaseInstance(mode, cmd->first, cmd->count, cmd->primCount, cmd->baseInstance);
        /// If a buffer is bound to the GL_DRAW_INDIRECT_BUFFER binding at the time            of a call to glDrawArraysIndirect, indirect            is interpreted as an offset, in basic machine units, into that buffer and the parameter            data is read from the buffer rather than from client memory.
        /// In contrast to glDrawArraysInstancedBaseInstance,            the first member of the parameter structure is unsigned, and out-of-range indices            do not generate an error.
        /// Vertex attributes that are modified by glDrawArraysIndirect have an            unspecified value after glDrawArraysIndirect returns. Attributes that aren't            modified remain well defined.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY, and                    GL_PATCHES                    are accepted.</param>
        /// <param name="indirect">Specifies the address of a structure containing the draw parameters.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawArraysIndirect(PrimitiveType mode, IntPtr indirect) => _DrawArraysIndirect(mode, indirect);

        // ---

        /// <summary>
        /// glDrawArraysInstanced behaves identically to glDrawArrays            except that instancecount instances of the range of elements are executed and the value of the internal counter            instanceID advances for each iteration. instanceID is an internal 32-bit integer counter            that may be read by a vertex shader as gl_InstanceID.
        /// glDrawArraysInstanced has the same effect as:                if ( mode or count is invalid )        generate appropriate error    else {        for (int i = 0; i < instancecount ; i++) {            instanceID = i;            glDrawArrays(mode, first, count);        }        instanceID = 0;    }
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS,                    GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,                    GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLESGL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="first">Specifies the starting index in the enabled arrays.</param>
        /// <param name="count">Specifies the number of indices to be rendered.</param>
        /// <param name="instancecount">Specifies the number of instances of the specified range of indices to be rendered.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawArraysInstanced(PrimitiveType mode, int first, int count, int instancecount) => _DrawArraysInstanced(mode, first, count, instancecount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawArraysInstancedANGLE(PrimitiveType mode, int first, int count, int primcount) => _DrawArraysInstancedANGLE(mode, first, count, primcount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawArraysInstancedARB(PrimitiveType mode, int first, int count, int primcount) => _DrawArraysInstancedARB(mode, first, count, primcount);

        // ---

        /// <summary>
        /// glDrawArraysInstancedBaseInstance behaves identically to glDrawArrays            except that instancecount instances of the range of elements are executed and the value of the internal counter            instanceID advances for each iteration. instanceID is an internal 32-bit integer counter            that may be read by a vertex shader as gl_InstanceID.
        /// glDrawArraysInstancedBaseInstance has the same effect as:                if ( mode or count is invalid )        generate appropriate error    else {        for (int i = 0; i < instancecount ; i++) {            instanceID = i;            glDrawArrays(mode, first, count);        }        instanceID = 0;    }
        /// Specific vertex attributes may be classified as instanced through the use of            glVertexAttribDivisor. Instanced vertex attributes            supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex            attribute arrays is calculated as:            . Note that baseinstance            does not affect the shader-visible value of            gl_InstanceID.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render. Symbolic constants GL_POINTS,                    GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES,                    GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLESGL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="first">Specifies the starting index in the enabled arrays.</param>
        /// <param name="count">Specifies the number of indices to be rendered.</param>
        /// <param name="instancecount">Specifies the number of instances of the specified range of indices to be rendered.</param>
        /// <param name="baseinstance">Specifies the base instance for use in fetching instanced vertex attributes.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawArraysInstancedBaseInstance(PrimitiveType mode, int first, int count, int instancecount, uint baseinstance) => _DrawArraysInstancedBaseInstance(mode, first, count, instancecount, baseinstance);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawArraysInstancedBaseInstanceEXT(PrimitiveType mode, int first, int count, int instancecount, uint baseinstance) => _DrawArraysInstancedBaseInstanceEXT(mode, first, count, instancecount, baseinstance);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawArraysInstancedEXT(PrimitiveType mode, int start, int count, int primcount) => _DrawArraysInstancedEXT(mode, start, count, primcount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawArraysInstancedNV(PrimitiveType mode, int first, int count, int primcount) => _DrawArraysInstancedNV(mode, first, count, primcount);

        // ---

        /// <summary>
        /// When colors are written to the frame buffer, they are written into    the color buffers specified by glDrawBuffer. One of    the following values can be used for default framebuffer:
        /// GL_NONENo color buffers are written.GL_FRONT_LEFTOnly the front left color buffer is written.GL_FRONT_RIGHTOnly the front right color buffer is written.GL_BACK_LEFTOnly the back left color buffer is written.GL_BACK_RIGHTOnly the back right color buffer is written.GL_FRONTOnly the front left and front right color buffers are written.          If there is no front right color buffer, only the front left color          buffer is written.GL_BACKOnly the back left and back right color buffers are written.          If there is no back right color buffer, only the back left color          buffer is written.GL_LEFTOnly the front left and back left color buffers are written.          If there is no back left color buffer, only the front left color          buffer is written.GL_RIGHTOnly the front right and back right color buffers are written.          If there is no back right color buffer, only the front right color          buffer is written.GL_FRONT_AND_BACKAll the front and back color buffers (front left, front right,          back left, back right) are written. If there are no back color          buffers, only the front left and front right color buffers are          written. If there are no right color buffers, only the front left          and back left color buffers are written. If there are no right or          back color buffers, only the front left color buffer is          written.
        /// If more than one color buffer is selected for drawing, then blending    or logical operations are computed and applied independently for each    color buffer and can produce different results in each buffer.
        /// Monoscopic contexts include only left buffers,    and stereoscopic contexts include both left and    right buffers. Likewise, single-buffered contexts    include only front buffers, and double-buffered    contexts include both front and    back buffers. The context is selected at GL    initialization.
        /// For framebuffer objects, GL_COLOR_ATTACHMENT$m$    and GL_NONE enums are accepted, where    $m$ is a value between 0 and    GL_MAX_COLOR_ATTACHMENTS. glDrawBuffer will set the    draw buffer for fragment colors other than zero to    GL_NONE.
        /// </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for          glNamedFramebufferDrawBuffer function. Must be          zero or the name of a framebuffer object.</param>
        /// <param name="buf">For default framebuffer, the argument specifies up to four          color buffers to be drawn into. Symbolic constants          GL_NONE, GL_FRONT_LEFT,          GL_FRONT_RIGHT,          GL_BACK_LEFT,          GL_BACK_RIGHT, GL_FRONT,          GL_BACK, GL_LEFT,          GL_RIGHT, and          GL_FRONT_AND_BACK are accepted. The initial          value is GL_FRONT for single-buffered contexts,          and GL_BACK for double-buffered contexts. For          framebuffer objects, GL_COLOR_ATTACHMENT$m$ and          GL_NONE enums are accepted, where          $m$ is a value between 0 and          GL_MAX_COLOR_ATTACHMENTS.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffer(DrawBufferMode buf) => _DrawBuffer(buf);

        // ---

        /// <summary>
        /// glDrawBuffers and glNamedFramebufferDrawBuffers define an array of buffers into    which outputs from the fragment shader data will be written. If a fragment    shader writes a value to one or more user defined output variables, then    the value of each variable will be written into the buffer specified at a    location within bufs corresponding to the location    assigned to that user defined output. The draw buffer used for user    defined outputs assigned to locations greater than or equal to    n is implicitly set to GL_NONE    and any data written to such an output is discarded.
        /// For glDrawBuffers, the framebuffer object that    is bound to the GL_DRAW_FRAMEBUFFER binding will be    used. For glNamedFramebufferDrawBuffers,    framebuffer is the name of the framebuffer object.    If framebuffer is zero, then the default    framebuffer is affected.
        /// The symbolic constants contained in bufs may    be any of the following:
        /// GL_NONEThe fragment shader output value is not written into any color          buffer.GL_FRONT_LEFTThe fragment shader output value is written into the front          left color buffer.GL_FRONT_RIGHTThe fragment shader output value is written into the front          right color buffer.GL_BACK_LEFTThe fragment shader output value is written into the back left          color buffer.GL_BACK_RIGHTThe fragment shader output value is written into the back          right color buffer.GL_COLOR_ATTACHMENTnThe fragment shader output value is written into the          nth color attachment of the current          framebuffer. n may range from zero to the value          of GL_MAX_COLOR_ATTACHMENTS.
        /// Except for GL_NONE, the preceding symbolic    constants may not appear more than once in bufs.    The maximum number of draw buffers supported is implementation dependent    and can be queried by calling    glGet    with the argument    GL_MAX_DRAW_BUFFERS.
        /// </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for          glNamedFramebufferDrawBuffers.</param>
        /// <param name="n">Specifies the number of buffers in          bufs.</param>
        /// <param name="bufs">Points to an array of symbolic constants specifying the          buffers into which fragment colors or data values will be          written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffers(int n, DrawBufferMode[] bufs) => _DrawBuffers(n, bufs);

        /// <summary>
        /// glDrawBuffers and glNamedFramebufferDrawBuffers define an array of buffers into    which outputs from the fragment shader data will be written. If a fragment    shader writes a value to one or more user defined output variables, then    the value of each variable will be written into the buffer specified at a    location within bufs corresponding to the location    assigned to that user defined output. The draw buffer used for user    defined outputs assigned to locations greater than or equal to    n is implicitly set to GL_NONE    and any data written to such an output is discarded.
        /// For glDrawBuffers, the framebuffer object that    is bound to the GL_DRAW_FRAMEBUFFER binding will be    used. For glNamedFramebufferDrawBuffers,    framebuffer is the name of the framebuffer object.    If framebuffer is zero, then the default    framebuffer is affected.
        /// The symbolic constants contained in bufs may    be any of the following:
        /// GL_NONEThe fragment shader output value is not written into any color          buffer.GL_FRONT_LEFTThe fragment shader output value is written into the front          left color buffer.GL_FRONT_RIGHTThe fragment shader output value is written into the front          right color buffer.GL_BACK_LEFTThe fragment shader output value is written into the back left          color buffer.GL_BACK_RIGHTThe fragment shader output value is written into the back          right color buffer.GL_COLOR_ATTACHMENTnThe fragment shader output value is written into the          nth color attachment of the current          framebuffer. n may range from zero to the value          of GL_MAX_COLOR_ATTACHMENTS.
        /// Except for GL_NONE, the preceding symbolic    constants may not appear more than once in bufs.    The maximum number of draw buffers supported is implementation dependent    and can be queried by calling    glGet    with the argument    GL_MAX_DRAW_BUFFERS.
        /// </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for          glNamedFramebufferDrawBuffers.</param>
        /// <param name="n">Specifies the number of buffers in          bufs.</param>
        /// <param name="bufs">Points to an array of symbolic constants specifying the          buffers into which fragment colors or data values will be          written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffers(int n, void* bufs) => _DrawBuffers_ptr(n, bufs);

        /// <summary>
        /// glDrawBuffers and glNamedFramebufferDrawBuffers define an array of buffers into    which outputs from the fragment shader data will be written. If a fragment    shader writes a value to one or more user defined output variables, then    the value of each variable will be written into the buffer specified at a    location within bufs corresponding to the location    assigned to that user defined output. The draw buffer used for user    defined outputs assigned to locations greater than or equal to    n is implicitly set to GL_NONE    and any data written to such an output is discarded.
        /// For glDrawBuffers, the framebuffer object that    is bound to the GL_DRAW_FRAMEBUFFER binding will be    used. For glNamedFramebufferDrawBuffers,    framebuffer is the name of the framebuffer object.    If framebuffer is zero, then the default    framebuffer is affected.
        /// The symbolic constants contained in bufs may    be any of the following:
        /// GL_NONEThe fragment shader output value is not written into any color          buffer.GL_FRONT_LEFTThe fragment shader output value is written into the front          left color buffer.GL_FRONT_RIGHTThe fragment shader output value is written into the front          right color buffer.GL_BACK_LEFTThe fragment shader output value is written into the back left          color buffer.GL_BACK_RIGHTThe fragment shader output value is written into the back          right color buffer.GL_COLOR_ATTACHMENTnThe fragment shader output value is written into the          nth color attachment of the current          framebuffer. n may range from zero to the value          of GL_MAX_COLOR_ATTACHMENTS.
        /// Except for GL_NONE, the preceding symbolic    constants may not appear more than once in bufs.    The maximum number of draw buffers supported is implementation dependent    and can be queried by calling    glGet    with the argument    GL_MAX_DRAW_BUFFERS.
        /// </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for          glNamedFramebufferDrawBuffers.</param>
        /// <param name="n">Specifies the number of buffers in          bufs.</param>
        /// <param name="bufs">Points to an array of symbolic constants specifying the          buffers into which fragment colors or data values will be          written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffers(int n, IntPtr bufs) => _DrawBuffers_intptr(n, bufs);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffersARB(int n, DrawBufferMode[] bufs) => _DrawBuffersARB(n, bufs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffersARB(int n, void* bufs) => _DrawBuffersARB_ptr(n, bufs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffersARB(int n, IntPtr bufs) => _DrawBuffersARB_intptr(n, bufs);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffersATI(int n, DrawBufferMode[] bufs) => _DrawBuffersATI(n, bufs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffersATI(int n, void* bufs) => _DrawBuffersATI_ptr(n, bufs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffersATI(int n, IntPtr bufs) => _DrawBuffersATI_intptr(n, bufs);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffersEXT(int n, int[] bufs) => _DrawBuffersEXT(n, bufs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffersEXT(int n, void* bufs) => _DrawBuffersEXT_ptr(n, bufs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffersEXT(int n, IntPtr bufs) => _DrawBuffersEXT_intptr(n, bufs);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffersIndexedEXT(int n, int[] location, int[] indices) => _DrawBuffersIndexedEXT(n, location, indices);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffersIndexedEXT(int n, void* location, void* indices) => _DrawBuffersIndexedEXT_ptr(n, location, indices);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffersIndexedEXT(int n, IntPtr location, IntPtr indices) => _DrawBuffersIndexedEXT_intptr(n, location, indices);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffersNV(int n, int[] bufs) => _DrawBuffersNV(n, bufs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffersNV(int n, void* bufs) => _DrawBuffersNV_ptr(n, bufs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawBuffersNV(int n, IntPtr bufs) => _DrawBuffersNV_intptr(n, bufs);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawCommandsAddressNV(int primitiveMode, UInt64[] indirects, int[] sizes, uint count) => _DrawCommandsAddressNV(primitiveMode, indirects, sizes, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawCommandsAddressNV(int primitiveMode, void* indirects, void* sizes, uint count) => _DrawCommandsAddressNV_ptr(primitiveMode, indirects, sizes, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawCommandsAddressNV(int primitiveMode, IntPtr indirects, IntPtr sizes, uint count) => _DrawCommandsAddressNV_intptr(primitiveMode, indirects, sizes, count);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawCommandsNV(int primitiveMode, uint buffer, IntPtr[] indirects, int[] sizes, uint count) => _DrawCommandsNV(primitiveMode, buffer, indirects, sizes, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawCommandsNV(int primitiveMode, uint buffer, void* indirects, void* sizes, uint count) => _DrawCommandsNV_ptr(primitiveMode, buffer, indirects, sizes, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawCommandsNV(int primitiveMode, uint buffer, IntPtr indirects, IntPtr sizes, uint count) => _DrawCommandsNV_intptr(primitiveMode, buffer, indirects, sizes, count);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawCommandsStatesAddressNV(UInt64[] indirects, int[] sizes, uint[] states, uint[] fbos, uint count) => _DrawCommandsStatesAddressNV(indirects, sizes, states, fbos, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawCommandsStatesAddressNV(void* indirects, void* sizes, void* states, void* fbos, uint count) => _DrawCommandsStatesAddressNV_ptr(indirects, sizes, states, fbos, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawCommandsStatesAddressNV(IntPtr indirects, IntPtr sizes, IntPtr states, IntPtr fbos, uint count) => _DrawCommandsStatesAddressNV_intptr(indirects, sizes, states, fbos, count);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawCommandsStatesNV(uint buffer, IntPtr[] indirects, int[] sizes, uint[] states, uint[] fbos, uint count) => _DrawCommandsStatesNV(buffer, indirects, sizes, states, fbos, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawCommandsStatesNV(uint buffer, void* indirects, void* sizes, void* states, void* fbos, uint count) => _DrawCommandsStatesNV_ptr(buffer, indirects, sizes, states, fbos, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawCommandsStatesNV(uint buffer, IntPtr indirects, IntPtr sizes, IntPtr states, IntPtr fbos, uint count) => _DrawCommandsStatesNV_intptr(buffer, indirects, sizes, states, fbos, count);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementArrayAPPLE(PrimitiveType mode, int first, int count) => _DrawElementArrayAPPLE(mode, first, count);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementArrayATI(PrimitiveType mode, int count) => _DrawElementArrayATI(mode, count);

        // ---

        /// <summary>
        /// glDrawElements specifies multiple geometric primitives            with very few subroutine calls. Instead of calling a GL function            to pass each individual vertex, normal, texture coordinate, edge            flag, or color, you can prespecify            separate arrays of vertices, normals, and so on, and use them to            construct a sequence of primitives with a single            call to glDrawElements.
        /// When glDrawElements is called, it uses count sequential elements from an            enabled array, starting at indices to construct a sequence of            geometric primitives. mode specifies what kind of primitives are            constructed and how the array elements construct these primitives. If            more than one array is enabled, each is used.
        /// Vertex attributes that are modified by glDrawElements have an            unspecified value after glDrawElements returns.  Attributes that aren't            modified maintain their previous values.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of                    GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or                    GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElements(PrimitiveType mode, int count, DrawElementsType type, IntPtr indices) => _DrawElements(mode, count, type, indices);

        // ---

        /// <summary>
        /// glDrawElementsBaseVertex behaves identically to            glDrawElements except that the ith element            transferred by the corresponding draw call will be taken from element indices[i] + basevertex            of each enabled array. If the resulting value is larger than the maximum value representable by type,            it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions).            The operation is undefined if the sum would be negative.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP,                    GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN,                    GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE,                    GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="basevertex">Specifies a constant that should be added to each element of indices                    when chosing elements from the enabled vertex arrays.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsBaseVertex(PrimitiveType mode, int count, DrawElementsType type, IntPtr indices, int basevertex) => _DrawElementsBaseVertex(mode, count, type, indices, basevertex);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsBaseVertexEXT(PrimitiveType mode, int count, DrawElementsType type, IntPtr indices, int basevertex) => _DrawElementsBaseVertexEXT(mode, count, type, indices, basevertex);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsBaseVertexOES(PrimitiveType mode, int count, DrawElementsType type, IntPtr indices, int basevertex) => _DrawElementsBaseVertexOES(mode, count, type, indices, basevertex);

        // ---

        /// <summary>
        /// glDrawElementsIndirect specifies multiple indexed geometric primitives            with very few subroutine calls. glDrawElementsIndirect behaves            similarly to glDrawElementsInstancedBaseVertexBaseInstance,            execpt that the parameters to glDrawElementsInstancedBaseVertexBaseInstance            are stored in memory at the address given by indirect.
        /// The parameters addressed by indirect are packed into a structure            that takes the form (in C):
        /// typedef  struct {        uint  count;        uint  primCount;        uint  firstIndex;        uint  baseVertex;        uint  baseInstance;    } DrawElementsIndirectCommand;
        /// glDrawElementsIndirect is equivalent to:
        /// void glDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect) {        const DrawElementsIndirectCommand *cmd  = (const DrawElementsIndirectCommand *)indirect;        glDrawElementsInstancedBaseVertexBaseInstance(mode,                                                      cmd->count,                                                      type,                                                      cmd->firstIndex * size-of-type,                                                      cmd->primCount,                                                      cmd->baseVertex,                                                      cmd->baseInstance);    }
        /// If a buffer is bound to the GL_DRAW_INDIRECT_BUFFER binding at the time            of a call to glDrawElementsIndirect, indirect            is interpreted as an offset, in basic machine units, into that buffer and the parameter            data is read from the buffer rather than from client memory.
        /// Note that indices stored in client memory are not supported. If no buffer is bound to the            GL_ELEMENT_ARRAY_BUFFER binding, an error will be generated.
        /// The results of the operation are undefined if the reservedMustBeZero member            of the parameter structure is non-zero. However, no error is generated in this case.
        /// Vertex attributes that are modified by glDrawElementsIndirect have an            unspecified value after glDrawElementsIndirect returns. Attributes that aren't            modified remain well defined.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY, and                    GL_PATCHES                    are accepted.</param>
        /// <param name="type">Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding.</param>
        /// <param name="indirect">Specifies the address of a structure containing the draw parameters.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsIndirect(PrimitiveType mode, DrawElementsType type, IntPtr indirect) => _DrawElementsIndirect(mode, type, indirect);

        // ---

        /// <summary>
        /// glDrawElementsInstanced behaves identically to glDrawElements            except that instancecount instances of the set of elements are executed and the value of the internal counter            instanceID advances for each iteration. instanceID is an internal 32-bit integer counter            that may be read by a vertex shader as gl_InstanceID.
        /// glDrawElementsInstanced has the same effect as:                if (mode, count, or type is invalid )        generate appropriate error    else {        for (int i = 0; i < instancecount ; i++) {            instanceID = i;            glDrawElements(mode, count, type, indices);        }        instanceID = 0;    }
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE,                    GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="instancecount">Specifies the number of instances of the specified range of indices to be rendered.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsInstanced(PrimitiveType mode, int count, DrawElementsType type, IntPtr indices, int instancecount) => _DrawElementsInstanced(mode, count, type, indices, instancecount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsInstancedANGLE(PrimitiveType mode, int count, PrimitiveType type, IntPtr indices, int primcount) => _DrawElementsInstancedANGLE(mode, count, type, indices, primcount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsInstancedARB(PrimitiveType mode, int count, DrawElementsType type, IntPtr indices, int primcount) => _DrawElementsInstancedARB(mode, count, type, indices, primcount);

        // ---

        /// <summary>
        /// glDrawElementsInstancedBaseInstance behaves identically to glDrawElements            except that instancecount instances of the set of elements are executed and the value of the internal counter            instanceID advances for each iteration. instanceID is an internal 32-bit integer counter            that may be read by a vertex shader as gl_InstanceID.
        /// glDrawElementsInstancedBaseInstance has the same effect as:                if (mode, count, or type is invalid )        generate appropriate error    else {        for (int i = 0; i < instancecount ; i++) {            instanceID = i;            glDrawElements(mode, count, type, indices);        }        instanceID = 0;    }
        /// Specific vertex attributes may be classified as instanced through the use of            glVertexAttribDivisor. Instanced vertex attributes            supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex            attribute arrays is calculated as            . Note that            baseinstance does not affect the            shader-visible value of gl_InstanceID.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE,                    GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="instancecount">Specifies the number of instances of the specified range of indices to be rendered.</param>
        /// <param name="baseinstance">Specifies the base instance for use in fetching instanced vertex attributes.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsInstancedBaseInstance(PrimitiveType mode, int count, PrimitiveType type, IntPtr indices, int instancecount, uint baseinstance) => _DrawElementsInstancedBaseInstance(mode, count, type, indices, instancecount, baseinstance);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsInstancedBaseInstanceEXT(PrimitiveType mode, int count, PrimitiveType type, IntPtr indices, int instancecount, uint baseinstance) => _DrawElementsInstancedBaseInstanceEXT(mode, count, type, indices, instancecount, baseinstance);

        // ---

        /// <summary>
        /// glDrawElementsInstancedBaseVertex behaves identically to            glDrawElementsInstanced except that the ith element            transferred by the corresponding draw call will be taken from element indices[i] + basevertex            of each enabled array. If the resulting value is larger than the maximum value representable by type,            it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions).            The operation is undefined if the sum would be negative.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP,                    GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN,                    GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE,                    GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="instancecount">Specifies the number of instances of the indexed geometry that should be drawn.</param>
        /// <param name="basevertex">Specifies a constant that should be added to each element of indices                    when chosing elements from the enabled vertex arrays.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsInstancedBaseVertex(PrimitiveType mode, int count, DrawElementsType type, IntPtr indices, int instancecount, int basevertex) => _DrawElementsInstancedBaseVertex(mode, count, type, indices, instancecount, basevertex);

        // ---

        /// <summary>
        /// glDrawElementsInstancedBaseVertexBaseInstance behaves identically to            glDrawElementsInstanced except that the ith element            transferred by the corresponding draw call will be taken from element indices[i] + basevertex            of each enabled array. If the resulting value is larger than the maximum value representable by type,            it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions).            The operation is undefined if the sum would be negative.
        /// Specific vertex attributes may be classified as instanced through the use of            glVertexAttribDivisor. Instanced vertex attributes            supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex            attribute arrays is calculated as            . Note that baseinstance            does not affect the shader-visible value of            gl_InstanceID.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP,                    GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN,                    GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE,                    GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="instancecount">Specifies the number of instances of the indexed geometry that should be drawn.</param>
        /// <param name="basevertex">Specifies a constant that should be added to each element of indices                    when chosing elements from the enabled vertex arrays.</param>
        /// <param name="baseinstance">Specifies the base instance for use in fetching instanced vertex attributes.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsInstancedBaseVertexBaseInstance(PrimitiveType mode, int count, DrawElementsType type, IntPtr indices, int instancecount, int basevertex, uint baseinstance) => _DrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, instancecount, basevertex, baseinstance);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsInstancedBaseVertexBaseInstanceEXT(PrimitiveType mode, int count, DrawElementsType type, IntPtr indices, int instancecount, int basevertex, uint baseinstance) => _DrawElementsInstancedBaseVertexBaseInstanceEXT(mode, count, type, indices, instancecount, basevertex, baseinstance);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsInstancedBaseVertexEXT(PrimitiveType mode, int count, DrawElementsType type, IntPtr indices, int instancecount, int basevertex) => _DrawElementsInstancedBaseVertexEXT(mode, count, type, indices, instancecount, basevertex);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsInstancedBaseVertexOES(PrimitiveType mode, int count, DrawElementsType type, IntPtr indices, int instancecount, int basevertex) => _DrawElementsInstancedBaseVertexOES(mode, count, type, indices, instancecount, basevertex);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsInstancedEXT(PrimitiveType mode, int count, DrawElementsType type, IntPtr indices, int primcount) => _DrawElementsInstancedEXT(mode, count, type, indices, primcount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawElementsInstancedNV(PrimitiveType mode, int count, PrimitiveType type, IntPtr indices, int primcount) => _DrawElementsInstancedNV(mode, count, type, indices, primcount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawMeshArraysSUN(PrimitiveType mode, int first, int count, int width) => _DrawMeshArraysSUN(mode, first, count, width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawMeshTasksNV(uint first, uint count) => _DrawMeshTasksNV(first, count);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawMeshTasksIndirectNV(IntPtr indirect) => _DrawMeshTasksIndirectNV(indirect);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawPixels(int width, int height, PixelFormat format, PixelType type, IntPtr pixels) => _DrawPixels(width, height, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawRangeElementArrayAPPLE(PrimitiveType mode, uint start, uint end, int first, int count) => _DrawRangeElementArrayAPPLE(mode, start, end, first, count);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawRangeElementArrayATI(PrimitiveType mode, uint start, uint end, int count) => _DrawRangeElementArrayATI(mode, start, end, count);

        // ---

        /// <summary>
        /// glDrawRangeElements is a restricted form of glDrawElements. mode,            and count match the corresponding arguments to glDrawElements, with            the additional constraint that all values in the arrays count must lie            between start and end, inclusive.
        /// Implementations denote recommended maximum amounts of vertex and            index data,            which may be queried by calling glGet with argument            GL_MAX_ELEMENTS_VERTICES and GL_MAX_ELEMENTS_INDICES.            If            .
        /// GL_INVALID_OPERATION is generated if a geometry shader is active and mode            is incompatible with the input primitive type of the geometry shader in the currently installed program object.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an            enabled array or the element array and the buffer object's data store is currently mapped.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="start">Specifies the minimum array index contained in indices.</param>
        /// <param name="end">Specifies the maximum array index contained in indices.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of                    GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or                    GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawRangeElements(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, IntPtr indices) => _DrawRangeElements(mode, start, end, count, type, indices);

        // ---

        /// <summary>
        /// glDrawRangeElementsBaseVertex is a restricted form of            glDrawElementsBaseVertex. mode,            count and basevertex match            the corresponding arguments to glDrawElementsBaseVertex, with the additional            constraint that all values in the array indices must lie between start and end,            inclusive, prior to adding basevertex. Index values lying outside the range [start, end]            are treated in the same way as glDrawElementsBaseVertex. The ith element            transferred by the corresponding draw call will be taken from element indices[i] + basevertex of each enabled            array. If the resulting value is larger than the maximum value representable by type, it is as if the calculation were upconverted to            32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP,                    GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN,                    GL_TRIANGLES, GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.</param>
        /// <param name="start">Specifies the minimum array index contained in indices.</param>
        /// <param name="end">Specifies the maximum array index contained in indices.</param>
        /// <param name="count">Specifies the number of elements to be rendered.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE,                    GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="basevertex">Specifies a constant that should be added to each element of indices                    when chosing elements from the enabled vertex arrays.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawRangeElementsBaseVertex(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, IntPtr indices, int basevertex) => _DrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawRangeElementsBaseVertexEXT(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, IntPtr indices, int basevertex) => _DrawRangeElementsBaseVertexEXT(mode, start, end, count, type, indices, basevertex);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawRangeElementsBaseVertexOES(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, IntPtr indices, int basevertex) => _DrawRangeElementsBaseVertexOES(mode, start, end, count, type, indices, basevertex);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawRangeElementsEXT(PrimitiveType mode, uint start, uint end, int count, DrawElementsType type, IntPtr indices) => _DrawRangeElementsEXT(mode, start, end, count, type, indices);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexfOES(float x, float y, float z, float width, float height) => _DrawTexfOES(x, y, z, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexfvOES(float[] coords) => _DrawTexfvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexfvOES(void* coords) => _DrawTexfvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexfvOES(IntPtr coords) => _DrawTexfvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexiOES(int x, int y, int z, int width, int height) => _DrawTexiOES(x, y, z, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexivOES(int[] coords) => _DrawTexivOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexivOES(void* coords) => _DrawTexivOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexivOES(IntPtr coords) => _DrawTexivOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexsOES(short x, short y, short z, short width, short height) => _DrawTexsOES(x, y, z, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexsvOES(short[] coords) => _DrawTexsvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexsvOES(void* coords) => _DrawTexsvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexsvOES(IntPtr coords) => _DrawTexsvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTextureNV(uint texture, uint sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) => _DrawTextureNV(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexxOES(float x, float y, float z, float width, float height) => _DrawTexxOES(x, y, z, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexxvOES(float[] coords) => _DrawTexxvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexxvOES(void* coords) => _DrawTexxvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTexxvOES(IntPtr coords) => _DrawTexxvOES_intptr(coords);

        // ---

        /// <summary>
        /// glDrawTransformFeedback draws primitives of a type specified by mode using            a count retrieved from the transform feedback specified by id. Calling glDrawTransformFeedback            is equivalent to calling glDrawArrays with mode            as specified, first set to zero, and count set to the number of vertices captured            on vertex stream zero the last time transform feedback was active on the transform feedback object named by id.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY, and                    GL_PATCHES                    are accepted.</param>
        /// <param name="id">Specifies the name of a transform feedback object from which to retrieve a primitive count.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTransformFeedback(PrimitiveType mode, uint id) => _DrawTransformFeedback(mode, id);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTransformFeedbackEXT(PrimitiveType mode, uint id) => _DrawTransformFeedbackEXT(mode, id);

        // ---

        /// <summary>
        /// glDrawTransformFeedbackInstanced draws multiple copies of a range of primitives of a type specified by mode using            a count retrieved from the transform feedback stream specified by stream of the transform feedback object            specified by id. Calling glDrawTransformFeedbackInstanced            is equivalent to calling glDrawArraysInstanced with mode            and instancecount as specified, first set to zero, and count set to the number of vertices captured            on vertex stream zero the last time transform feedback was active on the transform feedback object named            by id.
        /// Calling glDrawTransformFeedbackInstanced            is equivalent to calling            glDrawTransformFeedbackStreamInstanced            with stream set to zero.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY, and                    GL_PATCHES                    are accepted.</param>
        /// <param name="id">Specifies the name of a transform feedback object from which to retrieve a primitive count.</param>
        /// <param name="instancecount">Specifies the number of instances of the geometry to render.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTransformFeedbackInstanced(PrimitiveType mode, uint id, int instancecount) => _DrawTransformFeedbackInstanced(mode, id, instancecount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTransformFeedbackInstancedEXT(PrimitiveType mode, uint id, int instancecount) => _DrawTransformFeedbackInstancedEXT(mode, id, instancecount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTransformFeedbackNV(PrimitiveType mode, uint id) => _DrawTransformFeedbackNV(mode, id);

        // ---

        /// <summary>
        /// glDrawTransformFeedbackStream draws primitives of a type specified by mode using            a count retrieved from the transform feedback stream specified by stream of the transform feedback object            specified by id. Calling glDrawTransformFeedbackStream            is equivalent to calling glDrawArrays with mode            as specified, first set to zero, and count set to the number of vertices captured            on vertex stream stream the last time transform feedback was active on the transform feedback object named            by id.
        /// Calling glDrawTransformFeedback is equivalent to calling glDrawTransformFeedbackStream            with stream set to zero.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY, and                    GL_PATCHES                    are accepted.</param>
        /// <param name="id">Specifies the name of a transform feedback object from which to retrieve a primitive count.</param>
        /// <param name="stream">Specifies the index of the transform feedback stream from which to retrieve a primitive count.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTransformFeedbackStream(PrimitiveType mode, uint id, uint stream) => _DrawTransformFeedbackStream(mode, id, stream);

        // ---

        /// <summary>
        /// glDrawTransformFeedbackStreamInstanced draws multiple copies of a range of primitives of a type specified by mode using            a count retrieved from the transform feedback stream specified by stream of the transform feedback object            specified by id. Calling glDrawTransformFeedbackStreamInstanced            is equivalent to calling glDrawArraysInstanced with mode            and instancecount as specified, first set to zero, and count set to the number of vertices captured            on vertex stream stream the last time transform feedback was active on the transform feedback object named            by id.
        /// Calling glDrawTransformFeedbackInstanced is equivalent to calling glDrawTransformFeedbackStreamInstanced            with stream set to zero.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY, and                    GL_PATCHES                    are accepted.</param>
        /// <param name="id">Specifies the name of a transform feedback object from which to retrieve a primitive count.</param>
        /// <param name="stream">Specifies the index of the transform feedback stream from which to retrieve a primitive count.</param>
        /// <param name="instancecount">Specifies the number of instances of the geometry to render.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawTransformFeedbackStreamInstanced(PrimitiveType mode, uint id, uint stream, int instancecount) => _DrawTransformFeedbackStreamInstanced(mode, id, stream, instancecount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EGLImageTargetRenderbufferStorageOES(int target, IntPtr image) => _EGLImageTargetRenderbufferStorageOES(target, image);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EGLImageTargetTexStorageEXT(int target, IntPtr image, int[] attrib_list) => _EGLImageTargetTexStorageEXT(target, image, attrib_list);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EGLImageTargetTexStorageEXT(int target, IntPtr image, void* attrib_list) => _EGLImageTargetTexStorageEXT_ptr(target, image, attrib_list);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EGLImageTargetTexStorageEXT(int target, IntPtr image, IntPtr attrib_list) => _EGLImageTargetTexStorageEXT_intptr(target, image, attrib_list);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EGLImageTargetTexture2DOES(int target, IntPtr image) => _EGLImageTargetTexture2DOES(target, image);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EGLImageTargetTextureStorageEXT(uint texture, IntPtr image, int[] attrib_list) => _EGLImageTargetTextureStorageEXT(texture, image, attrib_list);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EGLImageTargetTextureStorageEXT(uint texture, IntPtr image, void* attrib_list) => _EGLImageTargetTextureStorageEXT_ptr(texture, image, attrib_list);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EGLImageTargetTextureStorageEXT(uint texture, IntPtr image, IntPtr attrib_list) => _EGLImageTargetTextureStorageEXT_intptr(texture, image, attrib_list);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EdgeFlag(bool flag) => _EdgeFlag(flag);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EdgeFlagFormatNV(int stride) => _EdgeFlagFormatNV(stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EdgeFlagPointer(int stride, IntPtr pointer) => _EdgeFlagPointer(stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EdgeFlagPointerEXT(int stride, int count, bool[] pointer) => _EdgeFlagPointerEXT(stride, count, pointer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EdgeFlagPointerEXT(int stride, int count, void* pointer) => _EdgeFlagPointerEXT_ptr(stride, count, pointer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EdgeFlagPointerEXT(int stride, int count, IntPtr pointer) => _EdgeFlagPointerEXT_intptr(stride, count, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EdgeFlagPointerListIBM(int stride, IntPtr* pointer, int ptrstride) => _EdgeFlagPointerListIBM(stride, pointer, ptrstride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EdgeFlagv(bool[] flag) => _EdgeFlagv(flag);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EdgeFlagv(void* flag) => _EdgeFlagv_ptr(flag);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EdgeFlagv(IntPtr flag) => _EdgeFlagv_intptr(flag);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ElementPointerAPPLE(ElementPointerTypeATI type, IntPtr pointer) => _ElementPointerAPPLE(type, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ElementPointerATI(ElementPointerTypeATI type, IntPtr pointer) => _ElementPointerATI(type, pointer);

        // ---

        /// <summary>
        /// glEnable and glDisable            enable and disable various capabilities. Use            glIsEnabled            or            glGet            to determine the current setting of any capability. The initial            value for each capability with the exception of            GL_DITHER and            GL_MULTISAMPLE is            GL_FALSE. The initial value for            GL_DITHER and            GL_MULTISAMPLE is            GL_TRUE.
        /// Both glEnable and glDisable take a single argument, cap,            which can assume one of the following values:
        /// Some of the GL's capabilities are indexed. glEnablei and glDisablei enable and disable            indexed capabilities.
        /// GL_BLEND                        If enabled,                        blend the computed fragment color values with the values in the color                        buffers. See glBlendFunc.                    GL_CLIP_DISTANCEi                        If enabled, clip geometry against user-defined half space i.                    GL_COLOR_LOGIC_OP                        If enabled,                        apply the currently selected logical operation to the computed fragment                        color and color buffer values. See glLogicOp.                    GL_CULL_FACE                        If enabled,                        cull polygons based on their winding in window coordinates.                        See glCullFace.                    GL_DEBUG_OUTPUT                        If enabled, debug messages are produced by a debug context. When disabled,                        the debug message log is silenced. Note that in a non-debug context, very                        few, if any messages might be produced, even when GL_DEBUG_OUTPUT                        is enabled.                    GL_DEBUG_OUTPUT_SYNCHRONOUS                        If enabled, debug messages are produced synchronously by a debug context. If disabled,                        debug messages may be produced asynchronously. In particular, they may be delayed relative                        to the execution of GL commands, and the debug callback function may be called from                        a thread other than that in which the commands are executed.                        See glDebugMessageCallback.                    GL_DEPTH_CLAMP                        If enabled,                        the                                                                        where n is equal to 8 for GL_UNSIGNED_BYTE,                        16 for GL_UNSIGNED_SHORT and 32 for GL_UNSIGNED_INT.                    GL_RASTERIZER_DISCARD                        If enabled,                        primitives are discarded after the optional transform feedback stage,                        but before rasterization. Furthermore, when enabled, glClear,                        glClearBufferData,                        glClearBufferSubData,                        glClearTexImage, and                        glClearTexSubImage are ignored.                    GL_SAMPLE_ALPHA_TO_COVERAGE                        If enabled,                        compute a temporary coverage value where each bit is determined by the                        alpha value at the corresponding sample location.  The temporary coverage                        value is then ANDed with the fragment coverage value.                    GL_SAMPLE_ALPHA_TO_ONE                        If enabled,                        each sample alpha value is replaced by the maximum representable alpha value.                    GL_SAMPLE_COVERAGE                        If enabled,                        the fragment's coverage is ANDed with the temporary coverage value.  If                        GL_SAMPLE_COVERAGE_INVERT is set to GL_TRUE, invert the coverage                        value.                        See glSampleCoverage.                    GL_SAMPLE_SHADING                        If enabled, the active fragment shader is run once for each covered sample, or at                        fraction of this rate as determined by the current value of GL_MIN_SAMPLE_SHADING_VALUE.                        See glMinSampleShading.                    GL_SAMPLE_MASK                        If enabled, the sample coverage mask generated for a fragment during rasterization                        will be ANDed with the value of GL_SAMPLE_MASK_VALUE before                        shading occurs.                        See glSampleMaski.                    GL_SCISSOR_TEST                        If enabled,                        discard fragments that are outside the scissor rectangle.                        See glScissor.                    GL_STENCIL_TEST                        If enabled,                        do stencil testing and update the stencil buffer.                        See glStencilFunc and glStencilOp.                    GL_TEXTURE_CUBE_MAP_SEAMLESS                        If enabled, cubemap textures are sampled such that when linearly sampling from the border                        between two adjacent faces, texels from both faces are used to generate the final sample                        value. When disabled, texels from only a single face are used to construct the final                        sample value.                    GL_PROGRAM_POINT_SIZE                        If enabled                        and a vertex or geometry shader is active, then the derived point size is taken from the (potentially clipped) shader builtin                        gl_PointSize and clamped to the implementation-dependent point size range.
        /// </summary>
        /// <param name="cap">Specifies a symbolic constant indicating a GL capability.</param>
        /// <param name="index">Specifies the index of the switch to disable (for                    glEnablei and                    glDisablei only).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Enable(EnableCap cap) => _Enable(cap);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnableClientState(EnableCap array) => _EnableClientState(array);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnableClientStateIndexedEXT(EnableCap array, uint index) => _EnableClientStateIndexedEXT(array, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnableClientStateiEXT(EnableCap array, uint index) => _EnableClientStateiEXT(array, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnableDriverControlQCOM(uint driverControl) => _EnableDriverControlQCOM(driverControl);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnableIndexedEXT(EnableCap target, uint index) => _EnableIndexedEXT(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnableVariantClientStateEXT(uint id) => _EnableVariantClientStateEXT(id);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnableVertexArrayAttrib(uint vaobj, uint index) => _EnableVertexArrayAttrib(vaobj, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnableVertexArrayAttribEXT(uint vaobj, uint index) => _EnableVertexArrayAttribEXT(vaobj, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnableVertexArrayEXT(uint vaobj, EnableCap array) => _EnableVertexArrayEXT(vaobj, array);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnableVertexAttribAPPLE(uint index, int pname) => _EnableVertexAttribAPPLE(index, pname);

        // ---

        /// <summary>
        /// glEnableVertexAttribArray and    glEnableVertexArrayAttrib enable the generic vertex    attribute array specified by index.    glEnableVertexAttribArray uses currently bound vertex    array object for the operation, whereas    glEnableVertexArrayAttrib updates state of the vertex    array object with ID vaobj.
        /// glDisableVertexAttribArray and    glDisableVertexArrayAttrib disable the generic vertex    attribute array specified by index.    glDisableVertexAttribArray uses currently bound    vertex array object for the operation, whereas    glDisableVertexArrayAttrib updates state of the    vertex array object with ID vaobj.
        /// By default, all client-side capabilities are disabled, including all        generic vertex attribute arrays. If enabled, the values in the generic        vertex attribute array will be accessed and used for rendering when calls        are made to vertex array commands such as        glDrawArrays,        glDrawElements,        glDrawRangeElements,        glMultiDrawElements, or        glMultiDrawArrays.
        /// </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for          glDisableVertexArrayAttrib and          glEnableVertexArrayAttrib functions.</param>
        /// <param name="index">Specifies the index of the generic vertex attribute to be          enabled or disabled.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnableVertexAttribArray(uint index) => _EnableVertexAttribArray(index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnableVertexAttribArrayARB(uint index) => _EnableVertexAttribArrayARB(index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Enablei(EnableCap target, uint index) => _Enablei(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnableiEXT(EnableCap target, uint index) => _EnableiEXT(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnableiNV(EnableCap target, uint index) => _EnableiNV(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnableiOES(EnableCap target, uint index) => _EnableiOES(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void End() => _End();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndConditionalRender() => _EndConditionalRender();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndConditionalRenderNV() => _EndConditionalRenderNV();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndConditionalRenderNVX() => _EndConditionalRenderNVX();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndFragmentShaderATI() => _EndFragmentShaderATI();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndList() => _EndList();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndOcclusionQueryNV() => _EndOcclusionQueryNV();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndPerfMonitorAMD(uint monitor) => _EndPerfMonitorAMD(monitor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndPerfQueryINTEL(uint queryHandle) => _EndPerfQueryINTEL(queryHandle);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndQuery(QueryTarget target) => _EndQuery(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndQueryARB(QueryTarget target) => _EndQueryARB(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndQueryEXT(QueryTarget target) => _EndQueryEXT(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndQueryIndexed(QueryTarget target, uint index) => _EndQueryIndexed(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndTilingQCOM(int preserveMask) => _EndTilingQCOM(preserveMask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndTransformFeedback() => _EndTransformFeedback();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndTransformFeedbackEXT() => _EndTransformFeedbackEXT();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndTransformFeedbackNV() => _EndTransformFeedbackNV();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndVertexShaderEXT() => _EndVertexShaderEXT();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndVideoCaptureNV(uint video_capture_slot) => _EndVideoCaptureNV(video_capture_slot);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord1d(double u) => _EvalCoord1d(u);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord1dv(double[] u) => _EvalCoord1dv(u);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord1dv(void* u) => _EvalCoord1dv_ptr(u);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord1dv(IntPtr u) => _EvalCoord1dv_intptr(u);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord1f(float u) => _EvalCoord1f(u);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord1fv(float[] u) => _EvalCoord1fv(u);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord1fv(void* u) => _EvalCoord1fv_ptr(u);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord1fv(IntPtr u) => _EvalCoord1fv_intptr(u);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord1xOES(float u) => _EvalCoord1xOES(u);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord1xvOES(float[] coords) => _EvalCoord1xvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord1xvOES(void* coords) => _EvalCoord1xvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord1xvOES(IntPtr coords) => _EvalCoord1xvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord2d(double u, double v) => _EvalCoord2d(u, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord2dv(double[] u) => _EvalCoord2dv(u);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord2dv(void* u) => _EvalCoord2dv_ptr(u);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord2dv(IntPtr u) => _EvalCoord2dv_intptr(u);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord2f(float u, float v) => _EvalCoord2f(u, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord2fv(float[] u) => _EvalCoord2fv(u);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord2fv(void* u) => _EvalCoord2fv_ptr(u);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord2fv(IntPtr u) => _EvalCoord2fv_intptr(u);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord2xOES(float u, float v) => _EvalCoord2xOES(u, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord2xvOES(float[] coords) => _EvalCoord2xvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord2xvOES(void* coords) => _EvalCoord2xvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalCoord2xvOES(IntPtr coords) => _EvalCoord2xvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalMapsNV(EvalTargetNV target, EvalMapsModeNV mode) => _EvalMapsNV(target, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalMesh1(MeshMode1 mode, int i1, int i2) => _EvalMesh1(mode, i1, i2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalMesh2(MeshMode2 mode, int i1, int i2, int j1, int j2) => _EvalMesh2(mode, i1, i2, j1, j2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalPoint1(int i) => _EvalPoint1(i);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvalPoint2(int i, int j) => _EvalPoint2(i, j);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EvaluateDepthValuesARB() => _EvaluateDepthValuesARB();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExecuteProgramNV(VertexAttribEnumNV target, uint id, float[] @params) => _ExecuteProgramNV(target, id, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExecuteProgramNV(VertexAttribEnumNV target, uint id, void* @params) => _ExecuteProgramNV_ptr(target, id, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExecuteProgramNV(VertexAttribEnumNV target, uint id, IntPtr @params) => _ExecuteProgramNV_intptr(target, id, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetBufferPointervQCOM(int target, IntPtr* @params) => _ExtGetBufferPointervQCOM(target, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetBuffersQCOM(uint[] buffers, int maxBuffers, out int numBuffers) => _ExtGetBuffersQCOM(buffers, maxBuffers, out numBuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetBuffersQCOM(void* buffers, int maxBuffers, out int numBuffers) => _ExtGetBuffersQCOM_ptr(buffers, maxBuffers, out numBuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetBuffersQCOM(IntPtr buffers, int maxBuffers, out int numBuffers) => _ExtGetBuffersQCOM_intptr(buffers, maxBuffers, out numBuffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetFramebuffersQCOM(uint[] framebuffers, int maxFramebuffers, out int numFramebuffers) => _ExtGetFramebuffersQCOM(framebuffers, maxFramebuffers, out numFramebuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetFramebuffersQCOM(void* framebuffers, int maxFramebuffers, out int numFramebuffers) => _ExtGetFramebuffersQCOM_ptr(framebuffers, maxFramebuffers, out numFramebuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetFramebuffersQCOM(IntPtr framebuffers, int maxFramebuffers, out int numFramebuffers) => _ExtGetFramebuffersQCOM_intptr(framebuffers, maxFramebuffers, out numFramebuffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetProgramBinarySourceQCOM(uint program, ShaderType shadertype, string source, int[] length) => _ExtGetProgramBinarySourceQCOM(program, shadertype, source, length);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetProgramBinarySourceQCOM(uint program, ShaderType shadertype, void* source, void* length) => _ExtGetProgramBinarySourceQCOM_ptr(program, shadertype, source, length);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetProgramBinarySourceQCOM(uint program, ShaderType shadertype, IntPtr source, IntPtr length) => _ExtGetProgramBinarySourceQCOM_intptr(program, shadertype, source, length);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetProgramsQCOM(uint[] programs, int maxPrograms, out int numPrograms) => _ExtGetProgramsQCOM(programs, maxPrograms, out numPrograms);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetProgramsQCOM(void* programs, int maxPrograms, out int numPrograms) => _ExtGetProgramsQCOM_ptr(programs, maxPrograms, out numPrograms);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetProgramsQCOM(IntPtr programs, int maxPrograms, out int numPrograms) => _ExtGetProgramsQCOM_intptr(programs, maxPrograms, out numPrograms);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetRenderbuffersQCOM(uint[] renderbuffers, int maxRenderbuffers, out int numRenderbuffers) => _ExtGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, out numRenderbuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetRenderbuffersQCOM(void* renderbuffers, int maxRenderbuffers, out int numRenderbuffers) => _ExtGetRenderbuffersQCOM_ptr(renderbuffers, maxRenderbuffers, out numRenderbuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetRenderbuffersQCOM(IntPtr renderbuffers, int maxRenderbuffers, out int numRenderbuffers) => _ExtGetRenderbuffersQCOM_intptr(renderbuffers, maxRenderbuffers, out numRenderbuffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetShadersQCOM(uint[] shaders, int maxShaders, out int numShaders) => _ExtGetShadersQCOM(shaders, maxShaders, out numShaders);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetShadersQCOM(void* shaders, int maxShaders, out int numShaders) => _ExtGetShadersQCOM_ptr(shaders, maxShaders, out numShaders);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetShadersQCOM(IntPtr shaders, int maxShaders, out int numShaders) => _ExtGetShadersQCOM_intptr(shaders, maxShaders, out numShaders);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetTexLevelParameterivQCOM(uint texture, int face, int level, int pname, int[] @params) => _ExtGetTexLevelParameterivQCOM(texture, face, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetTexLevelParameterivQCOM(uint texture, int face, int level, int pname, void* @params) => _ExtGetTexLevelParameterivQCOM_ptr(texture, face, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetTexLevelParameterivQCOM(uint texture, int face, int level, int pname, IntPtr @params) => _ExtGetTexLevelParameterivQCOM_intptr(texture, face, level, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetTexSubImageQCOM(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr texels) => _ExtGetTexSubImageQCOM(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetTexturesQCOM(uint[] textures, int maxTextures, int[] numTextures) => _ExtGetTexturesQCOM(textures, maxTextures, numTextures);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetTexturesQCOM(void* textures, int maxTextures, void* numTextures) => _ExtGetTexturesQCOM_ptr(textures, maxTextures, numTextures);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtGetTexturesQCOM(IntPtr textures, int maxTextures, IntPtr numTextures) => _ExtGetTexturesQCOM_intptr(textures, maxTextures, numTextures);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ExtIsProgramBinaryQCOM(uint program) => _ExtIsProgramBinaryQCOM(program);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtTexObjectStateOverrideiQCOM(int target, int pname, int param) => _ExtTexObjectStateOverrideiQCOM(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtractComponentEXT(uint res, uint src, uint num) => _ExtractComponentEXT(res, src, num);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FeedbackBuffer(int size, FeedbackType type, float[] buffer) => _FeedbackBuffer(size, type, buffer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FeedbackBuffer(int size, FeedbackType type, void* buffer) => _FeedbackBuffer_ptr(size, type, buffer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FeedbackBuffer(int size, FeedbackType type, IntPtr buffer) => _FeedbackBuffer_intptr(size, type, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FeedbackBufferxOES(int n, int type, float[] buffer) => _FeedbackBufferxOES(n, type, buffer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FeedbackBufferxOES(int n, int type, void* buffer) => _FeedbackBufferxOES_ptr(n, type, buffer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FeedbackBufferxOES(int n, int type, IntPtr buffer) => _FeedbackBufferxOES_intptr(n, type, buffer);

        // ---

        /// <summary>
        /// glFenceSync creates a new fence sync object, inserts a fence command into the GL command stream and            associates it with that sync object, and returns a non-zero name corresponding to the sync object.
        /// When the specified condition of the sync object is satisfied by the fence command, the sync object            is signaled by the GL, causing any glWaitSync,            glClientWaitSync commands blocking in sync            to unblock. No other state is affected by glFenceSync or by the execution            of the associated fence command.
        /// condition must be GL_SYNC_GPU_COMMANDS_COMPLETE. This condition is satisfied by            completion of the fence command corresponding to the sync object and all preceding commands in the same command stream.            The sync object will not be signaled until all effects from these commands on GL client and server state and the            framebuffer are fully realized. Note that completion of the fence command occurs once the state of the corresponding sync            object has been changed, but commands waiting on that sync object may not be unblocked until after the fence command completes.
        /// </summary>
        /// <param name="condition">Specifies the condition that must be met to set the sync object's state to signaled. condition                    must be GL_SYNC_GPU_COMMANDS_COMPLETE.</param>
        /// <param name="flags">Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined                    for this operation and flags must be zero.flags is a placeholder for anticipated future extensions of fence sync object capabilities.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int FenceSync(SyncCondition condition, int flags) => _FenceSync(condition, flags);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int FenceSyncAPPLE(SyncCondition condition, int flags) => _FenceSyncAPPLE(condition, flags);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FinalCombinerInputNV(CombinerVariableNV variable, CombinerRegisterNV input, CombinerMappingNV mapping, CombinerComponentUsageNV componentUsage) => _FinalCombinerInputNV(variable, input, mapping, componentUsage);

        // ---

        /// <summary>
        /// glFinish does not return until the effects of all previously            called GL commands are complete.            Such effects include all changes to GL state,            all changes to connection state,            and all changes to the frame buffer contents.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Finish() => _Finish();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int FinishAsyncSGIX(out uint markerp) => _FinishAsyncSGIX(out markerp);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FinishFenceAPPLE(uint fence) => _FinishFenceAPPLE(fence);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FinishFenceNV(uint fence) => _FinishFenceNV(fence);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FinishObjectAPPLE(ObjectTypeAPPLE @object, int name) => _FinishObjectAPPLE(@object, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FinishTextureSUNX() => _FinishTextureSUNX();

        // ---

        /// <summary>
        /// Different GL implementations buffer commands in several different locations,            including network buffers and the graphics accelerator itself.            glFlush empties all of these buffers,            causing all issued commands to be executed as quickly as            they are accepted by the actual rendering engine.            Though this execution may not be completed in any particular            time period,            it does complete in finite time.
        /// Because any GL program might be executed over a network,            or on an accelerator that buffers commands,            all programs should call glFlush whenever they count on having            all of their previously issued commands completed.            For example,            call glFlush before waiting for user input that depends on            the generated image.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Flush() => _Flush();

        // ---

        /// <summary>
        /// glFlushMappedBufferRange indicates that            modifications have been made to a range of a mapped buffer            object. The buffer object must previously have been mapped with            the GL_MAP_FLUSH_EXPLICIT_BIT flag.
        /// offset and length            indicate the modified subrange of the mapping, in basic machine            units. The specified subrange to flush is relative to the start            of the currently mapped range of the buffer. These commands may            be called multiple times to indicate distinct subranges of the            mapping which require flushing.
        /// If a buffer range is mapped with both            GL_MAP_PERSISTENT_BIT and            GL_MAP_FLUSH_EXPLICIT_BIT set, then these            commands may be called to ensure that data written by the client            into the flushed region becomes visible to the server. Data            written to a coherent store will always become visible to the            server after an unspecified period of time.
        /// </summary>
        /// <param name="target">Specifies the target to which the buffer object is bound                    for glFlushMappedBufferRange, which                    must be one of the buffer binding targets in the                    following table:</param>
        /// <param name="buffer">Specifies the name of the buffer object for                    glFlushMappedNamedBufferRange.</param>
        /// <param name="offset">Specifies the start of the buffer subrange, in basic machine units.</param>
        /// <param name="length">Specifies the length of the buffer subrange, in basic machine units.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FlushMappedBufferRange(BufferTargetARB target, IntPtr offset, IntPtr length) => _FlushMappedBufferRange(target, offset, length);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FlushMappedBufferRangeAPPLE(BufferTargetARB target, IntPtr offset, IntPtr size) => _FlushMappedBufferRangeAPPLE(target, offset, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FlushMappedBufferRangeEXT(BufferTargetARB target, IntPtr offset, IntPtr length) => _FlushMappedBufferRangeEXT(target, offset, length);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FlushMappedNamedBufferRange(uint buffer, IntPtr offset, IntPtr length) => _FlushMappedNamedBufferRange(buffer, offset, length);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FlushMappedNamedBufferRangeEXT(uint buffer, IntPtr offset, IntPtr length) => _FlushMappedNamedBufferRangeEXT(buffer, offset, length);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FlushPixelDataRangeNV(PixelDataRangeTargetNV target) => _FlushPixelDataRangeNV(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FlushRasterSGIX() => _FlushRasterSGIX();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FlushStaticDataIBM(int target) => _FlushStaticDataIBM(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FlushVertexArrayRangeAPPLE(int length, IntPtr pointer) => _FlushVertexArrayRangeAPPLE(length, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FlushVertexArrayRangeNV() => _FlushVertexArrayRangeNV();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordFormatNV(int type, int stride) => _FogCoordFormatNV(type, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordPointer(FogPointerTypeEXT type, int stride, IntPtr pointer) => _FogCoordPointer(type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordPointerEXT(FogPointerTypeEXT type, int stride, IntPtr pointer) => _FogCoordPointerEXT(type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordPointerListIBM(FogPointerTypeIBM type, int stride, IntPtr* pointer, int ptrstride) => _FogCoordPointerListIBM(type, stride, pointer, ptrstride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordd(double coord) => _FogCoordd(coord);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoorddEXT(double coord) => _FogCoorddEXT(coord);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoorddv(double[] coord) => _FogCoorddv(coord);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoorddv(void* coord) => _FogCoorddv_ptr(coord);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoorddv(IntPtr coord) => _FogCoorddv_intptr(coord);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoorddvEXT(double[] coord) => _FogCoorddvEXT(coord);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoorddvEXT(void* coord) => _FogCoorddvEXT_ptr(coord);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoorddvEXT(IntPtr coord) => _FogCoorddvEXT_intptr(coord);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordf(float coord) => _FogCoordf(coord);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordfEXT(float coord) => _FogCoordfEXT(coord);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordfv(float[] coord) => _FogCoordfv(coord);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordfv(void* coord) => _FogCoordfv_ptr(coord);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordfv(IntPtr coord) => _FogCoordfv_intptr(coord);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordfvEXT(float[] coord) => _FogCoordfvEXT(coord);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordfvEXT(void* coord) => _FogCoordfvEXT_ptr(coord);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordfvEXT(IntPtr coord) => _FogCoordfvEXT_intptr(coord);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordhNV(float fog) => _FogCoordhNV(fog);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordhvNV(float[] fog) => _FogCoordhvNV(fog);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordhvNV(void* fog) => _FogCoordhvNV_ptr(fog);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogCoordhvNV(IntPtr fog) => _FogCoordhvNV_intptr(fog);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogFuncSGIS(int n, float[] points) => _FogFuncSGIS(n, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogFuncSGIS(int n, void* points) => _FogFuncSGIS_ptr(n, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogFuncSGIS(int n, IntPtr points) => _FogFuncSGIS_intptr(n, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Fogf(FogParameter pname, float param) => _Fogf(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Fogfv(FogParameter pname, float[] @params) => _Fogfv(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Fogfv(FogParameter pname, void* @params) => _Fogfv_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Fogfv(FogParameter pname, IntPtr @params) => _Fogfv_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Fogi(FogParameter pname, int param) => _Fogi(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Fogiv(FogParameter pname, int[] @params) => _Fogiv(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Fogiv(FogParameter pname, void* @params) => _Fogiv_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Fogiv(FogParameter pname, IntPtr @params) => _Fogiv_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Fogx(FogPName pname, float param) => _Fogx(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogxOES(FogPName pname, float param) => _FogxOES(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Fogxv(FogPName pname, float[] param) => _Fogxv(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Fogxv(FogPName pname, void* param) => _Fogxv_ptr(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Fogxv(FogPName pname, IntPtr param) => _Fogxv_intptr(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogxvOES(FogPName pname, float[] param) => _FogxvOES(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogxvOES(FogPName pname, void* param) => _FogxvOES_ptr(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FogxvOES(FogPName pname, IntPtr param) => _FogxvOES_intptr(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentColorMaterialSGIX(MaterialFace face, MaterialParameter mode) => _FragmentColorMaterialSGIX(face, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentCoverageColorNV(uint color) => _FragmentCoverageColorNV(color);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightModelfSGIX(FragmentLightModelParameterSGIX pname, float param) => _FragmentLightModelfSGIX(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightModelfvSGIX(FragmentLightModelParameterSGIX pname, float[] @params) => _FragmentLightModelfvSGIX(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightModelfvSGIX(FragmentLightModelParameterSGIX pname, void* @params) => _FragmentLightModelfvSGIX_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightModelfvSGIX(FragmentLightModelParameterSGIX pname, IntPtr @params) => _FragmentLightModelfvSGIX_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightModeliSGIX(FragmentLightModelParameterSGIX pname, int param) => _FragmentLightModeliSGIX(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightModelivSGIX(FragmentLightModelParameterSGIX pname, int[] @params) => _FragmentLightModelivSGIX(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightModelivSGIX(FragmentLightModelParameterSGIX pname, void* @params) => _FragmentLightModelivSGIX_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightModelivSGIX(FragmentLightModelParameterSGIX pname, IntPtr @params) => _FragmentLightModelivSGIX_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightfSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float param) => _FragmentLightfSGIX(light, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float[] @params) => _FragmentLightfvSGIX(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, void* @params) => _FragmentLightfvSGIX_ptr(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, IntPtr @params) => _FragmentLightfvSGIX_intptr(light, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightiSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int param) => _FragmentLightiSGIX(light, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int[] @params) => _FragmentLightivSGIX(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, void* @params) => _FragmentLightivSGIX_ptr(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, IntPtr @params) => _FragmentLightivSGIX_intptr(light, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentMaterialfSGIX(MaterialFace face, MaterialParameter pname, float param) => _FragmentMaterialfSGIX(face, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, float[] @params) => _FragmentMaterialfvSGIX(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, void* @params) => _FragmentMaterialfvSGIX_ptr(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, IntPtr @params) => _FragmentMaterialfvSGIX_intptr(face, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentMaterialiSGIX(MaterialFace face, MaterialParameter pname, int param) => _FragmentMaterialiSGIX(face, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, int[] @params) => _FragmentMaterialivSGIX(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, void* @params) => _FragmentMaterialivSGIX_ptr(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, IntPtr @params) => _FragmentMaterialivSGIX_intptr(face, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FrameTerminatorGREMEDY() => _FrameTerminatorGREMEDY();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FrameZoomSGIX(int factor) => _FrameZoomSGIX(factor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferDrawBufferEXT(uint framebuffer, DrawBufferMode mode) => _FramebufferDrawBufferEXT(framebuffer, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferDrawBuffersEXT(uint framebuffer, int n, DrawBufferMode[] bufs) => _FramebufferDrawBuffersEXT(framebuffer, n, bufs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferDrawBuffersEXT(uint framebuffer, int n, void* bufs) => _FramebufferDrawBuffersEXT_ptr(framebuffer, n, bufs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferDrawBuffersEXT(uint framebuffer, int n, IntPtr bufs) => _FramebufferDrawBuffersEXT_intptr(framebuffer, n, bufs);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferFetchBarrierEXT() => _FramebufferFetchBarrierEXT();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferFetchBarrierQCOM() => _FramebufferFetchBarrierQCOM();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferFoveationConfigQCOM(uint framebuffer, uint numLayers, uint focalPointsPerLayer, uint requestedFeatures, out uint providedFeatures) => _FramebufferFoveationConfigQCOM(framebuffer, numLayers, focalPointsPerLayer, requestedFeatures, out providedFeatures);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferFoveationParametersQCOM(uint framebuffer, uint layer, uint focalPoint, float focalX, float focalY, float gainX, float gainY, float foveaArea) => _FramebufferFoveationParametersQCOM(framebuffer, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);

        // ---

        /// <summary>
        /// glFramebufferParameteri and            glNamedFramebufferParameteri modify the            value of the parameter named pname in the            specified framebuffer object. There are no modifiable parameters            of the default draw and read framebuffer, so they are not valid            targets of these commands.
        /// For glFramebufferParameteri,             the framebuffer object is that bound to            target, which must be            GL_DRAW_FRAMEBUFFER,            GL_READ_FRAMEBUFFER or            GL_FRAMEBUFFER.            GL_FRAMEBUFFER is equivalent to            GL_DRAW_FRAMEBUFFER.
        /// For glNamedFramebufferParameteri,            framebuffer is the name of the            framebuffer object.
        /// pname specifies the parameter to be            modified. The following values are accepted:
        /// GL_FRAMEBUFFER_DEFAULT_WIDTHparam specifies the assumed with for a framebuffer object with no attachments. If a                        framebuffer has attachments then the width of those attachments is used, otherwise                        the value of GL_FRAMEBUFFER_DEFAULT_WIDTH is used for the                        framebuffer. param must be greater than or equal to zero and less than                        or equal to the value of GL_MAX_FRAMEBUFFER_WIDTH.                    GL_FRAMEBUFFER_DEFAULT_HEIGHTparam specifies the assumed height for a framebuffer object with no attachments. If a                        framebuffer has attachments then the height of those attachments is used, otherwise                        the value of GL_FRAMEBUFFER_DEFAULT_HEIGHT is used for the                        framebuffer. param must be greater than or equal to zero and less than                        or equal to the value of GL_MAX_FRAMEBUFFER_HEIGHT.                    GL_FRAMEBUFFER_DEFAULT_LAYERSparam specifies the assumed number of layers for a framebuffer object with no attachments. If a                        framebuffer has attachments then the layer count of those attachments is used, otherwise                        the value of GL_FRAMEBUFFER_DEFAULT_LAYERS is used for the                        framebuffer. param must be greater than or equal to zero and less than                        or equal to the value of GL_MAX_FRAMEBUFFER_LAYERS.                    GL_FRAMEBUFFER_DEFAULT_SAMPLESparam specifies the assumed number of samples in a framebuffer object with no attachments. If a                        framebuffer has attachments then the sample count of those attachments is used, otherwise                        the value of GL_FRAMEBUFFER_DEFAULT_SAMPLES is used for the                        framebuffer. param must be greater than or equal to zero and less than                        or equal to the value of GL_MAX_FRAMEBUFFER_SAMPLE.                    GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONSparam specifies whether the framebuffer should assume identical sample locations and                        the same number of samples for all texels in the virtual image. If param is zero,                        then the implementation may vary the position or the count of samples within the virtual image from                        pixel to pixel, otherwise it will use the same sample position and count for all pixels in the virtual image.
        /// </summary>
        /// <param name="target">Specifies the target to which the framebuffer is bound                    for glFramebufferParameteri.</param>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for                    glNamedFramebufferParameteri.</param>
        /// <param name="pname">Specifies the framebuffer parameter to be modified.</param>
        /// <param name="param">The new value for the parameter named                    pname.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferParameteri(FramebufferTarget target, FramebufferParameterName pname, int param) => _FramebufferParameteri(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferPixelLocalStorageSizeEXT(uint target, int size) => _FramebufferPixelLocalStorageSizeEXT(target, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferReadBufferEXT(uint framebuffer, ReadBufferMode mode) => _FramebufferReadBufferEXT(framebuffer, mode);

        // ---

        /// <summary>
        /// glFramebufferRenderbuffer and            glNamedFramebufferRenderbuffer attaches a            renderbuffer as one of the logical buffers of the specified            framebuffer object. Renderbuffers cannot be attached to the            default draw and read framebuffer, so they are not valid targets            of these commands.
        /// For glFramebufferRenderbuffer,             the framebuffer object is that bound to            target, which must be            GL_DRAW_FRAMEBUFFER,            GL_READ_FRAMEBUFFER or            GL_FRAMEBUFFER.            GL_FRAMEBUFFER is equivalent to            GL_DRAW_FRAMEBUFFER.
        /// For glNamedFramebufferRenderbuffer,            framebuffer is the name of the            framebuffer object.
        /// renderbuffertarget must be            GL_RENDERBUFFER.
        /// renderbuffer must be zero or the name of            an existing renderbuffer object of type            renderbuffertarget. If            renderbuffer is not zero, then the            specified renderbuffer will be used as the logical buffer            identified by attachment of the specified            framebuffer object. If renderbuffer is            zero, then the value of            renderbuffertarget is ignored.
        /// attachment specifies the logical            attachment of the framebuffer and must be            GL_COLOR_ATTACHMENTi,            GL_DEPTH_ATTACHMENT,            GL_STENCIL_ATTACHMENT or            GL_DEPTH_STENCIL_ATTACHMENT.            i in may range from zero to the value of            GL_MAX_COLOR_ATTACHMENTS minus one.            Setting attachment to the value            GL_DEPTH_STENCIL_ATTACHMENT is a special            case causing both the depth and stencil attachments of the            specified framebuffer object to be set to            renderbuffer, which should have the base            internal format GL_DEPTH_STENCIL.
        /// The value of            GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for            the specified attachment point is set to            GL_RENDERBUFFER and the value of            GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is            set to renderbuffer. All other state            values of specified attachment point are set to their default            values. No change is made to the state of the renderbuuffer            object and any previous attachment to the            attachment logical buffer of the            specified framebuffer object is broken.
        /// If renderbuffer is zero, these commands            will detach the image, if any, identified by the specified            attachment point of the specified framebuffer object. All state            values of the attachment point are set to their default values.
        /// </summary>
        /// <param name="target">Specifies the target to which the framebuffer is bound                    for glFramebufferRenderbuffer.</param>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for                    glNamedFramebufferRenderbuffer.</param>
        /// <param name="attachment">Specifies the attachment point of the framebuffer.</param>
        /// <param name="renderbuffertarget">Specifies the renderbuffer target. Must be                    GL_RENDERBUFFER.</param>
        /// <param name="renderbuffer">Specifies the name of an existing renderbuffer object of                    type renderbuffertarget to                    attach.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferRenderbuffer(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, uint renderbuffer) => _FramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferRenderbufferEXT(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, uint renderbuffer) => _FramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferRenderbufferOES(FramebufferTarget target, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, uint renderbuffer) => _FramebufferRenderbufferOES(target, attachment, renderbuffertarget, renderbuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferSampleLocationsfvARB(FramebufferTarget target, uint start, int count, float[] v) => _FramebufferSampleLocationsfvARB(target, start, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferSampleLocationsfvARB(FramebufferTarget target, uint start, int count, void* v) => _FramebufferSampleLocationsfvARB_ptr(target, start, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferSampleLocationsfvARB(FramebufferTarget target, uint start, int count, IntPtr v) => _FramebufferSampleLocationsfvARB_intptr(target, start, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferSampleLocationsfvNV(FramebufferTarget target, uint start, int count, float[] v) => _FramebufferSampleLocationsfvNV(target, start, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferSampleLocationsfvNV(FramebufferTarget target, uint start, int count, void* v) => _FramebufferSampleLocationsfvNV_ptr(target, start, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferSampleLocationsfvNV(FramebufferTarget target, uint start, int count, IntPtr v) => _FramebufferSampleLocationsfvNV_intptr(target, start, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferSamplePositionsfvAMD(FramebufferTarget target, uint numsamples, uint pixelindex, float[] values) => _FramebufferSamplePositionsfvAMD(target, numsamples, pixelindex, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferSamplePositionsfvAMD(FramebufferTarget target, uint numsamples, uint pixelindex, void* values) => _FramebufferSamplePositionsfvAMD_ptr(target, numsamples, pixelindex, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferSamplePositionsfvAMD(FramebufferTarget target, uint numsamples, uint pixelindex, IntPtr values) => _FramebufferSamplePositionsfvAMD_intptr(target, numsamples, pixelindex, values);

        // ---

        /// <summary>
        /// These commands attach a selected mipmap level or image of a            texture object as one of the logical buffers of the specified            framebuffer object. Textures cannot be attached to the default            draw and read framebuffer, so they are not valid targets of            these commands.
        /// For all commands exceptglNamedFramebufferTexture, the framebuffer            object is that bound to target, which            must be GL_DRAW_FRAMEBUFFER,            GL_READ_FRAMEBUFFER, or            GL_FRAMEBUFFER.            GL_FRAMEBUFFER is equivalent to            GL_DRAW_FRAMEBUFFER.
        /// For glNamedFramebufferTexture,            framebuffer is the name of the            framebuffer object.
        /// attachment specifies the logical            attachment of the framebuffer and must be            GL_COLOR_ATTACHMENTi,            GL_DEPTH_ATTACHMENT,            GL_STENCIL_ATTACHMENT or            GL_DEPTH_STENCIL_ATTACHMENT.            i in            GL_COLOR_ATTACHMENTi            may range from zero to the value of            GL_MAX_COLOR_ATTACHMENTS minus one.            Attaching a level of a texture to            GL_DEPTH_STENCIL_ATTACHMENT is equivalent            to attaching that level to both the            GL_DEPTH_ATTACHMENTand the            GL_STENCIL_ATTACHMENT attachment points            simultaneously.
        /// For glFramebufferTexture1D,            glFramebufferTexture2D and            glFramebufferTexture3D,            textarget specifies what type of texture            is named by texture, and for cube map            textures, specifies the face that is to be attached. If            texture is not zero, it must be the name            of an existing texture object with effective target            textarget unless it is a cube map            texture, in which case textarget must be            GL_TEXTURE_CUBE_MAP_POSITIVE_XGL_TEXTURE_CUBE_MAP_NEGATIVE_X,            GL_TEXTURE_CUBE_MAP_POSITIVE_Y,            GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,            GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or            GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// If texture is non-zero, the specified            level of the texture object named            texture is attached to the framebfufer            attachment point named by attachment. For            glFramebufferTexture1D,            glFramebufferTexture2D, and            glFramebufferTexture3D,            texture must be zero or the name of an            existing texture with an effective target of            textarget, or            texture must be the name of an existing            cube-map texture and textarget must be            one of GL_TEXTURE_CUBE_MAP_POSITIVE_X,            GL_TEXTURE_CUBE_MAP_POSITIVE_Y,            GL_TEXTURE_CUBE_MAP_POSITIVE_Z,            GL_TEXTURE_CUBE_MAP_NEGATIVE_X,            GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, or            GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// If textarget is            GL_TEXTURE_RECTANGLE,            GL_TEXTURE_2D_MULTISAMPLE, or            GL_TEXTURE_2D_MULTISAMPLE_ARRAY, then            level must be zero.
        /// If textarget is            GL_TEXTURE_3D, then            level must be greater than or equal to            zero and less than or equal to $log_2$ of the value of            GL_MAX_3D_TEXTURE_SIZE.
        /// If textarget is one of            GL_TEXTURE_CUBE_MAP_POSITIVE_X,            GL_TEXTURE_CUBE_MAP_POSITIVE_Y,            GL_TEXTURE_CUBE_MAP_POSITIVE_Z,            GL_TEXTURE_CUBE_MAP_NEGATIVE_X,            GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, or            GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, then            level must be greater than or equal to            zero and less than or equal to $log_2$ of the value of            GL_MAX_CUBE_MAP_TEXTURE_SIZE.
        /// For all other values of textarget,            level must be greater than or equal to            zero and less than or equal to $log_2$ of the value of            GL_MAX_TEXTURE_SIZE.
        /// layer specifies the layer of a            2-dimensional image within a 3-dimensional texture.
        /// For glFramebufferTexture1D, if            texture is not zero, then            textarget must be            GL_TEXTURE_1D. For            glFramebufferTexture2D, if            texture is not zero,            textarget must be one of            GL_TEXTURE_2D,            GL_TEXTURE_RECTANGLE,            GL_TEXTURE_CUBE_MAP_POSITIVE_X,            GL_TEXTURE_CUBE_MAP_POSITIVE_Y,            GL_TEXTURE_CUBE_MAP_POSITIVE_Z,            GL_TEXTURE_CUBE_MAP_NEGATIVE_X,            GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,            GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or            GL_TEXTURE_2D_MULTISAMPLE. For            glFramebufferTexture3D, if            texture is not zero, then            textarget must be            GL_TEXTURE_3D.
        /// For glFramebufferTexture and            glNamedFramebufferTexture, if            texture is the name of a            three-dimensional, cube map array, cube map, one- or            two-dimensional array, or two-dimensional multisample array            texture, the specified texture level is an array of images, and            the framebuffer attachment is considered to be            layered.
        /// </summary>
        /// <param name="target">Specifies the target to which the framebuffer is bound                    for all commands exceptglNamedFramebufferTexture.</param>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for                    glNamedFramebufferTexture.</param>
        /// <param name="attachment">Specifies the attachment point of the framebuffer.</param>
        /// <param name="textarget">For glFramebufferTexture1D,                    glFramebufferTexture2D and                    glFramebufferTexture3D, specifies                    what type of texture is expected in the                    texture parameter, or for cube                    map textures, which face is to be attached.</param>
        /// <param name="texture">Specifies the name of an existing texture object to                    attach.</param>
        /// <param name="level">Specifies the mipmap level of the texture object to                    attach.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTexture(FramebufferTarget target, FramebufferAttachment attachment, uint texture, int level) => _FramebufferTexture(target, attachment, texture, level);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTexture1D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, uint texture, int level) => _FramebufferTexture1D(target, attachment, textarget, texture, level);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTexture1DEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, uint texture, int level) => _FramebufferTexture1DEXT(target, attachment, textarget, texture, level);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTexture2D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, uint texture, int level) => _FramebufferTexture2D(target, attachment, textarget, texture, level);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTexture2DEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, uint texture, int level) => _FramebufferTexture2DEXT(target, attachment, textarget, texture, level);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTexture2DDownsampleIMG(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, uint texture, int level, int xscale, int yscale) => _FramebufferTexture2DDownsampleIMG(target, attachment, textarget, texture, level, xscale, yscale);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTexture2DMultisampleEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, uint texture, int level, int samples) => _FramebufferTexture2DMultisampleEXT(target, attachment, textarget, texture, level, samples);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTexture2DMultisampleIMG(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, uint texture, int level, int samples) => _FramebufferTexture2DMultisampleIMG(target, attachment, textarget, texture, level, samples);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTexture2DOES(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, uint texture, int level) => _FramebufferTexture2DOES(target, attachment, textarget, texture, level);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTexture3D(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, uint texture, int level, int zoffset) => _FramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTexture3DEXT(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, uint texture, int level, int zoffset) => _FramebufferTexture3DEXT(target, attachment, textarget, texture, level, zoffset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTexture3DOES(FramebufferTarget target, FramebufferAttachment attachment, TextureTarget textarget, uint texture, int level, int zoffset) => _FramebufferTexture3DOES(target, attachment, textarget, texture, level, zoffset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTextureARB(FramebufferTarget target, FramebufferAttachment attachment, uint texture, int level) => _FramebufferTextureARB(target, attachment, texture, level);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTextureEXT(FramebufferTarget target, FramebufferAttachment attachment, uint texture, int level) => _FramebufferTextureEXT(target, attachment, texture, level);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTextureFaceARB(FramebufferTarget target, FramebufferAttachment attachment, uint texture, int level, TextureTarget face) => _FramebufferTextureFaceARB(target, attachment, texture, level, face);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTextureFaceEXT(FramebufferTarget target, FramebufferAttachment attachment, uint texture, int level, TextureTarget face) => _FramebufferTextureFaceEXT(target, attachment, texture, level, face);

        // ---

        /// <summary>
        /// glFramebufferTextureLayer and            glNamedFramebufferTextureLayer attach a            single layer of a three-dimensional or array texture object as            one of the logical buffers of the specified framebuffer object.            Textures cannot be attached to the default draw and read            framebuffer, so they are not valid targets of these commands.
        /// For            glFramebufferTextureLayer, the framebuffer            object is that bound to target, which            must be GL_DRAW_FRAMEBUFFER,            GL_READ_FRAMEBUFFER, or            GL_FRAMEBUFFER.            GL_FRAMEBUFFER is equivalent to            GL_DRAW_FRAMEBUFFER.
        /// For glNamedFramebufferTextureLayer,            framebuffer is the name of the            framebuffer object.
        /// attachment specifies the logical            attachment of the framebuffer and must be            GL_COLOR_ATTACHMENTi,            GL_DEPTH_ATTACHMENT,            GL_STENCIL_ATTACHMENT or            GL_DEPTH_STENCIL_ATTACHMENT.            i in            GL_COLOR_ATTACHMENTi            may range from zero to the value of            GL_MAX_COLOR_ATTACHMENTS minus one.            Attaching a level of a texture to            GL_DEPTH_STENCIL_ATTACHMENT is equivalent            to attaching that level to both the            GL_DEPTH_ATTACHMENTand the            GL_STENCIL_ATTACHMENT attachment points            simultaneously.
        /// If texture is not zero, it must be the            name of a three-dimensional, two-dimensional multisample array,            one- or two-dimensional array, or cube map array texture.
        /// If texture is a three-dimensional            texture, then level must be greater than            or equal to zero and less than or equal to $log_2$ of the value            of GL_MAX_3D_TEXTURE_SIZE.
        /// If texture is a two-dimensional array            texture, then level must be greater than            or equal to zero and less than or equal to $log_2$ of the value            of GL_MAX_TEXTURE_SIZE.
        /// For cube map textures, layer is            translated into a cube map face according to                $$ face = k \bmod 6. $$            For cube map array textures, layer is            translated into an array layer and face according to                $$ layer = \left\lfloor { layer \over 6 } \right\rfloor$$            and                $$ face = k \bmod 6. $$
        /// </summary>
        /// <param name="target">Specifies the target to which the framebuffer is bound                    for glFramebufferTextureLayer.</param>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for                    glNamedFramebufferTextureLayer.</param>
        /// <param name="attachment">Specifies the attachment point of the framebuffer.</param>
        /// <param name="texture">Specifies the name of an existing texture object to                    attach.</param>
        /// <param name="level">Specifies the mipmap level of the texture object to                    attach.</param>
        /// <param name="layer">Specifies the layer of the texture object to                    attach.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTextureLayer(FramebufferTarget target, FramebufferAttachment attachment, uint texture, int level, int layer) => _FramebufferTextureLayer(target, attachment, texture, level, layer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTextureLayerARB(FramebufferTarget target, FramebufferAttachment attachment, uint texture, int level, int layer) => _FramebufferTextureLayerARB(target, attachment, texture, level, layer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTextureLayerEXT(FramebufferTarget target, FramebufferAttachment attachment, uint texture, int level, int layer) => _FramebufferTextureLayerEXT(target, attachment, texture, level, layer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTextureLayerDownsampleIMG(FramebufferTarget target, FramebufferAttachment attachment, uint texture, int level, int layer, int xscale, int yscale) => _FramebufferTextureLayerDownsampleIMG(target, attachment, texture, level, layer, xscale, yscale);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTextureMultisampleMultiviewOVR(FramebufferTarget target, FramebufferAttachment attachment, uint texture, int level, int samples, int baseViewIndex, int numViews) => _FramebufferTextureMultisampleMultiviewOVR(target, attachment, texture, level, samples, baseViewIndex, numViews);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTextureMultiviewOVR(FramebufferTarget target, FramebufferAttachment attachment, uint texture, int level, int baseViewIndex, int numViews) => _FramebufferTextureMultiviewOVR(target, attachment, texture, level, baseViewIndex, numViews);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferTextureOES(FramebufferTarget target, FramebufferAttachment attachment, uint texture, int level) => _FramebufferTextureOES(target, attachment, texture, level);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FreeObjectBufferATI(uint buffer) => _FreeObjectBufferATI(buffer);

        // ---

        /// <summary>
        /// In a scene composed entirely of opaque closed surfaces,            back-facing polygons are never visible.            Eliminating these invisible polygons has the obvious benefit            of speeding up the rendering of the image.            To enable and disable elimination of back-facing polygons, call glEnable            and glDisable with argument GL_CULL_FACE.
        /// The projection of a polygon to window coordinates is said to have            clockwise winding if an imaginary object following the path            from its first vertex,            its second vertex,            and so on,            to its last vertex,            and finally back to its first vertex,            moves in a clockwise direction about the interior of the polygon.            The polygon's winding is said to be counterclockwise if the imaginary            object following the same path moves in a counterclockwise direction            about the interior of the polygon.            glFrontFace specifies whether polygons with clockwise winding in window coordinates,            or counterclockwise winding in window coordinates,            are taken to be front-facing.            Passing GL_CCW to mode selects counterclockwise polygons as            front-facing;            GL_CW selects clockwise polygons as front-facing.            By default, counterclockwise polygons are taken to be front-facing.
        /// </summary>
        /// <param name="mode">Specifies the orientation of front-facing polygons.                    GL_CW and GL_CCW are accepted.                    The initial value is GL_CCW.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FrontFace(FrontFaceDirection mode) => _FrontFace(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Frustum(double left, double right, double bottom, double top, double zNear, double zFar) => _Frustum(left, right, bottom, top, zNear, zFar);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Frustumf(float l, float r, float b, float t, float n, float f) => _Frustumf(l, r, b, t, n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FrustumfOES(float l, float r, float b, float t, float n, float f) => _FrustumfOES(l, r, b, t, n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Frustumx(float l, float r, float b, float t, float n, float f) => _Frustumx(l, r, b, t, n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FrustumxOES(float l, float r, float b, float t, float n, float f) => _FrustumxOES(l, r, b, t, n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GenAsyncMarkersSGIX(int range) => _GenAsyncMarkersSGIX(range);

        // ---

        /// <summary>
        /// glGenBuffers returns n buffer object names in buffers.            There is no guarantee that the names form a contiguous set of integers;            however, it is guaranteed that none of the returned names was in use            immediately before the call to glGenBuffers.
        /// Buffer object names returned by a call to glGenBuffers are not returned by            subsequent calls, unless they are first deleted with            glDeleteBuffers.
        /// No buffer objects are associated with the returned buffer object names until they are first bound by calling            glBindBuffer.
        /// </summary>
        /// <param name="n">Specifies the number of buffer object names to be generated.</param>
        /// <param name="buffers">Specifies an array in which the generated buffer object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenBuffers(int n, uint[] buffers) => _GenBuffers(n, buffers);

        /// <summary>
        /// glGenBuffers returns n buffer object names in buffers.            There is no guarantee that the names form a contiguous set of integers;            however, it is guaranteed that none of the returned names was in use            immediately before the call to glGenBuffers.
        /// Buffer object names returned by a call to glGenBuffers are not returned by            subsequent calls, unless they are first deleted with            glDeleteBuffers.
        /// No buffer objects are associated with the returned buffer object names until they are first bound by calling            glBindBuffer.
        /// </summary>
        /// <param name="n">Specifies the number of buffer object names to be generated.</param>
        /// <param name="buffers">Specifies an array in which the generated buffer object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenBuffers(int n, void* buffers) => _GenBuffers_ptr(n, buffers);

        /// <summary>
        /// glGenBuffers returns n buffer object names in buffers.            There is no guarantee that the names form a contiguous set of integers;            however, it is guaranteed that none of the returned names was in use            immediately before the call to glGenBuffers.
        /// Buffer object names returned by a call to glGenBuffers are not returned by            subsequent calls, unless they are first deleted with            glDeleteBuffers.
        /// No buffer objects are associated with the returned buffer object names until they are first bound by calling            glBindBuffer.
        /// </summary>
        /// <param name="n">Specifies the number of buffer object names to be generated.</param>
        /// <param name="buffers">Specifies an array in which the generated buffer object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenBuffers(int n, IntPtr buffers) => _GenBuffers_intptr(n, buffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenBuffersARB(int n, uint[] buffers) => _GenBuffersARB(n, buffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenBuffersARB(int n, void* buffers) => _GenBuffersARB_ptr(n, buffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenBuffersARB(int n, IntPtr buffers) => _GenBuffersARB_intptr(n, buffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenFencesAPPLE(int n, uint[] fences) => _GenFencesAPPLE(n, fences);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenFencesAPPLE(int n, void* fences) => _GenFencesAPPLE_ptr(n, fences);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenFencesAPPLE(int n, IntPtr fences) => _GenFencesAPPLE_intptr(n, fences);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenFencesNV(int n, uint[] fences) => _GenFencesNV(n, fences);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenFencesNV(int n, void* fences) => _GenFencesNV_ptr(n, fences);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenFencesNV(int n, IntPtr fences) => _GenFencesNV_intptr(n, fences);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GenFragmentShadersATI(uint range) => _GenFragmentShadersATI(range);

        // ---

        /// <summary>
        /// glGenFramebuffers returns n framebuffer object names in ids.            There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names            was in use immediately before the call to glGenFramebuffers.
        /// Framebuffer object names returned by a call to glGenFramebuffers are not returned by subsequent calls, unless            they are first deleted with glDeleteFramebuffers.
        /// The names returned in ids are marked as used, for the purposes of glGenFramebuffers only,            but they acquire state and type only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of framebuffer object names to generate.</param>
        /// <param name="ids">Specifies an array in which the generated framebuffer object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenFramebuffers(int n, uint[] framebuffers) => _GenFramebuffers(n, framebuffers);

        /// <summary>
        /// glGenFramebuffers returns n framebuffer object names in ids.            There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names            was in use immediately before the call to glGenFramebuffers.
        /// Framebuffer object names returned by a call to glGenFramebuffers are not returned by subsequent calls, unless            they are first deleted with glDeleteFramebuffers.
        /// The names returned in ids are marked as used, for the purposes of glGenFramebuffers only,            but they acquire state and type only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of framebuffer object names to generate.</param>
        /// <param name="ids">Specifies an array in which the generated framebuffer object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenFramebuffers(int n, void* framebuffers) => _GenFramebuffers_ptr(n, framebuffers);

        /// <summary>
        /// glGenFramebuffers returns n framebuffer object names in ids.            There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names            was in use immediately before the call to glGenFramebuffers.
        /// Framebuffer object names returned by a call to glGenFramebuffers are not returned by subsequent calls, unless            they are first deleted with glDeleteFramebuffers.
        /// The names returned in ids are marked as used, for the purposes of glGenFramebuffers only,            but they acquire state and type only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of framebuffer object names to generate.</param>
        /// <param name="ids">Specifies an array in which the generated framebuffer object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenFramebuffers(int n, IntPtr framebuffers) => _GenFramebuffers_intptr(n, framebuffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenFramebuffersEXT(int n, uint[] framebuffers) => _GenFramebuffersEXT(n, framebuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenFramebuffersEXT(int n, void* framebuffers) => _GenFramebuffersEXT_ptr(n, framebuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenFramebuffersEXT(int n, IntPtr framebuffers) => _GenFramebuffersEXT_intptr(n, framebuffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenFramebuffersOES(int n, uint[] framebuffers) => _GenFramebuffersOES(n, framebuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenFramebuffersOES(int n, void* framebuffers) => _GenFramebuffersOES_ptr(n, framebuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenFramebuffersOES(int n, IntPtr framebuffers) => _GenFramebuffersOES_intptr(n, framebuffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GenLists(int range) => _GenLists(range);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenNamesAMD(int identifier, uint num, uint[] names) => _GenNamesAMD(identifier, num, names);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenNamesAMD(int identifier, uint num, void* names) => _GenNamesAMD_ptr(identifier, num, names);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenNamesAMD(int identifier, uint num, IntPtr names) => _GenNamesAMD_intptr(identifier, num, names);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenOcclusionQueriesNV(int n, uint[] ids) => _GenOcclusionQueriesNV(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenOcclusionQueriesNV(int n, void* ids) => _GenOcclusionQueriesNV_ptr(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenOcclusionQueriesNV(int n, IntPtr ids) => _GenOcclusionQueriesNV_intptr(n, ids);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GenPathsNV(int range) => _GenPathsNV(range);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenPerfMonitorsAMD(int n, uint[] monitors) => _GenPerfMonitorsAMD(n, monitors);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenPerfMonitorsAMD(int n, void* monitors) => _GenPerfMonitorsAMD_ptr(n, monitors);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenPerfMonitorsAMD(int n, IntPtr monitors) => _GenPerfMonitorsAMD_intptr(n, monitors);

        // ---

        /// <summary>
        /// glGenProgramPipelines returns n previously unused            program pipeline object names in pipelines. These names are marked as used,            for the purposes of glGenProgramPipelines only, but they            acquire program pipeline state only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of program pipeline object names to reserve.</param>
        /// <param name="pipelines">Specifies an array of into which the reserved names will be written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenProgramPipelines(int n, uint[] pipelines) => _GenProgramPipelines(n, pipelines);

        /// <summary>
        /// glGenProgramPipelines returns n previously unused            program pipeline object names in pipelines. These names are marked as used,            for the purposes of glGenProgramPipelines only, but they            acquire program pipeline state only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of program pipeline object names to reserve.</param>
        /// <param name="pipelines">Specifies an array of into which the reserved names will be written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenProgramPipelines(int n, void* pipelines) => _GenProgramPipelines_ptr(n, pipelines);

        /// <summary>
        /// glGenProgramPipelines returns n previously unused            program pipeline object names in pipelines. These names are marked as used,            for the purposes of glGenProgramPipelines only, but they            acquire program pipeline state only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of program pipeline object names to reserve.</param>
        /// <param name="pipelines">Specifies an array of into which the reserved names will be written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenProgramPipelines(int n, IntPtr pipelines) => _GenProgramPipelines_intptr(n, pipelines);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenProgramPipelinesEXT(int n, uint[] pipelines) => _GenProgramPipelinesEXT(n, pipelines);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenProgramPipelinesEXT(int n, void* pipelines) => _GenProgramPipelinesEXT_ptr(n, pipelines);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenProgramPipelinesEXT(int n, IntPtr pipelines) => _GenProgramPipelinesEXT_intptr(n, pipelines);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenProgramsARB(int n, uint[] programs) => _GenProgramsARB(n, programs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenProgramsARB(int n, void* programs) => _GenProgramsARB_ptr(n, programs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenProgramsARB(int n, IntPtr programs) => _GenProgramsARB_intptr(n, programs);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenProgramsNV(int n, uint[] programs) => _GenProgramsNV(n, programs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenProgramsNV(int n, void* programs) => _GenProgramsNV_ptr(n, programs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenProgramsNV(int n, IntPtr programs) => _GenProgramsNV_intptr(n, programs);

        // ---

        /// <summary>
        /// glGenQueries returns n query object names in ids.            There is no guarantee that the names form a contiguous set of integers;            however, it is guaranteed that none of the returned names was in use            immediately before the call to glGenQueries.
        /// Query object names returned by a call to glGenQueries are not returned by            subsequent calls, unless they are first deleted with            glDeleteQueries.
        /// No query objects are associated with the returned query object names until they are first used by calling            glBeginQuery.
        /// </summary>
        /// <param name="n">Specifies the number of query object names to be generated.</param>
        /// <param name="ids">Specifies an array in which the generated query object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenQueries(int n, uint[] ids) => _GenQueries(n, ids);

        /// <summary>
        /// glGenQueries returns n query object names in ids.            There is no guarantee that the names form a contiguous set of integers;            however, it is guaranteed that none of the returned names was in use            immediately before the call to glGenQueries.
        /// Query object names returned by a call to glGenQueries are not returned by            subsequent calls, unless they are first deleted with            glDeleteQueries.
        /// No query objects are associated with the returned query object names until they are first used by calling            glBeginQuery.
        /// </summary>
        /// <param name="n">Specifies the number of query object names to be generated.</param>
        /// <param name="ids">Specifies an array in which the generated query object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenQueries(int n, void* ids) => _GenQueries_ptr(n, ids);

        /// <summary>
        /// glGenQueries returns n query object names in ids.            There is no guarantee that the names form a contiguous set of integers;            however, it is guaranteed that none of the returned names was in use            immediately before the call to glGenQueries.
        /// Query object names returned by a call to glGenQueries are not returned by            subsequent calls, unless they are first deleted with            glDeleteQueries.
        /// No query objects are associated with the returned query object names until they are first used by calling            glBeginQuery.
        /// </summary>
        /// <param name="n">Specifies the number of query object names to be generated.</param>
        /// <param name="ids">Specifies an array in which the generated query object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenQueries(int n, IntPtr ids) => _GenQueries_intptr(n, ids);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenQueriesARB(int n, uint[] ids) => _GenQueriesARB(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenQueriesARB(int n, void* ids) => _GenQueriesARB_ptr(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenQueriesARB(int n, IntPtr ids) => _GenQueriesARB_intptr(n, ids);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenQueriesEXT(int n, uint[] ids) => _GenQueriesEXT(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenQueriesEXT(int n, void* ids) => _GenQueriesEXT_ptr(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenQueriesEXT(int n, IntPtr ids) => _GenQueriesEXT_intptr(n, ids);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenQueryResourceTagNV(int n, int[] tagIds) => _GenQueryResourceTagNV(n, tagIds);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenQueryResourceTagNV(int n, void* tagIds) => _GenQueryResourceTagNV_ptr(n, tagIds);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenQueryResourceTagNV(int n, IntPtr tagIds) => _GenQueryResourceTagNV_intptr(n, tagIds);

        // ---

        /// <summary>
        /// glGenRenderbuffers returns n renderbuffer object names in renderbuffers.            There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names            was in use immediately before the call to glGenRenderbuffers.
        /// Renderbuffer object names returned by a call to glGenRenderbuffers are not returned by subsequent calls, unless            they are first deleted with glDeleteRenderbuffers.
        /// The names returned in renderbuffers are marked as used, for the purposes of glGenRenderbuffers only,            but they acquire state and type only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of renderbuffer object names to generate.</param>
        /// <param name="renderbuffers">Specifies an array in which the generated renderbuffer object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenRenderbuffers(int n, uint[] renderbuffers) => _GenRenderbuffers(n, renderbuffers);

        /// <summary>
        /// glGenRenderbuffers returns n renderbuffer object names in renderbuffers.            There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names            was in use immediately before the call to glGenRenderbuffers.
        /// Renderbuffer object names returned by a call to glGenRenderbuffers are not returned by subsequent calls, unless            they are first deleted with glDeleteRenderbuffers.
        /// The names returned in renderbuffers are marked as used, for the purposes of glGenRenderbuffers only,            but they acquire state and type only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of renderbuffer object names to generate.</param>
        /// <param name="renderbuffers">Specifies an array in which the generated renderbuffer object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenRenderbuffers(int n, void* renderbuffers) => _GenRenderbuffers_ptr(n, renderbuffers);

        /// <summary>
        /// glGenRenderbuffers returns n renderbuffer object names in renderbuffers.            There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names            was in use immediately before the call to glGenRenderbuffers.
        /// Renderbuffer object names returned by a call to glGenRenderbuffers are not returned by subsequent calls, unless            they are first deleted with glDeleteRenderbuffers.
        /// The names returned in renderbuffers are marked as used, for the purposes of glGenRenderbuffers only,            but they acquire state and type only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of renderbuffer object names to generate.</param>
        /// <param name="renderbuffers">Specifies an array in which the generated renderbuffer object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenRenderbuffers(int n, IntPtr renderbuffers) => _GenRenderbuffers_intptr(n, renderbuffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenRenderbuffersEXT(int n, uint[] renderbuffers) => _GenRenderbuffersEXT(n, renderbuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenRenderbuffersEXT(int n, void* renderbuffers) => _GenRenderbuffersEXT_ptr(n, renderbuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenRenderbuffersEXT(int n, IntPtr renderbuffers) => _GenRenderbuffersEXT_intptr(n, renderbuffers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenRenderbuffersOES(int n, uint[] renderbuffers) => _GenRenderbuffersOES(n, renderbuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenRenderbuffersOES(int n, void* renderbuffers) => _GenRenderbuffersOES_ptr(n, renderbuffers);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenRenderbuffersOES(int n, IntPtr renderbuffers) => _GenRenderbuffersOES_intptr(n, renderbuffers);

        // ---

        /// <summary>
        /// glGenSamplers returns n sampler object names in samplers.            There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names            was in use immediately before the call to glGenSamplers.
        /// Sampler object names returned by a call to glGenSamplers are not returned by subsequent calls, unless            they are first deleted with glDeleteSamplers.
        /// The names returned in samplers are marked as used, for the purposes of glGenSamplers only,            but they acquire state and type only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of sampler object names to generate.</param>
        /// <param name="samplers">Specifies an array in which the generated sampler object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenSamplers(int count, uint[] samplers) => _GenSamplers(count, samplers);

        /// <summary>
        /// glGenSamplers returns n sampler object names in samplers.            There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names            was in use immediately before the call to glGenSamplers.
        /// Sampler object names returned by a call to glGenSamplers are not returned by subsequent calls, unless            they are first deleted with glDeleteSamplers.
        /// The names returned in samplers are marked as used, for the purposes of glGenSamplers only,            but they acquire state and type only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of sampler object names to generate.</param>
        /// <param name="samplers">Specifies an array in which the generated sampler object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenSamplers(int count, void* samplers) => _GenSamplers_ptr(count, samplers);

        /// <summary>
        /// glGenSamplers returns n sampler object names in samplers.            There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names            was in use immediately before the call to glGenSamplers.
        /// Sampler object names returned by a call to glGenSamplers are not returned by subsequent calls, unless            they are first deleted with glDeleteSamplers.
        /// The names returned in samplers are marked as used, for the purposes of glGenSamplers only,            but they acquire state and type only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of sampler object names to generate.</param>
        /// <param name="samplers">Specifies an array in which the generated sampler object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenSamplers(int count, IntPtr samplers) => _GenSamplers_intptr(count, samplers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenSemaphoresEXT(int n, uint[] semaphores) => _GenSemaphoresEXT(n, semaphores);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenSemaphoresEXT(int n, void* semaphores) => _GenSemaphoresEXT_ptr(n, semaphores);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenSemaphoresEXT(int n, IntPtr semaphores) => _GenSemaphoresEXT_intptr(n, semaphores);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GenSymbolsEXT(DataTypeEXT datatype, VertexShaderStorageTypeEXT storagetype, ParameterRangeEXT range, uint components) => _GenSymbolsEXT(datatype, storagetype, range, components);

        // ---

        /// <summary>
        /// glGenTextures returns n texture names in textures.            There is no guarantee that the names form a contiguous set of integers;            however, it is guaranteed that none of the returned names was in use            immediately before the call to glGenTextures.
        /// The generated textures have no dimensionality; they assume the dimensionality            of the texture target to which they are first bound            (see glBindTexture).
        /// Texture names returned by a call to glGenTextures are not returned by            subsequent calls, unless they are first deleted with            glDeleteTextures.
        /// </summary>
        /// <param name="n">Specifies the number of texture names to be generated.</param>
        /// <param name="textures">Specifies an array in which the generated texture names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenTextures(int n, uint[] textures) => _GenTextures(n, textures);

        /// <summary>
        /// glGenTextures returns n texture names in textures.            There is no guarantee that the names form a contiguous set of integers;            however, it is guaranteed that none of the returned names was in use            immediately before the call to glGenTextures.
        /// The generated textures have no dimensionality; they assume the dimensionality            of the texture target to which they are first bound            (see glBindTexture).
        /// Texture names returned by a call to glGenTextures are not returned by            subsequent calls, unless they are first deleted with            glDeleteTextures.
        /// </summary>
        /// <param name="n">Specifies the number of texture names to be generated.</param>
        /// <param name="textures">Specifies an array in which the generated texture names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenTextures(int n, void* textures) => _GenTextures_ptr(n, textures);

        /// <summary>
        /// glGenTextures returns n texture names in textures.            There is no guarantee that the names form a contiguous set of integers;            however, it is guaranteed that none of the returned names was in use            immediately before the call to glGenTextures.
        /// The generated textures have no dimensionality; they assume the dimensionality            of the texture target to which they are first bound            (see glBindTexture).
        /// Texture names returned by a call to glGenTextures are not returned by            subsequent calls, unless they are first deleted with            glDeleteTextures.
        /// </summary>
        /// <param name="n">Specifies the number of texture names to be generated.</param>
        /// <param name="textures">Specifies an array in which the generated texture names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenTextures(int n, IntPtr textures) => _GenTextures_intptr(n, textures);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenTexturesEXT(int n, uint[] textures) => _GenTexturesEXT(n, textures);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenTexturesEXT(int n, void* textures) => _GenTexturesEXT_ptr(n, textures);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenTexturesEXT(int n, IntPtr textures) => _GenTexturesEXT_intptr(n, textures);

        // ---

        /// <summary>
        /// glGenTransformFeedbacks returns n previously unused            transform feedback object names in ids. These names are marked as used,            for the purposes of glGenTransformFeedbacks only, but they            acquire transform feedback state only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of transform feedback object names to reserve.</param>
        /// <param name="ids">Specifies an array of into which the reserved names will be written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenTransformFeedbacks(int n, uint[] ids) => _GenTransformFeedbacks(n, ids);

        /// <summary>
        /// glGenTransformFeedbacks returns n previously unused            transform feedback object names in ids. These names are marked as used,            for the purposes of glGenTransformFeedbacks only, but they            acquire transform feedback state only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of transform feedback object names to reserve.</param>
        /// <param name="ids">Specifies an array of into which the reserved names will be written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenTransformFeedbacks(int n, void* ids) => _GenTransformFeedbacks_ptr(n, ids);

        /// <summary>
        /// glGenTransformFeedbacks returns n previously unused            transform feedback object names in ids. These names are marked as used,            for the purposes of glGenTransformFeedbacks only, but they            acquire transform feedback state only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of transform feedback object names to reserve.</param>
        /// <param name="ids">Specifies an array of into which the reserved names will be written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenTransformFeedbacks(int n, IntPtr ids) => _GenTransformFeedbacks_intptr(n, ids);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenTransformFeedbacksNV(int n, uint[] ids) => _GenTransformFeedbacksNV(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenTransformFeedbacksNV(int n, void* ids) => _GenTransformFeedbacksNV_ptr(n, ids);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenTransformFeedbacksNV(int n, IntPtr ids) => _GenTransformFeedbacksNV_intptr(n, ids);

        // ---

        /// <summary>
        /// glGenVertexArrays returns n vertex array object names in arrays.            There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names            was in use immediately before the call to glGenVertexArrays.
        /// Vertex array object names returned by a call to glGenVertexArrays are not returned by subsequent calls, unless            they are first deleted with glDeleteVertexArrays.
        /// The names returned in arrays are marked as used, for the purposes of glGenVertexArrays only,            but they acquire state and type only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of vertex array object names to generate.</param>
        /// <param name="arrays">Specifies an array in which the generated vertex array object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenVertexArrays(int n, uint[] arrays) => _GenVertexArrays(n, arrays);

        /// <summary>
        /// glGenVertexArrays returns n vertex array object names in arrays.            There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names            was in use immediately before the call to glGenVertexArrays.
        /// Vertex array object names returned by a call to glGenVertexArrays are not returned by subsequent calls, unless            they are first deleted with glDeleteVertexArrays.
        /// The names returned in arrays are marked as used, for the purposes of glGenVertexArrays only,            but they acquire state and type only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of vertex array object names to generate.</param>
        /// <param name="arrays">Specifies an array in which the generated vertex array object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenVertexArrays(int n, void* arrays) => _GenVertexArrays_ptr(n, arrays);

        /// <summary>
        /// glGenVertexArrays returns n vertex array object names in arrays.            There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names            was in use immediately before the call to glGenVertexArrays.
        /// Vertex array object names returned by a call to glGenVertexArrays are not returned by subsequent calls, unless            they are first deleted with glDeleteVertexArrays.
        /// The names returned in arrays are marked as used, for the purposes of glGenVertexArrays only,            but they acquire state and type only when they are first bound.
        /// </summary>
        /// <param name="n">Specifies the number of vertex array object names to generate.</param>
        /// <param name="arrays">Specifies an array in which the generated vertex array object names are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenVertexArrays(int n, IntPtr arrays) => _GenVertexArrays_intptr(n, arrays);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenVertexArraysAPPLE(int n, uint[] arrays) => _GenVertexArraysAPPLE(n, arrays);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenVertexArraysAPPLE(int n, void* arrays) => _GenVertexArraysAPPLE_ptr(n, arrays);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenVertexArraysAPPLE(int n, IntPtr arrays) => _GenVertexArraysAPPLE_intptr(n, arrays);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenVertexArraysOES(int n, uint[] arrays) => _GenVertexArraysOES(n, arrays);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenVertexArraysOES(int n, void* arrays) => _GenVertexArraysOES_ptr(n, arrays);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenVertexArraysOES(int n, IntPtr arrays) => _GenVertexArraysOES_intptr(n, arrays);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GenVertexShadersEXT(uint range) => _GenVertexShadersEXT(range);

        // ---

        /// <summary>
        /// glGenerateMipmap and            glGenerateTextureMipmap generates mipmaps            for the specified texture object. For            glGenerateMipmap, the texture object            that is bound to target. For            glGenerateTextureMipmap,            texture is the name of the texture            object.
        /// For cube map and cube map array textures, the texture object            must be cube complete or cube array complete respectively.
        /// Mipmap generation replaces texel image levels $level_{base} + 1$            through $q$ with images derived from the $level_{base}$ image,            regardless of their previous contents. All other mimap images,            including the $level_{base}+1$ image, are left unchanged by this            computation.
        /// The internal formats of the derived mipmap images all match            those of the $level_{base}$ image. The contents of the derived            images are computed by repeated, filtered reduction of the            $level_{base} + 1$ image. For one- and two-dimensional array and            cube map array textures, each layer is filtered independently.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture object is                    bound for glGenerateMipmap. Must be                    one of GL_TEXTURE_1D,                    GL_TEXTURE_2D,                    GL_TEXTURE_3D,                    GL_TEXTURE_1D_ARRAY,                    GL_TEXTURE_2D_ARRAY,                    GL_TEXTURE_CUBE_MAP, or                    GL_TEXTURE_CUBE_MAP_ARRAY.</param>
        /// <param name="texture">Specifies the texture object name for                    glGenerateTextureMipmap.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenerateMipmap(TextureTarget target) => _GenerateMipmap(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenerateMipmapEXT(TextureTarget target) => _GenerateMipmapEXT(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenerateMipmapOES(TextureTarget target) => _GenerateMipmapOES(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenerateMultiTexMipmapEXT(TextureUnit texunit, TextureTarget target) => _GenerateMultiTexMipmapEXT(texunit, target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenerateTextureMipmap(uint texture) => _GenerateTextureMipmap(texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GenerateTextureMipmapEXT(uint texture, TextureTarget target) => _GenerateTextureMipmapEXT(texture, target);

        // ---

        /// <summary>
        /// glGetActiveAtomicCounterBufferiv retrieves information about the set of active            atomic counter buffers for a program object. program is the name of a program            object for which the command glLinkProgram            has been issued in the past. It is not necessary for program to have been linked            successfully. The link may have failed because the number of active atomic counters exceeded the limits.
        /// bufferIndex specifies the index of an active atomic counter buffer and must be in            the range zero to the value of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS minus one. The value            of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS for program indicates the            number of active atomic counter buffer and can be queried with            glGetProgram.
        /// If no error occurs, the parameter(s) specified by pname are returned in params.            If an error is generated, the contents of params are not modified.
        /// If pname is GL_ATOMIC_COUNTER_BUFFER_BINDING, then the index of the            counter buffer binding point associated with the active atomic counter buffer bufferIndex            for program is returned.
        /// If pname is GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE, then the implementation-dependent            minimum total buffer object size, in baseic machine units, required to hold all active atomic counters in the            atomic counter binding point identified by bufferIndex is returned.
        /// If pname is GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS, then the number of active            atomic counters for the atomic counter buffer identified by bufferIndex is returned.
        /// If pname is GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES,            then a list of the active atomic counter indices for the atomic counter buffer identified by bufferIndex            is returned. The number of elements that will be written into params is the value of            GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS for bufferIndex.
        /// If pname is GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER,            GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER,            GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER,            GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER,            GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER,            GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER then a boolean value indicating            whether the atomic counter buffer identified by bufferIndex is referenced by the vertex,            tessellation control, tessellation evaluation, geometry, fragment or compute processing stages of program,            respectively, is returned.
        /// </summary>
        /// <param name="program">The name of a program object from which to retrieve information.</param>
        /// <param name="bufferIndex">Specifies index of an active atomic counter buffer.</param>
        /// <param name="pname">Specifies which parameter of the atomic counter buffer to retrieve.</param>
        /// <param name="params">Specifies the address of a variable into which to write the retrieved information.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, AtomicCounterBufferPName pname, int[] @params) => _GetActiveAtomicCounterBufferiv(program, bufferIndex, pname, @params);

        /// <summary>
        /// glGetActiveAtomicCounterBufferiv retrieves information about the set of active            atomic counter buffers for a program object. program is the name of a program            object for which the command glLinkProgram            has been issued in the past. It is not necessary for program to have been linked            successfully. The link may have failed because the number of active atomic counters exceeded the limits.
        /// bufferIndex specifies the index of an active atomic counter buffer and must be in            the range zero to the value of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS minus one. The value            of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS for program indicates the            number of active atomic counter buffer and can be queried with            glGetProgram.
        /// If no error occurs, the parameter(s) specified by pname are returned in params.            If an error is generated, the contents of params are not modified.
        /// If pname is GL_ATOMIC_COUNTER_BUFFER_BINDING, then the index of the            counter buffer binding point associated with the active atomic counter buffer bufferIndex            for program is returned.
        /// If pname is GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE, then the implementation-dependent            minimum total buffer object size, in baseic machine units, required to hold all active atomic counters in the            atomic counter binding point identified by bufferIndex is returned.
        /// If pname is GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS, then the number of active            atomic counters for the atomic counter buffer identified by bufferIndex is returned.
        /// If pname is GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES,            then a list of the active atomic counter indices for the atomic counter buffer identified by bufferIndex            is returned. The number of elements that will be written into params is the value of            GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS for bufferIndex.
        /// If pname is GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER,            GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER,            GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER,            GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER,            GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER,            GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER then a boolean value indicating            whether the atomic counter buffer identified by bufferIndex is referenced by the vertex,            tessellation control, tessellation evaluation, geometry, fragment or compute processing stages of program,            respectively, is returned.
        /// </summary>
        /// <param name="program">The name of a program object from which to retrieve information.</param>
        /// <param name="bufferIndex">Specifies index of an active atomic counter buffer.</param>
        /// <param name="pname">Specifies which parameter of the atomic counter buffer to retrieve.</param>
        /// <param name="params">Specifies the address of a variable into which to write the retrieved information.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, AtomicCounterBufferPName pname, void* @params) => _GetActiveAtomicCounterBufferiv_ptr(program, bufferIndex, pname, @params);

        /// <summary>
        /// glGetActiveAtomicCounterBufferiv retrieves information about the set of active            atomic counter buffers for a program object. program is the name of a program            object for which the command glLinkProgram            has been issued in the past. It is not necessary for program to have been linked            successfully. The link may have failed because the number of active atomic counters exceeded the limits.
        /// bufferIndex specifies the index of an active atomic counter buffer and must be in            the range zero to the value of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS minus one. The value            of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS for program indicates the            number of active atomic counter buffer and can be queried with            glGetProgram.
        /// If no error occurs, the parameter(s) specified by pname are returned in params.            If an error is generated, the contents of params are not modified.
        /// If pname is GL_ATOMIC_COUNTER_BUFFER_BINDING, then the index of the            counter buffer binding point associated with the active atomic counter buffer bufferIndex            for program is returned.
        /// If pname is GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE, then the implementation-dependent            minimum total buffer object size, in baseic machine units, required to hold all active atomic counters in the            atomic counter binding point identified by bufferIndex is returned.
        /// If pname is GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS, then the number of active            atomic counters for the atomic counter buffer identified by bufferIndex is returned.
        /// If pname is GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES,            then a list of the active atomic counter indices for the atomic counter buffer identified by bufferIndex            is returned. The number of elements that will be written into params is the value of            GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS for bufferIndex.
        /// If pname is GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER,            GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER,            GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER,            GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER,            GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER,            GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER then a boolean value indicating            whether the atomic counter buffer identified by bufferIndex is referenced by the vertex,            tessellation control, tessellation evaluation, geometry, fragment or compute processing stages of program,            respectively, is returned.
        /// </summary>
        /// <param name="program">The name of a program object from which to retrieve information.</param>
        /// <param name="bufferIndex">Specifies index of an active atomic counter buffer.</param>
        /// <param name="pname">Specifies which parameter of the atomic counter buffer to retrieve.</param>
        /// <param name="params">Specifies the address of a variable into which to write the retrieved information.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, AtomicCounterBufferPName pname, IntPtr @params) => _GetActiveAtomicCounterBufferiv_intptr(program, bufferIndex, pname, @params);

        // ---

        /// <summary>
        /// glGetActiveAttrib returns information    about an active attribute variable in the program object    specified by program. The number of    active attributes can be obtained by calling    glGetProgram    with the value GL_ACTIVE_ATTRIBUTES. A    value of 0 for index selects the first    active attribute variable. Permissible values for    index range from zero to the number of    active attribute variables minus one.
        /// A vertex shader may use either built-in attribute    variables, user-defined attribute variables, or both. Built-in    attribute variables have a prefix of "gl_" and    reference conventional OpenGL vertex attribtes (e.g.,    gl_Vertex,    gl_Normal, etc., see the OpenGL Shading    Language specification for a complete list.) User-defined    attribute variables have arbitrary names and obtain their values    through numbered generic vertex attributes. An attribute    variable (either built-in or user-defined) is considered active    if it is determined during the link operation that it may be    accessed during program execution. Therefore,    program should have previously been the    target of a call to    glLinkProgram,    but it is not necessary for it to have been linked    successfully.
        /// The size of the character buffer required to store the    longest attribute variable name in    program can be obtained by calling    glGetProgram    with the value    GL_ACTIVE_ATTRIBUTE_MAX_LENGTH. This value    should be used to allocate a buffer of sufficient size to store    the returned attribute name. The size of this character buffer    is passed in bufSize, and a pointer to    this character buffer is passed in    name.
        /// glGetActiveAttrib returns the name of    the attribute variable indicated by    index, storing it in the character buffer    specified by name. The string returned    will be null terminated. The actual number of characters written    into this buffer is returned in length,    and this count does not include the null termination character.    If the length of the returned string is not required, a value of    NULL can be passed in the    length argument.
        /// The type argument specifies a    pointer to a variable into which the attribute variable's data type    will be written. The symbolic    constants GL_FLOAT,    GL_FLOAT_VEC2,    GL_FLOAT_VEC3,    GL_FLOAT_VEC4,    GL_FLOAT_MAT2,    GL_FLOAT_MAT3,    GL_FLOAT_MAT4,    GL_FLOAT_MAT2x3,    GL_FLOAT_MAT2x4,    GL_FLOAT_MAT3x2,    GL_FLOAT_MAT3x4,    GL_FLOAT_MAT4x2,    GL_FLOAT_MAT4x3,    GL_INT,    GL_INT_VEC2,    GL_INT_VEC3,    GL_INT_VEC4,    GL_UNSIGNED_INT,    GL_UNSIGNED_INT_VEC2,    GL_UNSIGNED_INT_VEC3,    GL_UNSIGNED_INT_VEC4,    GL_DOUBLE,    GL_DOUBLE_VEC2,    GL_DOUBLE_VEC3,    GL_DOUBLE_VEC4,    GL_DOUBLE_MAT2,    GL_DOUBLE_MAT3,    GL_DOUBLE_MAT4,    GL_DOUBLE_MAT2x3,    GL_DOUBLE_MAT2x4,    GL_DOUBLE_MAT3x2,    GL_DOUBLE_MAT3x4,    GL_DOUBLE_MAT4x2, or    GL_DOUBLE_MAT4x3     may be returned. The    size argument will return the size of the    attribute, in units of the type returned in    type.
        /// The list of active attribute variables may include both    built-in attribute variables (which begin with the prefix    "gl_") as well as user-defined attribute variable    names.
        /// This function will return as much information as it can    about the specified active attribute variable. If no information    is available, length will be 0, and    name will be an empty string. This    situation could occur if this function is called after a link    operation that failed. If an error occurs, the return values    length, size,    type, and name    will be unmodified.
        /// </summary>
        /// <param name="program">Specifies the program object to be            queried.</param>
        /// <param name="index">Specifies the index of the attribute variable            to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters            OpenGL is allowed to write in the character buffer            indicated by name.</param>
        /// <param name="length">Returns the number of characters actually            written by OpenGL in the string indicated by            name (excluding the null            terminator) if a value other than            NULL is passed.</param>
        /// <param name="size">Returns the size of the attribute            variable.</param>
        /// <param name="type">Returns the data type of the attribute            variable.</param>
        /// <param name="name">Returns a null terminated string containing            the name of the attribute variable.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveAttrib(uint program, uint index, int bufSize, out int length, out int size, out AttributeType type, string name) => _GetActiveAttrib(program, index, bufSize, out length, out size, out type, name);

        /// <summary>
        /// glGetActiveAttrib returns information    about an active attribute variable in the program object    specified by program. The number of    active attributes can be obtained by calling    glGetProgram    with the value GL_ACTIVE_ATTRIBUTES. A    value of 0 for index selects the first    active attribute variable. Permissible values for    index range from zero to the number of    active attribute variables minus one.
        /// A vertex shader may use either built-in attribute    variables, user-defined attribute variables, or both. Built-in    attribute variables have a prefix of "gl_" and    reference conventional OpenGL vertex attribtes (e.g.,    gl_Vertex,    gl_Normal, etc., see the OpenGL Shading    Language specification for a complete list.) User-defined    attribute variables have arbitrary names and obtain their values    through numbered generic vertex attributes. An attribute    variable (either built-in or user-defined) is considered active    if it is determined during the link operation that it may be    accessed during program execution. Therefore,    program should have previously been the    target of a call to    glLinkProgram,    but it is not necessary for it to have been linked    successfully.
        /// The size of the character buffer required to store the    longest attribute variable name in    program can be obtained by calling    glGetProgram    with the value    GL_ACTIVE_ATTRIBUTE_MAX_LENGTH. This value    should be used to allocate a buffer of sufficient size to store    the returned attribute name. The size of this character buffer    is passed in bufSize, and a pointer to    this character buffer is passed in    name.
        /// glGetActiveAttrib returns the name of    the attribute variable indicated by    index, storing it in the character buffer    specified by name. The string returned    will be null terminated. The actual number of characters written    into this buffer is returned in length,    and this count does not include the null termination character.    If the length of the returned string is not required, a value of    NULL can be passed in the    length argument.
        /// The type argument specifies a    pointer to a variable into which the attribute variable's data type    will be written. The symbolic    constants GL_FLOAT,    GL_FLOAT_VEC2,    GL_FLOAT_VEC3,    GL_FLOAT_VEC4,    GL_FLOAT_MAT2,    GL_FLOAT_MAT3,    GL_FLOAT_MAT4,    GL_FLOAT_MAT2x3,    GL_FLOAT_MAT2x4,    GL_FLOAT_MAT3x2,    GL_FLOAT_MAT3x4,    GL_FLOAT_MAT4x2,    GL_FLOAT_MAT4x3,    GL_INT,    GL_INT_VEC2,    GL_INT_VEC3,    GL_INT_VEC4,    GL_UNSIGNED_INT,    GL_UNSIGNED_INT_VEC2,    GL_UNSIGNED_INT_VEC3,    GL_UNSIGNED_INT_VEC4,    GL_DOUBLE,    GL_DOUBLE_VEC2,    GL_DOUBLE_VEC3,    GL_DOUBLE_VEC4,    GL_DOUBLE_MAT2,    GL_DOUBLE_MAT3,    GL_DOUBLE_MAT4,    GL_DOUBLE_MAT2x3,    GL_DOUBLE_MAT2x4,    GL_DOUBLE_MAT3x2,    GL_DOUBLE_MAT3x4,    GL_DOUBLE_MAT4x2, or    GL_DOUBLE_MAT4x3     may be returned. The    size argument will return the size of the    attribute, in units of the type returned in    type.
        /// The list of active attribute variables may include both    built-in attribute variables (which begin with the prefix    "gl_") as well as user-defined attribute variable    names.
        /// This function will return as much information as it can    about the specified active attribute variable. If no information    is available, length will be 0, and    name will be an empty string. This    situation could occur if this function is called after a link    operation that failed. If an error occurs, the return values    length, size,    type, and name    will be unmodified.
        /// </summary>
        /// <param name="program">Specifies the program object to be            queried.</param>
        /// <param name="index">Specifies the index of the attribute variable            to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters            OpenGL is allowed to write in the character buffer            indicated by name.</param>
        /// <param name="length">Returns the number of characters actually            written by OpenGL in the string indicated by            name (excluding the null            terminator) if a value other than            NULL is passed.</param>
        /// <param name="size">Returns the size of the attribute            variable.</param>
        /// <param name="type">Returns the data type of the attribute            variable.</param>
        /// <param name="name">Returns a null terminated string containing            the name of the attribute variable.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveAttrib(uint program, uint index, int bufSize, out int length, out int size, out AttributeType type, void* name) => _GetActiveAttrib_ptr(program, index, bufSize, out length, out size, out type, name);

        /// <summary>
        /// glGetActiveAttrib returns information    about an active attribute variable in the program object    specified by program. The number of    active attributes can be obtained by calling    glGetProgram    with the value GL_ACTIVE_ATTRIBUTES. A    value of 0 for index selects the first    active attribute variable. Permissible values for    index range from zero to the number of    active attribute variables minus one.
        /// A vertex shader may use either built-in attribute    variables, user-defined attribute variables, or both. Built-in    attribute variables have a prefix of "gl_" and    reference conventional OpenGL vertex attribtes (e.g.,    gl_Vertex,    gl_Normal, etc., see the OpenGL Shading    Language specification for a complete list.) User-defined    attribute variables have arbitrary names and obtain their values    through numbered generic vertex attributes. An attribute    variable (either built-in or user-defined) is considered active    if it is determined during the link operation that it may be    accessed during program execution. Therefore,    program should have previously been the    target of a call to    glLinkProgram,    but it is not necessary for it to have been linked    successfully.
        /// The size of the character buffer required to store the    longest attribute variable name in    program can be obtained by calling    glGetProgram    with the value    GL_ACTIVE_ATTRIBUTE_MAX_LENGTH. This value    should be used to allocate a buffer of sufficient size to store    the returned attribute name. The size of this character buffer    is passed in bufSize, and a pointer to    this character buffer is passed in    name.
        /// glGetActiveAttrib returns the name of    the attribute variable indicated by    index, storing it in the character buffer    specified by name. The string returned    will be null terminated. The actual number of characters written    into this buffer is returned in length,    and this count does not include the null termination character.    If the length of the returned string is not required, a value of    NULL can be passed in the    length argument.
        /// The type argument specifies a    pointer to a variable into which the attribute variable's data type    will be written. The symbolic    constants GL_FLOAT,    GL_FLOAT_VEC2,    GL_FLOAT_VEC3,    GL_FLOAT_VEC4,    GL_FLOAT_MAT2,    GL_FLOAT_MAT3,    GL_FLOAT_MAT4,    GL_FLOAT_MAT2x3,    GL_FLOAT_MAT2x4,    GL_FLOAT_MAT3x2,    GL_FLOAT_MAT3x4,    GL_FLOAT_MAT4x2,    GL_FLOAT_MAT4x3,    GL_INT,    GL_INT_VEC2,    GL_INT_VEC3,    GL_INT_VEC4,    GL_UNSIGNED_INT,    GL_UNSIGNED_INT_VEC2,    GL_UNSIGNED_INT_VEC3,    GL_UNSIGNED_INT_VEC4,    GL_DOUBLE,    GL_DOUBLE_VEC2,    GL_DOUBLE_VEC3,    GL_DOUBLE_VEC4,    GL_DOUBLE_MAT2,    GL_DOUBLE_MAT3,    GL_DOUBLE_MAT4,    GL_DOUBLE_MAT2x3,    GL_DOUBLE_MAT2x4,    GL_DOUBLE_MAT3x2,    GL_DOUBLE_MAT3x4,    GL_DOUBLE_MAT4x2, or    GL_DOUBLE_MAT4x3     may be returned. The    size argument will return the size of the    attribute, in units of the type returned in    type.
        /// The list of active attribute variables may include both    built-in attribute variables (which begin with the prefix    "gl_") as well as user-defined attribute variable    names.
        /// This function will return as much information as it can    about the specified active attribute variable. If no information    is available, length will be 0, and    name will be an empty string. This    situation could occur if this function is called after a link    operation that failed. If an error occurs, the return values    length, size,    type, and name    will be unmodified.
        /// </summary>
        /// <param name="program">Specifies the program object to be            queried.</param>
        /// <param name="index">Specifies the index of the attribute variable            to be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters            OpenGL is allowed to write in the character buffer            indicated by name.</param>
        /// <param name="length">Returns the number of characters actually            written by OpenGL in the string indicated by            name (excluding the null            terminator) if a value other than            NULL is passed.</param>
        /// <param name="size">Returns the size of the attribute            variable.</param>
        /// <param name="type">Returns the data type of the attribute            variable.</param>
        /// <param name="name">Returns a null terminated string containing            the name of the attribute variable.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveAttrib(uint program, uint index, int bufSize, out int length, out int size, out AttributeType type, IntPtr name) => _GetActiveAttrib_intptr(program, index, bufSize, out length, out size, out type, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveAttribARB(int programObj, uint index, int maxLength, out int length, out int size, out AttributeType type, string name) => _GetActiveAttribARB(programObj, index, maxLength, out length, out size, out type, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveAttribARB(int programObj, uint index, int maxLength, out int length, out int size, out AttributeType type, void* name) => _GetActiveAttribARB_ptr(programObj, index, maxLength, out length, out size, out type, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveAttribARB(int programObj, uint index, int maxLength, out int length, out int size, out AttributeType type, IntPtr name) => _GetActiveAttribARB_intptr(programObj, index, maxLength, out length, out size, out type, name);

        // ---

        /// <summary>
        /// glGetActiveSubroutineName queries the name of an active shader subroutine uniform from the            program object given in program. index specifies the index of            the shader subroutine uniform within the shader stage given by stage, and must between            zero and the value of GL_ACTIVE_SUBROUTINES minus one for the shader stage.
        /// The name of the selected subroutine is returned as a null-terminated string in name. The            actual number of characters written into name, not including the null-terminator, is            returned in length. If length is NULL,            no length is returned. The maximum number of characters that may be written into name,            including the null-terminator, is given in bufSize.
        /// </summary>
        /// <param name="program">Specifies the name of the program containing the subroutine.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query the subroutine name.</param>
        /// <param name="index">Specifies the index of the shader subroutine uniform.</param>
        /// <param name="bufSize">Specifies the size of the buffer whose address is given in name.</param>
        /// <param name="length">Specifies the address of a variable which is to receive the length of the shader subroutine uniform name.</param>
        /// <param name="name">Specifies the address of an array into which the name of the shader subroutine uniform will be written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveSubroutineName(uint program, ShaderType shadertype, uint index, int bufSize, out int length, string name) => _GetActiveSubroutineName(program, shadertype, index, bufSize, out length, name);

        /// <summary>
        /// glGetActiveSubroutineName queries the name of an active shader subroutine uniform from the            program object given in program. index specifies the index of            the shader subroutine uniform within the shader stage given by stage, and must between            zero and the value of GL_ACTIVE_SUBROUTINES minus one for the shader stage.
        /// The name of the selected subroutine is returned as a null-terminated string in name. The            actual number of characters written into name, not including the null-terminator, is            returned in length. If length is NULL,            no length is returned. The maximum number of characters that may be written into name,            including the null-terminator, is given in bufSize.
        /// </summary>
        /// <param name="program">Specifies the name of the program containing the subroutine.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query the subroutine name.</param>
        /// <param name="index">Specifies the index of the shader subroutine uniform.</param>
        /// <param name="bufSize">Specifies the size of the buffer whose address is given in name.</param>
        /// <param name="length">Specifies the address of a variable which is to receive the length of the shader subroutine uniform name.</param>
        /// <param name="name">Specifies the address of an array into which the name of the shader subroutine uniform will be written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveSubroutineName(uint program, ShaderType shadertype, uint index, int bufSize, out int length, void* name) => _GetActiveSubroutineName_ptr(program, shadertype, index, bufSize, out length, name);

        /// <summary>
        /// glGetActiveSubroutineName queries the name of an active shader subroutine uniform from the            program object given in program. index specifies the index of            the shader subroutine uniform within the shader stage given by stage, and must between            zero and the value of GL_ACTIVE_SUBROUTINES minus one for the shader stage.
        /// The name of the selected subroutine is returned as a null-terminated string in name. The            actual number of characters written into name, not including the null-terminator, is            returned in length. If length is NULL,            no length is returned. The maximum number of characters that may be written into name,            including the null-terminator, is given in bufSize.
        /// </summary>
        /// <param name="program">Specifies the name of the program containing the subroutine.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query the subroutine name.</param>
        /// <param name="index">Specifies the index of the shader subroutine uniform.</param>
        /// <param name="bufSize">Specifies the size of the buffer whose address is given in name.</param>
        /// <param name="length">Specifies the address of a variable which is to receive the length of the shader subroutine uniform name.</param>
        /// <param name="name">Specifies the address of an array into which the name of the shader subroutine uniform will be written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveSubroutineName(uint program, ShaderType shadertype, uint index, int bufSize, out int length, IntPtr name) => _GetActiveSubroutineName_intptr(program, shadertype, index, bufSize, out length, name);

        // ---

        /// <summary>
        /// glGetActiveSubroutineUniformName retrieves the name of an active shader subroutine uniform.            program contains the name of the program containing the uniform. shadertype            specifies the stage for which the uniform location, given by index, is valid. index            must be between zero and the value of GL_ACTIVE_SUBROUTINE_UNIFORMS minus one for the            shader stage.
        /// The uniform name is returned as a null-terminated string in name. The actual number of characters            written into name, excluding the null terminator is returned in length.            If length is NULL, no length is returned. The maximum number of characters            that may be written into name, including the null terminator, is specified by bufSize.            The length of the longest subroutine uniform name in program and shadertype is given            by the value of GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, which can be queried with            glGetProgramStage.
        /// </summary>
        /// <param name="program">Specifies the name of the program containing the subroutine.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for the subroutine parameter. shadertype                    must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER,                    GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or                    GL_FRAGMENT_SHADER.</param>
        /// <param name="index">Specifies the index of the shader subroutine uniform.</param>
        /// <param name="bufSize">Specifies the size of the buffer whose address is given in name.</param>
        /// <param name="length">Specifies the address of a variable into which is written the number of characters copied into name.</param>
        /// <param name="name">Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveSubroutineUniformName(uint program, ShaderType shadertype, uint index, int bufSize, out int length, string name) => _GetActiveSubroutineUniformName(program, shadertype, index, bufSize, out length, name);

        /// <summary>
        /// glGetActiveSubroutineUniformName retrieves the name of an active shader subroutine uniform.            program contains the name of the program containing the uniform. shadertype            specifies the stage for which the uniform location, given by index, is valid. index            must be between zero and the value of GL_ACTIVE_SUBROUTINE_UNIFORMS minus one for the            shader stage.
        /// The uniform name is returned as a null-terminated string in name. The actual number of characters            written into name, excluding the null terminator is returned in length.            If length is NULL, no length is returned. The maximum number of characters            that may be written into name, including the null terminator, is specified by bufSize.            The length of the longest subroutine uniform name in program and shadertype is given            by the value of GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, which can be queried with            glGetProgramStage.
        /// </summary>
        /// <param name="program">Specifies the name of the program containing the subroutine.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for the subroutine parameter. shadertype                    must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER,                    GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or                    GL_FRAGMENT_SHADER.</param>
        /// <param name="index">Specifies the index of the shader subroutine uniform.</param>
        /// <param name="bufSize">Specifies the size of the buffer whose address is given in name.</param>
        /// <param name="length">Specifies the address of a variable into which is written the number of characters copied into name.</param>
        /// <param name="name">Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveSubroutineUniformName(uint program, ShaderType shadertype, uint index, int bufSize, out int length, void* name) => _GetActiveSubroutineUniformName_ptr(program, shadertype, index, bufSize, out length, name);

        /// <summary>
        /// glGetActiveSubroutineUniformName retrieves the name of an active shader subroutine uniform.            program contains the name of the program containing the uniform. shadertype            specifies the stage for which the uniform location, given by index, is valid. index            must be between zero and the value of GL_ACTIVE_SUBROUTINE_UNIFORMS minus one for the            shader stage.
        /// The uniform name is returned as a null-terminated string in name. The actual number of characters            written into name, excluding the null terminator is returned in length.            If length is NULL, no length is returned. The maximum number of characters            that may be written into name, including the null terminator, is specified by bufSize.            The length of the longest subroutine uniform name in program and shadertype is given            by the value of GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, which can be queried with            glGetProgramStage.
        /// </summary>
        /// <param name="program">Specifies the name of the program containing the subroutine.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for the subroutine parameter. shadertype                    must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER,                    GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or                    GL_FRAGMENT_SHADER.</param>
        /// <param name="index">Specifies the index of the shader subroutine uniform.</param>
        /// <param name="bufSize">Specifies the size of the buffer whose address is given in name.</param>
        /// <param name="length">Specifies the address of a variable into which is written the number of characters copied into name.</param>
        /// <param name="name">Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveSubroutineUniformName(uint program, ShaderType shadertype, uint index, int bufSize, out int length, IntPtr name) => _GetActiveSubroutineUniformName_intptr(program, shadertype, index, bufSize, out length, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveSubroutineUniformiv(uint program, ShaderType shadertype, uint index, SubroutineParameterName pname, int[] values) => _GetActiveSubroutineUniformiv(program, shadertype, index, pname, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveSubroutineUniformiv(uint program, ShaderType shadertype, uint index, SubroutineParameterName pname, void* values) => _GetActiveSubroutineUniformiv_ptr(program, shadertype, index, pname, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveSubroutineUniformiv(uint program, ShaderType shadertype, uint index, SubroutineParameterName pname, IntPtr values) => _GetActiveSubroutineUniformiv_intptr(program, shadertype, index, pname, values);

        // ---

        /// <summary>
        /// glGetActiveUniform returns    information about an active uniform variable in the program    object specified by program. The number    of active uniform variables can be obtained by calling    glGetProgram    with the value GL_ACTIVE_UNIFORMS. A value    of 0 for index selects the first active    uniform variable. Permissible values for    index range from zero to the number of    active uniform variables minus one.
        /// Shaders may use either built-in uniform variables,    user-defined uniform variables, or both. Built-in uniform    variables have a prefix of "gl_" and reference    existing OpenGL state or values derived from such state (e.g.,    gl_DepthRangeParameters, see the OpenGL    Shading Language specification for a complete list.)    User-defined uniform variables have arbitrary names and obtain    their values from the application through calls to    glUniform.    A uniform variable (either built-in or user-defined) is    considered active if it is determined during the link operation    that it may be accessed during program execution. Therefore,    program should have previously been the    target of a call to    glLinkProgram,    but it is not necessary for it to have been linked    successfully.
        /// The size of the character buffer required to store the    longest uniform variable name in program    can be obtained by calling    glGetProgram    with the value    GL_ACTIVE_UNIFORM_MAX_LENGTH. This value    should be used to allocate a buffer of sufficient size to store    the returned uniform variable name. The size of this character    buffer is passed in bufSize, and a    pointer to this character buffer is passed in    name.
        /// glGetActiveUniform returns the name    of the uniform variable indicated by    index, storing it in the character buffer    specified by name. The string returned    will be null terminated. The actual number of characters written    into this buffer is returned in length,    and this count does not include the null termination character.    If the length of the returned string is not required, a value of    NULL can be passed in the    length argument.
        /// The type    argument will return a pointer to the uniform variable's data    type. The symbolic constants returned for uniform types are shown in the    table below.         Returned Symbolic Contant  Shader Uniform Type GL_FLOATfloatGL_FLOAT_VEC2vec2GL_FLOAT_VEC3vec3GL_FLOAT_VEC4vec4GL_DOUBLEdoubleGL_DOUBLE_VEC2dvec2GL_DOUBLE_VEC3dvec3GL_DOUBLE_VEC4dvec4GL_INTintGL_INT_VEC2ivec2GL_INT_VEC3ivec3GL_INT_VEC4ivec4GL_UNSIGNED_INTunsigned intGL_UNSIGNED_INT_VEC2uvec2GL_UNSIGNED_INT_VEC3uvec3GL_UNSIGNED_INT_VEC4uvec4GL_BOOLboolGL_BOOL_VEC2bvec2GL_BOOL_VEC3bvec3GL_BOOL_VEC4bvec4GL_FLOAT_MAT2mat2GL_FLOAT_MAT3mat3GL_FLOAT_MAT4mat4GL_FLOAT_MAT2x3mat2x3GL_FLOAT_MAT2x4mat2x4GL_FLOAT_MAT3x2mat3x2GL_FLOAT_MAT3x4mat3x4GL_FLOAT_MAT4x2mat4x2GL_FLOAT_MAT4x3mat4x3GL_DOUBLE_MAT2dmat2GL_DOUBLE_MAT3dmat3GL_DOUBLE_MAT4dmat4GL_DOUBLE_MAT2x3dmat2x3GL_DOUBLE_MAT2x4dmat2x4GL_DOUBLE_MAT3x2dmat3x2GL_DOUBLE_MAT3x4dmat3x4GL_DOUBLE_MAT4x2dmat4x2GL_DOUBLE_MAT4x3dmat4x3GL_SAMPLER_1Dsampler1DGL_SAMPLER_2Dsampler2DGL_SAMPLER_3Dsampler3DGL_SAMPLER_CUBEsamplerCubeGL_SAMPLER_1D_SHADOWsampler1DShadowGL_SAMPLER_2D_SHADOWsampler2DShadowGL_SAMPLER_1D_ARRAYsampler1DArrayGL_SAMPLER_2D_ARRAYsampler2DArrayGL_SAMPLER_1D_ARRAY_SHADOWsampler1DArrayShadowGL_SAMPLER_2D_ARRAY_SHADOWsampler2DArrayShadowGL_SAMPLER_2D_MULTISAMPLEsampler2DMSGL_SAMPLER_2D_MULTISAMPLE_ARRAYsampler2DMSArrayGL_SAMPLER_CUBE_SHADOWsamplerCubeShadowGL_SAMPLER_BUFFERsamplerBufferGL_SAMPLER_2D_RECTsampler2DRectGL_SAMPLER_2D_RECT_SHADOWsampler2DRectShadowGL_INT_SAMPLER_1Disampler1DGL_INT_SAMPLER_2Disampler2DGL_INT_SAMPLER_3Disampler3DGL_INT_SAMPLER_CUBEisamplerCubeGL_INT_SAMPLER_1D_ARRAYisampler1DArrayGL_INT_SAMPLER_2D_ARRAYisampler2DArrayGL_INT_SAMPLER_2D_MULTISAMPLEisampler2DMSGL_INT_SAMPLER_2D_MULTISAMPLE_ARRAYisampler2DMSArrayGL_INT_SAMPLER_BUFFERisamplerBufferGL_INT_SAMPLER_2D_RECTisampler2DRectGL_UNSIGNED_INT_SAMPLER_1Dusampler1DGL_UNSIGNED_INT_SAMPLER_2Dusampler2DGL_UNSIGNED_INT_SAMPLER_3Dusampler3DGL_UNSIGNED_INT_SAMPLER_CUBEusamplerCubeGL_UNSIGNED_INT_SAMPLER_1D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLEusampler2DMSGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAYusampler2DMSArrayGL_UNSIGNED_INT_SAMPLER_BUFFERusamplerBufferGL_UNSIGNED_INT_SAMPLER_2D_RECTusampler2DRectGL_IMAGE_1Dimage1DGL_IMAGE_2Dimage2DGL_IMAGE_3Dimage3DGL_IMAGE_2D_RECTimage2DRectGL_IMAGE_CUBEimageCubeGL_IMAGE_BUFFERimageBufferGL_IMAGE_1D_ARRAYimage1DArrayGL_IMAGE_2D_ARRAYimage2DArrayGL_IMAGE_2D_MULTISAMPLEimage2DMSGL_IMAGE_2D_MULTISAMPLE_ARRAYimage2DMSArrayGL_INT_IMAGE_1Diimage1DGL_INT_IMAGE_2Diimage2DGL_INT_IMAGE_3Diimage3DGL_INT_IMAGE_2D_RECTiimage2DRectGL_INT_IMAGE_CUBEiimageCubeGL_INT_IMAGE_BUFFERiimageBufferGL_INT_IMAGE_1D_ARRAYiimage1DArrayGL_INT_IMAGE_2D_ARRAYiimage2DArrayGL_INT_IMAGE_2D_MULTISAMPLEiimage2DMSGL_INT_IMAGE_2D_MULTISAMPLE_ARRAYiimage2DMSArrayGL_UNSIGNED_INT_IMAGE_1Duimage1DGL_UNSIGNED_INT_IMAGE_2Duimage2DGL_UNSIGNED_INT_IMAGE_3Duimage3DGL_UNSIGNED_INT_IMAGE_2D_RECTuimage2DRectGL_UNSIGNED_INT_IMAGE_CUBEuimageCubeGL_UNSIGNED_INT_IMAGE_BUFFERuimageBufferGL_UNSIGNED_INT_IMAGE_1D_ARRAYuimage1DArrayGL_UNSIGNED_INT_IMAGE_2D_ARRAYuimage2DArrayGL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLEuimage2DMSGL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAYuimage2DMSArrayGL_UNSIGNED_INT_ATOMIC_COUNTERatomic_uint
        /// If one or more elements of an array are active, the name    of the array is returned in name, the    type is returned in type, and the    size parameter returns the highest array    element index used, plus one, as determined by the compiler    and/or linker. Only one active uniform variable will be reported    for a uniform array.
        /// Uniform variables that are declared as structures or    arrays of structures will not be returned directly by this    function. Instead, each of these uniform variables will be    reduced to its fundamental components containing the    "." and "[]" operators such that each of the    names is valid as an argument to    glGetUniformLocation.    Each of these reduced uniform variables is counted as one active    uniform variable and is assigned an index. A valid name cannot    be a structure, an array of structures, or a subcomponent of a    vector or matrix.
        /// The size of the uniform variable will be returned in    size. Uniform variables other than arrays    will have a size of 1. Structures and arrays of structures will    be reduced as described earlier, such that each of the names    returned will be a data type in the earlier list. If this    reduction results in an array, the size returned will be as    described for uniform arrays; otherwise, the size returned will    be 1.
        /// The list of active uniform variables may include both    built-in uniform variables (which begin with the prefix    "gl_") as well as user-defined uniform variable    names.
        /// This function will return as much information as it can    about the specified active uniform variable. If no information    is available, length will be 0, and    name will be an empty string. This    situation could occur if this function is called after a link    operation that failed. If an error occurs, the return values    length, size,    type, and name    will be unmodified.
        /// </summary>
        /// <param name="program">Specifies the program object to be            queried.</param>
        /// <param name="index">Specifies the index of the uniform variable to            be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters            OpenGL is allowed to write in the character buffer            indicated by name.</param>
        /// <param name="length">Returns the number of characters actually            written by OpenGL in the string indicated by            name (excluding the null            terminator) if a value other than            NULL is passed.</param>
        /// <param name="size">Returns the size of the uniform            variable.</param>
        /// <param name="type">Returns the data type of the uniform            variable.</param>
        /// <param name="name">Returns a null terminated string containing            the name of the uniform variable.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniform(uint program, uint index, int bufSize, out int length, out int size, out UniformType type, string name) => _GetActiveUniform(program, index, bufSize, out length, out size, out type, name);

        /// <summary>
        /// glGetActiveUniform returns    information about an active uniform variable in the program    object specified by program. The number    of active uniform variables can be obtained by calling    glGetProgram    with the value GL_ACTIVE_UNIFORMS. A value    of 0 for index selects the first active    uniform variable. Permissible values for    index range from zero to the number of    active uniform variables minus one.
        /// Shaders may use either built-in uniform variables,    user-defined uniform variables, or both. Built-in uniform    variables have a prefix of "gl_" and reference    existing OpenGL state or values derived from such state (e.g.,    gl_DepthRangeParameters, see the OpenGL    Shading Language specification for a complete list.)    User-defined uniform variables have arbitrary names and obtain    their values from the application through calls to    glUniform.    A uniform variable (either built-in or user-defined) is    considered active if it is determined during the link operation    that it may be accessed during program execution. Therefore,    program should have previously been the    target of a call to    glLinkProgram,    but it is not necessary for it to have been linked    successfully.
        /// The size of the character buffer required to store the    longest uniform variable name in program    can be obtained by calling    glGetProgram    with the value    GL_ACTIVE_UNIFORM_MAX_LENGTH. This value    should be used to allocate a buffer of sufficient size to store    the returned uniform variable name. The size of this character    buffer is passed in bufSize, and a    pointer to this character buffer is passed in    name.
        /// glGetActiveUniform returns the name    of the uniform variable indicated by    index, storing it in the character buffer    specified by name. The string returned    will be null terminated. The actual number of characters written    into this buffer is returned in length,    and this count does not include the null termination character.    If the length of the returned string is not required, a value of    NULL can be passed in the    length argument.
        /// The type    argument will return a pointer to the uniform variable's data    type. The symbolic constants returned for uniform types are shown in the    table below.         Returned Symbolic Contant  Shader Uniform Type GL_FLOATfloatGL_FLOAT_VEC2vec2GL_FLOAT_VEC3vec3GL_FLOAT_VEC4vec4GL_DOUBLEdoubleGL_DOUBLE_VEC2dvec2GL_DOUBLE_VEC3dvec3GL_DOUBLE_VEC4dvec4GL_INTintGL_INT_VEC2ivec2GL_INT_VEC3ivec3GL_INT_VEC4ivec4GL_UNSIGNED_INTunsigned intGL_UNSIGNED_INT_VEC2uvec2GL_UNSIGNED_INT_VEC3uvec3GL_UNSIGNED_INT_VEC4uvec4GL_BOOLboolGL_BOOL_VEC2bvec2GL_BOOL_VEC3bvec3GL_BOOL_VEC4bvec4GL_FLOAT_MAT2mat2GL_FLOAT_MAT3mat3GL_FLOAT_MAT4mat4GL_FLOAT_MAT2x3mat2x3GL_FLOAT_MAT2x4mat2x4GL_FLOAT_MAT3x2mat3x2GL_FLOAT_MAT3x4mat3x4GL_FLOAT_MAT4x2mat4x2GL_FLOAT_MAT4x3mat4x3GL_DOUBLE_MAT2dmat2GL_DOUBLE_MAT3dmat3GL_DOUBLE_MAT4dmat4GL_DOUBLE_MAT2x3dmat2x3GL_DOUBLE_MAT2x4dmat2x4GL_DOUBLE_MAT3x2dmat3x2GL_DOUBLE_MAT3x4dmat3x4GL_DOUBLE_MAT4x2dmat4x2GL_DOUBLE_MAT4x3dmat4x3GL_SAMPLER_1Dsampler1DGL_SAMPLER_2Dsampler2DGL_SAMPLER_3Dsampler3DGL_SAMPLER_CUBEsamplerCubeGL_SAMPLER_1D_SHADOWsampler1DShadowGL_SAMPLER_2D_SHADOWsampler2DShadowGL_SAMPLER_1D_ARRAYsampler1DArrayGL_SAMPLER_2D_ARRAYsampler2DArrayGL_SAMPLER_1D_ARRAY_SHADOWsampler1DArrayShadowGL_SAMPLER_2D_ARRAY_SHADOWsampler2DArrayShadowGL_SAMPLER_2D_MULTISAMPLEsampler2DMSGL_SAMPLER_2D_MULTISAMPLE_ARRAYsampler2DMSArrayGL_SAMPLER_CUBE_SHADOWsamplerCubeShadowGL_SAMPLER_BUFFERsamplerBufferGL_SAMPLER_2D_RECTsampler2DRectGL_SAMPLER_2D_RECT_SHADOWsampler2DRectShadowGL_INT_SAMPLER_1Disampler1DGL_INT_SAMPLER_2Disampler2DGL_INT_SAMPLER_3Disampler3DGL_INT_SAMPLER_CUBEisamplerCubeGL_INT_SAMPLER_1D_ARRAYisampler1DArrayGL_INT_SAMPLER_2D_ARRAYisampler2DArrayGL_INT_SAMPLER_2D_MULTISAMPLEisampler2DMSGL_INT_SAMPLER_2D_MULTISAMPLE_ARRAYisampler2DMSArrayGL_INT_SAMPLER_BUFFERisamplerBufferGL_INT_SAMPLER_2D_RECTisampler2DRectGL_UNSIGNED_INT_SAMPLER_1Dusampler1DGL_UNSIGNED_INT_SAMPLER_2Dusampler2DGL_UNSIGNED_INT_SAMPLER_3Dusampler3DGL_UNSIGNED_INT_SAMPLER_CUBEusamplerCubeGL_UNSIGNED_INT_SAMPLER_1D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLEusampler2DMSGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAYusampler2DMSArrayGL_UNSIGNED_INT_SAMPLER_BUFFERusamplerBufferGL_UNSIGNED_INT_SAMPLER_2D_RECTusampler2DRectGL_IMAGE_1Dimage1DGL_IMAGE_2Dimage2DGL_IMAGE_3Dimage3DGL_IMAGE_2D_RECTimage2DRectGL_IMAGE_CUBEimageCubeGL_IMAGE_BUFFERimageBufferGL_IMAGE_1D_ARRAYimage1DArrayGL_IMAGE_2D_ARRAYimage2DArrayGL_IMAGE_2D_MULTISAMPLEimage2DMSGL_IMAGE_2D_MULTISAMPLE_ARRAYimage2DMSArrayGL_INT_IMAGE_1Diimage1DGL_INT_IMAGE_2Diimage2DGL_INT_IMAGE_3Diimage3DGL_INT_IMAGE_2D_RECTiimage2DRectGL_INT_IMAGE_CUBEiimageCubeGL_INT_IMAGE_BUFFERiimageBufferGL_INT_IMAGE_1D_ARRAYiimage1DArrayGL_INT_IMAGE_2D_ARRAYiimage2DArrayGL_INT_IMAGE_2D_MULTISAMPLEiimage2DMSGL_INT_IMAGE_2D_MULTISAMPLE_ARRAYiimage2DMSArrayGL_UNSIGNED_INT_IMAGE_1Duimage1DGL_UNSIGNED_INT_IMAGE_2Duimage2DGL_UNSIGNED_INT_IMAGE_3Duimage3DGL_UNSIGNED_INT_IMAGE_2D_RECTuimage2DRectGL_UNSIGNED_INT_IMAGE_CUBEuimageCubeGL_UNSIGNED_INT_IMAGE_BUFFERuimageBufferGL_UNSIGNED_INT_IMAGE_1D_ARRAYuimage1DArrayGL_UNSIGNED_INT_IMAGE_2D_ARRAYuimage2DArrayGL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLEuimage2DMSGL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAYuimage2DMSArrayGL_UNSIGNED_INT_ATOMIC_COUNTERatomic_uint
        /// If one or more elements of an array are active, the name    of the array is returned in name, the    type is returned in type, and the    size parameter returns the highest array    element index used, plus one, as determined by the compiler    and/or linker. Only one active uniform variable will be reported    for a uniform array.
        /// Uniform variables that are declared as structures or    arrays of structures will not be returned directly by this    function. Instead, each of these uniform variables will be    reduced to its fundamental components containing the    "." and "[]" operators such that each of the    names is valid as an argument to    glGetUniformLocation.    Each of these reduced uniform variables is counted as one active    uniform variable and is assigned an index. A valid name cannot    be a structure, an array of structures, or a subcomponent of a    vector or matrix.
        /// The size of the uniform variable will be returned in    size. Uniform variables other than arrays    will have a size of 1. Structures and arrays of structures will    be reduced as described earlier, such that each of the names    returned will be a data type in the earlier list. If this    reduction results in an array, the size returned will be as    described for uniform arrays; otherwise, the size returned will    be 1.
        /// The list of active uniform variables may include both    built-in uniform variables (which begin with the prefix    "gl_") as well as user-defined uniform variable    names.
        /// This function will return as much information as it can    about the specified active uniform variable. If no information    is available, length will be 0, and    name will be an empty string. This    situation could occur if this function is called after a link    operation that failed. If an error occurs, the return values    length, size,    type, and name    will be unmodified.
        /// </summary>
        /// <param name="program">Specifies the program object to be            queried.</param>
        /// <param name="index">Specifies the index of the uniform variable to            be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters            OpenGL is allowed to write in the character buffer            indicated by name.</param>
        /// <param name="length">Returns the number of characters actually            written by OpenGL in the string indicated by            name (excluding the null            terminator) if a value other than            NULL is passed.</param>
        /// <param name="size">Returns the size of the uniform            variable.</param>
        /// <param name="type">Returns the data type of the uniform            variable.</param>
        /// <param name="name">Returns a null terminated string containing            the name of the uniform variable.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniform(uint program, uint index, int bufSize, out int length, out int size, out UniformType type, void* name) => _GetActiveUniform_ptr(program, index, bufSize, out length, out size, out type, name);

        /// <summary>
        /// glGetActiveUniform returns    information about an active uniform variable in the program    object specified by program. The number    of active uniform variables can be obtained by calling    glGetProgram    with the value GL_ACTIVE_UNIFORMS. A value    of 0 for index selects the first active    uniform variable. Permissible values for    index range from zero to the number of    active uniform variables minus one.
        /// Shaders may use either built-in uniform variables,    user-defined uniform variables, or both. Built-in uniform    variables have a prefix of "gl_" and reference    existing OpenGL state or values derived from such state (e.g.,    gl_DepthRangeParameters, see the OpenGL    Shading Language specification for a complete list.)    User-defined uniform variables have arbitrary names and obtain    their values from the application through calls to    glUniform.    A uniform variable (either built-in or user-defined) is    considered active if it is determined during the link operation    that it may be accessed during program execution. Therefore,    program should have previously been the    target of a call to    glLinkProgram,    but it is not necessary for it to have been linked    successfully.
        /// The size of the character buffer required to store the    longest uniform variable name in program    can be obtained by calling    glGetProgram    with the value    GL_ACTIVE_UNIFORM_MAX_LENGTH. This value    should be used to allocate a buffer of sufficient size to store    the returned uniform variable name. The size of this character    buffer is passed in bufSize, and a    pointer to this character buffer is passed in    name.
        /// glGetActiveUniform returns the name    of the uniform variable indicated by    index, storing it in the character buffer    specified by name. The string returned    will be null terminated. The actual number of characters written    into this buffer is returned in length,    and this count does not include the null termination character.    If the length of the returned string is not required, a value of    NULL can be passed in the    length argument.
        /// The type    argument will return a pointer to the uniform variable's data    type. The symbolic constants returned for uniform types are shown in the    table below.         Returned Symbolic Contant  Shader Uniform Type GL_FLOATfloatGL_FLOAT_VEC2vec2GL_FLOAT_VEC3vec3GL_FLOAT_VEC4vec4GL_DOUBLEdoubleGL_DOUBLE_VEC2dvec2GL_DOUBLE_VEC3dvec3GL_DOUBLE_VEC4dvec4GL_INTintGL_INT_VEC2ivec2GL_INT_VEC3ivec3GL_INT_VEC4ivec4GL_UNSIGNED_INTunsigned intGL_UNSIGNED_INT_VEC2uvec2GL_UNSIGNED_INT_VEC3uvec3GL_UNSIGNED_INT_VEC4uvec4GL_BOOLboolGL_BOOL_VEC2bvec2GL_BOOL_VEC3bvec3GL_BOOL_VEC4bvec4GL_FLOAT_MAT2mat2GL_FLOAT_MAT3mat3GL_FLOAT_MAT4mat4GL_FLOAT_MAT2x3mat2x3GL_FLOAT_MAT2x4mat2x4GL_FLOAT_MAT3x2mat3x2GL_FLOAT_MAT3x4mat3x4GL_FLOAT_MAT4x2mat4x2GL_FLOAT_MAT4x3mat4x3GL_DOUBLE_MAT2dmat2GL_DOUBLE_MAT3dmat3GL_DOUBLE_MAT4dmat4GL_DOUBLE_MAT2x3dmat2x3GL_DOUBLE_MAT2x4dmat2x4GL_DOUBLE_MAT3x2dmat3x2GL_DOUBLE_MAT3x4dmat3x4GL_DOUBLE_MAT4x2dmat4x2GL_DOUBLE_MAT4x3dmat4x3GL_SAMPLER_1Dsampler1DGL_SAMPLER_2Dsampler2DGL_SAMPLER_3Dsampler3DGL_SAMPLER_CUBEsamplerCubeGL_SAMPLER_1D_SHADOWsampler1DShadowGL_SAMPLER_2D_SHADOWsampler2DShadowGL_SAMPLER_1D_ARRAYsampler1DArrayGL_SAMPLER_2D_ARRAYsampler2DArrayGL_SAMPLER_1D_ARRAY_SHADOWsampler1DArrayShadowGL_SAMPLER_2D_ARRAY_SHADOWsampler2DArrayShadowGL_SAMPLER_2D_MULTISAMPLEsampler2DMSGL_SAMPLER_2D_MULTISAMPLE_ARRAYsampler2DMSArrayGL_SAMPLER_CUBE_SHADOWsamplerCubeShadowGL_SAMPLER_BUFFERsamplerBufferGL_SAMPLER_2D_RECTsampler2DRectGL_SAMPLER_2D_RECT_SHADOWsampler2DRectShadowGL_INT_SAMPLER_1Disampler1DGL_INT_SAMPLER_2Disampler2DGL_INT_SAMPLER_3Disampler3DGL_INT_SAMPLER_CUBEisamplerCubeGL_INT_SAMPLER_1D_ARRAYisampler1DArrayGL_INT_SAMPLER_2D_ARRAYisampler2DArrayGL_INT_SAMPLER_2D_MULTISAMPLEisampler2DMSGL_INT_SAMPLER_2D_MULTISAMPLE_ARRAYisampler2DMSArrayGL_INT_SAMPLER_BUFFERisamplerBufferGL_INT_SAMPLER_2D_RECTisampler2DRectGL_UNSIGNED_INT_SAMPLER_1Dusampler1DGL_UNSIGNED_INT_SAMPLER_2Dusampler2DGL_UNSIGNED_INT_SAMPLER_3Dusampler3DGL_UNSIGNED_INT_SAMPLER_CUBEusamplerCubeGL_UNSIGNED_INT_SAMPLER_1D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLEusampler2DMSGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAYusampler2DMSArrayGL_UNSIGNED_INT_SAMPLER_BUFFERusamplerBufferGL_UNSIGNED_INT_SAMPLER_2D_RECTusampler2DRectGL_IMAGE_1Dimage1DGL_IMAGE_2Dimage2DGL_IMAGE_3Dimage3DGL_IMAGE_2D_RECTimage2DRectGL_IMAGE_CUBEimageCubeGL_IMAGE_BUFFERimageBufferGL_IMAGE_1D_ARRAYimage1DArrayGL_IMAGE_2D_ARRAYimage2DArrayGL_IMAGE_2D_MULTISAMPLEimage2DMSGL_IMAGE_2D_MULTISAMPLE_ARRAYimage2DMSArrayGL_INT_IMAGE_1Diimage1DGL_INT_IMAGE_2Diimage2DGL_INT_IMAGE_3Diimage3DGL_INT_IMAGE_2D_RECTiimage2DRectGL_INT_IMAGE_CUBEiimageCubeGL_INT_IMAGE_BUFFERiimageBufferGL_INT_IMAGE_1D_ARRAYiimage1DArrayGL_INT_IMAGE_2D_ARRAYiimage2DArrayGL_INT_IMAGE_2D_MULTISAMPLEiimage2DMSGL_INT_IMAGE_2D_MULTISAMPLE_ARRAYiimage2DMSArrayGL_UNSIGNED_INT_IMAGE_1Duimage1DGL_UNSIGNED_INT_IMAGE_2Duimage2DGL_UNSIGNED_INT_IMAGE_3Duimage3DGL_UNSIGNED_INT_IMAGE_2D_RECTuimage2DRectGL_UNSIGNED_INT_IMAGE_CUBEuimageCubeGL_UNSIGNED_INT_IMAGE_BUFFERuimageBufferGL_UNSIGNED_INT_IMAGE_1D_ARRAYuimage1DArrayGL_UNSIGNED_INT_IMAGE_2D_ARRAYuimage2DArrayGL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLEuimage2DMSGL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAYuimage2DMSArrayGL_UNSIGNED_INT_ATOMIC_COUNTERatomic_uint
        /// If one or more elements of an array are active, the name    of the array is returned in name, the    type is returned in type, and the    size parameter returns the highest array    element index used, plus one, as determined by the compiler    and/or linker. Only one active uniform variable will be reported    for a uniform array.
        /// Uniform variables that are declared as structures or    arrays of structures will not be returned directly by this    function. Instead, each of these uniform variables will be    reduced to its fundamental components containing the    "." and "[]" operators such that each of the    names is valid as an argument to    glGetUniformLocation.    Each of these reduced uniform variables is counted as one active    uniform variable and is assigned an index. A valid name cannot    be a structure, an array of structures, or a subcomponent of a    vector or matrix.
        /// The size of the uniform variable will be returned in    size. Uniform variables other than arrays    will have a size of 1. Structures and arrays of structures will    be reduced as described earlier, such that each of the names    returned will be a data type in the earlier list. If this    reduction results in an array, the size returned will be as    described for uniform arrays; otherwise, the size returned will    be 1.
        /// The list of active uniform variables may include both    built-in uniform variables (which begin with the prefix    "gl_") as well as user-defined uniform variable    names.
        /// This function will return as much information as it can    about the specified active uniform variable. If no information    is available, length will be 0, and    name will be an empty string. This    situation could occur if this function is called after a link    operation that failed. If an error occurs, the return values    length, size,    type, and name    will be unmodified.
        /// </summary>
        /// <param name="program">Specifies the program object to be            queried.</param>
        /// <param name="index">Specifies the index of the uniform variable to            be queried.</param>
        /// <param name="bufSize">Specifies the maximum number of characters            OpenGL is allowed to write in the character buffer            indicated by name.</param>
        /// <param name="length">Returns the number of characters actually            written by OpenGL in the string indicated by            name (excluding the null            terminator) if a value other than            NULL is passed.</param>
        /// <param name="size">Returns the size of the uniform            variable.</param>
        /// <param name="type">Returns the data type of the uniform            variable.</param>
        /// <param name="name">Returns a null terminated string containing            the name of the uniform variable.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniform(uint program, uint index, int bufSize, out int length, out int size, out UniformType type, IntPtr name) => _GetActiveUniform_intptr(program, index, bufSize, out length, out size, out type, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniformARB(int programObj, uint index, int maxLength, out int length, out int size, out UniformType type, string name) => _GetActiveUniformARB(programObj, index, maxLength, out length, out size, out type, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniformARB(int programObj, uint index, int maxLength, out int length, out int size, out UniformType type, void* name) => _GetActiveUniformARB_ptr(programObj, index, maxLength, out length, out size, out type, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniformARB(int programObj, uint index, int maxLength, out int length, out int size, out UniformType type, IntPtr name) => _GetActiveUniformARB_intptr(programObj, index, maxLength, out length, out size, out type, name);

        // ---

        /// <summary>
        /// glGetActiveUniformBlockName retrieves the name of the active uniform block at uniformBlockIndex            within program.
        /// program must be the name of a program object for which the command            glLinkProgram must have been called in the past, although it is not required that            glLinkProgram must have succeeded. The link could have failed because the number            of active uniforms exceeded the limit.
        /// uniformBlockIndex is an active uniform block index of program, and must be less than the value            of GL_ACTIVE_UNIFORM_BLOCKS.
        /// Upon success, the name of the uniform block identified by unifomBlockIndex is returned into            uniformBlockName. The name is nul-terminated. The actual number of characters written into uniformBlockName,            excluding the nul terminator, is returned in length. If length is NULL, no length is returned.
        /// bufSize contains the maximum number of characters (including the nul terminator) that will be written into            uniformBlockName.
        /// If an error occurs, nothing will be written to uniformBlockName or length.
        /// </summary>
        /// <param name="program">Specifies the name of a program containing the uniform block.</param>
        /// <param name="uniformBlockIndex">Specifies the index of the uniform block within program.</param>
        /// <param name="bufSize">Specifies the size of the buffer addressed by uniformBlockName.</param>
        /// <param name="length">Specifies the address of a variable to receive the number of characters that were written to uniformBlockName.</param>
        /// <param name="uniformBlockName">Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, out int length, string uniformBlockName) => _GetActiveUniformBlockName(program, uniformBlockIndex, bufSize, out length, uniformBlockName);

        /// <summary>
        /// glGetActiveUniformBlockName retrieves the name of the active uniform block at uniformBlockIndex            within program.
        /// program must be the name of a program object for which the command            glLinkProgram must have been called in the past, although it is not required that            glLinkProgram must have succeeded. The link could have failed because the number            of active uniforms exceeded the limit.
        /// uniformBlockIndex is an active uniform block index of program, and must be less than the value            of GL_ACTIVE_UNIFORM_BLOCKS.
        /// Upon success, the name of the uniform block identified by unifomBlockIndex is returned into            uniformBlockName. The name is nul-terminated. The actual number of characters written into uniformBlockName,            excluding the nul terminator, is returned in length. If length is NULL, no length is returned.
        /// bufSize contains the maximum number of characters (including the nul terminator) that will be written into            uniformBlockName.
        /// If an error occurs, nothing will be written to uniformBlockName or length.
        /// </summary>
        /// <param name="program">Specifies the name of a program containing the uniform block.</param>
        /// <param name="uniformBlockIndex">Specifies the index of the uniform block within program.</param>
        /// <param name="bufSize">Specifies the size of the buffer addressed by uniformBlockName.</param>
        /// <param name="length">Specifies the address of a variable to receive the number of characters that were written to uniformBlockName.</param>
        /// <param name="uniformBlockName">Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, out int length, void* uniformBlockName) => _GetActiveUniformBlockName_ptr(program, uniformBlockIndex, bufSize, out length, uniformBlockName);

        /// <summary>
        /// glGetActiveUniformBlockName retrieves the name of the active uniform block at uniformBlockIndex            within program.
        /// program must be the name of a program object for which the command            glLinkProgram must have been called in the past, although it is not required that            glLinkProgram must have succeeded. The link could have failed because the number            of active uniforms exceeded the limit.
        /// uniformBlockIndex is an active uniform block index of program, and must be less than the value            of GL_ACTIVE_UNIFORM_BLOCKS.
        /// Upon success, the name of the uniform block identified by unifomBlockIndex is returned into            uniformBlockName. The name is nul-terminated. The actual number of characters written into uniformBlockName,            excluding the nul terminator, is returned in length. If length is NULL, no length is returned.
        /// bufSize contains the maximum number of characters (including the nul terminator) that will be written into            uniformBlockName.
        /// If an error occurs, nothing will be written to uniformBlockName or length.
        /// </summary>
        /// <param name="program">Specifies the name of a program containing the uniform block.</param>
        /// <param name="uniformBlockIndex">Specifies the index of the uniform block within program.</param>
        /// <param name="bufSize">Specifies the size of the buffer addressed by uniformBlockName.</param>
        /// <param name="length">Specifies the address of a variable to receive the number of characters that were written to uniformBlockName.</param>
        /// <param name="uniformBlockName">Specifies the address an array of characters to receive the name of the uniform block at uniformBlockIndex.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, out int length, IntPtr uniformBlockName) => _GetActiveUniformBlockName_intptr(program, uniformBlockIndex, bufSize, out length, uniformBlockName);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, UniformBlockPName pname, int[] @params) => _GetActiveUniformBlockiv(program, uniformBlockIndex, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, UniformBlockPName pname, void* @params) => _GetActiveUniformBlockiv_ptr(program, uniformBlockIndex, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, UniformBlockPName pname, IntPtr @params) => _GetActiveUniformBlockiv_intptr(program, uniformBlockIndex, pname, @params);

        // ---

        /// <summary>
        /// glGetActiveUniformName returns the name of the active uniform at uniformIndex within program.            If uniformName is not NULL, up to bufSize characters (including a nul-terminator) will be written into            the array whose address is specified by uniformName. If length is not NULL, the number of characters            that were (or would have been) written into uniformName (not including the nul-terminator) will be placed in the variable whose address            is specified in length. If length is NULL, no length is returned. The length of the longest uniform            name in program is given by the value of GL_ACTIVE_UNIFORM_MAX_LENGTH, which can be queried with            glGetProgram.
        /// If glGetActiveUniformName is not successful, nothing is written to length or uniformName.
        /// program must be the name of a program for which the command glLinkProgram            has been issued in the past. It is not necessary for program to have been linked successfully. The link could have failed because            the number of active uniforms exceeded the limit.
        /// uniformIndex must be an active uniform            index of the program program, in the            range zero to the value of            GL_ACTIVE_UNIFORMS minus one. The value of            GL_ACTIVE_UNIFORMS can be queried with            glGetProgram.
        /// </summary>
        /// <param name="program">Specifies the program containing the active uniform index uniformIndex.</param>
        /// <param name="uniformIndex">Specifies the index of the active uniform whose name to query.</param>
        /// <param name="bufSize">Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in uniformName.</param>
        /// <param name="length">Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by uniformName.</param>
        /// <param name="uniformName">Specifies the address of a buffer into which the GL will place the name of the active uniform at uniformIndex within program.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, out int length, string uniformName) => _GetActiveUniformName(program, uniformIndex, bufSize, out length, uniformName);

        /// <summary>
        /// glGetActiveUniformName returns the name of the active uniform at uniformIndex within program.            If uniformName is not NULL, up to bufSize characters (including a nul-terminator) will be written into            the array whose address is specified by uniformName. If length is not NULL, the number of characters            that were (or would have been) written into uniformName (not including the nul-terminator) will be placed in the variable whose address            is specified in length. If length is NULL, no length is returned. The length of the longest uniform            name in program is given by the value of GL_ACTIVE_UNIFORM_MAX_LENGTH, which can be queried with            glGetProgram.
        /// If glGetActiveUniformName is not successful, nothing is written to length or uniformName.
        /// program must be the name of a program for which the command glLinkProgram            has been issued in the past. It is not necessary for program to have been linked successfully. The link could have failed because            the number of active uniforms exceeded the limit.
        /// uniformIndex must be an active uniform            index of the program program, in the            range zero to the value of            GL_ACTIVE_UNIFORMS minus one. The value of            GL_ACTIVE_UNIFORMS can be queried with            glGetProgram.
        /// </summary>
        /// <param name="program">Specifies the program containing the active uniform index uniformIndex.</param>
        /// <param name="uniformIndex">Specifies the index of the active uniform whose name to query.</param>
        /// <param name="bufSize">Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in uniformName.</param>
        /// <param name="length">Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by uniformName.</param>
        /// <param name="uniformName">Specifies the address of a buffer into which the GL will place the name of the active uniform at uniformIndex within program.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, out int length, void* uniformName) => _GetActiveUniformName_ptr(program, uniformIndex, bufSize, out length, uniformName);

        /// <summary>
        /// glGetActiveUniformName returns the name of the active uniform at uniformIndex within program.            If uniformName is not NULL, up to bufSize characters (including a nul-terminator) will be written into            the array whose address is specified by uniformName. If length is not NULL, the number of characters            that were (or would have been) written into uniformName (not including the nul-terminator) will be placed in the variable whose address            is specified in length. If length is NULL, no length is returned. The length of the longest uniform            name in program is given by the value of GL_ACTIVE_UNIFORM_MAX_LENGTH, which can be queried with            glGetProgram.
        /// If glGetActiveUniformName is not successful, nothing is written to length or uniformName.
        /// program must be the name of a program for which the command glLinkProgram            has been issued in the past. It is not necessary for program to have been linked successfully. The link could have failed because            the number of active uniforms exceeded the limit.
        /// uniformIndex must be an active uniform            index of the program program, in the            range zero to the value of            GL_ACTIVE_UNIFORMS minus one. The value of            GL_ACTIVE_UNIFORMS can be queried with            glGetProgram.
        /// </summary>
        /// <param name="program">Specifies the program containing the active uniform index uniformIndex.</param>
        /// <param name="uniformIndex">Specifies the index of the active uniform whose name to query.</param>
        /// <param name="bufSize">Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in uniformName.</param>
        /// <param name="length">Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by uniformName.</param>
        /// <param name="uniformName">Specifies the address of a buffer into which the GL will place the name of the active uniform at uniformIndex within program.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, out int length, IntPtr uniformName) => _GetActiveUniformName_intptr(program, uniformIndex, bufSize, out length, uniformName);

        // ---

        /// <summary>
        /// glGetActiveUniformsiv queries the value of            the parameter named pname for each of the            uniforms within program whose indices are            specified in the array of uniformCount            unsigned integers uniformIndices. Upon            success, the value of the parameter for each uniform is written            into the corresponding entry in the array whose address is given            in params. If an error is generated,            nothing is written into params.
        /// If pname is            GL_UNIFORM_TYPE, then an array identifying            the types of uniforms specified by the corresponding array of            uniformIndices is returned. The returned            types can be any of the values from the following table:         Returned Symbolic Contant  Shader Uniform Type GL_FLOATfloatGL_FLOAT_VEC2vec2GL_FLOAT_VEC3vec3GL_FLOAT_VEC4vec4GL_DOUBLEdoubleGL_DOUBLE_VEC2dvec2GL_DOUBLE_VEC3dvec3GL_DOUBLE_VEC4dvec4GL_INTintGL_INT_VEC2ivec2GL_INT_VEC3ivec3GL_INT_VEC4ivec4GL_UNSIGNED_INTunsigned intGL_UNSIGNED_INT_VEC2uvec2GL_UNSIGNED_INT_VEC3uvec3GL_UNSIGNED_INT_VEC4uvec4GL_BOOLboolGL_BOOL_VEC2bvec2GL_BOOL_VEC3bvec3GL_BOOL_VEC4bvec4GL_FLOAT_MAT2mat2GL_FLOAT_MAT3mat3GL_FLOAT_MAT4mat4GL_FLOAT_MAT2x3mat2x3GL_FLOAT_MAT2x4mat2x4GL_FLOAT_MAT3x2mat3x2GL_FLOAT_MAT3x4mat3x4GL_FLOAT_MAT4x2mat4x2GL_FLOAT_MAT4x3mat4x3GL_DOUBLE_MAT2dmat2GL_DOUBLE_MAT3dmat3GL_DOUBLE_MAT4dmat4GL_DOUBLE_MAT2x3dmat2x3GL_DOUBLE_MAT2x4dmat2x4GL_DOUBLE_MAT3x2dmat3x2GL_DOUBLE_MAT3x4dmat3x4GL_DOUBLE_MAT4x2dmat4x2GL_DOUBLE_MAT4x3dmat4x3GL_SAMPLER_1Dsampler1DGL_SAMPLER_2Dsampler2DGL_SAMPLER_3Dsampler3DGL_SAMPLER_CUBEsamplerCubeGL_SAMPLER_1D_SHADOWsampler1DShadowGL_SAMPLER_2D_SHADOWsampler2DShadowGL_SAMPLER_1D_ARRAYsampler1DArrayGL_SAMPLER_2D_ARRAYsampler2DArrayGL_SAMPLER_1D_ARRAY_SHADOWsampler1DArrayShadowGL_SAMPLER_2D_ARRAY_SHADOWsampler2DArrayShadowGL_SAMPLER_2D_MULTISAMPLEsampler2DMSGL_SAMPLER_2D_MULTISAMPLE_ARRAYsampler2DMSArrayGL_SAMPLER_CUBE_SHADOWsamplerCubeShadowGL_SAMPLER_BUFFERsamplerBufferGL_SAMPLER_2D_RECTsampler2DRectGL_SAMPLER_2D_RECT_SHADOWsampler2DRectShadowGL_INT_SAMPLER_1Disampler1DGL_INT_SAMPLER_2Disampler2DGL_INT_SAMPLER_3Disampler3DGL_INT_SAMPLER_CUBEisamplerCubeGL_INT_SAMPLER_1D_ARRAYisampler1DArrayGL_INT_SAMPLER_2D_ARRAYisampler2DArrayGL_INT_SAMPLER_2D_MULTISAMPLEisampler2DMSGL_INT_SAMPLER_2D_MULTISAMPLE_ARRAYisampler2DMSArrayGL_INT_SAMPLER_BUFFERisamplerBufferGL_INT_SAMPLER_2D_RECTisampler2DRectGL_UNSIGNED_INT_SAMPLER_1Dusampler1DGL_UNSIGNED_INT_SAMPLER_2Dusampler2DGL_UNSIGNED_INT_SAMPLER_3Dusampler3DGL_UNSIGNED_INT_SAMPLER_CUBEusamplerCubeGL_UNSIGNED_INT_SAMPLER_1D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLEusampler2DMSGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAYusampler2DMSArrayGL_UNSIGNED_INT_SAMPLER_BUFFERusamplerBufferGL_UNSIGNED_INT_SAMPLER_2D_RECTusampler2DRect
        /// If pname is GL_UNIFORM_SIZE, then an array identifying the            size of the uniforms specified by the corresponding array of uniformIndices is            returned. The sizes returned are in units of the type returned by a query of GL_UNIFORM_TYPE.            For active uniforms that are arrays, the size is the number of active elements in the array;            for all other uniforms, the size is one.
        /// If pname is GL_UNIFORM_NAME_LENGTH, then an array identifying the            length, including the terminating null character, of the uniform name strings specified by the corresponding            array of uniformIndices is returned.
        /// If pname is GL_UNIFORM_BLOCK_INDEX, then an array identifying the            uniform block index of each of the uniforms specified by the corresponding array of uniformIndices            is returned. The uniform block index of a uniform associated with the default uniform block is -1.
        /// If pname is GL_UNIFORM_OFFSET, then an array of uniform buffer            offsets is returned. For uniforms in a named uniform block, the returned value will be its offset, in basic            machine units, relative to the beginning of the uniform block in the buffer object data store.            For atomic counter uniforms, the returned value will be its offset relative to the beginning of its active            atomic counter buffer.            For all other uniforms, -1 will be returned.
        /// If pname is GL_UNIFORM_ARRAY_STRIDE, then an array identifying the            stride between elements of each of the uniforms specified by the corresponding array of            uniformIndices is returned.            For uniforms in named uniform blocks and for uniforms declared as atomic counters, the stride is the difference,            in basic machine units, of consecutive elements in an array, or zero for uniforms not declared as an array.            For all other uniforms, a stride of -1 will be returned.
        /// If pname is GL_UNIFORM_MATRIX_STRIDE, then an array identifying the stride            between columns of a column-major matrix or rows of a row-major matrix, in basic machine units, of each of the uniforms            specified by the corresponding array of uniformIndices is returned. The matrix stride of a            uniform associated with the default uniform block is -1. Note that this information only makes sense for uniforms            that are matrices. For uniforms that are not matrices, but are declared in a named uniform block, a matrix stride of            zero is returned.
        /// If pname is GL_UNIFORM_IS_ROW_MAJOR, then an array identifying whether each            of the uniforms specified by the corresponding array of uniformIndices is a row-major matrix or not is returned. A            value of one indicates a row-major matrix, and a value of zero indicates a column-major matrix, a matrix in the default            uniform block, or a non-matrix.
        /// If pname is GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX, then an array            identifying the active atomic counter buffer index of each of the uniforms specified by the corresponding array            of uniformIndices is returned. For uniforms other than atomic counters, the returned buffer            index is -1. The returned indices may be passed to glGetActiveAtomicCounterBufferiv            to query the properties of the associated buffer, and not necessarily the binding point specified in the uniform declaration.
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="uniformCount">Specifies both the number of elements in the array of            indices uniformIndices and the number of            parameters written to params upon            successful return.</param>
        /// <param name="uniformIndices">Specifies the address of an array of            uniformCount integers containing the            indices of uniforms within program whose            parameter pname should be queried.</param>
        /// <param name="pname">Specifies the property of each uniform in            uniformIndices that should be written            into the corresponding element of            params.</param>
        /// <param name="params">Specifies the address of an array of            uniformCount integers which are to            receive the value of pname for each            uniform in uniformIndices.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniformsiv(uint program, int uniformCount, uint[] uniformIndices, UniformPName pname, int[] @params) => _GetActiveUniformsiv(program, uniformCount, uniformIndices, pname, @params);

        /// <summary>
        /// glGetActiveUniformsiv queries the value of            the parameter named pname for each of the            uniforms within program whose indices are            specified in the array of uniformCount            unsigned integers uniformIndices. Upon            success, the value of the parameter for each uniform is written            into the corresponding entry in the array whose address is given            in params. If an error is generated,            nothing is written into params.
        /// If pname is            GL_UNIFORM_TYPE, then an array identifying            the types of uniforms specified by the corresponding array of            uniformIndices is returned. The returned            types can be any of the values from the following table:         Returned Symbolic Contant  Shader Uniform Type GL_FLOATfloatGL_FLOAT_VEC2vec2GL_FLOAT_VEC3vec3GL_FLOAT_VEC4vec4GL_DOUBLEdoubleGL_DOUBLE_VEC2dvec2GL_DOUBLE_VEC3dvec3GL_DOUBLE_VEC4dvec4GL_INTintGL_INT_VEC2ivec2GL_INT_VEC3ivec3GL_INT_VEC4ivec4GL_UNSIGNED_INTunsigned intGL_UNSIGNED_INT_VEC2uvec2GL_UNSIGNED_INT_VEC3uvec3GL_UNSIGNED_INT_VEC4uvec4GL_BOOLboolGL_BOOL_VEC2bvec2GL_BOOL_VEC3bvec3GL_BOOL_VEC4bvec4GL_FLOAT_MAT2mat2GL_FLOAT_MAT3mat3GL_FLOAT_MAT4mat4GL_FLOAT_MAT2x3mat2x3GL_FLOAT_MAT2x4mat2x4GL_FLOAT_MAT3x2mat3x2GL_FLOAT_MAT3x4mat3x4GL_FLOAT_MAT4x2mat4x2GL_FLOAT_MAT4x3mat4x3GL_DOUBLE_MAT2dmat2GL_DOUBLE_MAT3dmat3GL_DOUBLE_MAT4dmat4GL_DOUBLE_MAT2x3dmat2x3GL_DOUBLE_MAT2x4dmat2x4GL_DOUBLE_MAT3x2dmat3x2GL_DOUBLE_MAT3x4dmat3x4GL_DOUBLE_MAT4x2dmat4x2GL_DOUBLE_MAT4x3dmat4x3GL_SAMPLER_1Dsampler1DGL_SAMPLER_2Dsampler2DGL_SAMPLER_3Dsampler3DGL_SAMPLER_CUBEsamplerCubeGL_SAMPLER_1D_SHADOWsampler1DShadowGL_SAMPLER_2D_SHADOWsampler2DShadowGL_SAMPLER_1D_ARRAYsampler1DArrayGL_SAMPLER_2D_ARRAYsampler2DArrayGL_SAMPLER_1D_ARRAY_SHADOWsampler1DArrayShadowGL_SAMPLER_2D_ARRAY_SHADOWsampler2DArrayShadowGL_SAMPLER_2D_MULTISAMPLEsampler2DMSGL_SAMPLER_2D_MULTISAMPLE_ARRAYsampler2DMSArrayGL_SAMPLER_CUBE_SHADOWsamplerCubeShadowGL_SAMPLER_BUFFERsamplerBufferGL_SAMPLER_2D_RECTsampler2DRectGL_SAMPLER_2D_RECT_SHADOWsampler2DRectShadowGL_INT_SAMPLER_1Disampler1DGL_INT_SAMPLER_2Disampler2DGL_INT_SAMPLER_3Disampler3DGL_INT_SAMPLER_CUBEisamplerCubeGL_INT_SAMPLER_1D_ARRAYisampler1DArrayGL_INT_SAMPLER_2D_ARRAYisampler2DArrayGL_INT_SAMPLER_2D_MULTISAMPLEisampler2DMSGL_INT_SAMPLER_2D_MULTISAMPLE_ARRAYisampler2DMSArrayGL_INT_SAMPLER_BUFFERisamplerBufferGL_INT_SAMPLER_2D_RECTisampler2DRectGL_UNSIGNED_INT_SAMPLER_1Dusampler1DGL_UNSIGNED_INT_SAMPLER_2Dusampler2DGL_UNSIGNED_INT_SAMPLER_3Dusampler3DGL_UNSIGNED_INT_SAMPLER_CUBEusamplerCubeGL_UNSIGNED_INT_SAMPLER_1D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLEusampler2DMSGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAYusampler2DMSArrayGL_UNSIGNED_INT_SAMPLER_BUFFERusamplerBufferGL_UNSIGNED_INT_SAMPLER_2D_RECTusampler2DRect
        /// If pname is GL_UNIFORM_SIZE, then an array identifying the            size of the uniforms specified by the corresponding array of uniformIndices is            returned. The sizes returned are in units of the type returned by a query of GL_UNIFORM_TYPE.            For active uniforms that are arrays, the size is the number of active elements in the array;            for all other uniforms, the size is one.
        /// If pname is GL_UNIFORM_NAME_LENGTH, then an array identifying the            length, including the terminating null character, of the uniform name strings specified by the corresponding            array of uniformIndices is returned.
        /// If pname is GL_UNIFORM_BLOCK_INDEX, then an array identifying the            uniform block index of each of the uniforms specified by the corresponding array of uniformIndices            is returned. The uniform block index of a uniform associated with the default uniform block is -1.
        /// If pname is GL_UNIFORM_OFFSET, then an array of uniform buffer            offsets is returned. For uniforms in a named uniform block, the returned value will be its offset, in basic            machine units, relative to the beginning of the uniform block in the buffer object data store.            For atomic counter uniforms, the returned value will be its offset relative to the beginning of its active            atomic counter buffer.            For all other uniforms, -1 will be returned.
        /// If pname is GL_UNIFORM_ARRAY_STRIDE, then an array identifying the            stride between elements of each of the uniforms specified by the corresponding array of            uniformIndices is returned.            For uniforms in named uniform blocks and for uniforms declared as atomic counters, the stride is the difference,            in basic machine units, of consecutive elements in an array, or zero for uniforms not declared as an array.            For all other uniforms, a stride of -1 will be returned.
        /// If pname is GL_UNIFORM_MATRIX_STRIDE, then an array identifying the stride            between columns of a column-major matrix or rows of a row-major matrix, in basic machine units, of each of the uniforms            specified by the corresponding array of uniformIndices is returned. The matrix stride of a            uniform associated with the default uniform block is -1. Note that this information only makes sense for uniforms            that are matrices. For uniforms that are not matrices, but are declared in a named uniform block, a matrix stride of            zero is returned.
        /// If pname is GL_UNIFORM_IS_ROW_MAJOR, then an array identifying whether each            of the uniforms specified by the corresponding array of uniformIndices is a row-major matrix or not is returned. A            value of one indicates a row-major matrix, and a value of zero indicates a column-major matrix, a matrix in the default            uniform block, or a non-matrix.
        /// If pname is GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX, then an array            identifying the active atomic counter buffer index of each of the uniforms specified by the corresponding array            of uniformIndices is returned. For uniforms other than atomic counters, the returned buffer            index is -1. The returned indices may be passed to glGetActiveAtomicCounterBufferiv            to query the properties of the associated buffer, and not necessarily the binding point specified in the uniform declaration.
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="uniformCount">Specifies both the number of elements in the array of            indices uniformIndices and the number of            parameters written to params upon            successful return.</param>
        /// <param name="uniformIndices">Specifies the address of an array of            uniformCount integers containing the            indices of uniforms within program whose            parameter pname should be queried.</param>
        /// <param name="pname">Specifies the property of each uniform in            uniformIndices that should be written            into the corresponding element of            params.</param>
        /// <param name="params">Specifies the address of an array of            uniformCount integers which are to            receive the value of pname for each            uniform in uniformIndices.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniformsiv(uint program, int uniformCount, void* uniformIndices, UniformPName pname, void* @params) => _GetActiveUniformsiv_ptr(program, uniformCount, uniformIndices, pname, @params);

        /// <summary>
        /// glGetActiveUniformsiv queries the value of            the parameter named pname for each of the            uniforms within program whose indices are            specified in the array of uniformCount            unsigned integers uniformIndices. Upon            success, the value of the parameter for each uniform is written            into the corresponding entry in the array whose address is given            in params. If an error is generated,            nothing is written into params.
        /// If pname is            GL_UNIFORM_TYPE, then an array identifying            the types of uniforms specified by the corresponding array of            uniformIndices is returned. The returned            types can be any of the values from the following table:         Returned Symbolic Contant  Shader Uniform Type GL_FLOATfloatGL_FLOAT_VEC2vec2GL_FLOAT_VEC3vec3GL_FLOAT_VEC4vec4GL_DOUBLEdoubleGL_DOUBLE_VEC2dvec2GL_DOUBLE_VEC3dvec3GL_DOUBLE_VEC4dvec4GL_INTintGL_INT_VEC2ivec2GL_INT_VEC3ivec3GL_INT_VEC4ivec4GL_UNSIGNED_INTunsigned intGL_UNSIGNED_INT_VEC2uvec2GL_UNSIGNED_INT_VEC3uvec3GL_UNSIGNED_INT_VEC4uvec4GL_BOOLboolGL_BOOL_VEC2bvec2GL_BOOL_VEC3bvec3GL_BOOL_VEC4bvec4GL_FLOAT_MAT2mat2GL_FLOAT_MAT3mat3GL_FLOAT_MAT4mat4GL_FLOAT_MAT2x3mat2x3GL_FLOAT_MAT2x4mat2x4GL_FLOAT_MAT3x2mat3x2GL_FLOAT_MAT3x4mat3x4GL_FLOAT_MAT4x2mat4x2GL_FLOAT_MAT4x3mat4x3GL_DOUBLE_MAT2dmat2GL_DOUBLE_MAT3dmat3GL_DOUBLE_MAT4dmat4GL_DOUBLE_MAT2x3dmat2x3GL_DOUBLE_MAT2x4dmat2x4GL_DOUBLE_MAT3x2dmat3x2GL_DOUBLE_MAT3x4dmat3x4GL_DOUBLE_MAT4x2dmat4x2GL_DOUBLE_MAT4x3dmat4x3GL_SAMPLER_1Dsampler1DGL_SAMPLER_2Dsampler2DGL_SAMPLER_3Dsampler3DGL_SAMPLER_CUBEsamplerCubeGL_SAMPLER_1D_SHADOWsampler1DShadowGL_SAMPLER_2D_SHADOWsampler2DShadowGL_SAMPLER_1D_ARRAYsampler1DArrayGL_SAMPLER_2D_ARRAYsampler2DArrayGL_SAMPLER_1D_ARRAY_SHADOWsampler1DArrayShadowGL_SAMPLER_2D_ARRAY_SHADOWsampler2DArrayShadowGL_SAMPLER_2D_MULTISAMPLEsampler2DMSGL_SAMPLER_2D_MULTISAMPLE_ARRAYsampler2DMSArrayGL_SAMPLER_CUBE_SHADOWsamplerCubeShadowGL_SAMPLER_BUFFERsamplerBufferGL_SAMPLER_2D_RECTsampler2DRectGL_SAMPLER_2D_RECT_SHADOWsampler2DRectShadowGL_INT_SAMPLER_1Disampler1DGL_INT_SAMPLER_2Disampler2DGL_INT_SAMPLER_3Disampler3DGL_INT_SAMPLER_CUBEisamplerCubeGL_INT_SAMPLER_1D_ARRAYisampler1DArrayGL_INT_SAMPLER_2D_ARRAYisampler2DArrayGL_INT_SAMPLER_2D_MULTISAMPLEisampler2DMSGL_INT_SAMPLER_2D_MULTISAMPLE_ARRAYisampler2DMSArrayGL_INT_SAMPLER_BUFFERisamplerBufferGL_INT_SAMPLER_2D_RECTisampler2DRectGL_UNSIGNED_INT_SAMPLER_1Dusampler1DGL_UNSIGNED_INT_SAMPLER_2Dusampler2DGL_UNSIGNED_INT_SAMPLER_3Dusampler3DGL_UNSIGNED_INT_SAMPLER_CUBEusamplerCubeGL_UNSIGNED_INT_SAMPLER_1D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_ARRAYusampler2DArrayGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLEusampler2DMSGL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAYusampler2DMSArrayGL_UNSIGNED_INT_SAMPLER_BUFFERusamplerBufferGL_UNSIGNED_INT_SAMPLER_2D_RECTusampler2DRect
        /// If pname is GL_UNIFORM_SIZE, then an array identifying the            size of the uniforms specified by the corresponding array of uniformIndices is            returned. The sizes returned are in units of the type returned by a query of GL_UNIFORM_TYPE.            For active uniforms that are arrays, the size is the number of active elements in the array;            for all other uniforms, the size is one.
        /// If pname is GL_UNIFORM_NAME_LENGTH, then an array identifying the            length, including the terminating null character, of the uniform name strings specified by the corresponding            array of uniformIndices is returned.
        /// If pname is GL_UNIFORM_BLOCK_INDEX, then an array identifying the            uniform block index of each of the uniforms specified by the corresponding array of uniformIndices            is returned. The uniform block index of a uniform associated with the default uniform block is -1.
        /// If pname is GL_UNIFORM_OFFSET, then an array of uniform buffer            offsets is returned. For uniforms in a named uniform block, the returned value will be its offset, in basic            machine units, relative to the beginning of the uniform block in the buffer object data store.            For atomic counter uniforms, the returned value will be its offset relative to the beginning of its active            atomic counter buffer.            For all other uniforms, -1 will be returned.
        /// If pname is GL_UNIFORM_ARRAY_STRIDE, then an array identifying the            stride between elements of each of the uniforms specified by the corresponding array of            uniformIndices is returned.            For uniforms in named uniform blocks and for uniforms declared as atomic counters, the stride is the difference,            in basic machine units, of consecutive elements in an array, or zero for uniforms not declared as an array.            For all other uniforms, a stride of -1 will be returned.
        /// If pname is GL_UNIFORM_MATRIX_STRIDE, then an array identifying the stride            between columns of a column-major matrix or rows of a row-major matrix, in basic machine units, of each of the uniforms            specified by the corresponding array of uniformIndices is returned. The matrix stride of a            uniform associated with the default uniform block is -1. Note that this information only makes sense for uniforms            that are matrices. For uniforms that are not matrices, but are declared in a named uniform block, a matrix stride of            zero is returned.
        /// If pname is GL_UNIFORM_IS_ROW_MAJOR, then an array identifying whether each            of the uniforms specified by the corresponding array of uniformIndices is a row-major matrix or not is returned. A            value of one indicates a row-major matrix, and a value of zero indicates a column-major matrix, a matrix in the default            uniform block, or a non-matrix.
        /// If pname is GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX, then an array            identifying the active atomic counter buffer index of each of the uniforms specified by the corresponding array            of uniformIndices is returned. For uniforms other than atomic counters, the returned buffer            index is -1. The returned indices may be passed to glGetActiveAtomicCounterBufferiv            to query the properties of the associated buffer, and not necessarily the binding point specified in the uniform declaration.
        /// </summary>
        /// <param name="program">Specifies the program object to be queried.</param>
        /// <param name="uniformCount">Specifies both the number of elements in the array of            indices uniformIndices and the number of            parameters written to params upon            successful return.</param>
        /// <param name="uniformIndices">Specifies the address of an array of            uniformCount integers containing the            indices of uniforms within program whose            parameter pname should be queried.</param>
        /// <param name="pname">Specifies the property of each uniform in            uniformIndices that should be written            into the corresponding element of            params.</param>
        /// <param name="params">Specifies the address of an array of            uniformCount integers which are to            receive the value of pname for each            uniform in uniformIndices.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveUniformsiv(uint program, int uniformCount, IntPtr uniformIndices, UniformPName pname, IntPtr @params) => _GetActiveUniformsiv_intptr(program, uniformCount, uniformIndices, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveVaryingNV(uint program, uint index, int bufSize, out int length, out int size, out int type, string name) => _GetActiveVaryingNV(program, index, bufSize, out length, out size, out type, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveVaryingNV(uint program, uint index, int bufSize, out int length, out int size, out int type, void* name) => _GetActiveVaryingNV_ptr(program, index, bufSize, out length, out size, out type, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetActiveVaryingNV(uint program, uint index, int bufSize, out int length, out int size, out int type, IntPtr name) => _GetActiveVaryingNV_intptr(program, index, bufSize, out length, out size, out type, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetArrayObjectfvATI(EnableCap array, ArrayObjectPNameATI pname, out float @params) => _GetArrayObjectfvATI(array, pname, out @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetArrayObjectivATI(EnableCap array, ArrayObjectPNameATI pname, out int @params) => _GetArrayObjectivATI(array, pname, out @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetAttachedObjectsARB(int containerObj, int maxCount, out int count, int[] obj) => _GetAttachedObjectsARB(containerObj, maxCount, out count, obj);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetAttachedObjectsARB(int containerObj, int maxCount, out int count, void* obj) => _GetAttachedObjectsARB_ptr(containerObj, maxCount, out count, obj);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetAttachedObjectsARB(int containerObj, int maxCount, out int count, IntPtr obj) => _GetAttachedObjectsARB_intptr(containerObj, maxCount, out count, obj);

        // ---

        /// <summary>
        /// glGetAttachedShaders returns the    names of the shader objects attached to    program. The names of shader objects that    are attached to program will be returned    in shaders. The actual number of shader    names written into shaders is returned in    count. If no shader objects are attached    to program, count    is set to 0. The maximum number of shader names that may be    returned in shaders is specified by    maxCount.
        /// If the number of names actually returned is not required    (for instance, if it has just been obtained by calling    glGetProgram),    a value of NULL may be passed for count. If    no shader objects are attached to    program, a value of 0 will be returned in    count. The actual number of attached    shaders can be obtained by calling    glGetProgram    with the value GL_ATTACHED_SHADERS.
        /// </summary>
        /// <param name="program">Specifies the program object to be            queried.</param>
        /// <param name="maxCount">Specifies the size of the array for storing            the returned object names.</param>
        /// <param name="count">Returns the number of names actually returned            in shaders.</param>
        /// <param name="shaders">Specifies an array that is used to return the            names of attached shader objects.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetAttachedShaders(uint program, int maxCount, out int count, uint[] shaders) => _GetAttachedShaders(program, maxCount, out count, shaders);

        /// <summary>
        /// glGetAttachedShaders returns the    names of the shader objects attached to    program. The names of shader objects that    are attached to program will be returned    in shaders. The actual number of shader    names written into shaders is returned in    count. If no shader objects are attached    to program, count    is set to 0. The maximum number of shader names that may be    returned in shaders is specified by    maxCount.
        /// If the number of names actually returned is not required    (for instance, if it has just been obtained by calling    glGetProgram),    a value of NULL may be passed for count. If    no shader objects are attached to    program, a value of 0 will be returned in    count. The actual number of attached    shaders can be obtained by calling    glGetProgram    with the value GL_ATTACHED_SHADERS.
        /// </summary>
        /// <param name="program">Specifies the program object to be            queried.</param>
        /// <param name="maxCount">Specifies the size of the array for storing            the returned object names.</param>
        /// <param name="count">Returns the number of names actually returned            in shaders.</param>
        /// <param name="shaders">Specifies an array that is used to return the            names of attached shader objects.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetAttachedShaders(uint program, int maxCount, out int count, void* shaders) => _GetAttachedShaders_ptr(program, maxCount, out count, shaders);

        /// <summary>
        /// glGetAttachedShaders returns the    names of the shader objects attached to    program. The names of shader objects that    are attached to program will be returned    in shaders. The actual number of shader    names written into shaders is returned in    count. If no shader objects are attached    to program, count    is set to 0. The maximum number of shader names that may be    returned in shaders is specified by    maxCount.
        /// If the number of names actually returned is not required    (for instance, if it has just been obtained by calling    glGetProgram),    a value of NULL may be passed for count. If    no shader objects are attached to    program, a value of 0 will be returned in    count. The actual number of attached    shaders can be obtained by calling    glGetProgram    with the value GL_ATTACHED_SHADERS.
        /// </summary>
        /// <param name="program">Specifies the program object to be            queried.</param>
        /// <param name="maxCount">Specifies the size of the array for storing            the returned object names.</param>
        /// <param name="count">Returns the number of names actually returned            in shaders.</param>
        /// <param name="shaders">Specifies an array that is used to return the            names of attached shader objects.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetAttachedShaders(uint program, int maxCount, out int count, IntPtr shaders) => _GetAttachedShaders_intptr(program, maxCount, out count, shaders);

        // ---

        /// <summary>
        /// glGetAttribLocation queries the    previously linked program object specified by    program for the attribute variable    specified by name and returns the index    of the generic vertex attribute that is bound to that attribute    variable. If name is a matrix attribute    variable, the index of the first column of the matrix is    returned. If the named attribute variable is not an active    attribute in the specified program object or if    name starts with the reserved prefix    "gl_", a value of -1 is returned.
        /// The association between an attribute variable name and a    generic attribute index can be specified at any time by calling    glBindAttribLocation.    Attribute bindings do not go into effect until    glLinkProgram    is called. After a program object has been linked successfully,    the index values for attribute variables remain fixed until the    next link command occurs. The attribute values can only be    queried after a link if the link was successful.    glGetAttribLocation returns the binding    that actually went into effect the last time    glLinkProgram    was called for the specified program object. Attribute bindings    that have been specified since the last link operation are not    returned by glGetAttribLocation.
        /// </summary>
        /// <param name="program">Specifies the program object to be            queried.</param>
        /// <param name="name">Points to a null terminated string containing            the name of the attribute variable whose location is            to be queried.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetAttribLocation(uint program, string name) => _GetAttribLocation(program, name);

        /// <summary>
        /// glGetAttribLocation queries the    previously linked program object specified by    program for the attribute variable    specified by name and returns the index    of the generic vertex attribute that is bound to that attribute    variable. If name is a matrix attribute    variable, the index of the first column of the matrix is    returned. If the named attribute variable is not an active    attribute in the specified program object or if    name starts with the reserved prefix    "gl_", a value of -1 is returned.
        /// The association between an attribute variable name and a    generic attribute index can be specified at any time by calling    glBindAttribLocation.    Attribute bindings do not go into effect until    glLinkProgram    is called. After a program object has been linked successfully,    the index values for attribute variables remain fixed until the    next link command occurs. The attribute values can only be    queried after a link if the link was successful.    glGetAttribLocation returns the binding    that actually went into effect the last time    glLinkProgram    was called for the specified program object. Attribute bindings    that have been specified since the last link operation are not    returned by glGetAttribLocation.
        /// </summary>
        /// <param name="program">Specifies the program object to be            queried.</param>
        /// <param name="name">Points to a null terminated string containing            the name of the attribute variable whose location is            to be queried.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetAttribLocation(uint program, void* name) => _GetAttribLocation_ptr(program, name);

        /// <summary>
        /// glGetAttribLocation queries the    previously linked program object specified by    program for the attribute variable    specified by name and returns the index    of the generic vertex attribute that is bound to that attribute    variable. If name is a matrix attribute    variable, the index of the first column of the matrix is    returned. If the named attribute variable is not an active    attribute in the specified program object or if    name starts with the reserved prefix    "gl_", a value of -1 is returned.
        /// The association between an attribute variable name and a    generic attribute index can be specified at any time by calling    glBindAttribLocation.    Attribute bindings do not go into effect until    glLinkProgram    is called. After a program object has been linked successfully,    the index values for attribute variables remain fixed until the    next link command occurs. The attribute values can only be    queried after a link if the link was successful.    glGetAttribLocation returns the binding    that actually went into effect the last time    glLinkProgram    was called for the specified program object. Attribute bindings    that have been specified since the last link operation are not    returned by glGetAttribLocation.
        /// </summary>
        /// <param name="program">Specifies the program object to be            queried.</param>
        /// <param name="name">Points to a null terminated string containing            the name of the attribute variable whose location is            to be queried.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetAttribLocation(uint program, IntPtr name) => _GetAttribLocation_intptr(program, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetAttribLocationARB(int programObj, string name) => _GetAttribLocationARB(programObj, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetAttribLocationARB(int programObj, void* name) => _GetAttribLocationARB_ptr(programObj, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetAttribLocationARB(int programObj, IntPtr name) => _GetAttribLocationARB_intptr(programObj, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBooleanIndexedvEXT(BufferTargetARB target, uint index, bool[] data) => _GetBooleanIndexedvEXT(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBooleanIndexedvEXT(BufferTargetARB target, uint index, void* data) => _GetBooleanIndexedvEXT_ptr(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBooleanIndexedvEXT(BufferTargetARB target, uint index, IntPtr data) => _GetBooleanIndexedvEXT_intptr(target, index, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBooleani_v(BufferTargetARB target, uint index, bool[] data) => _GetBooleani_v(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBooleani_v(BufferTargetARB target, uint index, void* data) => _GetBooleani_v_ptr(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBooleani_v(BufferTargetARB target, uint index, IntPtr data) => _GetBooleani_v_intptr(target, index, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBooleanv(GetPName pname, bool[] data) => _GetBooleanv(pname, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBooleanv(GetPName pname, void* data) => _GetBooleanv_ptr(pname, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBooleanv(GetPName pname, IntPtr data) => _GetBooleanv_intptr(pname, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferParameteri64v(BufferTargetARB target, BufferPNameARB pname, Int64[] @params) => _GetBufferParameteri64v(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferParameteri64v(BufferTargetARB target, BufferPNameARB pname, void* @params) => _GetBufferParameteri64v_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferParameteri64v(BufferTargetARB target, BufferPNameARB pname, IntPtr @params) => _GetBufferParameteri64v_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferParameteriv(BufferTargetARB target, BufferPNameARB pname, int[] @params) => _GetBufferParameteriv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferParameteriv(BufferTargetARB target, BufferPNameARB pname, void* @params) => _GetBufferParameteriv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferParameteriv(BufferTargetARB target, BufferPNameARB pname, IntPtr @params) => _GetBufferParameteriv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferParameterivARB(BufferTargetARB target, BufferPNameARB pname, int[] @params) => _GetBufferParameterivARB(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferParameterivARB(BufferTargetARB target, BufferPNameARB pname, void* @params) => _GetBufferParameterivARB_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferParameterivARB(BufferTargetARB target, BufferPNameARB pname, IntPtr @params) => _GetBufferParameterivARB_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferParameterui64vNV(BufferTargetARB target, int pname, UInt64[] @params) => _GetBufferParameterui64vNV(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferParameterui64vNV(BufferTargetARB target, int pname, void* @params) => _GetBufferParameterui64vNV_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferParameterui64vNV(BufferTargetARB target, int pname, IntPtr @params) => _GetBufferParameterui64vNV_intptr(target, pname, @params);

        // ---

        /// <summary>
        /// glGetBufferPointerv and            glGetNamedBufferPointerv return the buffer            pointer pname, which must be            GL_BUFFER_MAP_POINTER. The single buffer            map pointer is returned in params. A            NULL pointer is returned if the buffer            object's data store is not currently mapped; or if the            requesting context did not map the buffer object's data store,            and the implementation is unable to support mappings on multiple            clients.
        /// </summary>
        /// <param name="target">Specifies the target to which the buffer object is bound                    for glGetBufferPointerv, which must                    be one of the buffer binding targets in the following                    table:</param>
        /// <param name="buffer">Specifies the name of the buffer object for                    glGetNamedBufferPointerv.</param>
        /// <param name="pname">Specifies the name of the pointer to be returned. Must                    be GL_BUFFER_MAP_POINTER.</param>
        /// <param name="params">Returns the pointer value specified by                    pname.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferPointerv(BufferTargetARB target, BufferPointerNameARB pname, IntPtr* @params) => _GetBufferPointerv(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferPointervARB(BufferTargetARB target, BufferPointerNameARB pname, IntPtr* @params) => _GetBufferPointervARB(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferPointervOES(BufferTargetARB target, BufferPointerNameARB pname, IntPtr* @params) => _GetBufferPointervOES(target, pname, @params);

        // ---

        /// <summary>
        /// glGetBufferSubData and            glGetNamedBufferSubData return some or all            of the data contents of the data store of the specified buffer            object. Data starting at byte offset            offset and extending for            size bytes is copied from the buffer            object's data store to the memory pointed to by            data. An error is thrown if the buffer            object is currently mapped, or if offset            and size together define a range beyond            the bounds of the buffer object's data store.
        /// </summary>
        /// <param name="target">Specifies the target to which the buffer object is bound                    for glGetBufferSubData, which must                    be one of the buffer binding targets in the following                    table:</param>
        /// <param name="buffer">Specifies the name of the buffer object for                    glGetNamedBufferSubData.</param>
        /// <param name="offset">Specifies the offset into the buffer object's data store                    from which data will be returned, measured in bytes.</param>
        /// <param name="size">Specifies the size in bytes of the data store region being returned.</param>
        /// <param name="data">Specifies a pointer to the location where buffer object data is returned.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferSubData(BufferTargetARB target, IntPtr offset, IntPtr size, IntPtr data) => _GetBufferSubData(target, offset, size, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetBufferSubDataARB(BufferTargetARB target, IntPtr offset, IntPtr size, IntPtr data) => _GetBufferSubDataARB(target, offset, size, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetClipPlane(ClipPlaneName plane, double[] equation) => _GetClipPlane(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetClipPlane(ClipPlaneName plane, void* equation) => _GetClipPlane_ptr(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetClipPlane(ClipPlaneName plane, IntPtr equation) => _GetClipPlane_intptr(plane, equation);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetClipPlanef(ClipPlaneName plane, float[] equation) => _GetClipPlanef(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetClipPlanef(ClipPlaneName plane, void* equation) => _GetClipPlanef_ptr(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetClipPlanef(ClipPlaneName plane, IntPtr equation) => _GetClipPlanef_intptr(plane, equation);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetClipPlanefOES(ClipPlaneName plane, float[] equation) => _GetClipPlanefOES(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetClipPlanefOES(ClipPlaneName plane, void* equation) => _GetClipPlanefOES_ptr(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetClipPlanefOES(ClipPlaneName plane, IntPtr equation) => _GetClipPlanefOES_intptr(plane, equation);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetClipPlanex(ClipPlaneName plane, float[] equation) => _GetClipPlanex(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetClipPlanex(ClipPlaneName plane, void* equation) => _GetClipPlanex_ptr(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetClipPlanex(ClipPlaneName plane, IntPtr equation) => _GetClipPlanex_intptr(plane, equation);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetClipPlanexOES(ClipPlaneName plane, float[] equation) => _GetClipPlanexOES(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetClipPlanexOES(ClipPlaneName plane, void* equation) => _GetClipPlanexOES_ptr(plane, equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetClipPlanexOES(ClipPlaneName plane, IntPtr equation) => _GetClipPlanexOES_intptr(plane, equation);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTable(ColorTableTarget target, PixelFormat format, PixelType type, IntPtr table) => _GetColorTable(target, format, type, table);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableEXT(ColorTableTarget target, PixelFormat format, PixelType type, IntPtr data) => _GetColorTableEXT(target, format, type, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameterfv(ColorTableTarget target, GetColorTableParameterPNameSGI pname, float[] @params) => _GetColorTableParameterfv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameterfv(ColorTableTarget target, GetColorTableParameterPNameSGI pname, void* @params) => _GetColorTableParameterfv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameterfv(ColorTableTarget target, GetColorTableParameterPNameSGI pname, IntPtr @params) => _GetColorTableParameterfv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameterfvEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, float[] @params) => _GetColorTableParameterfvEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameterfvEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, void* @params) => _GetColorTableParameterfvEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameterfvEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, IntPtr @params) => _GetColorTableParameterfvEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameterfvSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, float[] @params) => _GetColorTableParameterfvSGI(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameterfvSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, void* @params) => _GetColorTableParameterfvSGI_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameterfvSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, IntPtr @params) => _GetColorTableParameterfvSGI_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameteriv(ColorTableTarget target, GetColorTableParameterPNameSGI pname, int[] @params) => _GetColorTableParameteriv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameteriv(ColorTableTarget target, GetColorTableParameterPNameSGI pname, void* @params) => _GetColorTableParameteriv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameteriv(ColorTableTarget target, GetColorTableParameterPNameSGI pname, IntPtr @params) => _GetColorTableParameteriv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameterivEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, int[] @params) => _GetColorTableParameterivEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameterivEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, void* @params) => _GetColorTableParameterivEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameterivEXT(ColorTableTarget target, GetColorTableParameterPNameSGI pname, IntPtr @params) => _GetColorTableParameterivEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameterivSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, int[] @params) => _GetColorTableParameterivSGI(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameterivSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, void* @params) => _GetColorTableParameterivSGI_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableParameterivSGI(ColorTableTargetSGI target, GetColorTableParameterPNameSGI pname, IntPtr @params) => _GetColorTableParameterivSGI_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetColorTableSGI(ColorTableTargetSGI target, PixelFormat format, PixelType type, IntPtr table) => _GetColorTableSGI(target, format, type, table);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCombinerInputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, float[] @params) => _GetCombinerInputParameterfvNV(stage, portion, variable, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCombinerInputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, void* @params) => _GetCombinerInputParameterfvNV_ptr(stage, portion, variable, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCombinerInputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, IntPtr @params) => _GetCombinerInputParameterfvNV_intptr(stage, portion, variable, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCombinerInputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, int[] @params) => _GetCombinerInputParameterivNV(stage, portion, variable, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCombinerInputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, void* @params) => _GetCombinerInputParameterivNV_ptr(stage, portion, variable, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCombinerInputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerVariableNV variable, CombinerParameterNV pname, IntPtr @params) => _GetCombinerInputParameterivNV_intptr(stage, portion, variable, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCombinerOutputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, float[] @params) => _GetCombinerOutputParameterfvNV(stage, portion, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCombinerOutputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, void* @params) => _GetCombinerOutputParameterfvNV_ptr(stage, portion, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCombinerOutputParameterfvNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, IntPtr @params) => _GetCombinerOutputParameterfvNV_intptr(stage, portion, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCombinerOutputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, int[] @params) => _GetCombinerOutputParameterivNV(stage, portion, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCombinerOutputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, void* @params) => _GetCombinerOutputParameterivNV_ptr(stage, portion, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCombinerOutputParameterivNV(CombinerStageNV stage, CombinerPortionNV portion, CombinerParameterNV pname, IntPtr @params) => _GetCombinerOutputParameterivNV_intptr(stage, portion, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, float[] @params) => _GetCombinerStageParameterfvNV(stage, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, void* @params) => _GetCombinerStageParameterfvNV_ptr(stage, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCombinerStageParameterfvNV(CombinerStageNV stage, CombinerParameterNV pname, IntPtr @params) => _GetCombinerStageParameterfvNV_intptr(stage, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetCommandHeaderNV(int tokenID, uint size) => _GetCommandHeaderNV(tokenID, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCompressedMultiTexImageEXT(TextureUnit texunit, TextureTarget target, int lod, IntPtr img) => _GetCompressedMultiTexImageEXT(texunit, target, lod, img);

        // ---

        /// <summary>
        /// glGetCompressedTexImage and    glGetnCompressedTexImage return the compressed    texture image associated with target and    lod into pixels.    glGetCompressedTextureImage serves the same purpose,    but instead of taking a texture target, it takes the ID of the texture    object. pixels should be an array of    bufSize bytes for    glGetnCompresedTexImage and    glGetCompressedTextureImage functions, and of    GL_TEXTURE_COMPRESSED_IMAGE_SIZE bytes in case of    glGetCompressedTexImage. If the actual data takes    less space than bufSize, the remaining bytes will    not be touched. target specifies the texture    target, to which the texture the data the function should extract the data    from is bound to. lod specifies the level-of-detail    number of the desired image.
        /// If a non-zero named buffer object is bound to the    GL_PIXEL_PACK_BUFFER target (see    glBindBuffer) while a texture image is requested,    pixels is treated as a byte offset into the buffer    object's data store.
        /// To minimize errors, first verify that the texture is compressed by    calling glGetTexLevelParameter with argument    GL_TEXTURE_COMPRESSED. If the texture is compressed,    you can determine the amount of memory required to store the compressed    texture by calling glGetTexLevelParameter with argument    GL_TEXTURE_COMPRESSED_IMAGE_SIZE. Finally, retrieve    the internal format of the texture by calling glGetTexLevelParameter with argument    GL_TEXTURE_INTERNAL_FORMAT. To store the texture for    later use, associate the internal format and size with the retrieved    texture image. These data can be used by the respective texture or    subtexture loading routine used for loading target    textures.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture is bound for          glGetCompressedTexImage and          glGetnCompressedTexImage functions.          GL_TEXTURE_1D,          GL_TEXTURE_1D_ARRAY,          GL_TEXTURE_2D,          GL_TEXTURE_2D_ARRAY,          GL_TEXTURE_3D,          GL_TEXTURE_CUBE_MAP_ARRAY,          GL_TEXTURE_CUBE_MAP_POSITIVE_X,          GL_TEXTURE_CUBE_MAP_NEGATIVE_X,          GL_TEXTURE_CUBE_MAP_POSITIVE_Y,          GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,          GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and          GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,          GL_TEXTURE_RECTANGLE are accepted.</param>
        /// <param name="texture">Specifies the texture object name for          glGetCompressedTextureImage function.</param>
        /// <param name="level">Specifies the level-of-detail number of the desired image.          Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.</param>
        /// <param name="bufSize">Specifies the size of the buffer pixels          for glGetCompressedTextureImage and          glGetnCompressedTexImage functions.</param>
        /// <param name="pixels">Returns the compressed texture image.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCompressedTexImage(TextureTarget target, int level, IntPtr img) => _GetCompressedTexImage(target, level, img);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCompressedTexImageARB(TextureTarget target, int level, IntPtr img) => _GetCompressedTexImageARB(target, level, img);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCompressedTextureImage(uint texture, int level, int bufSize, IntPtr pixels) => _GetCompressedTextureImage(texture, level, bufSize, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCompressedTextureImageEXT(uint texture, TextureTarget target, int lod, IntPtr img) => _GetCompressedTextureImageEXT(texture, target, lod, img);

        // ---

        /// <summary>
        /// glGetCompressedTextureSubImage can be used to    obtain a sub-region of a compressed texture image instead of the whole    image, as long as the compressed data are arranged into fixed-size blocks    of texels. texture is the name of the texture    object, and must not be a buffer or multisample texture. The effective    target is the value of    GL_TEXTURE_TARGET for texture.    level and pixels have the    same meaning as the corresponding arguments of    glCompressedTexSubImage3D.    bufSize indicates the size of the buffer to receive    the retrieved pixel data.
        /// For cube map textures, the behavior is as though    glGetCompressedTexImage were called once for each    requested face (selected by zoffset and    depth, as described below) with target    corresponding to the requested texture cube map face as indicated by the    table presented below. pixels is offset    appropriately for each successive image.
        /// Layer numberCube Map Face0GL_TEXTURE_CUBE_MAP_POSITIVE_X1GL_TEXTURE_CUBE_MAP_NEGATIVE_X2GL_TEXTURE_CUBE_MAP_POSITIVE_Y3GL_TEXTURE_CUBE_MAP_NEGATIVE_Y4GL_TEXTURE_CUBE_MAP_POSITIVE_Z5GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
        /// xoffset, yoffset and    zoffset indicate the position of the subregion to    return. width, height and    depth indicate the size of the region to return.    These arguments have the same meaning as for    glCompressedTexSubImage3D, though there are extra    restrictions, described in the errors section below.
        /// The mapping between the xoffset,    yoffset, zoffset,    width, height and    depth parameters and the faces, layers, and    layer-faces for cube map, array, and cube map array textures is the same    as for glGetTextureSubImage.
        /// The xoffset, yoffset,    zoffset offsets and width,    height and depth sizes must    be multiples of the values of    GL_PACK_COMPRESSED_BLOCK_WIDTH,    GL_PACK_COMPRESSED_BLOCK_HEIGHT, and    GL_PACK_COMPRESSED_BLOCK_DEPTH respectively, unless    offset is zero and the corresponding    size is the same as the texture size in that    dimension.
        /// Pixel storage modes are treated as for    glGetCompressedTexSubImage. The texel at    (xoffset, yoffset,    zoffset) will be stored at the location indicated    by pixels and the current pixel packing parameters.
        /// </summary>
        /// <param name="texture">Specifies the name of the source texture object. Must be          GL_TEXTURE_1D,          GL_TEXTURE_1D_ARRAY,          GL_TEXTURE_2D,          GL_TEXTURE_2D_ARRAY,          GL_TEXTURE_3D,          GL_TEXTURE_CUBE_MAP,          GL_TEXTURE_CUBE_MAP_ARRAY or          GL_TEXTURE_RECTANGLE. In specific, buffer and          multisample textures are not permitted.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base          image level. Level $n$ is the $n$th          mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture          array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture          array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture          array.</param>
        /// <param name="width">Specifies the width of the texture subimage. Must be a          multiple of the compressed block's width, unless the          offset is zero and the size equals the texture          image size.</param>
        /// <param name="height">Specifies the height of the texture subimage. Must be a          multiple of the compressed block's height, unless the          offset is zero and the size equals the texture          image size.</param>
        /// <param name="depth">Specifies the depth of the texture subimage. Must be a          multiple of the compressed block's depth, unless the          offset is zero and the size equals the texture          image size.</param>
        /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved          pixel data.</param>
        /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array          of the type specified by type.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCompressedTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, IntPtr pixels) => _GetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionFilter(ConvolutionTarget target, PixelFormat format, PixelType type, IntPtr image) => _GetConvolutionFilter(target, format, type, image);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionFilterEXT(ConvolutionTargetEXT target, PixelFormat format, PixelType type, IntPtr image) => _GetConvolutionFilterEXT(target, format, type, image);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionParameterfv(ConvolutionTarget target, ConvolutionParameterEXT pname, float[] @params) => _GetConvolutionParameterfv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionParameterfv(ConvolutionTarget target, ConvolutionParameterEXT pname, void* @params) => _GetConvolutionParameterfv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionParameterfv(ConvolutionTarget target, ConvolutionParameterEXT pname, IntPtr @params) => _GetConvolutionParameterfv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, float[] @params) => _GetConvolutionParameterfvEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, void* @params) => _GetConvolutionParameterfvEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionParameterfvEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, IntPtr @params) => _GetConvolutionParameterfvEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionParameteriv(ConvolutionTarget target, ConvolutionParameterEXT pname, int[] @params) => _GetConvolutionParameteriv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionParameteriv(ConvolutionTarget target, ConvolutionParameterEXT pname, void* @params) => _GetConvolutionParameteriv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionParameteriv(ConvolutionTarget target, ConvolutionParameterEXT pname, IntPtr @params) => _GetConvolutionParameteriv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, int[] @params) => _GetConvolutionParameterivEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, void* @params) => _GetConvolutionParameterivEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionParameterivEXT(ConvolutionTargetEXT target, ConvolutionParameterEXT pname, IntPtr @params) => _GetConvolutionParameterivEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionParameterxvOES(int target, int pname, float[] @params) => _GetConvolutionParameterxvOES(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionParameterxvOES(int target, int pname, void* @params) => _GetConvolutionParameterxvOES_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetConvolutionParameterxvOES(int target, int pname, IntPtr @params) => _GetConvolutionParameterxvOES_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCoverageModulationTableNV(int bufSize, float[] v) => _GetCoverageModulationTableNV(bufSize, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCoverageModulationTableNV(int bufSize, void* v) => _GetCoverageModulationTableNV_ptr(bufSize, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetCoverageModulationTableNV(int bufSize, IntPtr v) => _GetCoverageModulationTableNV_intptr(bufSize, v);

        // ---

        /// <summary>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of            count messages are retrieved from the log. If sources            is not NULL then the source of each message is written into up to count elements            of the array. If types            is not NULL then the type of each message is written into up to count elements            of the array. If id            is not NULL then the identifier of each message is written into up to count elements            of the array. If severities            is not NULL then the severity of each message is written into up to count elements            of the array. If lengths            is not NULL then the length of each message is written into up to count elements            of the array.
        /// messageLog specifies the address of a character array into which the debug messages            will be written. Each message will be concatenated onto the array starting at the first element of messageLog.            bufSize specifies the size of the array messageLog. If a message will not            fit into the remaining space in messageLog then the function terminates and returns the number            of messages written so far, which may be zero.
        /// If glGetDebugMessageLog returns zero then no messages are present in the debug log, or there            was not enough space in messageLog to retrieve the first message in the queue. If messageLog            is NULL then no messages are written and the value of bufSize is ignored.
        /// </summary>
        /// <param name="count">The number of debug messages to retrieve from the log.</param>
        /// <param name="bufSize">The size of the buffer whose address is given by messageLog.</param>
        /// <param name="sources">The address of an array of variables to receive the sources of the retrieved messages.</param>
        /// <param name="types">The address of an array of variables to receive the types of the retrieved messages.</param>
        /// <param name="ids">The address of an array of unsigned integers to receive the ids of the retrieved messages.</param>
        /// <param name="severities">The address of an array of variables to receive the severites of the retrieved messages.</param>
        /// <param name="lengths">The address of an array of variables to receive the lengths of the received messages.</param>
        /// <param name="messageLog">The address of an array of characters that will receive the messages.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetDebugMessageLog(uint count, int bufSize, DebugSource[] sources, DebugType[] types, uint[] ids, DebugSeverity[] severities, int[] lengths, string messageLog) => _GetDebugMessageLog(count, bufSize, sources, types, ids, severities, lengths, messageLog);

        /// <summary>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of            count messages are retrieved from the log. If sources            is not NULL then the source of each message is written into up to count elements            of the array. If types            is not NULL then the type of each message is written into up to count elements            of the array. If id            is not NULL then the identifier of each message is written into up to count elements            of the array. If severities            is not NULL then the severity of each message is written into up to count elements            of the array. If lengths            is not NULL then the length of each message is written into up to count elements            of the array.
        /// messageLog specifies the address of a character array into which the debug messages            will be written. Each message will be concatenated onto the array starting at the first element of messageLog.            bufSize specifies the size of the array messageLog. If a message will not            fit into the remaining space in messageLog then the function terminates and returns the number            of messages written so far, which may be zero.
        /// If glGetDebugMessageLog returns zero then no messages are present in the debug log, or there            was not enough space in messageLog to retrieve the first message in the queue. If messageLog            is NULL then no messages are written and the value of bufSize is ignored.
        /// </summary>
        /// <param name="count">The number of debug messages to retrieve from the log.</param>
        /// <param name="bufSize">The size of the buffer whose address is given by messageLog.</param>
        /// <param name="sources">The address of an array of variables to receive the sources of the retrieved messages.</param>
        /// <param name="types">The address of an array of variables to receive the types of the retrieved messages.</param>
        /// <param name="ids">The address of an array of unsigned integers to receive the ids of the retrieved messages.</param>
        /// <param name="severities">The address of an array of variables to receive the severites of the retrieved messages.</param>
        /// <param name="lengths">The address of an array of variables to receive the lengths of the received messages.</param>
        /// <param name="messageLog">The address of an array of characters that will receive the messages.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetDebugMessageLog(uint count, int bufSize, void* sources, void* types, void* ids, void* severities, void* lengths, void* messageLog) => _GetDebugMessageLog_ptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);

        /// <summary>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of            count messages are retrieved from the log. If sources            is not NULL then the source of each message is written into up to count elements            of the array. If types            is not NULL then the type of each message is written into up to count elements            of the array. If id            is not NULL then the identifier of each message is written into up to count elements            of the array. If severities            is not NULL then the severity of each message is written into up to count elements            of the array. If lengths            is not NULL then the length of each message is written into up to count elements            of the array.
        /// messageLog specifies the address of a character array into which the debug messages            will be written. Each message will be concatenated onto the array starting at the first element of messageLog.            bufSize specifies the size of the array messageLog. If a message will not            fit into the remaining space in messageLog then the function terminates and returns the number            of messages written so far, which may be zero.
        /// If glGetDebugMessageLog returns zero then no messages are present in the debug log, or there            was not enough space in messageLog to retrieve the first message in the queue. If messageLog            is NULL then no messages are written and the value of bufSize is ignored.
        /// </summary>
        /// <param name="count">The number of debug messages to retrieve from the log.</param>
        /// <param name="bufSize">The size of the buffer whose address is given by messageLog.</param>
        /// <param name="sources">The address of an array of variables to receive the sources of the retrieved messages.</param>
        /// <param name="types">The address of an array of variables to receive the types of the retrieved messages.</param>
        /// <param name="ids">The address of an array of unsigned integers to receive the ids of the retrieved messages.</param>
        /// <param name="severities">The address of an array of variables to receive the severites of the retrieved messages.</param>
        /// <param name="lengths">The address of an array of variables to receive the lengths of the received messages.</param>
        /// <param name="messageLog">The address of an array of characters that will receive the messages.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetDebugMessageLog(uint count, int bufSize, IntPtr sources, IntPtr types, IntPtr ids, IntPtr severities, IntPtr lengths, IntPtr messageLog) => _GetDebugMessageLog_intptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetDebugMessageLogAMD(uint count, int bufSize, int[] categories, uint[] severities, uint[] ids, int[] lengths, string message) => _GetDebugMessageLogAMD(count, bufSize, categories, severities, ids, lengths, message);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetDebugMessageLogAMD(uint count, int bufSize, void* categories, void* severities, void* ids, void* lengths, void* message) => _GetDebugMessageLogAMD_ptr(count, bufSize, categories, severities, ids, lengths, message);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetDebugMessageLogAMD(uint count, int bufSize, IntPtr categories, IntPtr severities, IntPtr ids, IntPtr lengths, IntPtr message) => _GetDebugMessageLogAMD_intptr(count, bufSize, categories, severities, ids, lengths, message);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetDebugMessageLogARB(uint count, int bufSize, DebugSource[] sources, DebugType[] types, uint[] ids, DebugSeverity[] severities, int[] lengths, string messageLog) => _GetDebugMessageLogARB(count, bufSize, sources, types, ids, severities, lengths, messageLog);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetDebugMessageLogARB(uint count, int bufSize, void* sources, void* types, void* ids, void* severities, void* lengths, void* messageLog) => _GetDebugMessageLogARB_ptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetDebugMessageLogARB(uint count, int bufSize, IntPtr sources, IntPtr types, IntPtr ids, IntPtr severities, IntPtr lengths, IntPtr messageLog) => _GetDebugMessageLogARB_intptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetDebugMessageLogKHR(uint count, int bufSize, DebugSource[] sources, DebugType[] types, uint[] ids, DebugSeverity[] severities, int[] lengths, string messageLog) => _GetDebugMessageLogKHR(count, bufSize, sources, types, ids, severities, lengths, messageLog);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetDebugMessageLogKHR(uint count, int bufSize, void* sources, void* types, void* ids, void* severities, void* lengths, void* messageLog) => _GetDebugMessageLogKHR_ptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetDebugMessageLogKHR(uint count, int bufSize, IntPtr sources, IntPtr types, IntPtr ids, IntPtr severities, IntPtr lengths, IntPtr messageLog) => _GetDebugMessageLogKHR_intptr(count, bufSize, sources, types, ids, severities, lengths, messageLog);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDetailTexFuncSGIS(TextureTarget target, float[] points) => _GetDetailTexFuncSGIS(target, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDetailTexFuncSGIS(TextureTarget target, void* points) => _GetDetailTexFuncSGIS_ptr(target, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDetailTexFuncSGIS(TextureTarget target, IntPtr points) => _GetDetailTexFuncSGIS_intptr(target, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDoubleIndexedvEXT(int target, uint index, double[] data) => _GetDoubleIndexedvEXT(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDoubleIndexedvEXT(int target, uint index, void* data) => _GetDoubleIndexedvEXT_ptr(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDoubleIndexedvEXT(int target, uint index, IntPtr data) => _GetDoubleIndexedvEXT_intptr(target, index, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDoublei_v(int target, uint index, double[] data) => _GetDoublei_v(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDoublei_v(int target, uint index, void* data) => _GetDoublei_v_ptr(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDoublei_v(int target, uint index, IntPtr data) => _GetDoublei_v_intptr(target, index, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDoublei_vEXT(int pname, uint index, double[] @params) => _GetDoublei_vEXT(pname, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDoublei_vEXT(int pname, uint index, void* @params) => _GetDoublei_vEXT_ptr(pname, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDoublei_vEXT(int pname, uint index, IntPtr @params) => _GetDoublei_vEXT_intptr(pname, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDoublev(GetPName pname, double[] data) => _GetDoublev(pname, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDoublev(GetPName pname, void* data) => _GetDoublev_ptr(pname, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDoublev(GetPName pname, IntPtr data) => _GetDoublev_intptr(pname, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDriverControlStringQCOM(uint driverControl, int bufSize, int[] length, string driverControlString) => _GetDriverControlStringQCOM(driverControl, bufSize, length, driverControlString);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDriverControlStringQCOM(uint driverControl, int bufSize, void* length, void* driverControlString) => _GetDriverControlStringQCOM_ptr(driverControl, bufSize, length, driverControlString);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDriverControlStringQCOM(uint driverControl, int bufSize, IntPtr length, IntPtr driverControlString) => _GetDriverControlStringQCOM_intptr(driverControl, bufSize, length, driverControlString);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDriverControlsQCOM(int[] num, int size, uint[] driverControls) => _GetDriverControlsQCOM(num, size, driverControls);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDriverControlsQCOM(void* num, int size, void* driverControls) => _GetDriverControlsQCOM_ptr(num, size, driverControls);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetDriverControlsQCOM(IntPtr num, int size, IntPtr driverControls) => _GetDriverControlsQCOM_intptr(num, size, driverControls);

        // ---

        /// <summary>
        /// glGetError returns the value of the error flag.            Each detectable error is assigned a numeric code and symbolic name.            When an error occurs,            the error flag is set to the appropriate error code value.            No other errors are recorded until glGetError is called,            the error code is returned,            and the flag is reset to GL_NO_ERROR.            If a call to glGetError returns GL_NO_ERROR,            there has been no detectable error since the last call to glGetError,            or since the GL was initialized.
        /// To allow for distributed implementations,            there may be several error flags.            If any single error flag has recorded an error,            the value of that flag is returned            and that flag is reset to GL_NO_ERROR            when glGetError is called.            If more than one flag has recorded an error,            glGetError returns and clears an arbitrary error flag value.            Thus, glGetError should always be called in a loop,            until it returns GL_NO_ERROR,            if all error flags are to be reset.
        /// Initially, all error flags are set to GL_NO_ERROR.
        /// The following errors are currently defined:
        /// GL_NO_ERROR                        No error has been recorded.                        The value of this symbolic constant is guaranteed to be 0.                    GL_INVALID_ENUM                        An unacceptable value is specified for an enumerated argument.                        The offending command is ignored                        and has no other side effect than to set the error flag.                    GL_INVALID_VALUE                        A numeric argument is out of range.                        The offending command is ignored                        and has no other side effect than to set the error flag.                    GL_INVALID_OPERATION                        The specified operation is not allowed in the current state.                        The offending command is ignored                        and has no other side effect than to set the error flag.                    GL_INVALID_FRAMEBUFFER_OPERATION                        The framebuffer object is not complete. The offending command                        is ignored and has no other side effect than to set the error flag.                    GL_OUT_OF_MEMORY                        There is not enough memory left to execute the command.                        The state of the GL is undefined,                        except for the state of the error flags,                        after this error is recorded.                    GL_STACK_UNDERFLOW                        An attempt has been made to perform an operation that would                        cause an internal stack to underflow.                    GL_STACK_OVERFLOW                        An attempt has been made to perform an operation that would                        cause an internal stack to overflow.
        /// When an error flag is set,            results of a GL operation are undefined only if GL_OUT_OF_MEMORY            has occurred.            In all other cases,            the command generating the error is ignored and has no effect on the GL state            or frame buffer contents.            If the generating command returns a value, it returns 0.            If glGetError itself generates an error, it returns 0.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetError() => _GetError();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFenceivNV(uint fence, FenceParameterNameNV pname, int[] @params) => _GetFenceivNV(fence, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFenceivNV(uint fence, FenceParameterNameNV pname, void* @params) => _GetFenceivNV_ptr(fence, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFenceivNV(uint fence, FenceParameterNameNV pname, IntPtr @params) => _GetFenceivNV_intptr(fence, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFinalCombinerInputParameterfvNV(CombinerVariableNV variable, CombinerParameterNV pname, float[] @params) => _GetFinalCombinerInputParameterfvNV(variable, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFinalCombinerInputParameterfvNV(CombinerVariableNV variable, CombinerParameterNV pname, void* @params) => _GetFinalCombinerInputParameterfvNV_ptr(variable, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFinalCombinerInputParameterfvNV(CombinerVariableNV variable, CombinerParameterNV pname, IntPtr @params) => _GetFinalCombinerInputParameterfvNV_intptr(variable, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFinalCombinerInputParameterivNV(CombinerVariableNV variable, CombinerParameterNV pname, int[] @params) => _GetFinalCombinerInputParameterivNV(variable, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFinalCombinerInputParameterivNV(CombinerVariableNV variable, CombinerParameterNV pname, void* @params) => _GetFinalCombinerInputParameterivNV_ptr(variable, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFinalCombinerInputParameterivNV(CombinerVariableNV variable, CombinerParameterNV pname, IntPtr @params) => _GetFinalCombinerInputParameterivNV_intptr(variable, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFirstPerfQueryIdINTEL(uint[] queryId) => _GetFirstPerfQueryIdINTEL(queryId);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFirstPerfQueryIdINTEL(void* queryId) => _GetFirstPerfQueryIdINTEL_ptr(queryId);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFirstPerfQueryIdINTEL(IntPtr queryId) => _GetFirstPerfQueryIdINTEL_intptr(queryId);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFixedv(GetPName pname, float[] @params) => _GetFixedv(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFixedv(GetPName pname, void* @params) => _GetFixedv_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFixedv(GetPName pname, IntPtr @params) => _GetFixedv_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFixedvOES(GetPName pname, float[] @params) => _GetFixedvOES(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFixedvOES(GetPName pname, void* @params) => _GetFixedvOES_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFixedvOES(GetPName pname, IntPtr @params) => _GetFixedvOES_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloatIndexedvEXT(int target, uint index, float[] data) => _GetFloatIndexedvEXT(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloatIndexedvEXT(int target, uint index, void* data) => _GetFloatIndexedvEXT_ptr(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloatIndexedvEXT(int target, uint index, IntPtr data) => _GetFloatIndexedvEXT_intptr(target, index, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloati_v(int target, uint index, float[] data) => _GetFloati_v(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloati_v(int target, uint index, void* data) => _GetFloati_v_ptr(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloati_v(int target, uint index, IntPtr data) => _GetFloati_v_intptr(target, index, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloati_vEXT(int pname, uint index, float[] @params) => _GetFloati_vEXT(pname, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloati_vEXT(int pname, uint index, void* @params) => _GetFloati_vEXT_ptr(pname, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloati_vEXT(int pname, uint index, IntPtr @params) => _GetFloati_vEXT_intptr(pname, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloati_vNV(int target, uint index, float[] data) => _GetFloati_vNV(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloati_vNV(int target, uint index, void* data) => _GetFloati_vNV_ptr(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloati_vNV(int target, uint index, IntPtr data) => _GetFloati_vNV_intptr(target, index, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloati_vOES(int target, uint index, float[] data) => _GetFloati_vOES(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloati_vOES(int target, uint index, void* data) => _GetFloati_vOES_ptr(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloati_vOES(int target, uint index, IntPtr data) => _GetFloati_vOES_intptr(target, index, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloatv(GetPName pname, float[] data) => _GetFloatv(pname, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloatv(GetPName pname, void* data) => _GetFloatv_ptr(pname, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFloatv(GetPName pname, IntPtr data) => _GetFloatv_intptr(pname, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFogFuncSGIS(float[] points) => _GetFogFuncSGIS(points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFogFuncSGIS(void* points) => _GetFogFuncSGIS_ptr(points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFogFuncSGIS(IntPtr points) => _GetFogFuncSGIS_intptr(points);

        // ---

        /// <summary>
        /// glGetFragDataIndex returns the index of the fragment color to which the variable name            was bound when the program object program was last linked. If name is not a varying out            variable of program, or if an error occurs, -1 will be returned.
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to query</param>
        /// <param name="name">The name of the user-defined varying out variable whose index to query</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetFragDataIndex(uint program, string name) => _GetFragDataIndex(program, name);

        /// <summary>
        /// glGetFragDataIndex returns the index of the fragment color to which the variable name            was bound when the program object program was last linked. If name is not a varying out            variable of program, or if an error occurs, -1 will be returned.
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to query</param>
        /// <param name="name">The name of the user-defined varying out variable whose index to query</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetFragDataIndex(uint program, void* name) => _GetFragDataIndex_ptr(program, name);

        /// <summary>
        /// glGetFragDataIndex returns the index of the fragment color to which the variable name            was bound when the program object program was last linked. If name is not a varying out            variable of program, or if an error occurs, -1 will be returned.
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to query</param>
        /// <param name="name">The name of the user-defined varying out variable whose index to query</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetFragDataIndex(uint program, IntPtr name) => _GetFragDataIndex_intptr(program, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetFragDataIndexEXT(uint program, string name) => _GetFragDataIndexEXT(program, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetFragDataIndexEXT(uint program, void* name) => _GetFragDataIndexEXT_ptr(program, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetFragDataIndexEXT(uint program, IntPtr name) => _GetFragDataIndexEXT_intptr(program, name);

        // ---

        /// <summary>
        /// glGetFragDataLocation retrieves the assigned color number binding for the user-defined            varying out variable name for program program. program            must have previously been linked. name must be a null-terminated string. If name            is not the name of an active user-defined varying out fragment shader variable within program, -1 will            be returned.
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to query</param>
        /// <param name="name">The name of the user-defined varying out variable whose binding to query</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetFragDataLocation(uint program, string name) => _GetFragDataLocation(program, name);

        /// <summary>
        /// glGetFragDataLocation retrieves the assigned color number binding for the user-defined            varying out variable name for program program. program            must have previously been linked. name must be a null-terminated string. If name            is not the name of an active user-defined varying out fragment shader variable within program, -1 will            be returned.
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to query</param>
        /// <param name="name">The name of the user-defined varying out variable whose binding to query</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetFragDataLocation(uint program, void* name) => _GetFragDataLocation_ptr(program, name);

        /// <summary>
        /// glGetFragDataLocation retrieves the assigned color number binding for the user-defined            varying out variable name for program program. program            must have previously been linked. name must be a null-terminated string. If name            is not the name of an active user-defined varying out fragment shader variable within program, -1 will            be returned.
        /// </summary>
        /// <param name="program">The name of the program containing varying out variable whose binding to query</param>
        /// <param name="name">The name of the user-defined varying out variable whose binding to query</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetFragDataLocation(uint program, IntPtr name) => _GetFragDataLocation_intptr(program, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetFragDataLocationEXT(uint program, string name) => _GetFragDataLocationEXT(program, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetFragDataLocationEXT(uint program, void* name) => _GetFragDataLocationEXT_ptr(program, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetFragDataLocationEXT(uint program, IntPtr name) => _GetFragDataLocationEXT_intptr(program, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, float[] @params) => _GetFragmentLightfvSGIX(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, void* @params) => _GetFragmentLightfvSGIX_ptr(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFragmentLightfvSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, IntPtr @params) => _GetFragmentLightfvSGIX_intptr(light, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, int[] @params) => _GetFragmentLightivSGIX(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, void* @params) => _GetFragmentLightivSGIX_ptr(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFragmentLightivSGIX(FragmentLightNameSGIX light, FragmentLightParameterSGIX pname, IntPtr @params) => _GetFragmentLightivSGIX_intptr(light, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, float[] @params) => _GetFragmentMaterialfvSGIX(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, void* @params) => _GetFragmentMaterialfvSGIX_ptr(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFragmentMaterialfvSGIX(MaterialFace face, MaterialParameter pname, IntPtr @params) => _GetFragmentMaterialfvSGIX_intptr(face, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, int[] @params) => _GetFragmentMaterialivSGIX(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, void* @params) => _GetFragmentMaterialivSGIX_ptr(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFragmentMaterialivSGIX(MaterialFace face, MaterialParameter pname, IntPtr @params) => _GetFragmentMaterialivSGIX_intptr(face, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferAttachmentParameteriv(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int[] @params) => _GetFramebufferAttachmentParameteriv(target, attachment, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferAttachmentParameteriv(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, void* @params) => _GetFramebufferAttachmentParameteriv_ptr(target, attachment, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferAttachmentParameteriv(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, IntPtr @params) => _GetFramebufferAttachmentParameteriv_intptr(target, attachment, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferAttachmentParameterivEXT(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int[] @params) => _GetFramebufferAttachmentParameterivEXT(target, attachment, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferAttachmentParameterivEXT(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, void* @params) => _GetFramebufferAttachmentParameterivEXT_ptr(target, attachment, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferAttachmentParameterivEXT(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, IntPtr @params) => _GetFramebufferAttachmentParameterivEXT_intptr(target, attachment, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferAttachmentParameterivOES(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int[] @params) => _GetFramebufferAttachmentParameterivOES(target, attachment, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferAttachmentParameterivOES(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, void* @params) => _GetFramebufferAttachmentParameterivOES_ptr(target, attachment, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferAttachmentParameterivOES(FramebufferTarget target, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, IntPtr @params) => _GetFramebufferAttachmentParameterivOES_intptr(target, attachment, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferParameterfvAMD(FramebufferTarget target, FramebufferAttachmentParameterName pname, uint numsamples, uint pixelindex, int size, float[] values) => _GetFramebufferParameterfvAMD(target, pname, numsamples, pixelindex, size, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferParameterfvAMD(FramebufferTarget target, FramebufferAttachmentParameterName pname, uint numsamples, uint pixelindex, int size, void* values) => _GetFramebufferParameterfvAMD_ptr(target, pname, numsamples, pixelindex, size, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferParameterfvAMD(FramebufferTarget target, FramebufferAttachmentParameterName pname, uint numsamples, uint pixelindex, int size, IntPtr values) => _GetFramebufferParameterfvAMD_intptr(target, pname, numsamples, pixelindex, size, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferParameteriv(FramebufferTarget target, FramebufferAttachmentParameterName pname, int[] @params) => _GetFramebufferParameteriv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferParameteriv(FramebufferTarget target, FramebufferAttachmentParameterName pname, void* @params) => _GetFramebufferParameteriv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferParameteriv(FramebufferTarget target, FramebufferAttachmentParameterName pname, IntPtr @params) => _GetFramebufferParameteriv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferParameterivEXT(uint framebuffer, GetFramebufferParameter pname, int[] @params) => _GetFramebufferParameterivEXT(framebuffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferParameterivEXT(uint framebuffer, GetFramebufferParameter pname, void* @params) => _GetFramebufferParameterivEXT_ptr(framebuffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferParameterivEXT(uint framebuffer, GetFramebufferParameter pname, IntPtr @params) => _GetFramebufferParameterivEXT_intptr(framebuffer, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetFramebufferPixelLocalStorageSizeEXT(uint target) => _GetFramebufferPixelLocalStorageSizeEXT(target);

        // ---

        /// <summary>
        /// Certain events can result in a reset of the GL context. Such a reset causes            all context state to be lost and requires the application to recreate all            objects in the affected context.
        /// glGetGraphicsResetStatus can return one of the following            constants:
        /// GL_NO_ERROR                        Indicates that the GL context has not been in a reset state since                        the last call.                    GL_GUILTY_CONTEXT_RESET                        Indicates that a reset has been detected that is attributable to                        the current GL context.                    GL_INNOCENT_CONTEXT_RESET                        Indicates a reset has been detected that is not attributable to                        the current GL context.                    GL_UNKNOWN_CONTEXT_RESET                        Indicates a detected graphics reset whose cause is unknown.
        /// If a reset status other than GL_NO_ERROR is returned            and subsequent calls return GL_NO_ERROR, the context            reset was encountered and completed. If a reset status is repeatedly            returned, the context may be in the process of resetting.
        /// Reset notification behavior is determined at context creation time, and            may be queried by calling GetIntegerv with the            symbolic constant GL_RESET_NOTIFICATION_STRATEGY.
        /// If the reset notification behavior is            GL_NO_RESET_NOTIFICATION, then the            implementation will never deliver notification of reset events,            and glGetGraphicsResetStatus will always            return GL_NO_ERROR.
        /// If the behavior is GL_LOSE_CONTEXT_ON_RESET, a graphics reset            will result in the loss of all context state, requiring the recreation of all            associated objects. In this case glGetGraphicsResetStatus            may return any of the values described above.
        /// If a graphics reset notification occurs in a context, a notification must also occur            in all other contexts which share objects with that context.
        /// After a graphics reset has occurred on a context, subsequent GL commands on that            context (or any context which shares with that context) will generate a            GL_CONTEXT_LOST error. Such commands will not have            side effects (in particular, they will not modify memory passed by pointer            for query results), and will not block indefinitely or cause termination            of the application. There are two important exceptions to this behavior:
        /// glGetError and glGetGraphicsResetStatus                        behave normally following a graphics reset, so that the application can                        determine a reset has occurred, and when it is safe to destroy and re-create                        the context.                                            Any commands which might cause a polling application to block indefinitely                        will generate a GL_CONTEXT_LOST error, but will also return                        a value indicating completion to the application. Such commands include:                        glGetSynciv with pname GL_SYNC_STATUS                                    ignores the other parameters and returns GL_SIGNALED in                                    values.                                glGetQueryObjectuiv with pname GL_QUERY_RESULT_AVAILABLE                                    ignores the other parameters and returns TRUE in params.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetGraphicsResetStatus() => _GetGraphicsResetStatus();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetGraphicsResetStatusARB() => _GetGraphicsResetStatusARB();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetGraphicsResetStatusEXT() => _GetGraphicsResetStatusEXT();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetGraphicsResetStatusKHR() => _GetGraphicsResetStatusKHR();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHandleARB(int pname) => _GetHandleARB(pname);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogram(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, IntPtr values) => _GetHistogram(target, reset, format, type, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramEXT(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, IntPtr values) => _GetHistogramEXT(target, reset, format, type, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramParameterfv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float[] @params) => _GetHistogramParameterfv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramParameterfv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, void* @params) => _GetHistogramParameterfv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramParameterfv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, IntPtr @params) => _GetHistogramParameterfv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramParameterfvEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float[] @params) => _GetHistogramParameterfvEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramParameterfvEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, void* @params) => _GetHistogramParameterfvEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramParameterfvEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, IntPtr @params) => _GetHistogramParameterfvEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramParameteriv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int[] @params) => _GetHistogramParameteriv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramParameteriv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, void* @params) => _GetHistogramParameteriv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramParameteriv(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, IntPtr @params) => _GetHistogramParameteriv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramParameterivEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, int[] @params) => _GetHistogramParameterivEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramParameterivEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, void* @params) => _GetHistogramParameterivEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramParameterivEXT(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, IntPtr @params) => _GetHistogramParameterivEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramParameterxvOES(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, float[] @params) => _GetHistogramParameterxvOES(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramParameterxvOES(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, void* @params) => _GetHistogramParameterxvOES_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetHistogramParameterxvOES(HistogramTargetEXT target, GetHistogramParameterPNameEXT pname, IntPtr @params) => _GetHistogramParameterxvOES_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public UInt64 GetImageHandleARB(uint texture, int level, bool layered, int layer, PixelFormat format) => _GetImageHandleARB(texture, level, layered, layer, format);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public UInt64 GetImageHandleNV(uint texture, int level, bool layered, int layer, PixelFormat format) => _GetImageHandleNV(texture, level, layered, layer, format);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float[] @params) => _GetImageTransformParameterfvHP(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, void* @params) => _GetImageTransformParameterfvHP_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, IntPtr @params) => _GetImageTransformParameterfvHP_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int[] @params) => _GetImageTransformParameterivHP(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, void* @params) => _GetImageTransformParameterivHP_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, IntPtr @params) => _GetImageTransformParameterivHP_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInfoLogARB(int obj, int maxLength, out int length, string infoLog) => _GetInfoLogARB(obj, maxLength, out length, infoLog);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInfoLogARB(int obj, int maxLength, out int length, void* infoLog) => _GetInfoLogARB_ptr(obj, maxLength, out length, infoLog);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInfoLogARB(int obj, int maxLength, out int length, IntPtr infoLog) => _GetInfoLogARB_intptr(obj, maxLength, out length, infoLog);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetInstrumentsSGIX() => _GetInstrumentsSGIX();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInteger64i_v(int target, uint index, Int64[] data) => _GetInteger64i_v(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInteger64i_v(int target, uint index, void* data) => _GetInteger64i_v_ptr(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInteger64i_v(int target, uint index, IntPtr data) => _GetInteger64i_v_intptr(target, index, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInteger64v(GetPName pname, Int64[] data) => _GetInteger64v(pname, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInteger64v(GetPName pname, void* data) => _GetInteger64v_ptr(pname, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInteger64v(GetPName pname, IntPtr data) => _GetInteger64v_intptr(pname, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInteger64vAPPLE(GetPName pname, Int64[] @params) => _GetInteger64vAPPLE(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInteger64vAPPLE(GetPName pname, void* @params) => _GetInteger64vAPPLE_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInteger64vAPPLE(GetPName pname, IntPtr @params) => _GetInteger64vAPPLE_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInteger64vEXT(GetPName pname, Int64[] data) => _GetInteger64vEXT(pname, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInteger64vEXT(GetPName pname, void* data) => _GetInteger64vEXT_ptr(pname, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInteger64vEXT(GetPName pname, IntPtr data) => _GetInteger64vEXT_intptr(pname, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegerIndexedvEXT(int target, uint index, int[] data) => _GetIntegerIndexedvEXT(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegerIndexedvEXT(int target, uint index, void* data) => _GetIntegerIndexedvEXT_ptr(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegerIndexedvEXT(int target, uint index, IntPtr data) => _GetIntegerIndexedvEXT_intptr(target, index, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegeri_v(int target, uint index, int[] data) => _GetIntegeri_v(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegeri_v(int target, uint index, void* data) => _GetIntegeri_v_ptr(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegeri_v(int target, uint index, IntPtr data) => _GetIntegeri_v_intptr(target, index, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegeri_vEXT(int target, uint index, int[] data) => _GetIntegeri_vEXT(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegeri_vEXT(int target, uint index, void* data) => _GetIntegeri_vEXT_ptr(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegeri_vEXT(int target, uint index, IntPtr data) => _GetIntegeri_vEXT_intptr(target, index, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegerui64i_vNV(int value, uint index, UInt64[] result) => _GetIntegerui64i_vNV(value, index, result);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegerui64i_vNV(int value, uint index, void* result) => _GetIntegerui64i_vNV_ptr(value, index, result);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegerui64i_vNV(int value, uint index, IntPtr result) => _GetIntegerui64i_vNV_intptr(value, index, result);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegerui64vNV(int value, UInt64[] result) => _GetIntegerui64vNV(value, result);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegerui64vNV(int value, void* result) => _GetIntegerui64vNV_ptr(value, result);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegerui64vNV(int value, IntPtr result) => _GetIntegerui64vNV_intptr(value, result);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegerv(GetPName pname, int[] data) => _GetIntegerv(pname, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegerv(GetPName pname, void* data) => _GetIntegerv_ptr(pname, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetIntegerv(GetPName pname, IntPtr data) => _GetIntegerv_intptr(pname, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInternalformatSampleivNV(TextureTarget target, InternalFormat internalformat, int samples, InternalFormatPName pname, int count, int[] @params) => _GetInternalformatSampleivNV(target, internalformat, samples, pname, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInternalformatSampleivNV(TextureTarget target, InternalFormat internalformat, int samples, InternalFormatPName pname, int count, void* @params) => _GetInternalformatSampleivNV_ptr(target, internalformat, samples, pname, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInternalformatSampleivNV(TextureTarget target, InternalFormat internalformat, int samples, InternalFormatPName pname, int count, IntPtr @params) => _GetInternalformatSampleivNV_intptr(target, internalformat, samples, pname, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInternalformati64v(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, Int64[] @params) => _GetInternalformati64v(target, internalformat, pname, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInternalformati64v(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, void* @params) => _GetInternalformati64v_ptr(target, internalformat, pname, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInternalformati64v(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, IntPtr @params) => _GetInternalformati64v_intptr(target, internalformat, pname, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInternalformativ(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, int[] @params) => _GetInternalformativ(target, internalformat, pname, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInternalformativ(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, void* @params) => _GetInternalformativ_ptr(target, internalformat, pname, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInternalformativ(TextureTarget target, InternalFormat internalformat, InternalFormatPName pname, int count, IntPtr @params) => _GetInternalformativ_intptr(target, internalformat, pname, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInvariantBooleanvEXT(uint id, GetVariantValueEXT value, bool[] data) => _GetInvariantBooleanvEXT(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInvariantBooleanvEXT(uint id, GetVariantValueEXT value, void* data) => _GetInvariantBooleanvEXT_ptr(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInvariantBooleanvEXT(uint id, GetVariantValueEXT value, IntPtr data) => _GetInvariantBooleanvEXT_intptr(id, value, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInvariantFloatvEXT(uint id, GetVariantValueEXT value, float[] data) => _GetInvariantFloatvEXT(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInvariantFloatvEXT(uint id, GetVariantValueEXT value, void* data) => _GetInvariantFloatvEXT_ptr(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInvariantFloatvEXT(uint id, GetVariantValueEXT value, IntPtr data) => _GetInvariantFloatvEXT_intptr(id, value, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInvariantIntegervEXT(uint id, GetVariantValueEXT value, int[] data) => _GetInvariantIntegervEXT(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInvariantIntegervEXT(uint id, GetVariantValueEXT value, void* data) => _GetInvariantIntegervEXT_ptr(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetInvariantIntegervEXT(uint id, GetVariantValueEXT value, IntPtr data) => _GetInvariantIntegervEXT_intptr(id, value, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLightfv(LightName light, LightParameter pname, float[] @params) => _GetLightfv(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLightfv(LightName light, LightParameter pname, void* @params) => _GetLightfv_ptr(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLightfv(LightName light, LightParameter pname, IntPtr @params) => _GetLightfv_intptr(light, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLightiv(LightName light, LightParameter pname, int[] @params) => _GetLightiv(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLightiv(LightName light, LightParameter pname, void* @params) => _GetLightiv_ptr(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLightiv(LightName light, LightParameter pname, IntPtr @params) => _GetLightiv_intptr(light, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLightxOES(LightName light, LightParameter pname, float[] @params) => _GetLightxOES(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLightxOES(LightName light, LightParameter pname, void* @params) => _GetLightxOES_ptr(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLightxOES(LightName light, LightParameter pname, IntPtr @params) => _GetLightxOES_intptr(light, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLightxv(LightName light, LightParameter pname, float[] @params) => _GetLightxv(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLightxv(LightName light, LightParameter pname, void* @params) => _GetLightxv_ptr(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLightxv(LightName light, LightParameter pname, IntPtr @params) => _GetLightxv_intptr(light, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLightxvOES(LightName light, LightParameter pname, float[] @params) => _GetLightxvOES(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLightxvOES(LightName light, LightParameter pname, void* @params) => _GetLightxvOES_ptr(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLightxvOES(LightName light, LightParameter pname, IntPtr @params) => _GetLightxvOES_intptr(light, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetListParameterfvSGIX(uint list, ListParameterName pname, float[] @params) => _GetListParameterfvSGIX(list, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetListParameterfvSGIX(uint list, ListParameterName pname, void* @params) => _GetListParameterfvSGIX_ptr(list, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetListParameterfvSGIX(uint list, ListParameterName pname, IntPtr @params) => _GetListParameterfvSGIX_intptr(list, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetListParameterivSGIX(uint list, ListParameterName pname, int[] @params) => _GetListParameterivSGIX(list, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetListParameterivSGIX(uint list, ListParameterName pname, void* @params) => _GetListParameterivSGIX_ptr(list, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetListParameterivSGIX(uint list, ListParameterName pname, IntPtr @params) => _GetListParameterivSGIX_intptr(list, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLocalConstantBooleanvEXT(uint id, GetVariantValueEXT value, bool[] data) => _GetLocalConstantBooleanvEXT(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLocalConstantBooleanvEXT(uint id, GetVariantValueEXT value, void* data) => _GetLocalConstantBooleanvEXT_ptr(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLocalConstantBooleanvEXT(uint id, GetVariantValueEXT value, IntPtr data) => _GetLocalConstantBooleanvEXT_intptr(id, value, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLocalConstantFloatvEXT(uint id, GetVariantValueEXT value, float[] data) => _GetLocalConstantFloatvEXT(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLocalConstantFloatvEXT(uint id, GetVariantValueEXT value, void* data) => _GetLocalConstantFloatvEXT_ptr(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLocalConstantFloatvEXT(uint id, GetVariantValueEXT value, IntPtr data) => _GetLocalConstantFloatvEXT_intptr(id, value, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLocalConstantIntegervEXT(uint id, GetVariantValueEXT value, int[] data) => _GetLocalConstantIntegervEXT(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLocalConstantIntegervEXT(uint id, GetVariantValueEXT value, void* data) => _GetLocalConstantIntegervEXT_ptr(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetLocalConstantIntegervEXT(uint id, GetVariantValueEXT value, IntPtr data) => _GetLocalConstantIntegervEXT_intptr(id, value, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapAttribParameterfvNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, float[] @params) => _GetMapAttribParameterfvNV(target, index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapAttribParameterfvNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, void* @params) => _GetMapAttribParameterfvNV_ptr(target, index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapAttribParameterfvNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, IntPtr @params) => _GetMapAttribParameterfvNV_intptr(target, index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapAttribParameterivNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, int[] @params) => _GetMapAttribParameterivNV(target, index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapAttribParameterivNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, void* @params) => _GetMapAttribParameterivNV_ptr(target, index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapAttribParameterivNV(EvalTargetNV target, uint index, MapAttribParameterNV pname, IntPtr @params) => _GetMapAttribParameterivNV_intptr(target, index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapControlPointsNV(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, bool packed, IntPtr points) => _GetMapControlPointsNV(target, index, type, ustride, vstride, packed, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapParameterfvNV(EvalTargetNV target, MapParameterNV pname, float[] @params) => _GetMapParameterfvNV(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapParameterfvNV(EvalTargetNV target, MapParameterNV pname, void* @params) => _GetMapParameterfvNV_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapParameterfvNV(EvalTargetNV target, MapParameterNV pname, IntPtr @params) => _GetMapParameterfvNV_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapParameterivNV(EvalTargetNV target, MapParameterNV pname, int[] @params) => _GetMapParameterivNV(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapParameterivNV(EvalTargetNV target, MapParameterNV pname, void* @params) => _GetMapParameterivNV_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapParameterivNV(EvalTargetNV target, MapParameterNV pname, IntPtr @params) => _GetMapParameterivNV_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapdv(MapTarget target, GetMapQuery query, double[] v) => _GetMapdv(target, query, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapdv(MapTarget target, GetMapQuery query, void* v) => _GetMapdv_ptr(target, query, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapdv(MapTarget target, GetMapQuery query, IntPtr v) => _GetMapdv_intptr(target, query, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapfv(MapTarget target, GetMapQuery query, float[] v) => _GetMapfv(target, query, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapfv(MapTarget target, GetMapQuery query, void* v) => _GetMapfv_ptr(target, query, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapfv(MapTarget target, GetMapQuery query, IntPtr v) => _GetMapfv_intptr(target, query, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapiv(MapTarget target, GetMapQuery query, int[] v) => _GetMapiv(target, query, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapiv(MapTarget target, GetMapQuery query, void* v) => _GetMapiv_ptr(target, query, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapiv(MapTarget target, GetMapQuery query, IntPtr v) => _GetMapiv_intptr(target, query, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapxvOES(MapTarget target, GetMapQuery query, float[] v) => _GetMapxvOES(target, query, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapxvOES(MapTarget target, GetMapQuery query, void* v) => _GetMapxvOES_ptr(target, query, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMapxvOES(MapTarget target, GetMapQuery query, IntPtr v) => _GetMapxvOES_intptr(target, query, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMaterialfv(MaterialFace face, MaterialParameter pname, float[] @params) => _GetMaterialfv(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMaterialfv(MaterialFace face, MaterialParameter pname, void* @params) => _GetMaterialfv_ptr(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMaterialfv(MaterialFace face, MaterialParameter pname, IntPtr @params) => _GetMaterialfv_intptr(face, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMaterialiv(MaterialFace face, MaterialParameter pname, int[] @params) => _GetMaterialiv(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMaterialiv(MaterialFace face, MaterialParameter pname, void* @params) => _GetMaterialiv_ptr(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMaterialiv(MaterialFace face, MaterialParameter pname, IntPtr @params) => _GetMaterialiv_intptr(face, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMaterialxOES(MaterialFace face, MaterialParameter pname, float param) => _GetMaterialxOES(face, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMaterialxv(MaterialFace face, MaterialParameter pname, float[] @params) => _GetMaterialxv(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMaterialxv(MaterialFace face, MaterialParameter pname, void* @params) => _GetMaterialxv_ptr(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMaterialxv(MaterialFace face, MaterialParameter pname, IntPtr @params) => _GetMaterialxv_intptr(face, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMaterialxvOES(MaterialFace face, MaterialParameter pname, float[] @params) => _GetMaterialxvOES(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMaterialxvOES(MaterialFace face, MaterialParameter pname, void* @params) => _GetMaterialxvOES_ptr(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMaterialxvOES(MaterialFace face, MaterialParameter pname, IntPtr @params) => _GetMaterialxvOES_intptr(face, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMemoryObjectDetachedResourcesuivNV(uint memory, int pname, int first, int count, uint[] @params) => _GetMemoryObjectDetachedResourcesuivNV(memory, pname, first, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMemoryObjectDetachedResourcesuivNV(uint memory, int pname, int first, int count, void* @params) => _GetMemoryObjectDetachedResourcesuivNV_ptr(memory, pname, first, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMemoryObjectDetachedResourcesuivNV(uint memory, int pname, int first, int count, IntPtr @params) => _GetMemoryObjectDetachedResourcesuivNV_intptr(memory, pname, first, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, int[] @params) => _GetMemoryObjectParameterivEXT(memoryObject, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, void* @params) => _GetMemoryObjectParameterivEXT_ptr(memoryObject, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, IntPtr @params) => _GetMemoryObjectParameterivEXT_intptr(memoryObject, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinmax(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, IntPtr values) => _GetMinmax(target, reset, format, type, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinmaxEXT(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, IntPtr values) => _GetMinmaxEXT(target, reset, format, type, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinmaxParameterfv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, float[] @params) => _GetMinmaxParameterfv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinmaxParameterfv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, void* @params) => _GetMinmaxParameterfv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinmaxParameterfv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, IntPtr @params) => _GetMinmaxParameterfv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinmaxParameterfvEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, float[] @params) => _GetMinmaxParameterfvEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinmaxParameterfvEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, void* @params) => _GetMinmaxParameterfvEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinmaxParameterfvEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, IntPtr @params) => _GetMinmaxParameterfvEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinmaxParameteriv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, int[] @params) => _GetMinmaxParameteriv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinmaxParameteriv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, void* @params) => _GetMinmaxParameteriv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinmaxParameteriv(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, IntPtr @params) => _GetMinmaxParameteriv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinmaxParameterivEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, int[] @params) => _GetMinmaxParameterivEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinmaxParameterivEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, void* @params) => _GetMinmaxParameterivEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinmaxParameterivEXT(MinmaxTargetEXT target, GetMinmaxParameterPNameEXT pname, IntPtr @params) => _GetMinmaxParameterivEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float[] @params) => _GetMultiTexEnvfvEXT(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, void* @params) => _GetMultiTexEnvfvEXT_ptr(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, IntPtr @params) => _GetMultiTexEnvfvEXT_intptr(texunit, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int[] @params) => _GetMultiTexEnvivEXT(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, void* @params) => _GetMultiTexEnvivEXT_ptr(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, IntPtr @params) => _GetMultiTexEnvivEXT_intptr(texunit, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double[] @params) => _GetMultiTexGendvEXT(texunit, coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, void* @params) => _GetMultiTexGendvEXT_ptr(texunit, coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _GetMultiTexGendvEXT_intptr(texunit, coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float[] @params) => _GetMultiTexGenfvEXT(texunit, coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, void* @params) => _GetMultiTexGenfvEXT_ptr(texunit, coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _GetMultiTexGenfvEXT_intptr(texunit, coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int[] @params) => _GetMultiTexGenivEXT(texunit, coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, void* @params) => _GetMultiTexGenivEXT_ptr(texunit, coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _GetMultiTexGenivEXT_intptr(texunit, coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexImageEXT(TextureUnit texunit, TextureTarget target, int level, PixelFormat format, PixelType type, IntPtr pixels) => _GetMultiTexImageEXT(texunit, target, level, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexLevelParameterfvEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, float[] @params) => _GetMultiTexLevelParameterfvEXT(texunit, target, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexLevelParameterfvEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, void* @params) => _GetMultiTexLevelParameterfvEXT_ptr(texunit, target, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexLevelParameterfvEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, IntPtr @params) => _GetMultiTexLevelParameterfvEXT_intptr(texunit, target, level, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexLevelParameterivEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, int[] @params) => _GetMultiTexLevelParameterivEXT(texunit, target, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexLevelParameterivEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, void* @params) => _GetMultiTexLevelParameterivEXT_ptr(texunit, target, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexLevelParameterivEXT(TextureUnit texunit, TextureTarget target, int level, GetTextureParameter pname, IntPtr @params) => _GetMultiTexLevelParameterivEXT_intptr(texunit, target, level, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int[] @params) => _GetMultiTexParameterIivEXT(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, void* @params) => _GetMultiTexParameterIivEXT_ptr(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetMultiTexParameterIivEXT_intptr(texunit, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, uint[] @params) => _GetMultiTexParameterIuivEXT(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, void* @params) => _GetMultiTexParameterIuivEXT_ptr(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetMultiTexParameterIuivEXT_intptr(texunit, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, float[] @params) => _GetMultiTexParameterfvEXT(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, void* @params) => _GetMultiTexParameterfvEXT_ptr(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetMultiTexParameterfvEXT_intptr(texunit, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, int[] @params) => _GetMultiTexParameterivEXT(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, void* @params) => _GetMultiTexParameterivEXT_ptr(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetMultiTexParameterivEXT_intptr(texunit, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultisamplefv(GetMultisamplePNameNV pname, uint index, float[] val) => _GetMultisamplefv(pname, index, val);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultisamplefv(GetMultisamplePNameNV pname, uint index, void* val) => _GetMultisamplefv_ptr(pname, index, val);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultisamplefv(GetMultisamplePNameNV pname, uint index, IntPtr val) => _GetMultisamplefv_intptr(pname, index, val);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultisamplefvNV(GetMultisamplePNameNV pname, uint index, float[] val) => _GetMultisamplefvNV(pname, index, val);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultisamplefvNV(GetMultisamplePNameNV pname, uint index, void* val) => _GetMultisamplefvNV_ptr(pname, index, val);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMultisamplefvNV(GetMultisamplePNameNV pname, uint index, IntPtr val) => _GetMultisamplefvNV_intptr(pname, index, val);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferParameteri64v(uint buffer, BufferPNameARB pname, Int64[] @params) => _GetNamedBufferParameteri64v(buffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferParameteri64v(uint buffer, BufferPNameARB pname, void* @params) => _GetNamedBufferParameteri64v_ptr(buffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferParameteri64v(uint buffer, BufferPNameARB pname, IntPtr @params) => _GetNamedBufferParameteri64v_intptr(buffer, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferParameteriv(uint buffer, BufferPNameARB pname, int[] @params) => _GetNamedBufferParameteriv(buffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferParameteriv(uint buffer, BufferPNameARB pname, void* @params) => _GetNamedBufferParameteriv_ptr(buffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferParameteriv(uint buffer, BufferPNameARB pname, IntPtr @params) => _GetNamedBufferParameteriv_intptr(buffer, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferParameterivEXT(uint buffer, BufferPNameARB pname, int[] @params) => _GetNamedBufferParameterivEXT(buffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferParameterivEXT(uint buffer, BufferPNameARB pname, void* @params) => _GetNamedBufferParameterivEXT_ptr(buffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferParameterivEXT(uint buffer, BufferPNameARB pname, IntPtr @params) => _GetNamedBufferParameterivEXT_intptr(buffer, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferParameterui64vNV(uint buffer, BufferPNameARB pname, UInt64[] @params) => _GetNamedBufferParameterui64vNV(buffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferParameterui64vNV(uint buffer, BufferPNameARB pname, void* @params) => _GetNamedBufferParameterui64vNV_ptr(buffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferParameterui64vNV(uint buffer, BufferPNameARB pname, IntPtr @params) => _GetNamedBufferParameterui64vNV_intptr(buffer, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferPointerv(uint buffer, BufferPointerNameARB pname, IntPtr* @params) => _GetNamedBufferPointerv(buffer, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferPointervEXT(uint buffer, BufferPointerNameARB pname, IntPtr* @params) => _GetNamedBufferPointervEXT(buffer, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferSubData(uint buffer, IntPtr offset, IntPtr size, IntPtr data) => _GetNamedBufferSubData(buffer, offset, size, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedBufferSubDataEXT(uint buffer, IntPtr offset, IntPtr size, IntPtr data) => _GetNamedBufferSubDataEXT(buffer, offset, size, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedFramebufferParameterfvAMD(uint framebuffer, int pname, uint numsamples, uint pixelindex, int size, float[] values) => _GetNamedFramebufferParameterfvAMD(framebuffer, pname, numsamples, pixelindex, size, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedFramebufferParameterfvAMD(uint framebuffer, int pname, uint numsamples, uint pixelindex, int size, void* values) => _GetNamedFramebufferParameterfvAMD_ptr(framebuffer, pname, numsamples, pixelindex, size, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedFramebufferParameterfvAMD(uint framebuffer, int pname, uint numsamples, uint pixelindex, int size, IntPtr values) => _GetNamedFramebufferParameterfvAMD_intptr(framebuffer, pname, numsamples, pixelindex, size, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedFramebufferAttachmentParameteriv(uint framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int[] @params) => _GetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedFramebufferAttachmentParameteriv(uint framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, void* @params) => _GetNamedFramebufferAttachmentParameteriv_ptr(framebuffer, attachment, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedFramebufferAttachmentParameteriv(uint framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, IntPtr @params) => _GetNamedFramebufferAttachmentParameteriv_intptr(framebuffer, attachment, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedFramebufferAttachmentParameterivEXT(uint framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, int[] @params) => _GetNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedFramebufferAttachmentParameterivEXT(uint framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, void* @params) => _GetNamedFramebufferAttachmentParameterivEXT_ptr(framebuffer, attachment, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedFramebufferAttachmentParameterivEXT(uint framebuffer, FramebufferAttachment attachment, FramebufferAttachmentParameterName pname, IntPtr @params) => _GetNamedFramebufferAttachmentParameterivEXT_intptr(framebuffer, attachment, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedFramebufferParameteriv(uint framebuffer, GetFramebufferParameter pname, int[] param) => _GetNamedFramebufferParameteriv(framebuffer, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedFramebufferParameteriv(uint framebuffer, GetFramebufferParameter pname, void* param) => _GetNamedFramebufferParameteriv_ptr(framebuffer, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedFramebufferParameteriv(uint framebuffer, GetFramebufferParameter pname, IntPtr param) => _GetNamedFramebufferParameteriv_intptr(framebuffer, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedFramebufferParameterivEXT(uint framebuffer, GetFramebufferParameter pname, int[] @params) => _GetNamedFramebufferParameterivEXT(framebuffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedFramebufferParameterivEXT(uint framebuffer, GetFramebufferParameter pname, void* @params) => _GetNamedFramebufferParameterivEXT_ptr(framebuffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedFramebufferParameterivEXT(uint framebuffer, GetFramebufferParameter pname, IntPtr @params) => _GetNamedFramebufferParameterivEXT_intptr(framebuffer, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedProgramLocalParameterIivEXT(uint program, ProgramTarget target, uint index, int[] @params) => _GetNamedProgramLocalParameterIivEXT(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedProgramLocalParameterIivEXT(uint program, ProgramTarget target, uint index, void* @params) => _GetNamedProgramLocalParameterIivEXT_ptr(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedProgramLocalParameterIivEXT(uint program, ProgramTarget target, uint index, IntPtr @params) => _GetNamedProgramLocalParameterIivEXT_intptr(program, target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedProgramLocalParameterIuivEXT(uint program, ProgramTarget target, uint index, uint[] @params) => _GetNamedProgramLocalParameterIuivEXT(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedProgramLocalParameterIuivEXT(uint program, ProgramTarget target, uint index, void* @params) => _GetNamedProgramLocalParameterIuivEXT_ptr(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedProgramLocalParameterIuivEXT(uint program, ProgramTarget target, uint index, IntPtr @params) => _GetNamedProgramLocalParameterIuivEXT_intptr(program, target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedProgramLocalParameterdvEXT(uint program, ProgramTarget target, uint index, double[] @params) => _GetNamedProgramLocalParameterdvEXT(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedProgramLocalParameterdvEXT(uint program, ProgramTarget target, uint index, void* @params) => _GetNamedProgramLocalParameterdvEXT_ptr(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedProgramLocalParameterdvEXT(uint program, ProgramTarget target, uint index, IntPtr @params) => _GetNamedProgramLocalParameterdvEXT_intptr(program, target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedProgramLocalParameterfvEXT(uint program, ProgramTarget target, uint index, float[] @params) => _GetNamedProgramLocalParameterfvEXT(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedProgramLocalParameterfvEXT(uint program, ProgramTarget target, uint index, void* @params) => _GetNamedProgramLocalParameterfvEXT_ptr(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedProgramLocalParameterfvEXT(uint program, ProgramTarget target, uint index, IntPtr @params) => _GetNamedProgramLocalParameterfvEXT_intptr(program, target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedProgramStringEXT(uint program, ProgramTarget target, ProgramStringProperty pname, IntPtr @string) => _GetNamedProgramStringEXT(program, target, pname, @string);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedProgramivEXT(uint program, ProgramTarget target, ProgramPropertyARB pname, out int @params) => _GetNamedProgramivEXT(program, target, pname, out @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedRenderbufferParameteriv(uint renderbuffer, RenderbufferParameterName pname, int[] @params) => _GetNamedRenderbufferParameteriv(renderbuffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedRenderbufferParameteriv(uint renderbuffer, RenderbufferParameterName pname, void* @params) => _GetNamedRenderbufferParameteriv_ptr(renderbuffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedRenderbufferParameteriv(uint renderbuffer, RenderbufferParameterName pname, IntPtr @params) => _GetNamedRenderbufferParameteriv_intptr(renderbuffer, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedRenderbufferParameterivEXT(uint renderbuffer, RenderbufferParameterName pname, int[] @params) => _GetNamedRenderbufferParameterivEXT(renderbuffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedRenderbufferParameterivEXT(uint renderbuffer, RenderbufferParameterName pname, void* @params) => _GetNamedRenderbufferParameterivEXT_ptr(renderbuffer, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedRenderbufferParameterivEXT(uint renderbuffer, RenderbufferParameterName pname, IntPtr @params) => _GetNamedRenderbufferParameterivEXT_intptr(renderbuffer, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedStringARB(int namelen, string name, int bufSize, out int stringlen, string @string) => _GetNamedStringARB(namelen, name, bufSize, out stringlen, @string);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedStringARB(int namelen, void* name, int bufSize, out int stringlen, void* @string) => _GetNamedStringARB_ptr(namelen, name, bufSize, out stringlen, @string);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedStringARB(int namelen, IntPtr name, int bufSize, out int stringlen, IntPtr @string) => _GetNamedStringARB_intptr(namelen, name, bufSize, out stringlen, @string);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedStringivARB(int namelen, string name, int pname, int[] @params) => _GetNamedStringivARB(namelen, name, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedStringivARB(int namelen, void* name, int pname, void* @params) => _GetNamedStringivARB_ptr(namelen, name, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNamedStringivARB(int namelen, IntPtr name, int pname, IntPtr @params) => _GetNamedStringivARB_intptr(namelen, name, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNextPerfQueryIdINTEL(uint queryId, uint[] nextQueryId) => _GetNextPerfQueryIdINTEL(queryId, nextQueryId);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNextPerfQueryIdINTEL(uint queryId, void* nextQueryId) => _GetNextPerfQueryIdINTEL_ptr(queryId, nextQueryId);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetNextPerfQueryIdINTEL(uint queryId, IntPtr nextQueryId) => _GetNextPerfQueryIdINTEL_intptr(queryId, nextQueryId);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectBufferfvATI(uint buffer, ArrayObjectPNameATI pname, out float @params) => _GetObjectBufferfvATI(buffer, pname, out @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectBufferivATI(uint buffer, ArrayObjectPNameATI pname, out int @params) => _GetObjectBufferivATI(buffer, pname, out @params);

        // ---

        /// <summary>
        /// glGetObjectLabel retrieves the label of the object identified by            name within the namespace given by identifier.            identifier must be one of GL_BUFFER, GL_SHADER,            GL_PROGRAM, GL_VERTEX_ARRAY, GL_QUERY,            GL_PROGRAM_PIPELINE, GL_TRANSFORM_FEEDBACK, GL_SAMPLER,            GL_TEXTURE, GL_RENDERBUFFER, GL_FRAMEBUFFER,            to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects, query objects,            program pipelines, transform feedback objects, samplers, textures, renderbuffers and frame            buffers, respectively.
        /// label is the address of a string that will be used to store the object label.            bufSize specifies the number of characters in the array identified by label.            length contains the address of a variable which will receive the number of characters in the object label.            If length is NULL, then it is ignored and no data is written. Likewise, if label            is NULL, or if bufSize is zero then no data is written to label.
        /// </summary>
        /// <param name="identifier">The namespace from which the name of the object is allocated.</param>
        /// <param name="name">The name of the object whose label to retrieve.</param>
        /// <param name="bufSize">The length of the buffer whose address is in label.</param>
        /// <param name="length">The address of a variable to receive the length of the object label.</param>
        /// <param name="label">The address of a string that will receive the object label.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, out int length, string label) => _GetObjectLabel(identifier, name, bufSize, out length, label);

        /// <summary>
        /// glGetObjectLabel retrieves the label of the object identified by            name within the namespace given by identifier.            identifier must be one of GL_BUFFER, GL_SHADER,            GL_PROGRAM, GL_VERTEX_ARRAY, GL_QUERY,            GL_PROGRAM_PIPELINE, GL_TRANSFORM_FEEDBACK, GL_SAMPLER,            GL_TEXTURE, GL_RENDERBUFFER, GL_FRAMEBUFFER,            to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects, query objects,            program pipelines, transform feedback objects, samplers, textures, renderbuffers and frame            buffers, respectively.
        /// label is the address of a string that will be used to store the object label.            bufSize specifies the number of characters in the array identified by label.            length contains the address of a variable which will receive the number of characters in the object label.            If length is NULL, then it is ignored and no data is written. Likewise, if label            is NULL, or if bufSize is zero then no data is written to label.
        /// </summary>
        /// <param name="identifier">The namespace from which the name of the object is allocated.</param>
        /// <param name="name">The name of the object whose label to retrieve.</param>
        /// <param name="bufSize">The length of the buffer whose address is in label.</param>
        /// <param name="length">The address of a variable to receive the length of the object label.</param>
        /// <param name="label">The address of a string that will receive the object label.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, out int length, void* label) => _GetObjectLabel_ptr(identifier, name, bufSize, out length, label);

        /// <summary>
        /// glGetObjectLabel retrieves the label of the object identified by            name within the namespace given by identifier.            identifier must be one of GL_BUFFER, GL_SHADER,            GL_PROGRAM, GL_VERTEX_ARRAY, GL_QUERY,            GL_PROGRAM_PIPELINE, GL_TRANSFORM_FEEDBACK, GL_SAMPLER,            GL_TEXTURE, GL_RENDERBUFFER, GL_FRAMEBUFFER,            to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects, query objects,            program pipelines, transform feedback objects, samplers, textures, renderbuffers and frame            buffers, respectively.
        /// label is the address of a string that will be used to store the object label.            bufSize specifies the number of characters in the array identified by label.            length contains the address of a variable which will receive the number of characters in the object label.            If length is NULL, then it is ignored and no data is written. Likewise, if label            is NULL, or if bufSize is zero then no data is written to label.
        /// </summary>
        /// <param name="identifier">The namespace from which the name of the object is allocated.</param>
        /// <param name="name">The name of the object whose label to retrieve.</param>
        /// <param name="bufSize">The length of the buffer whose address is in label.</param>
        /// <param name="length">The address of a variable to receive the length of the object label.</param>
        /// <param name="label">The address of a string that will receive the object label.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectLabel(ObjectIdentifier identifier, uint name, int bufSize, out int length, IntPtr label) => _GetObjectLabel_intptr(identifier, name, bufSize, out length, label);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectLabelEXT(int type, uint @object, int bufSize, out int length, string label) => _GetObjectLabelEXT(type, @object, bufSize, out length, label);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectLabelEXT(int type, uint @object, int bufSize, out int length, void* label) => _GetObjectLabelEXT_ptr(type, @object, bufSize, out length, label);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectLabelEXT(int type, uint @object, int bufSize, out int length, IntPtr label) => _GetObjectLabelEXT_intptr(type, @object, bufSize, out length, label);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectLabelKHR(int identifier, uint name, int bufSize, int[] length, string label) => _GetObjectLabelKHR(identifier, name, bufSize, length, label);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectLabelKHR(int identifier, uint name, int bufSize, void* length, void* label) => _GetObjectLabelKHR_ptr(identifier, name, bufSize, length, label);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectLabelKHR(int identifier, uint name, int bufSize, IntPtr length, IntPtr label) => _GetObjectLabelKHR_intptr(identifier, name, bufSize, length, label);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectParameterfvARB(int obj, int pname, float[] @params) => _GetObjectParameterfvARB(obj, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectParameterfvARB(int obj, int pname, void* @params) => _GetObjectParameterfvARB_ptr(obj, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectParameterfvARB(int obj, int pname, IntPtr @params) => _GetObjectParameterfvARB_intptr(obj, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectParameterivAPPLE(int objectType, uint name, int pname, int[] @params) => _GetObjectParameterivAPPLE(objectType, name, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectParameterivAPPLE(int objectType, uint name, int pname, void* @params) => _GetObjectParameterivAPPLE_ptr(objectType, name, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectParameterivAPPLE(int objectType, uint name, int pname, IntPtr @params) => _GetObjectParameterivAPPLE_intptr(objectType, name, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectParameterivARB(int obj, int pname, int[] @params) => _GetObjectParameterivARB(obj, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectParameterivARB(int obj, int pname, void* @params) => _GetObjectParameterivARB_ptr(obj, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectParameterivARB(int obj, int pname, IntPtr @params) => _GetObjectParameterivARB_intptr(obj, pname, @params);

        // ---

        /// <summary>
        /// glGetObjectPtrLabel retrieves the label of the sync object identified by            ptr.
        /// label is the address of a string that will be used to store the object label.            bufSize specifies the number of characters in the array identified by label.            length contains the address of a variable which will receive the number of characters in the object label.            If length is NULL, then it is ignored and no data is written. Likewise, if label            is NULL, or if bufSize is zero then no data is written to label.
        /// </summary>
        /// <param name="ptr">The name of the sync object whose label to retrieve.</param>
        /// <param name="bufSize">The length of the buffer whose address is in label.</param>
        /// <param name="length">The address of a variable to receive the length of the object label.</param>
        /// <param name="label">The address of a string that will receive the object label.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectPtrLabel(IntPtr ptr, int bufSize, out int length, string label) => _GetObjectPtrLabel(ptr, bufSize, out length, label);

        /// <summary>
        /// glGetObjectPtrLabel retrieves the label of the sync object identified by            ptr.
        /// label is the address of a string that will be used to store the object label.            bufSize specifies the number of characters in the array identified by label.            length contains the address of a variable which will receive the number of characters in the object label.            If length is NULL, then it is ignored and no data is written. Likewise, if label            is NULL, or if bufSize is zero then no data is written to label.
        /// </summary>
        /// <param name="ptr">The name of the sync object whose label to retrieve.</param>
        /// <param name="bufSize">The length of the buffer whose address is in label.</param>
        /// <param name="length">The address of a variable to receive the length of the object label.</param>
        /// <param name="label">The address of a string that will receive the object label.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectPtrLabel(IntPtr ptr, int bufSize, out int length, void* label) => _GetObjectPtrLabel_ptr(ptr, bufSize, out length, label);

        /// <summary>
        /// glGetObjectPtrLabel retrieves the label of the sync object identified by            ptr.
        /// label is the address of a string that will be used to store the object label.            bufSize specifies the number of characters in the array identified by label.            length contains the address of a variable which will receive the number of characters in the object label.            If length is NULL, then it is ignored and no data is written. Likewise, if label            is NULL, or if bufSize is zero then no data is written to label.
        /// </summary>
        /// <param name="ptr">The name of the sync object whose label to retrieve.</param>
        /// <param name="bufSize">The length of the buffer whose address is in label.</param>
        /// <param name="length">The address of a variable to receive the length of the object label.</param>
        /// <param name="label">The address of a string that will receive the object label.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectPtrLabel(IntPtr ptr, int bufSize, out int length, IntPtr label) => _GetObjectPtrLabel_intptr(ptr, bufSize, out length, label);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectPtrLabelKHR(IntPtr ptr, int bufSize, out int length, string label) => _GetObjectPtrLabelKHR(ptr, bufSize, out length, label);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectPtrLabelKHR(IntPtr ptr, int bufSize, out int length, void* label) => _GetObjectPtrLabelKHR_ptr(ptr, bufSize, out length, label);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetObjectPtrLabelKHR(IntPtr ptr, int bufSize, out int length, IntPtr label) => _GetObjectPtrLabelKHR_intptr(ptr, bufSize, out length, label);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetOcclusionQueryivNV(uint id, OcclusionQueryParameterNameNV pname, int[] @params) => _GetOcclusionQueryivNV(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetOcclusionQueryivNV(uint id, OcclusionQueryParameterNameNV pname, void* @params) => _GetOcclusionQueryivNV_ptr(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetOcclusionQueryivNV(uint id, OcclusionQueryParameterNameNV pname, IntPtr @params) => _GetOcclusionQueryivNV_intptr(id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetOcclusionQueryuivNV(uint id, OcclusionQueryParameterNameNV pname, uint[] @params) => _GetOcclusionQueryuivNV(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetOcclusionQueryuivNV(uint id, OcclusionQueryParameterNameNV pname, void* @params) => _GetOcclusionQueryuivNV_ptr(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetOcclusionQueryuivNV(uint id, OcclusionQueryParameterNameNV pname, IntPtr @params) => _GetOcclusionQueryuivNV_intptr(id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathColorGenfvNV(PathColor color, PathGenMode pname, float[] value) => _GetPathColorGenfvNV(color, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathColorGenfvNV(PathColor color, PathGenMode pname, void* value) => _GetPathColorGenfvNV_ptr(color, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathColorGenfvNV(PathColor color, PathGenMode pname, IntPtr value) => _GetPathColorGenfvNV_intptr(color, pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathColorGenivNV(PathColor color, PathGenMode pname, int[] value) => _GetPathColorGenivNV(color, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathColorGenivNV(PathColor color, PathGenMode pname, void* value) => _GetPathColorGenivNV_ptr(color, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathColorGenivNV(PathColor color, PathGenMode pname, IntPtr value) => _GetPathColorGenivNV_intptr(color, pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathCommandsNV(uint path, byte[] commands) => _GetPathCommandsNV(path, commands);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathCommandsNV(uint path, void* commands) => _GetPathCommandsNV_ptr(path, commands);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathCommandsNV(uint path, IntPtr commands) => _GetPathCommandsNV_intptr(path, commands);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathCoordsNV(uint path, float[] coords) => _GetPathCoordsNV(path, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathCoordsNV(uint path, void* coords) => _GetPathCoordsNV_ptr(path, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathCoordsNV(uint path, IntPtr coords) => _GetPathCoordsNV_intptr(path, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathDashArrayNV(uint path, float[] dashArray) => _GetPathDashArrayNV(path, dashArray);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathDashArrayNV(uint path, void* dashArray) => _GetPathDashArrayNV_ptr(path, dashArray);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathDashArrayNV(uint path, IntPtr dashArray) => _GetPathDashArrayNV_intptr(path, dashArray);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float GetPathLengthNV(uint path, int startSegment, int numSegments) => _GetPathLengthNV(path, startSegment, numSegments);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathMetricRangeNV(int metricQueryMask, uint firstPathName, int numPaths, int stride, float[] metrics) => _GetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathMetricRangeNV(int metricQueryMask, uint firstPathName, int numPaths, int stride, void* metrics) => _GetPathMetricRangeNV_ptr(metricQueryMask, firstPathName, numPaths, stride, metrics);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathMetricRangeNV(int metricQueryMask, uint firstPathName, int numPaths, int stride, IntPtr metrics) => _GetPathMetricRangeNV_intptr(metricQueryMask, firstPathName, numPaths, stride, metrics);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathMetricsNV(int metricQueryMask, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int stride, float[] metrics) => _GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathMetricsNV(int metricQueryMask, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int stride, void* metrics) => _GetPathMetricsNV_ptr(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathMetricsNV(int metricQueryMask, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int stride, IntPtr metrics) => _GetPathMetricsNV_intptr(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathParameterfvNV(uint path, PathParameter pname, float[] value) => _GetPathParameterfvNV(path, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathParameterfvNV(uint path, PathParameter pname, void* value) => _GetPathParameterfvNV_ptr(path, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathParameterfvNV(uint path, PathParameter pname, IntPtr value) => _GetPathParameterfvNV_intptr(path, pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathParameterivNV(uint path, PathParameter pname, int[] value) => _GetPathParameterivNV(path, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathParameterivNV(uint path, PathParameter pname, void* value) => _GetPathParameterivNV_ptr(path, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathParameterivNV(uint path, PathParameter pname, IntPtr value) => _GetPathParameterivNV_intptr(path, pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathSpacingNV(PathListMode pathListMode, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, float[] returnedSpacing) => _GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathSpacingNV(PathListMode pathListMode, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, void* returnedSpacing) => _GetPathSpacingNV_ptr(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathSpacingNV(PathListMode pathListMode, int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, float advanceScale, float kerningScale, PathTransformType transformType, IntPtr returnedSpacing) => _GetPathSpacingNV_intptr(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathTexGenfvNV(TextureUnit texCoordSet, PathGenMode pname, float[] value) => _GetPathTexGenfvNV(texCoordSet, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathTexGenfvNV(TextureUnit texCoordSet, PathGenMode pname, void* value) => _GetPathTexGenfvNV_ptr(texCoordSet, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathTexGenfvNV(TextureUnit texCoordSet, PathGenMode pname, IntPtr value) => _GetPathTexGenfvNV_intptr(texCoordSet, pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathTexGenivNV(TextureUnit texCoordSet, PathGenMode pname, int[] value) => _GetPathTexGenivNV(texCoordSet, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathTexGenivNV(TextureUnit texCoordSet, PathGenMode pname, void* value) => _GetPathTexGenivNV_ptr(texCoordSet, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPathTexGenivNV(TextureUnit texCoordSet, PathGenMode pname, IntPtr value) => _GetPathTexGenivNV_intptr(texCoordSet, pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, string counterName, uint counterDescLength, string counterDesc, uint[] counterOffset, uint[] counterDataSize, uint[] counterTypeEnum, uint[] counterDataTypeEnum, UInt64[] rawCounterMaxValue) => _GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, void* counterName, uint counterDescLength, void* counterDesc, void* counterOffset, void* counterDataSize, void* counterTypeEnum, void* counterDataTypeEnum, void* rawCounterMaxValue) => _GetPerfCounterInfoINTEL_ptr(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, IntPtr counterName, uint counterDescLength, IntPtr counterDesc, IntPtr counterOffset, IntPtr counterDataSize, IntPtr counterTypeEnum, IntPtr counterDataTypeEnum, IntPtr rawCounterMaxValue) => _GetPerfCounterInfoINTEL_intptr(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorCounterDataAMD(uint monitor, int pname, int dataSize, uint[] data, out int bytesWritten) => _GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, out bytesWritten);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorCounterDataAMD(uint monitor, int pname, int dataSize, void* data, out int bytesWritten) => _GetPerfMonitorCounterDataAMD_ptr(monitor, pname, dataSize, data, out bytesWritten);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorCounterDataAMD(uint monitor, int pname, int dataSize, IntPtr data, out int bytesWritten) => _GetPerfMonitorCounterDataAMD_intptr(monitor, pname, dataSize, data, out bytesWritten);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorCounterInfoAMD(uint group, uint counter, int pname, IntPtr data) => _GetPerfMonitorCounterInfoAMD(group, counter, pname, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, out int length, string counterString) => _GetPerfMonitorCounterStringAMD(group, counter, bufSize, out length, counterString);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, out int length, void* counterString) => _GetPerfMonitorCounterStringAMD_ptr(group, counter, bufSize, out length, counterString);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, out int length, IntPtr counterString) => _GetPerfMonitorCounterStringAMD_intptr(group, counter, bufSize, out length, counterString);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorCountersAMD(uint group, out int numCounters, out int maxActiveCounters, int counterSize, uint[] counters) => _GetPerfMonitorCountersAMD(group, out numCounters, out maxActiveCounters, counterSize, counters);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorCountersAMD(uint group, out int numCounters, out int maxActiveCounters, int counterSize, void* counters) => _GetPerfMonitorCountersAMD_ptr(group, out numCounters, out maxActiveCounters, counterSize, counters);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorCountersAMD(uint group, out int numCounters, out int maxActiveCounters, int counterSize, IntPtr counters) => _GetPerfMonitorCountersAMD_intptr(group, out numCounters, out maxActiveCounters, counterSize, counters);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorGroupStringAMD(uint group, int bufSize, out int length, string groupString) => _GetPerfMonitorGroupStringAMD(group, bufSize, out length, groupString);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorGroupStringAMD(uint group, int bufSize, out int length, void* groupString) => _GetPerfMonitorGroupStringAMD_ptr(group, bufSize, out length, groupString);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorGroupStringAMD(uint group, int bufSize, out int length, IntPtr groupString) => _GetPerfMonitorGroupStringAMD_intptr(group, bufSize, out length, groupString);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorGroupsAMD(out int numGroups, int groupsSize, uint[] groups) => _GetPerfMonitorGroupsAMD(out numGroups, groupsSize, groups);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorGroupsAMD(out int numGroups, int groupsSize, void* groups) => _GetPerfMonitorGroupsAMD_ptr(out numGroups, groupsSize, groups);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfMonitorGroupsAMD(out int numGroups, int groupsSize, IntPtr groups) => _GetPerfMonitorGroupsAMD_intptr(out numGroups, groupsSize, groups);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfQueryDataINTEL(uint queryHandle, uint flags, int dataSize, IntPtr data, uint[] bytesWritten) => _GetPerfQueryDataINTEL(queryHandle, flags, dataSize, data, bytesWritten);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfQueryDataINTEL(uint queryHandle, uint flags, int dataSize, IntPtr data, void* bytesWritten) => _GetPerfQueryDataINTEL_ptr(queryHandle, flags, dataSize, data, bytesWritten);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfQueryDataINTEL(uint queryHandle, uint flags, int dataSize, IntPtr data, IntPtr bytesWritten) => _GetPerfQueryDataINTEL_intptr(queryHandle, flags, dataSize, data, bytesWritten);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfQueryIdByNameINTEL(string queryName, uint[] queryId) => _GetPerfQueryIdByNameINTEL(queryName, queryId);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfQueryIdByNameINTEL(void* queryName, void* queryId) => _GetPerfQueryIdByNameINTEL_ptr(queryName, queryId);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfQueryIdByNameINTEL(IntPtr queryName, IntPtr queryId) => _GetPerfQueryIdByNameINTEL_intptr(queryName, queryId);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, string queryName, uint[] dataSize, uint[] noCounters, uint[] noInstances, uint[] capsMask) => _GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, void* queryName, void* dataSize, void* noCounters, void* noInstances, void* capsMask) => _GetPerfQueryInfoINTEL_ptr(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, IntPtr queryName, IntPtr dataSize, IntPtr noCounters, IntPtr noInstances, IntPtr capsMask) => _GetPerfQueryInfoINTEL_intptr(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelMapfv(PixelMap map, float[] values) => _GetPixelMapfv(map, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelMapfv(PixelMap map, void* values) => _GetPixelMapfv_ptr(map, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelMapfv(PixelMap map, IntPtr values) => _GetPixelMapfv_intptr(map, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelMapuiv(PixelMap map, uint[] values) => _GetPixelMapuiv(map, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelMapuiv(PixelMap map, void* values) => _GetPixelMapuiv_ptr(map, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelMapuiv(PixelMap map, IntPtr values) => _GetPixelMapuiv_intptr(map, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelMapusv(PixelMap map, ushort[] values) => _GetPixelMapusv(map, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelMapusv(PixelMap map, void* values) => _GetPixelMapusv_ptr(map, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelMapusv(PixelMap map, IntPtr values) => _GetPixelMapusv_intptr(map, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelMapxv(PixelMap map, int size, float[] values) => _GetPixelMapxv(map, size, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelMapxv(PixelMap map, int size, void* values) => _GetPixelMapxv_ptr(map, size, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelMapxv(PixelMap map, int size, IntPtr values) => _GetPixelMapxv_intptr(map, size, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, float[] @params) => _GetPixelTexGenParameterfvSGIS(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, void* @params) => _GetPixelTexGenParameterfvSGIS_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, IntPtr @params) => _GetPixelTexGenParameterfvSGIS_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, int[] @params) => _GetPixelTexGenParameterivSGIS(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, void* @params) => _GetPixelTexGenParameterivSGIS_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, IntPtr @params) => _GetPixelTexGenParameterivSGIS_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelTransformParameterfvEXT(int target, int pname, float[] @params) => _GetPixelTransformParameterfvEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelTransformParameterfvEXT(int target, int pname, void* @params) => _GetPixelTransformParameterfvEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelTransformParameterfvEXT(int target, int pname, IntPtr @params) => _GetPixelTransformParameterfvEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelTransformParameterivEXT(int target, int pname, int[] @params) => _GetPixelTransformParameterivEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelTransformParameterivEXT(int target, int pname, void* @params) => _GetPixelTransformParameterivEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPixelTransformParameterivEXT(int target, int pname, IntPtr @params) => _GetPixelTransformParameterivEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPointerIndexedvEXT(int target, uint index, IntPtr* data) => _GetPointerIndexedvEXT(target, index, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPointeri_vEXT(int pname, uint index, IntPtr* @params) => _GetPointeri_vEXT(pname, index, @params);

        // ---

        /// <summary>
        /// glGetPointerv returns pointer information.            pname indicates the pointer to be            returned, and params is a pointer to a            location in which to place the returned data. The parameters            that may be queried include:
        /// GL_DEBUG_CALLBACK_FUNCTION                        Returns the current callback function set with the                        callback argument of                        glDebugMessageCallback.                    GL_DEBUG_CALLBACK_USER_PARAM                        Returns the user parameter to the current callback                        function set with the                        userParam argument of                        glDebugMessageCallback.
        /// </summary>
        /// <param name="pname">Specifies the pointer to be returned. Must be one of                    GL_DEBUG_CALLBACK_FUNCTION or                    GL_DEBUG_CALLBACK_USER_PARAM.</param>
        /// <param name="params">Returns the pointer value specified by pname.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPointerv(GetPointervPName pname, IntPtr* @params) => _GetPointerv(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPointervEXT(GetPointervPName pname, IntPtr* @params) => _GetPointervEXT(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPointervKHR(int pname, IntPtr* @params) => _GetPointervKHR(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPolygonStipple(byte[] mask) => _GetPolygonStipple(mask);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPolygonStipple(void* mask) => _GetPolygonStipple_ptr(mask);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetPolygonStipple(IntPtr mask) => _GetPolygonStipple_intptr(mask);

        // ---

        /// <summary>
        /// glGetProgramBinary returns a binary representation of the compiled            and linked executable for program into the array of bytes whose            address is specified in binary. The maximum number of bytes that            may be written into binary is specified by bufSize.            If the program binary is greater in size than bufSize bytes,            then an error is generated, otherwise the actual number of bytes written into binary            is returned in the variable whose address is given by length. If            length is NULL, then no length is returned.
        /// The format of the program binary written into binary is returned in            the variable whose address is given by binaryFormat, and may be implementation dependent. The binary produced            by the GL may subsequently be returned to the GL by calling glProgramBinary,            with binaryFormat and length set to the values            returned by glGetProgramBinary, and passing the returned binary data            in the binary parameter.
        /// </summary>
        /// <param name="program">Specifies the name of a program object whose binary representation to retrieve.</param>
        /// <param name="bufSize">Specifies the size of the buffer whose address is given by binary.</param>
        /// <param name="length">Specifies the address of a variable to receive the number of bytes written into binary.</param>
        /// <param name="binaryFormat">Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.</param>
        /// <param name="binary">Specifies the address an array into which the GL will return program's binary representation.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramBinary(uint program, int bufSize, out int length, out int binaryFormat, IntPtr binary) => _GetProgramBinary(program, bufSize, out length, out binaryFormat, binary);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramBinaryOES(uint program, int bufSize, out int length, out int binaryFormat, IntPtr binary) => _GetProgramBinaryOES(program, bufSize, out length, out binaryFormat, binary);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramEnvParameterIivNV(ProgramTarget target, uint index, int[] @params) => _GetProgramEnvParameterIivNV(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramEnvParameterIivNV(ProgramTarget target, uint index, void* @params) => _GetProgramEnvParameterIivNV_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramEnvParameterIivNV(ProgramTarget target, uint index, IntPtr @params) => _GetProgramEnvParameterIivNV_intptr(target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramEnvParameterIuivNV(ProgramTarget target, uint index, uint[] @params) => _GetProgramEnvParameterIuivNV(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramEnvParameterIuivNV(ProgramTarget target, uint index, void* @params) => _GetProgramEnvParameterIuivNV_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramEnvParameterIuivNV(ProgramTarget target, uint index, IntPtr @params) => _GetProgramEnvParameterIuivNV_intptr(target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramEnvParameterdvARB(ProgramTarget target, uint index, double[] @params) => _GetProgramEnvParameterdvARB(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramEnvParameterdvARB(ProgramTarget target, uint index, void* @params) => _GetProgramEnvParameterdvARB_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramEnvParameterdvARB(ProgramTarget target, uint index, IntPtr @params) => _GetProgramEnvParameterdvARB_intptr(target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramEnvParameterfvARB(ProgramTarget target, uint index, float[] @params) => _GetProgramEnvParameterfvARB(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramEnvParameterfvARB(ProgramTarget target, uint index, void* @params) => _GetProgramEnvParameterfvARB_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramEnvParameterfvARB(ProgramTarget target, uint index, IntPtr @params) => _GetProgramEnvParameterfvARB_intptr(target, index, @params);

        // ---

        /// <summary>
        /// glGetProgramInfoLog returns the        information log for the specified program object. The        information log for a program object is modified when the        program object is linked or validated. The string that is        returned will be null terminated.
        /// glGetProgramInfoLog returns in        infoLog as much of the information log as        it can, up to a maximum of maxLength        characters. The number of characters actually returned,        excluding the null termination character, is specified by        length. If the length of the returned        string is not required, a value of NULL can        be passed in the length argument. The        size of the buffer required to store the returned information        log can be obtained by calling        glGetProgram        with the value GL_INFO_LOG_LENGTH.
        /// The information log for a program object is either an        empty string, or a string containing information about the last        link operation, or a string containing information about the        last validation operation. It may contain diagnostic messages,        warning messages, and other information. When a program object        is created, its information log will be a string of length        0.
        /// </summary>
        /// <param name="program">Specifies the program object whose information                    log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for                    storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in                    infoLog (excluding the null                    terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used                    to return the information log.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramInfoLog(uint program, int bufSize, out int length, string infoLog) => _GetProgramInfoLog(program, bufSize, out length, infoLog);

        /// <summary>
        /// glGetProgramInfoLog returns the        information log for the specified program object. The        information log for a program object is modified when the        program object is linked or validated. The string that is        returned will be null terminated.
        /// glGetProgramInfoLog returns in        infoLog as much of the information log as        it can, up to a maximum of maxLength        characters. The number of characters actually returned,        excluding the null termination character, is specified by        length. If the length of the returned        string is not required, a value of NULL can        be passed in the length argument. The        size of the buffer required to store the returned information        log can be obtained by calling        glGetProgram        with the value GL_INFO_LOG_LENGTH.
        /// The information log for a program object is either an        empty string, or a string containing information about the last        link operation, or a string containing information about the        last validation operation. It may contain diagnostic messages,        warning messages, and other information. When a program object        is created, its information log will be a string of length        0.
        /// </summary>
        /// <param name="program">Specifies the program object whose information                    log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for                    storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in                    infoLog (excluding the null                    terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used                    to return the information log.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramInfoLog(uint program, int bufSize, out int length, void* infoLog) => _GetProgramInfoLog_ptr(program, bufSize, out length, infoLog);

        /// <summary>
        /// glGetProgramInfoLog returns the        information log for the specified program object. The        information log for a program object is modified when the        program object is linked or validated. The string that is        returned will be null terminated.
        /// glGetProgramInfoLog returns in        infoLog as much of the information log as        it can, up to a maximum of maxLength        characters. The number of characters actually returned,        excluding the null termination character, is specified by        length. If the length of the returned        string is not required, a value of NULL can        be passed in the length argument. The        size of the buffer required to store the returned information        log can be obtained by calling        glGetProgram        with the value GL_INFO_LOG_LENGTH.
        /// The information log for a program object is either an        empty string, or a string containing information about the last        link operation, or a string containing information about the        last validation operation. It may contain diagnostic messages,        warning messages, and other information. When a program object        is created, its information log will be a string of length        0.
        /// </summary>
        /// <param name="program">Specifies the program object whose information                    log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for                    storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in                    infoLog (excluding the null                    terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used                    to return the information log.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramInfoLog(uint program, int bufSize, out int length, IntPtr infoLog) => _GetProgramInfoLog_intptr(program, bufSize, out length, infoLog);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramInterfaceiv(uint program, ProgramInterface programInterface, ProgramInterfacePName pname, int[] @params) => _GetProgramInterfaceiv(program, programInterface, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramInterfaceiv(uint program, ProgramInterface programInterface, ProgramInterfacePName pname, void* @params) => _GetProgramInterfaceiv_ptr(program, programInterface, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramInterfaceiv(uint program, ProgramInterface programInterface, ProgramInterfacePName pname, IntPtr @params) => _GetProgramInterfaceiv_intptr(program, programInterface, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramLocalParameterIivNV(ProgramTarget target, uint index, int[] @params) => _GetProgramLocalParameterIivNV(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramLocalParameterIivNV(ProgramTarget target, uint index, void* @params) => _GetProgramLocalParameterIivNV_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramLocalParameterIivNV(ProgramTarget target, uint index, IntPtr @params) => _GetProgramLocalParameterIivNV_intptr(target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramLocalParameterIuivNV(ProgramTarget target, uint index, uint[] @params) => _GetProgramLocalParameterIuivNV(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramLocalParameterIuivNV(ProgramTarget target, uint index, void* @params) => _GetProgramLocalParameterIuivNV_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramLocalParameterIuivNV(ProgramTarget target, uint index, IntPtr @params) => _GetProgramLocalParameterIuivNV_intptr(target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramLocalParameterdvARB(ProgramTarget target, uint index, double[] @params) => _GetProgramLocalParameterdvARB(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramLocalParameterdvARB(ProgramTarget target, uint index, void* @params) => _GetProgramLocalParameterdvARB_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramLocalParameterdvARB(ProgramTarget target, uint index, IntPtr @params) => _GetProgramLocalParameterdvARB_intptr(target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramLocalParameterfvARB(ProgramTarget target, uint index, float[] @params) => _GetProgramLocalParameterfvARB(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramLocalParameterfvARB(ProgramTarget target, uint index, void* @params) => _GetProgramLocalParameterfvARB_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramLocalParameterfvARB(ProgramTarget target, uint index, IntPtr @params) => _GetProgramLocalParameterfvARB_intptr(target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramNamedParameterdvNV(uint id, int len, byte[] name, double[] @params) => _GetProgramNamedParameterdvNV(id, len, name, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramNamedParameterdvNV(uint id, int len, void* name, void* @params) => _GetProgramNamedParameterdvNV_ptr(id, len, name, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramNamedParameterdvNV(uint id, int len, IntPtr name, IntPtr @params) => _GetProgramNamedParameterdvNV_intptr(id, len, name, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramNamedParameterfvNV(uint id, int len, byte[] name, float[] @params) => _GetProgramNamedParameterfvNV(id, len, name, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramNamedParameterfvNV(uint id, int len, void* name, void* @params) => _GetProgramNamedParameterfvNV_ptr(id, len, name, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramNamedParameterfvNV(uint id, int len, IntPtr name, IntPtr @params) => _GetProgramNamedParameterfvNV_intptr(id, len, name, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramParameterdvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, double[] @params) => _GetProgramParameterdvNV(target, index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramParameterdvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, void* @params) => _GetProgramParameterdvNV_ptr(target, index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramParameterdvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, IntPtr @params) => _GetProgramParameterdvNV_intptr(target, index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramParameterfvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, float[] @params) => _GetProgramParameterfvNV(target, index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramParameterfvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, void* @params) => _GetProgramParameterfvNV_ptr(target, index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramParameterfvNV(VertexAttribEnumNV target, uint index, VertexAttribEnumNV pname, IntPtr @params) => _GetProgramParameterfvNV_intptr(target, index, pname, @params);

        // ---

        /// <summary>
        /// glGetProgramPipelineInfoLog retrieves the info log for the program            pipeline object pipeline. The info log, including its null terminator,            is written into the array of characters whose address is given by infoLog.            The maximum number of characters that may be written into infoLog            is given by bufSize, and the actual number of characters written            into infoLog is returned in the integer whose address is given            by length. If length is NULL,            no length is returned.
        /// The actual length of the info log for the program pipeline may be determined by calling            glGetProgramPipeline with            pname set to GL_INFO_LOG_LENGTH.
        /// </summary>
        /// <param name="pipeline">Specifies the name of a program pipeline object from which to retrieve the info log.</param>
        /// <param name="bufSize">Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.</param>
        /// <param name="length">Specifies the address of a variable into which will be written the number of characters written into infoLog.</param>
        /// <param name="infoLog">Specifies the address of an array of characters into which will be written the info log for pipeline.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramPipelineInfoLog(uint pipeline, int bufSize, out int length, string infoLog) => _GetProgramPipelineInfoLog(pipeline, bufSize, out length, infoLog);

        /// <summary>
        /// glGetProgramPipelineInfoLog retrieves the info log for the program            pipeline object pipeline. The info log, including its null terminator,            is written into the array of characters whose address is given by infoLog.            The maximum number of characters that may be written into infoLog            is given by bufSize, and the actual number of characters written            into infoLog is returned in the integer whose address is given            by length. If length is NULL,            no length is returned.
        /// The actual length of the info log for the program pipeline may be determined by calling            glGetProgramPipeline with            pname set to GL_INFO_LOG_LENGTH.
        /// </summary>
        /// <param name="pipeline">Specifies the name of a program pipeline object from which to retrieve the info log.</param>
        /// <param name="bufSize">Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.</param>
        /// <param name="length">Specifies the address of a variable into which will be written the number of characters written into infoLog.</param>
        /// <param name="infoLog">Specifies the address of an array of characters into which will be written the info log for pipeline.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramPipelineInfoLog(uint pipeline, int bufSize, out int length, void* infoLog) => _GetProgramPipelineInfoLog_ptr(pipeline, bufSize, out length, infoLog);

        /// <summary>
        /// glGetProgramPipelineInfoLog retrieves the info log for the program            pipeline object pipeline. The info log, including its null terminator,            is written into the array of characters whose address is given by infoLog.            The maximum number of characters that may be written into infoLog            is given by bufSize, and the actual number of characters written            into infoLog is returned in the integer whose address is given            by length. If length is NULL,            no length is returned.
        /// The actual length of the info log for the program pipeline may be determined by calling            glGetProgramPipeline with            pname set to GL_INFO_LOG_LENGTH.
        /// </summary>
        /// <param name="pipeline">Specifies the name of a program pipeline object from which to retrieve the info log.</param>
        /// <param name="bufSize">Specifies the maximum number of characters, including the null terminator, that may be written into infoLog.</param>
        /// <param name="length">Specifies the address of a variable into which will be written the number of characters written into infoLog.</param>
        /// <param name="infoLog">Specifies the address of an array of characters into which will be written the info log for pipeline.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramPipelineInfoLog(uint pipeline, int bufSize, out int length, IntPtr infoLog) => _GetProgramPipelineInfoLog_intptr(pipeline, bufSize, out length, infoLog);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, out int length, string infoLog) => _GetProgramPipelineInfoLogEXT(pipeline, bufSize, out length, infoLog);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, out int length, void* infoLog) => _GetProgramPipelineInfoLogEXT_ptr(pipeline, bufSize, out length, infoLog);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, out int length, IntPtr infoLog) => _GetProgramPipelineInfoLogEXT_intptr(pipeline, bufSize, out length, infoLog);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramPipelineiv(uint pipeline, PipelineParameterName pname, int[] @params) => _GetProgramPipelineiv(pipeline, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramPipelineiv(uint pipeline, PipelineParameterName pname, void* @params) => _GetProgramPipelineiv_ptr(pipeline, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramPipelineiv(uint pipeline, PipelineParameterName pname, IntPtr @params) => _GetProgramPipelineiv_intptr(pipeline, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramPipelineivEXT(uint pipeline, PipelineParameterName pname, int[] @params) => _GetProgramPipelineivEXT(pipeline, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramPipelineivEXT(uint pipeline, PipelineParameterName pname, void* @params) => _GetProgramPipelineivEXT_ptr(pipeline, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramPipelineivEXT(uint pipeline, PipelineParameterName pname, IntPtr @params) => _GetProgramPipelineivEXT_intptr(pipeline, pname, @params);

        // ---

        /// <summary>
        /// glGetProgramResourceIndex returns the unsigned            integer index assigned to a resource named name in            the interface type programInterface of program object program.
        /// program must be the name of an existing program object. programInterface            is the name of the interface within program which contains the resource named            nameand must be one of the following            values:
        /// GL_UNIFORM                        The query is targeted at the set of active uniforms within program.                    GL_UNIFORM_BLOCK                        The query is targeted at the set of active uniform blocks within program.                    GL_PROGRAM_INPUT                        The query is targeted at the set of active input variables used by the first shader stage of program.                        If program contains multiple shader stages then input variables from any stage other than the first                        will not be enumerated.                    GL_PROGRAM_OUTPUT                        The query is targeted at the set of active output variables produced by the last shader stage of program.                        If program contains multiple shader stages then output variables from any stage other than the last                        will not be enumerated.                    GL_VERTEX_SUBROUTINEGL_TESS_CONTROL_SUBROUTINEGL_TESS_EVALUATION_SUBROUTINEGL_GEOMETRY_SUBROUTINEGL_FRAGMENT_SUBROUTINEGL_COMPUTE_SUBROUTINE                        The query is targeted at the set of active subroutines for the vertex, tessellation control, tessellation evaluation,                        geometry, fragment and compute shader stages of program, respectively.                    GL_VERTEX_SUBROUTINE_UNIFORMGL_TESS_CONTROL_SUBROUTINE_UNIFORMGL_TESS_EVALUATION_SUBROUTINE_UNIFORMGL_GEOMETRY_SUBROUTINE_UNIFORMGL_FRAGMENT_SUBROUTINE_UNIFORMGL_COMPUTE_SUBROUTINE_UNIFORM                        The query is targeted at the set of active subroutine uniform variables used by the vertex, tessellation control, tessellation evaluation,                        geometry, fragment and compute shader stages of program, respectively.                    GL_TRANSFORM_FEEDBACK_VARYING                        The query is targeted at the set of output variables from the last non-fragment stage of program that would be                        captured if transform feedback were active.                    GL_TRANSFORM_FEEDBACK_BUFFER                        The query is targeted at the set of active buffer binding points to which output variables in the                        GL_TRANSFORM_FEEDBACK_VARYING interface are written.                    GL_BUFFER_VARIABLE                        The query is targeted at the set of active buffer variables used by program.                    GL_SHADER_STORAGE_BLOCK                        The query is targeted at the set of active shader storage blocks used by program.
        /// If name exactly matches the name string of one of the active resources            for programInterface, the index of the matched resource is returned.            Additionally, if name would exactly match the name string of an active            resource if "[0]" were appended to name, the index of the matched            resource is returned.  Otherwise, name is considered not to be the name            of an active resource, and GL_INVALID_INDEX is returned.
        /// For the interface GL_TRANSFORM_FEEDBACK_VARYING, the value GL_INVALID_INDEX            should be returned when querying the index assigned to the special names            gl_NextBuffer, gl_SkipComponents1, gl_SkipComponents2,            gl_SkipComponents3, or gl_SkipComponents4.
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the resource named name.</param>
        /// <param name="name">The name of the resource to query the index of.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetProgramResourceIndex(uint program, ProgramInterface programInterface, string name) => _GetProgramResourceIndex(program, programInterface, name);

        /// <summary>
        /// glGetProgramResourceIndex returns the unsigned            integer index assigned to a resource named name in            the interface type programInterface of program object program.
        /// program must be the name of an existing program object. programInterface            is the name of the interface within program which contains the resource named            nameand must be one of the following            values:
        /// GL_UNIFORM                        The query is targeted at the set of active uniforms within program.                    GL_UNIFORM_BLOCK                        The query is targeted at the set of active uniform blocks within program.                    GL_PROGRAM_INPUT                        The query is targeted at the set of active input variables used by the first shader stage of program.                        If program contains multiple shader stages then input variables from any stage other than the first                        will not be enumerated.                    GL_PROGRAM_OUTPUT                        The query is targeted at the set of active output variables produced by the last shader stage of program.                        If program contains multiple shader stages then output variables from any stage other than the last                        will not be enumerated.                    GL_VERTEX_SUBROUTINEGL_TESS_CONTROL_SUBROUTINEGL_TESS_EVALUATION_SUBROUTINEGL_GEOMETRY_SUBROUTINEGL_FRAGMENT_SUBROUTINEGL_COMPUTE_SUBROUTINE                        The query is targeted at the set of active subroutines for the vertex, tessellation control, tessellation evaluation,                        geometry, fragment and compute shader stages of program, respectively.                    GL_VERTEX_SUBROUTINE_UNIFORMGL_TESS_CONTROL_SUBROUTINE_UNIFORMGL_TESS_EVALUATION_SUBROUTINE_UNIFORMGL_GEOMETRY_SUBROUTINE_UNIFORMGL_FRAGMENT_SUBROUTINE_UNIFORMGL_COMPUTE_SUBROUTINE_UNIFORM                        The query is targeted at the set of active subroutine uniform variables used by the vertex, tessellation control, tessellation evaluation,                        geometry, fragment and compute shader stages of program, respectively.                    GL_TRANSFORM_FEEDBACK_VARYING                        The query is targeted at the set of output variables from the last non-fragment stage of program that would be                        captured if transform feedback were active.                    GL_TRANSFORM_FEEDBACK_BUFFER                        The query is targeted at the set of active buffer binding points to which output variables in the                        GL_TRANSFORM_FEEDBACK_VARYING interface are written.                    GL_BUFFER_VARIABLE                        The query is targeted at the set of active buffer variables used by program.                    GL_SHADER_STORAGE_BLOCK                        The query is targeted at the set of active shader storage blocks used by program.
        /// If name exactly matches the name string of one of the active resources            for programInterface, the index of the matched resource is returned.            Additionally, if name would exactly match the name string of an active            resource if "[0]" were appended to name, the index of the matched            resource is returned.  Otherwise, name is considered not to be the name            of an active resource, and GL_INVALID_INDEX is returned.
        /// For the interface GL_TRANSFORM_FEEDBACK_VARYING, the value GL_INVALID_INDEX            should be returned when querying the index assigned to the special names            gl_NextBuffer, gl_SkipComponents1, gl_SkipComponents2,            gl_SkipComponents3, or gl_SkipComponents4.
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the resource named name.</param>
        /// <param name="name">The name of the resource to query the index of.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetProgramResourceIndex(uint program, ProgramInterface programInterface, void* name) => _GetProgramResourceIndex_ptr(program, programInterface, name);

        /// <summary>
        /// glGetProgramResourceIndex returns the unsigned            integer index assigned to a resource named name in            the interface type programInterface of program object program.
        /// program must be the name of an existing program object. programInterface            is the name of the interface within program which contains the resource named            nameand must be one of the following            values:
        /// GL_UNIFORM                        The query is targeted at the set of active uniforms within program.                    GL_UNIFORM_BLOCK                        The query is targeted at the set of active uniform blocks within program.                    GL_PROGRAM_INPUT                        The query is targeted at the set of active input variables used by the first shader stage of program.                        If program contains multiple shader stages then input variables from any stage other than the first                        will not be enumerated.                    GL_PROGRAM_OUTPUT                        The query is targeted at the set of active output variables produced by the last shader stage of program.                        If program contains multiple shader stages then output variables from any stage other than the last                        will not be enumerated.                    GL_VERTEX_SUBROUTINEGL_TESS_CONTROL_SUBROUTINEGL_TESS_EVALUATION_SUBROUTINEGL_GEOMETRY_SUBROUTINEGL_FRAGMENT_SUBROUTINEGL_COMPUTE_SUBROUTINE                        The query is targeted at the set of active subroutines for the vertex, tessellation control, tessellation evaluation,                        geometry, fragment and compute shader stages of program, respectively.                    GL_VERTEX_SUBROUTINE_UNIFORMGL_TESS_CONTROL_SUBROUTINE_UNIFORMGL_TESS_EVALUATION_SUBROUTINE_UNIFORMGL_GEOMETRY_SUBROUTINE_UNIFORMGL_FRAGMENT_SUBROUTINE_UNIFORMGL_COMPUTE_SUBROUTINE_UNIFORM                        The query is targeted at the set of active subroutine uniform variables used by the vertex, tessellation control, tessellation evaluation,                        geometry, fragment and compute shader stages of program, respectively.                    GL_TRANSFORM_FEEDBACK_VARYING                        The query is targeted at the set of output variables from the last non-fragment stage of program that would be                        captured if transform feedback were active.                    GL_TRANSFORM_FEEDBACK_BUFFER                        The query is targeted at the set of active buffer binding points to which output variables in the                        GL_TRANSFORM_FEEDBACK_VARYING interface are written.                    GL_BUFFER_VARIABLE                        The query is targeted at the set of active buffer variables used by program.                    GL_SHADER_STORAGE_BLOCK                        The query is targeted at the set of active shader storage blocks used by program.
        /// If name exactly matches the name string of one of the active resources            for programInterface, the index of the matched resource is returned.            Additionally, if name would exactly match the name string of an active            resource if "[0]" were appended to name, the index of the matched            resource is returned.  Otherwise, name is considered not to be the name            of an active resource, and GL_INVALID_INDEX is returned.
        /// For the interface GL_TRANSFORM_FEEDBACK_VARYING, the value GL_INVALID_INDEX            should be returned when querying the index assigned to the special names            gl_NextBuffer, gl_SkipComponents1, gl_SkipComponents2,            gl_SkipComponents3, or gl_SkipComponents4.
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the resource named name.</param>
        /// <param name="name">The name of the resource to query the index of.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetProgramResourceIndex(uint program, ProgramInterface programInterface, IntPtr name) => _GetProgramResourceIndex_intptr(program, programInterface, name);

        // ---

        /// <summary>
        /// glGetProgramResourceLocation returns the location assigned            to the variable named name in interface programInterface of program            object program.  program must be the name of a program that has been            linked successfully. programInterface must            be one of GL_UNIFORM, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT,            GL_VERTEX_SUBROUTINE_UNIFORM, GL_TESS_CONTROL_SUBROUTINE_UNIFORM,            GL_TESS_EVALUATION_SUBROUTINE_UNIFORM, GL_GEOMETRY_SUBROUTINE_UNIFORM,            GL_FRAGMENT_SUBROUTINE_UNIFORM, GL_COMPUTE_SUBROUTINE_UNIFORM, or GL_TRANSFORM_FEEDBACK_BUFFER.
        /// The value -1 will be returned if an error occurs, if name does not identify an active variable on            programInterface, or if name identifies an active variable that does            not have a valid location assigned, as described above.  The locations            returned by these commands are the same locations returned when querying            the GL_LOCATION and GL_LOCATION_INDEX resource properties.
        /// A string provided to glGetProgramResourceLocation is considered to match an active variable if:
        /// the string exactly matches the name of the active variable                                    if the string identifies the base name of an active array, where the                    string would exactly match the name of the variable if the suffix                    "[0]" were appended to the string                                    if the string identifies an active element of the array, where the                    string ends with the concatenation of the "[" character, an integer                    with no "+" sign, extra leading zeroes, or whitespace identifying an                    array element, and the "]" character, the integer is less than the                    number of active elements of the array variable, and where the string                    would exactly match the enumerated name of the array if the decimal                    integer were replaced with zero.
        /// Any other string is considered not to identify an active variable.  If the            string specifies an element of an array variable,            glGetProgramResourceLocation returns the            location assigned to that element.  If it            specifies the base name of an array, it identifies the resources            associated with the first element of the array.
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the resource named name.</param>
        /// <param name="name">The name of the resource to query the location of.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetProgramResourceLocation(uint program, ProgramInterface programInterface, string name) => _GetProgramResourceLocation(program, programInterface, name);

        /// <summary>
        /// glGetProgramResourceLocation returns the location assigned            to the variable named name in interface programInterface of program            object program.  program must be the name of a program that has been            linked successfully. programInterface must            be one of GL_UNIFORM, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT,            GL_VERTEX_SUBROUTINE_UNIFORM, GL_TESS_CONTROL_SUBROUTINE_UNIFORM,            GL_TESS_EVALUATION_SUBROUTINE_UNIFORM, GL_GEOMETRY_SUBROUTINE_UNIFORM,            GL_FRAGMENT_SUBROUTINE_UNIFORM, GL_COMPUTE_SUBROUTINE_UNIFORM, or GL_TRANSFORM_FEEDBACK_BUFFER.
        /// The value -1 will be returned if an error occurs, if name does not identify an active variable on            programInterface, or if name identifies an active variable that does            not have a valid location assigned, as described above.  The locations            returned by these commands are the same locations returned when querying            the GL_LOCATION and GL_LOCATION_INDEX resource properties.
        /// A string provided to glGetProgramResourceLocation is considered to match an active variable if:
        /// the string exactly matches the name of the active variable                                    if the string identifies the base name of an active array, where the                    string would exactly match the name of the variable if the suffix                    "[0]" were appended to the string                                    if the string identifies an active element of the array, where the                    string ends with the concatenation of the "[" character, an integer                    with no "+" sign, extra leading zeroes, or whitespace identifying an                    array element, and the "]" character, the integer is less than the                    number of active elements of the array variable, and where the string                    would exactly match the enumerated name of the array if the decimal                    integer were replaced with zero.
        /// Any other string is considered not to identify an active variable.  If the            string specifies an element of an array variable,            glGetProgramResourceLocation returns the            location assigned to that element.  If it            specifies the base name of an array, it identifies the resources            associated with the first element of the array.
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the resource named name.</param>
        /// <param name="name">The name of the resource to query the location of.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetProgramResourceLocation(uint program, ProgramInterface programInterface, void* name) => _GetProgramResourceLocation_ptr(program, programInterface, name);

        /// <summary>
        /// glGetProgramResourceLocation returns the location assigned            to the variable named name in interface programInterface of program            object program.  program must be the name of a program that has been            linked successfully. programInterface must            be one of GL_UNIFORM, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT,            GL_VERTEX_SUBROUTINE_UNIFORM, GL_TESS_CONTROL_SUBROUTINE_UNIFORM,            GL_TESS_EVALUATION_SUBROUTINE_UNIFORM, GL_GEOMETRY_SUBROUTINE_UNIFORM,            GL_FRAGMENT_SUBROUTINE_UNIFORM, GL_COMPUTE_SUBROUTINE_UNIFORM, or GL_TRANSFORM_FEEDBACK_BUFFER.
        /// The value -1 will be returned if an error occurs, if name does not identify an active variable on            programInterface, or if name identifies an active variable that does            not have a valid location assigned, as described above.  The locations            returned by these commands are the same locations returned when querying            the GL_LOCATION and GL_LOCATION_INDEX resource properties.
        /// A string provided to glGetProgramResourceLocation is considered to match an active variable if:
        /// the string exactly matches the name of the active variable                                    if the string identifies the base name of an active array, where the                    string would exactly match the name of the variable if the suffix                    "[0]" were appended to the string                                    if the string identifies an active element of the array, where the                    string ends with the concatenation of the "[" character, an integer                    with no "+" sign, extra leading zeroes, or whitespace identifying an                    array element, and the "]" character, the integer is less than the                    number of active elements of the array variable, and where the string                    would exactly match the enumerated name of the array if the decimal                    integer were replaced with zero.
        /// Any other string is considered not to identify an active variable.  If the            string specifies an element of an array variable,            glGetProgramResourceLocation returns the            location assigned to that element.  If it            specifies the base name of an array, it identifies the resources            associated with the first element of the array.
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the resource named name.</param>
        /// <param name="name">The name of the resource to query the location of.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetProgramResourceLocation(uint program, ProgramInterface programInterface, IntPtr name) => _GetProgramResourceLocation_intptr(program, programInterface, name);

        // ---

        /// <summary>
        /// glGetProgramResourceLocationIndex returns the fragment color index assigned            to the variable named name in interface programInterface of program            object program.  program must be the name of a program that has been            linked successfully. programInterface must            be GL_PROGRAM_OUTPUT.
        /// The value -1 will be returned if an error occurs, if name does not identify an active variable on            programInterface, or if name identifies an active variable that does            not have a valid location assigned, as described above.  The locations            returned by these commands are the same locations returned when querying            the GL_LOCATION and GL_LOCATION_INDEX resource properties.
        /// A string provided to glGetProgramResourceLocationIndex is considered to match an active variable if:
        /// the string exactly matches the name of the active variable                                    if the string identifies the base name of an active array, where the                    string would exactly match the name of the variable if the suffix                    "[0]" were appended to the string                                    if the string identifies an active element of the array, where the                    string ends with the concatenation of the "[" character, an integer                    with no "+" sign, extra leading zeroes, or whitespace identifying an                    array element, and the "]" character, the integer is less than the                    number of active elements of the array variable, and where the string                    would exactly match the enumerated name of the array if the decimal                    integer were replaced with zero.
        /// Any other string is considered not to identify an active variable.  If the            string specifies an element of an array variable,            glGetProgramResourceLocation returns the            location assigned to that element.  If it            specifies the base name of an array, it identifies the resources            associated with the first element of the array.
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the resource named name.</param>
        /// <param name="name">The name of the resource to query the location of.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetProgramResourceLocationIndex(uint program, ProgramInterface programInterface, string name) => _GetProgramResourceLocationIndex(program, programInterface, name);

        /// <summary>
        /// glGetProgramResourceLocationIndex returns the fragment color index assigned            to the variable named name in interface programInterface of program            object program.  program must be the name of a program that has been            linked successfully. programInterface must            be GL_PROGRAM_OUTPUT.
        /// The value -1 will be returned if an error occurs, if name does not identify an active variable on            programInterface, or if name identifies an active variable that does            not have a valid location assigned, as described above.  The locations            returned by these commands are the same locations returned when querying            the GL_LOCATION and GL_LOCATION_INDEX resource properties.
        /// A string provided to glGetProgramResourceLocationIndex is considered to match an active variable if:
        /// the string exactly matches the name of the active variable                                    if the string identifies the base name of an active array, where the                    string would exactly match the name of the variable if the suffix                    "[0]" were appended to the string                                    if the string identifies an active element of the array, where the                    string ends with the concatenation of the "[" character, an integer                    with no "+" sign, extra leading zeroes, or whitespace identifying an                    array element, and the "]" character, the integer is less than the                    number of active elements of the array variable, and where the string                    would exactly match the enumerated name of the array if the decimal                    integer were replaced with zero.
        /// Any other string is considered not to identify an active variable.  If the            string specifies an element of an array variable,            glGetProgramResourceLocation returns the            location assigned to that element.  If it            specifies the base name of an array, it identifies the resources            associated with the first element of the array.
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the resource named name.</param>
        /// <param name="name">The name of the resource to query the location of.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetProgramResourceLocationIndex(uint program, ProgramInterface programInterface, void* name) => _GetProgramResourceLocationIndex_ptr(program, programInterface, name);

        /// <summary>
        /// glGetProgramResourceLocationIndex returns the fragment color index assigned            to the variable named name in interface programInterface of program            object program.  program must be the name of a program that has been            linked successfully. programInterface must            be GL_PROGRAM_OUTPUT.
        /// The value -1 will be returned if an error occurs, if name does not identify an active variable on            programInterface, or if name identifies an active variable that does            not have a valid location assigned, as described above.  The locations            returned by these commands are the same locations returned when querying            the GL_LOCATION and GL_LOCATION_INDEX resource properties.
        /// A string provided to glGetProgramResourceLocationIndex is considered to match an active variable if:
        /// the string exactly matches the name of the active variable                                    if the string identifies the base name of an active array, where the                    string would exactly match the name of the variable if the suffix                    "[0]" were appended to the string                                    if the string identifies an active element of the array, where the                    string ends with the concatenation of the "[" character, an integer                    with no "+" sign, extra leading zeroes, or whitespace identifying an                    array element, and the "]" character, the integer is less than the                    number of active elements of the array variable, and where the string                    would exactly match the enumerated name of the array if the decimal                    integer were replaced with zero.
        /// Any other string is considered not to identify an active variable.  If the            string specifies an element of an array variable,            glGetProgramResourceLocation returns the            location assigned to that element.  If it            specifies the base name of an array, it identifies the resources            associated with the first element of the array.
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the resource named name.</param>
        /// <param name="name">The name of the resource to query the location of.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetProgramResourceLocationIndex(uint program, ProgramInterface programInterface, IntPtr name) => _GetProgramResourceLocationIndex_intptr(program, programInterface, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetProgramResourceLocationIndexEXT(uint program, ProgramInterface programInterface, string name) => _GetProgramResourceLocationIndexEXT(program, programInterface, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetProgramResourceLocationIndexEXT(uint program, ProgramInterface programInterface, void* name) => _GetProgramResourceLocationIndexEXT_ptr(program, programInterface, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetProgramResourceLocationIndexEXT(uint program, ProgramInterface programInterface, IntPtr name) => _GetProgramResourceLocationIndexEXT_intptr(program, programInterface, name);

        // ---

        /// <summary>
        /// glGetProgramResourceName retrieves the name string            assigned to the single active resource with an index of index            in the interface programInterface of program object            program. index must be less than            the number of entries in the active resource list for programInterface.
        /// program must be the name of an existing program object. programInterface            is the name of the interface within program which contains the resource and must be one of the following            values:
        /// GL_UNIFORM                        The query is targeted at the set of active uniforms within program.                    GL_UNIFORM_BLOCK                        The query is targeted at the set of active uniform blocks within program.                    GL_PROGRAM_INPUT                        The query is targeted at the set of active input variables used by the first shader stage of program.                        If program contains multiple shader stages then input variables from any stage other than the first                        will not be enumerated.                    GL_PROGRAM_OUTPUT                        The query is targeted at the set of active output variables produced by the last shader stage of program.                        If program contains multiple shader stages then output variables from any stage other than the last                        will not be enumerated.                    GL_VERTEX_SUBROUTINEGL_TESS_CONTROL_SUBROUTINEGL_TESS_EVALUATION_SUBROUTINEGL_GEOMETRY_SUBROUTINEGL_FRAGMENT_SUBROUTINEGL_COMPUTE_SUBROUTINE                        The query is targeted at the set of active subroutines for the vertex, tessellation control, tessellation evaluation,                        geometry, fragment and compute shader stages of program, respectively.                    GL_VERTEX_SUBROUTINE_UNIFORMGL_TESS_CONTROL_SUBROUTINE_UNIFORMGL_TESS_EVALUATION_SUBROUTINE_UNIFORMGL_GEOMETRY_SUBROUTINE_UNIFORMGL_FRAGMENT_SUBROUTINE_UNIFORMGL_COMPUTE_SUBROUTINE_UNIFORM                        The query is targeted at the set of active subroutine uniform variables used by the vertex, tessellation control, tessellation evaluation,                        geometry, fragment and compute shader stages of program, respectively.                    GL_TRANSFORM_FEEDBACK_VARYING                        The query is targeted at the set of output variables from the last non-fragment stage of program that would be                        captured if transform feedback were active.                    GL_BUFFER_VARIABLE                        The query is targeted at the set of active buffer variables used by program.                    GL_SHADER_STORAGE_BLOCK                        The query is targeted at the set of active shader storage blocks used by program.
        /// The name string assigned to the active resource identified by index is            returned as a null-terminated string in the character array whose address is given in name.  The actual number of            characters written into name, excluding the null terminator, is returned            in length.  If length is NULL, no length is returned.  The maximum            number of characters that may be written into name, including the null            terminator, is specified by bufSize.  If the length of the name string            including the null terminator is greater than bufSize, the first            bufSize-1 characters of the name string will be written to name,            followed by a null terminator.  If bufSize is zero, no error will be            generated but no characters will be written to name.  The length of the            longest name string for programInterface>, including a null terminator,            can be queried by calling glGetProgramInterface with a pname of            GL_MAX_NAME_LENGTH.
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the indexed resource.</param>
        /// <param name="index">The index of the resource within programInterface of program.</param>
        /// <param name="bufSize">The size of the character array whose address is given by name.</param>
        /// <param name="length">The address of a variable which will receive the length of the resource name.</param>
        /// <param name="name">The address of a character array into which will be written the name of the resource.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramResourceName(uint program, ProgramInterface programInterface, uint index, int bufSize, out int length, string name) => _GetProgramResourceName(program, programInterface, index, bufSize, out length, name);

        /// <summary>
        /// glGetProgramResourceName retrieves the name string            assigned to the single active resource with an index of index            in the interface programInterface of program object            program. index must be less than            the number of entries in the active resource list for programInterface.
        /// program must be the name of an existing program object. programInterface            is the name of the interface within program which contains the resource and must be one of the following            values:
        /// GL_UNIFORM                        The query is targeted at the set of active uniforms within program.                    GL_UNIFORM_BLOCK                        The query is targeted at the set of active uniform blocks within program.                    GL_PROGRAM_INPUT                        The query is targeted at the set of active input variables used by the first shader stage of program.                        If program contains multiple shader stages then input variables from any stage other than the first                        will not be enumerated.                    GL_PROGRAM_OUTPUT                        The query is targeted at the set of active output variables produced by the last shader stage of program.                        If program contains multiple shader stages then output variables from any stage other than the last                        will not be enumerated.                    GL_VERTEX_SUBROUTINEGL_TESS_CONTROL_SUBROUTINEGL_TESS_EVALUATION_SUBROUTINEGL_GEOMETRY_SUBROUTINEGL_FRAGMENT_SUBROUTINEGL_COMPUTE_SUBROUTINE                        The query is targeted at the set of active subroutines for the vertex, tessellation control, tessellation evaluation,                        geometry, fragment and compute shader stages of program, respectively.                    GL_VERTEX_SUBROUTINE_UNIFORMGL_TESS_CONTROL_SUBROUTINE_UNIFORMGL_TESS_EVALUATION_SUBROUTINE_UNIFORMGL_GEOMETRY_SUBROUTINE_UNIFORMGL_FRAGMENT_SUBROUTINE_UNIFORMGL_COMPUTE_SUBROUTINE_UNIFORM                        The query is targeted at the set of active subroutine uniform variables used by the vertex, tessellation control, tessellation evaluation,                        geometry, fragment and compute shader stages of program, respectively.                    GL_TRANSFORM_FEEDBACK_VARYING                        The query is targeted at the set of output variables from the last non-fragment stage of program that would be                        captured if transform feedback were active.                    GL_BUFFER_VARIABLE                        The query is targeted at the set of active buffer variables used by program.                    GL_SHADER_STORAGE_BLOCK                        The query is targeted at the set of active shader storage blocks used by program.
        /// The name string assigned to the active resource identified by index is            returned as a null-terminated string in the character array whose address is given in name.  The actual number of            characters written into name, excluding the null terminator, is returned            in length.  If length is NULL, no length is returned.  The maximum            number of characters that may be written into name, including the null            terminator, is specified by bufSize.  If the length of the name string            including the null terminator is greater than bufSize, the first            bufSize-1 characters of the name string will be written to name,            followed by a null terminator.  If bufSize is zero, no error will be            generated but no characters will be written to name.  The length of the            longest name string for programInterface>, including a null terminator,            can be queried by calling glGetProgramInterface with a pname of            GL_MAX_NAME_LENGTH.
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the indexed resource.</param>
        /// <param name="index">The index of the resource within programInterface of program.</param>
        /// <param name="bufSize">The size of the character array whose address is given by name.</param>
        /// <param name="length">The address of a variable which will receive the length of the resource name.</param>
        /// <param name="name">The address of a character array into which will be written the name of the resource.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramResourceName(uint program, ProgramInterface programInterface, uint index, int bufSize, out int length, void* name) => _GetProgramResourceName_ptr(program, programInterface, index, bufSize, out length, name);

        /// <summary>
        /// glGetProgramResourceName retrieves the name string            assigned to the single active resource with an index of index            in the interface programInterface of program object            program. index must be less than            the number of entries in the active resource list for programInterface.
        /// program must be the name of an existing program object. programInterface            is the name of the interface within program which contains the resource and must be one of the following            values:
        /// GL_UNIFORM                        The query is targeted at the set of active uniforms within program.                    GL_UNIFORM_BLOCK                        The query is targeted at the set of active uniform blocks within program.                    GL_PROGRAM_INPUT                        The query is targeted at the set of active input variables used by the first shader stage of program.                        If program contains multiple shader stages then input variables from any stage other than the first                        will not be enumerated.                    GL_PROGRAM_OUTPUT                        The query is targeted at the set of active output variables produced by the last shader stage of program.                        If program contains multiple shader stages then output variables from any stage other than the last                        will not be enumerated.                    GL_VERTEX_SUBROUTINEGL_TESS_CONTROL_SUBROUTINEGL_TESS_EVALUATION_SUBROUTINEGL_GEOMETRY_SUBROUTINEGL_FRAGMENT_SUBROUTINEGL_COMPUTE_SUBROUTINE                        The query is targeted at the set of active subroutines for the vertex, tessellation control, tessellation evaluation,                        geometry, fragment and compute shader stages of program, respectively.                    GL_VERTEX_SUBROUTINE_UNIFORMGL_TESS_CONTROL_SUBROUTINE_UNIFORMGL_TESS_EVALUATION_SUBROUTINE_UNIFORMGL_GEOMETRY_SUBROUTINE_UNIFORMGL_FRAGMENT_SUBROUTINE_UNIFORMGL_COMPUTE_SUBROUTINE_UNIFORM                        The query is targeted at the set of active subroutine uniform variables used by the vertex, tessellation control, tessellation evaluation,                        geometry, fragment and compute shader stages of program, respectively.                    GL_TRANSFORM_FEEDBACK_VARYING                        The query is targeted at the set of output variables from the last non-fragment stage of program that would be                        captured if transform feedback were active.                    GL_BUFFER_VARIABLE                        The query is targeted at the set of active buffer variables used by program.                    GL_SHADER_STORAGE_BLOCK                        The query is targeted at the set of active shader storage blocks used by program.
        /// The name string assigned to the active resource identified by index is            returned as a null-terminated string in the character array whose address is given in name.  The actual number of            characters written into name, excluding the null terminator, is returned            in length.  If length is NULL, no length is returned.  The maximum            number of characters that may be written into name, including the null            terminator, is specified by bufSize.  If the length of the name string            including the null terminator is greater than bufSize, the first            bufSize-1 characters of the name string will be written to name,            followed by a null terminator.  If bufSize is zero, no error will be            generated but no characters will be written to name.  The length of the            longest name string for programInterface>, including a null terminator,            can be queried by calling glGetProgramInterface with a pname of            GL_MAX_NAME_LENGTH.
        /// </summary>
        /// <param name="program">The name of a program object whose resources to query.</param>
        /// <param name="programInterface">A token identifying the interface within program containing the indexed resource.</param>
        /// <param name="index">The index of the resource within programInterface of program.</param>
        /// <param name="bufSize">The size of the character array whose address is given by name.</param>
        /// <param name="length">The address of a variable which will receive the length of the resource name.</param>
        /// <param name="name">The address of a character array into which will be written the name of the resource.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramResourceName(uint program, ProgramInterface programInterface, uint index, int bufSize, out int length, IntPtr name) => _GetProgramResourceName_intptr(program, programInterface, index, bufSize, out length, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramResourcefvNV(uint program, ProgramInterface programInterface, uint index, int propCount, int[] props, int count, out int length, float[] @params) => _GetProgramResourcefvNV(program, programInterface, index, propCount, props, count, out length, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramResourcefvNV(uint program, ProgramInterface programInterface, uint index, int propCount, void* props, int count, out int length, void* @params) => _GetProgramResourcefvNV_ptr(program, programInterface, index, propCount, props, count, out length, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramResourcefvNV(uint program, ProgramInterface programInterface, uint index, int propCount, IntPtr props, int count, out int length, IntPtr @params) => _GetProgramResourcefvNV_intptr(program, programInterface, index, propCount, props, count, out length, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramResourceiv(uint program, ProgramInterface programInterface, uint index, int propCount, ProgramResourceProperty[] props, int count, out int length, int[] @params) => _GetProgramResourceiv(program, programInterface, index, propCount, props, count, out length, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramResourceiv(uint program, ProgramInterface programInterface, uint index, int propCount, void* props, int count, out int length, void* @params) => _GetProgramResourceiv_ptr(program, programInterface, index, propCount, props, count, out length, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramResourceiv(uint program, ProgramInterface programInterface, uint index, int propCount, IntPtr props, int count, out int length, IntPtr @params) => _GetProgramResourceiv_intptr(program, programInterface, index, propCount, props, count, out length, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramStageiv(uint program, ShaderType shadertype, ProgramStagePName pname, out int values) => _GetProgramStageiv(program, shadertype, pname, out values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramStringARB(ProgramTarget target, ProgramStringProperty pname, IntPtr @string) => _GetProgramStringARB(target, pname, @string);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramStringNV(uint id, VertexAttribEnumNV pname, byte[] program) => _GetProgramStringNV(id, pname, program);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramStringNV(uint id, VertexAttribEnumNV pname, void* program) => _GetProgramStringNV_ptr(id, pname, program);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramStringNV(uint id, VertexAttribEnumNV pname, IntPtr program) => _GetProgramStringNV_intptr(id, pname, program);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramSubroutineParameteruivNV(int target, uint index, uint[] param) => _GetProgramSubroutineParameteruivNV(target, index, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramSubroutineParameteruivNV(int target, uint index, void* param) => _GetProgramSubroutineParameteruivNV_ptr(target, index, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramSubroutineParameteruivNV(int target, uint index, IntPtr param) => _GetProgramSubroutineParameteruivNV_intptr(target, index, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramiv(uint program, ProgramPropertyARB pname, int[] @params) => _GetProgramiv(program, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramiv(uint program, ProgramPropertyARB pname, void* @params) => _GetProgramiv_ptr(program, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramiv(uint program, ProgramPropertyARB pname, IntPtr @params) => _GetProgramiv_intptr(program, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramivARB(ProgramTarget target, ProgramPropertyARB pname, out int @params) => _GetProgramivARB(target, pname, out @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramivNV(uint id, VertexAttribEnumNV pname, int[] @params) => _GetProgramivNV(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramivNV(uint id, VertexAttribEnumNV pname, void* @params) => _GetProgramivNV_ptr(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetProgramivNV(uint id, VertexAttribEnumNV pname, IntPtr @params) => _GetProgramivNV_intptr(id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryBufferObjecti64v(uint id, uint buffer, QueryObjectParameterName pname, IntPtr offset) => _GetQueryBufferObjecti64v(id, buffer, pname, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryBufferObjectiv(uint id, uint buffer, QueryObjectParameterName pname, IntPtr offset) => _GetQueryBufferObjectiv(id, buffer, pname, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryBufferObjectui64v(uint id, uint buffer, QueryObjectParameterName pname, IntPtr offset) => _GetQueryBufferObjectui64v(id, buffer, pname, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryBufferObjectuiv(uint id, uint buffer, QueryObjectParameterName pname, IntPtr offset) => _GetQueryBufferObjectuiv(id, buffer, pname, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryIndexediv(QueryTarget target, uint index, QueryParameterName pname, int[] @params) => _GetQueryIndexediv(target, index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryIndexediv(QueryTarget target, uint index, QueryParameterName pname, void* @params) => _GetQueryIndexediv_ptr(target, index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryIndexediv(QueryTarget target, uint index, QueryParameterName pname, IntPtr @params) => _GetQueryIndexediv_intptr(target, index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjecti64v(uint id, QueryObjectParameterName pname, Int64[] @params) => _GetQueryObjecti64v(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjecti64v(uint id, QueryObjectParameterName pname, void* @params) => _GetQueryObjecti64v_ptr(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjecti64v(uint id, QueryObjectParameterName pname, IntPtr @params) => _GetQueryObjecti64v_intptr(id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjecti64vEXT(uint id, QueryObjectParameterName pname, Int64[] @params) => _GetQueryObjecti64vEXT(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjecti64vEXT(uint id, QueryObjectParameterName pname, void* @params) => _GetQueryObjecti64vEXT_ptr(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjecti64vEXT(uint id, QueryObjectParameterName pname, IntPtr @params) => _GetQueryObjecti64vEXT_intptr(id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectiv(uint id, QueryObjectParameterName pname, int[] @params) => _GetQueryObjectiv(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectiv(uint id, QueryObjectParameterName pname, void* @params) => _GetQueryObjectiv_ptr(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectiv(uint id, QueryObjectParameterName pname, IntPtr @params) => _GetQueryObjectiv_intptr(id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectivARB(uint id, QueryObjectParameterName pname, int[] @params) => _GetQueryObjectivARB(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectivARB(uint id, QueryObjectParameterName pname, void* @params) => _GetQueryObjectivARB_ptr(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectivARB(uint id, QueryObjectParameterName pname, IntPtr @params) => _GetQueryObjectivARB_intptr(id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectivEXT(uint id, QueryObjectParameterName pname, int[] @params) => _GetQueryObjectivEXT(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectivEXT(uint id, QueryObjectParameterName pname, void* @params) => _GetQueryObjectivEXT_ptr(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectivEXT(uint id, QueryObjectParameterName pname, IntPtr @params) => _GetQueryObjectivEXT_intptr(id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectui64v(uint id, QueryObjectParameterName pname, UInt64[] @params) => _GetQueryObjectui64v(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectui64v(uint id, QueryObjectParameterName pname, void* @params) => _GetQueryObjectui64v_ptr(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectui64v(uint id, QueryObjectParameterName pname, IntPtr @params) => _GetQueryObjectui64v_intptr(id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectui64vEXT(uint id, QueryObjectParameterName pname, UInt64[] @params) => _GetQueryObjectui64vEXT(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectui64vEXT(uint id, QueryObjectParameterName pname, void* @params) => _GetQueryObjectui64vEXT_ptr(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectui64vEXT(uint id, QueryObjectParameterName pname, IntPtr @params) => _GetQueryObjectui64vEXT_intptr(id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectuiv(uint id, QueryObjectParameterName pname, uint[] @params) => _GetQueryObjectuiv(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectuiv(uint id, QueryObjectParameterName pname, void* @params) => _GetQueryObjectuiv_ptr(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectuiv(uint id, QueryObjectParameterName pname, IntPtr @params) => _GetQueryObjectuiv_intptr(id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectuivARB(uint id, QueryObjectParameterName pname, uint[] @params) => _GetQueryObjectuivARB(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectuivARB(uint id, QueryObjectParameterName pname, void* @params) => _GetQueryObjectuivARB_ptr(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectuivARB(uint id, QueryObjectParameterName pname, IntPtr @params) => _GetQueryObjectuivARB_intptr(id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectuivEXT(uint id, QueryObjectParameterName pname, uint[] @params) => _GetQueryObjectuivEXT(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectuivEXT(uint id, QueryObjectParameterName pname, void* @params) => _GetQueryObjectuivEXT_ptr(id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryObjectuivEXT(uint id, QueryObjectParameterName pname, IntPtr @params) => _GetQueryObjectuivEXT_intptr(id, pname, @params);

        // ---

        /// <summary>
        /// glGetQueryiv returns in params a selected parameter of the query object target            specified by target.
        /// pname names a specific query object target parameter.  When pname is            GL_CURRENT_QUERY, the name of the currently active query for target,            or zero if no query is active, will be placed in params.            If pname is GL_QUERY_COUNTER_BITS, the implementation-dependent number            of bits used to hold the result of queries for target is returned in params.
        /// </summary>
        /// <param name="target">Specifies a query object target.                    Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVEGL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN,                    GL_TIME_ELAPSED, or GL_TIMESTAMP.</param>
        /// <param name="pname">Specifies the symbolic name of a query object target parameter.                    Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS.</param>
        /// <param name="params">Returns the requested data.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryiv(QueryTarget target, QueryParameterName pname, int[] @params) => _GetQueryiv(target, pname, @params);

        /// <summary>
        /// glGetQueryiv returns in params a selected parameter of the query object target            specified by target.
        /// pname names a specific query object target parameter.  When pname is            GL_CURRENT_QUERY, the name of the currently active query for target,            or zero if no query is active, will be placed in params.            If pname is GL_QUERY_COUNTER_BITS, the implementation-dependent number            of bits used to hold the result of queries for target is returned in params.
        /// </summary>
        /// <param name="target">Specifies a query object target.                    Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVEGL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN,                    GL_TIME_ELAPSED, or GL_TIMESTAMP.</param>
        /// <param name="pname">Specifies the symbolic name of a query object target parameter.                    Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS.</param>
        /// <param name="params">Returns the requested data.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryiv(QueryTarget target, QueryParameterName pname, void* @params) => _GetQueryiv_ptr(target, pname, @params);

        /// <summary>
        /// glGetQueryiv returns in params a selected parameter of the query object target            specified by target.
        /// pname names a specific query object target parameter.  When pname is            GL_CURRENT_QUERY, the name of the currently active query for target,            or zero if no query is active, will be placed in params.            If pname is GL_QUERY_COUNTER_BITS, the implementation-dependent number            of bits used to hold the result of queries for target is returned in params.
        /// </summary>
        /// <param name="target">Specifies a query object target.                    Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVEGL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN,                    GL_TIME_ELAPSED, or GL_TIMESTAMP.</param>
        /// <param name="pname">Specifies the symbolic name of a query object target parameter.                    Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS.</param>
        /// <param name="params">Returns the requested data.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryiv(QueryTarget target, QueryParameterName pname, IntPtr @params) => _GetQueryiv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryivARB(QueryTarget target, QueryParameterName pname, int[] @params) => _GetQueryivARB(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryivARB(QueryTarget target, QueryParameterName pname, void* @params) => _GetQueryivARB_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryivARB(QueryTarget target, QueryParameterName pname, IntPtr @params) => _GetQueryivARB_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryivEXT(QueryTarget target, QueryParameterName pname, int[] @params) => _GetQueryivEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryivEXT(QueryTarget target, QueryParameterName pname, void* @params) => _GetQueryivEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetQueryivEXT(QueryTarget target, QueryParameterName pname, IntPtr @params) => _GetQueryivEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetRenderbufferParameteriv(RenderbufferTarget target, RenderbufferParameterName pname, int[] @params) => _GetRenderbufferParameteriv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetRenderbufferParameteriv(RenderbufferTarget target, RenderbufferParameterName pname, void* @params) => _GetRenderbufferParameteriv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetRenderbufferParameteriv(RenderbufferTarget target, RenderbufferParameterName pname, IntPtr @params) => _GetRenderbufferParameteriv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetRenderbufferParameterivEXT(RenderbufferTarget target, RenderbufferParameterName pname, int[] @params) => _GetRenderbufferParameterivEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetRenderbufferParameterivEXT(RenderbufferTarget target, RenderbufferParameterName pname, void* @params) => _GetRenderbufferParameterivEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetRenderbufferParameterivEXT(RenderbufferTarget target, RenderbufferParameterName pname, IntPtr @params) => _GetRenderbufferParameterivEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetRenderbufferParameterivOES(RenderbufferTarget target, RenderbufferParameterName pname, int[] @params) => _GetRenderbufferParameterivOES(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetRenderbufferParameterivOES(RenderbufferTarget target, RenderbufferParameterName pname, void* @params) => _GetRenderbufferParameterivOES_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetRenderbufferParameterivOES(RenderbufferTarget target, RenderbufferParameterName pname, IntPtr @params) => _GetRenderbufferParameterivOES_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIiv(uint sampler, SamplerParameterI pname, int[] @params) => _GetSamplerParameterIiv(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIiv(uint sampler, SamplerParameterI pname, void* @params) => _GetSamplerParameterIiv_ptr(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIiv(uint sampler, SamplerParameterI pname, IntPtr @params) => _GetSamplerParameterIiv_intptr(sampler, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIivEXT(uint sampler, SamplerParameterI pname, int[] @params) => _GetSamplerParameterIivEXT(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIivEXT(uint sampler, SamplerParameterI pname, void* @params) => _GetSamplerParameterIivEXT_ptr(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIivEXT(uint sampler, SamplerParameterI pname, IntPtr @params) => _GetSamplerParameterIivEXT_intptr(sampler, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIivOES(uint sampler, SamplerParameterI pname, int[] @params) => _GetSamplerParameterIivOES(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIivOES(uint sampler, SamplerParameterI pname, void* @params) => _GetSamplerParameterIivOES_ptr(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIivOES(uint sampler, SamplerParameterI pname, IntPtr @params) => _GetSamplerParameterIivOES_intptr(sampler, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIuiv(uint sampler, SamplerParameterI pname, uint[] @params) => _GetSamplerParameterIuiv(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIuiv(uint sampler, SamplerParameterI pname, void* @params) => _GetSamplerParameterIuiv_ptr(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIuiv(uint sampler, SamplerParameterI pname, IntPtr @params) => _GetSamplerParameterIuiv_intptr(sampler, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIuivEXT(uint sampler, SamplerParameterI pname, uint[] @params) => _GetSamplerParameterIuivEXT(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIuivEXT(uint sampler, SamplerParameterI pname, void* @params) => _GetSamplerParameterIuivEXT_ptr(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIuivEXT(uint sampler, SamplerParameterI pname, IntPtr @params) => _GetSamplerParameterIuivEXT_intptr(sampler, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIuivOES(uint sampler, SamplerParameterI pname, uint[] @params) => _GetSamplerParameterIuivOES(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIuivOES(uint sampler, SamplerParameterI pname, void* @params) => _GetSamplerParameterIuivOES_ptr(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterIuivOES(uint sampler, SamplerParameterI pname, IntPtr @params) => _GetSamplerParameterIuivOES_intptr(sampler, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterfv(uint sampler, SamplerParameterF pname, float[] @params) => _GetSamplerParameterfv(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterfv(uint sampler, SamplerParameterF pname, void* @params) => _GetSamplerParameterfv_ptr(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameterfv(uint sampler, SamplerParameterF pname, IntPtr @params) => _GetSamplerParameterfv_intptr(sampler, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameteriv(uint sampler, SamplerParameterI pname, int[] @params) => _GetSamplerParameteriv(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameteriv(uint sampler, SamplerParameterI pname, void* @params) => _GetSamplerParameteriv_ptr(sampler, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSamplerParameteriv(uint sampler, SamplerParameterI pname, IntPtr @params) => _GetSamplerParameteriv_intptr(sampler, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, UInt64[] @params) => _GetSemaphoreParameterui64vEXT(semaphore, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, void* @params) => _GetSemaphoreParameterui64vEXT_ptr(semaphore, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, IntPtr @params) => _GetSemaphoreParameterui64vEXT_intptr(semaphore, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSeparableFilter(SeparableTargetEXT target, PixelFormat format, PixelType type, IntPtr row, IntPtr column, IntPtr span) => _GetSeparableFilter(target, format, type, row, column, span);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSeparableFilterEXT(SeparableTargetEXT target, PixelFormat format, PixelType type, IntPtr row, IntPtr column, IntPtr span) => _GetSeparableFilterEXT(target, format, type, row, column, span);

        // ---

        /// <summary>
        /// glGetShaderInfoLog returns the        information log for the specified shader object. The information        log for a shader object is modified when the shader is compiled.        The string that is returned will be null terminated.
        /// glGetShaderInfoLog returns in        infoLog as much of the information log as        it can, up to a maximum of maxLength        characters. The number of characters actually returned,        excluding the null termination character, is specified by        length. If the length of the returned        string is not required, a value of NULL can        be passed in the length argument. The        size of the buffer required to store the returned information        log can be obtained by calling        glGetShader        with the value GL_INFO_LOG_LENGTH.
        /// The information log for a shader object is a string that        may contain diagnostic messages, warning messages, and other        information about the last compile operation. When a shader        object is created, its information log will be a string of        length 0.
        /// </summary>
        /// <param name="shader">Specifies the shader object whose information                    log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for                    storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in                    infoLog (excluding the null                    terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used                    to return the information log.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShaderInfoLog(uint shader, int bufSize, out int length, string infoLog) => _GetShaderInfoLog(shader, bufSize, out length, infoLog);

        /// <summary>
        /// glGetShaderInfoLog returns the        information log for the specified shader object. The information        log for a shader object is modified when the shader is compiled.        The string that is returned will be null terminated.
        /// glGetShaderInfoLog returns in        infoLog as much of the information log as        it can, up to a maximum of maxLength        characters. The number of characters actually returned,        excluding the null termination character, is specified by        length. If the length of the returned        string is not required, a value of NULL can        be passed in the length argument. The        size of the buffer required to store the returned information        log can be obtained by calling        glGetShader        with the value GL_INFO_LOG_LENGTH.
        /// The information log for a shader object is a string that        may contain diagnostic messages, warning messages, and other        information about the last compile operation. When a shader        object is created, its information log will be a string of        length 0.
        /// </summary>
        /// <param name="shader">Specifies the shader object whose information                    log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for                    storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in                    infoLog (excluding the null                    terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used                    to return the information log.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShaderInfoLog(uint shader, int bufSize, out int length, void* infoLog) => _GetShaderInfoLog_ptr(shader, bufSize, out length, infoLog);

        /// <summary>
        /// glGetShaderInfoLog returns the        information log for the specified shader object. The information        log for a shader object is modified when the shader is compiled.        The string that is returned will be null terminated.
        /// glGetShaderInfoLog returns in        infoLog as much of the information log as        it can, up to a maximum of maxLength        characters. The number of characters actually returned,        excluding the null termination character, is specified by        length. If the length of the returned        string is not required, a value of NULL can        be passed in the length argument. The        size of the buffer required to store the returned information        log can be obtained by calling        glGetShader        with the value GL_INFO_LOG_LENGTH.
        /// The information log for a shader object is a string that        may contain diagnostic messages, warning messages, and other        information about the last compile operation. When a shader        object is created, its information log will be a string of        length 0.
        /// </summary>
        /// <param name="shader">Specifies the shader object whose information                    log is to be queried.</param>
        /// <param name="maxLength">Specifies the size of the character buffer for                    storing the returned information log.</param>
        /// <param name="length">Returns the length of the string returned in                    infoLog (excluding the null                    terminator).</param>
        /// <param name="infoLog">Specifies an array of characters that is used                    to return the information log.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShaderInfoLog(uint shader, int bufSize, out int length, IntPtr infoLog) => _GetShaderInfoLog_intptr(shader, bufSize, out length, infoLog);

        // ---

        /// <summary>
        /// glGetShaderPrecisionFormat retrieves the numeric range and precision for            the implementation's representation of quantities in different numeric formats in specified            shader type. shaderType specifies the type of shader for which the numeric            precision and range is to be retrieved and must be one of GL_VERTEX_SHADER            or GL_FRAGMENT_SHADER. precisionType specifies the            numeric format to query and must be one of GL_LOW_FLOAT, GL_MEDIUM_FLOATGL_HIGH_FLOAT, GL_LOW_INT, GL_MEDIUM_INT,            or GL_HIGH_INT.
        /// range points to an array of two integers into which the format's numeric range            will be returned. If min and max are the smallest values representable in the format, then the values            returned are defined to be: range[0] = floor(log2(|min|)) and            range[1] = floor(log2(|max|)).
        /// precision specifies the address of an integer into which will be written            the log2 value of the number of bits of precision of the format. If the smallest representable            value greater than 1 is 1 + eps, then the integer addressed by precision            will contain floor(-log2(eps)).
        /// </summary>
        /// <param name="shaderType">Specifies the type of shader whose precision to query. shaderType                must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER.</param>
        /// <param name="precisionType">Specifies the numeric format whose precision and range to query.</param>
        /// <param name="range">Specifies the address of array of two integers into which encodings of the implementation's                numeric range are returned.</param>
        /// <param name="precision">Specifies the address of an integer into which the numeric precision of the implementation                is written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, int[] range, out int precision) => _GetShaderPrecisionFormat(shadertype, precisiontype, range, out precision);

        /// <summary>
        /// glGetShaderPrecisionFormat retrieves the numeric range and precision for            the implementation's representation of quantities in different numeric formats in specified            shader type. shaderType specifies the type of shader for which the numeric            precision and range is to be retrieved and must be one of GL_VERTEX_SHADER            or GL_FRAGMENT_SHADER. precisionType specifies the            numeric format to query and must be one of GL_LOW_FLOAT, GL_MEDIUM_FLOATGL_HIGH_FLOAT, GL_LOW_INT, GL_MEDIUM_INT,            or GL_HIGH_INT.
        /// range points to an array of two integers into which the format's numeric range            will be returned. If min and max are the smallest values representable in the format, then the values            returned are defined to be: range[0] = floor(log2(|min|)) and            range[1] = floor(log2(|max|)).
        /// precision specifies the address of an integer into which will be written            the log2 value of the number of bits of precision of the format. If the smallest representable            value greater than 1 is 1 + eps, then the integer addressed by precision            will contain floor(-log2(eps)).
        /// </summary>
        /// <param name="shaderType">Specifies the type of shader whose precision to query. shaderType                must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER.</param>
        /// <param name="precisionType">Specifies the numeric format whose precision and range to query.</param>
        /// <param name="range">Specifies the address of array of two integers into which encodings of the implementation's                numeric range are returned.</param>
        /// <param name="precision">Specifies the address of an integer into which the numeric precision of the implementation                is written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, void* range, out int precision) => _GetShaderPrecisionFormat_ptr(shadertype, precisiontype, range, out precision);

        /// <summary>
        /// glGetShaderPrecisionFormat retrieves the numeric range and precision for            the implementation's representation of quantities in different numeric formats in specified            shader type. shaderType specifies the type of shader for which the numeric            precision and range is to be retrieved and must be one of GL_VERTEX_SHADER            or GL_FRAGMENT_SHADER. precisionType specifies the            numeric format to query and must be one of GL_LOW_FLOAT, GL_MEDIUM_FLOATGL_HIGH_FLOAT, GL_LOW_INT, GL_MEDIUM_INT,            or GL_HIGH_INT.
        /// range points to an array of two integers into which the format's numeric range            will be returned. If min and max are the smallest values representable in the format, then the values            returned are defined to be: range[0] = floor(log2(|min|)) and            range[1] = floor(log2(|max|)).
        /// precision specifies the address of an integer into which will be written            the log2 value of the number of bits of precision of the format. If the smallest representable            value greater than 1 is 1 + eps, then the integer addressed by precision            will contain floor(-log2(eps)).
        /// </summary>
        /// <param name="shaderType">Specifies the type of shader whose precision to query. shaderType                must be GL_VERTEX_SHADER or GL_FRAGMENT_SHADER.</param>
        /// <param name="precisionType">Specifies the numeric format whose precision and range to query.</param>
        /// <param name="range">Specifies the address of array of two integers into which encodings of the implementation's                numeric range are returned.</param>
        /// <param name="precision">Specifies the address of an integer into which the numeric precision of the implementation                is written.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShaderPrecisionFormat(ShaderType shadertype, PrecisionType precisiontype, IntPtr range, out int precision) => _GetShaderPrecisionFormat_intptr(shadertype, precisiontype, range, out precision);

        // ---

        /// <summary>
        /// glGetShaderSource returns the    concatenation of the source code strings from the shader object    specified by shader. The source code    strings for a shader object are the result of a previous call to    glShaderSource.    The string returned by the function will be null    terminated.
        /// glGetShaderSource returns in    source as much of the source code string    as it can, up to a maximum of bufSize    characters. The number of characters actually returned,    excluding the null termination character, is specified by    length. If the length of the returned    string is not required, a value of NULL can    be passed in the length argument. The    size of the buffer required to store the returned source code    string can be obtained by calling    glGetShader    with the value    GL_SHADER_SOURCE_LENGTH.
        /// </summary>
        /// <param name="shader">Specifies the shader object to be            queried.</param>
        /// <param name="bufSize">Specifies the size of the character buffer for            storing the returned source code string.</param>
        /// <param name="length">Returns the length of the string returned in            source (excluding the null            terminator).</param>
        /// <param name="source">Specifies an array of characters that is used            to return the source code string.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShaderSource(uint shader, int bufSize, out int length, string source) => _GetShaderSource(shader, bufSize, out length, source);

        /// <summary>
        /// glGetShaderSource returns the    concatenation of the source code strings from the shader object    specified by shader. The source code    strings for a shader object are the result of a previous call to    glShaderSource.    The string returned by the function will be null    terminated.
        /// glGetShaderSource returns in    source as much of the source code string    as it can, up to a maximum of bufSize    characters. The number of characters actually returned,    excluding the null termination character, is specified by    length. If the length of the returned    string is not required, a value of NULL can    be passed in the length argument. The    size of the buffer required to store the returned source code    string can be obtained by calling    glGetShader    with the value    GL_SHADER_SOURCE_LENGTH.
        /// </summary>
        /// <param name="shader">Specifies the shader object to be            queried.</param>
        /// <param name="bufSize">Specifies the size of the character buffer for            storing the returned source code string.</param>
        /// <param name="length">Returns the length of the string returned in            source (excluding the null            terminator).</param>
        /// <param name="source">Specifies an array of characters that is used            to return the source code string.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShaderSource(uint shader, int bufSize, out int length, void* source) => _GetShaderSource_ptr(shader, bufSize, out length, source);

        /// <summary>
        /// glGetShaderSource returns the    concatenation of the source code strings from the shader object    specified by shader. The source code    strings for a shader object are the result of a previous call to    glShaderSource.    The string returned by the function will be null    terminated.
        /// glGetShaderSource returns in    source as much of the source code string    as it can, up to a maximum of bufSize    characters. The number of characters actually returned,    excluding the null termination character, is specified by    length. If the length of the returned    string is not required, a value of NULL can    be passed in the length argument. The    size of the buffer required to store the returned source code    string can be obtained by calling    glGetShader    with the value    GL_SHADER_SOURCE_LENGTH.
        /// </summary>
        /// <param name="shader">Specifies the shader object to be            queried.</param>
        /// <param name="bufSize">Specifies the size of the character buffer for            storing the returned source code string.</param>
        /// <param name="length">Returns the length of the string returned in            source (excluding the null            terminator).</param>
        /// <param name="source">Specifies an array of characters that is used            to return the source code string.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShaderSource(uint shader, int bufSize, out int length, IntPtr source) => _GetShaderSource_intptr(shader, bufSize, out length, source);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShaderSourceARB(int obj, int maxLength, out int length, string source) => _GetShaderSourceARB(obj, maxLength, out length, source);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShaderSourceARB(int obj, int maxLength, out int length, void* source) => _GetShaderSourceARB_ptr(obj, maxLength, out length, source);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShaderSourceARB(int obj, int maxLength, out int length, IntPtr source) => _GetShaderSourceARB_intptr(obj, maxLength, out length, source);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShaderiv(uint shader, ShaderParameterName pname, int[] @params) => _GetShaderiv(shader, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShaderiv(uint shader, ShaderParameterName pname, void* @params) => _GetShaderiv_ptr(shader, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShaderiv(uint shader, ShaderParameterName pname, IntPtr @params) => _GetShaderiv_intptr(shader, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShadingRateImagePaletteNV(uint viewport, uint entry, out int rate) => _GetShadingRateImagePaletteNV(viewport, entry, out rate);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShadingRateSampleLocationivNV(int rate, uint samples, uint index, int[] location) => _GetShadingRateSampleLocationivNV(rate, samples, index, location);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShadingRateSampleLocationivNV(int rate, uint samples, uint index, void* location) => _GetShadingRateSampleLocationivNV_ptr(rate, samples, index, location);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetShadingRateSampleLocationivNV(int rate, uint samples, uint index, IntPtr location) => _GetShadingRateSampleLocationivNV_intptr(rate, samples, index, location);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSharpenTexFuncSGIS(TextureTarget target, float[] points) => _GetSharpenTexFuncSGIS(target, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSharpenTexFuncSGIS(TextureTarget target, void* points) => _GetSharpenTexFuncSGIS_ptr(target, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSharpenTexFuncSGIS(TextureTarget target, IntPtr points) => _GetSharpenTexFuncSGIS_intptr(target, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ushort GetStageIndexNV(ShaderType shadertype) => _GetStageIndexNV(shadertype);

        // ---

        /// <summary>
        /// glGetString returns a pointer to a static string            describing some aspect of the current GL connection.            name can be one of the following:
        /// GL_VENDOR                        Returns the company responsible for this GL implementation.                        This name does not change from release to release.                    GL_RENDERER                        Returns the name of the renderer.                        This name is typically specific to a particular configuration of a hardware                        platform.                        It does not change from release to release.                    GL_VERSION                        Returns a version or release number.                    GL_SHADING_LANGUAGE_VERSION                        Returns a version or release number for the shading language.
        /// glGetStringi returns a pointer to a static string            indexed by index.            name can be one of the following:
        /// GL_EXTENSIONS                        For glGetStringi only, returns the extension string                        supported by the implementation at index.
        /// Strings GL_VENDOR and GL_RENDERER together uniquely specify            a platform. They do not change from release to release and should be used            by platform-recognition algorithms.
        /// The GL_VERSION and GL_SHADING_LANGUAGE_VERSION strings begin with a version number.            The version number uses one            of these forms:
        /// major_number.minor_numbermajor_number.minor_number.release_number
        /// Vendor-specific information may follow the version            number. Its format depends on the implementation, but            a space always separates the version number and            the vendor-specific information.
        /// All strings are null-terminated.
        /// </summary>
        /// <param name="name">Specifies a symbolic constant, one of                    GL_VENDOR, GL_RENDERER,                    GL_VERSION, or GL_SHADING_LANGUAGE_VERSION.                    Additionally, glGetStringi accepts the GL_EXTENSIONS token.</param>
        /// <param name="index">For glGetStringi, specifies the index of the string to return.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string GetString(StringName name)
        {
            var ptr = _GetString(name);
            if (ptr != IntPtr.Zero)
                return Marshal.PtrToStringAnsi(ptr);

            return null;
        }

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IntPtr GetStringi(StringName name, uint index) => _GetStringi(name, index);

        // ---

        /// <summary>
        /// glGetSubroutineIndex returns the index of a subroutine uniform within a shader stage attached to a program object.            program contains the name of the program to which the shader is attached. shadertype            specifies the stage from which to query shader subroutine index. name contains the null-terminated            name of the subroutine uniform whose name to query.
        /// If name is not the name of a subroutine uniform in the shader stage, GL_INVALID_INDEX            is returned, but no error is generated. If name is the name of a subroutine uniform in the shader stage,            a value between zero and the value of GL_ACTIVE_SUBROUTINES minus one will be returned. Subroutine indices            are assigned using consecutive integers in the range from zero to the value of GL_ACTIVE_SUBROUTINES minus            one for the shader stage.
        /// </summary>
        /// <param name="program">Specifies the name of the program containing shader stage.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for subroutine uniform index.                    shadertype                    must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER,                    GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or                    GL_FRAGMENT_SHADER.</param>
        /// <param name="name">Specifies the name of the subroutine uniform whose index to query.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetSubroutineIndex(uint program, ShaderType shadertype, string name) => _GetSubroutineIndex(program, shadertype, name);

        /// <summary>
        /// glGetSubroutineIndex returns the index of a subroutine uniform within a shader stage attached to a program object.            program contains the name of the program to which the shader is attached. shadertype            specifies the stage from which to query shader subroutine index. name contains the null-terminated            name of the subroutine uniform whose name to query.
        /// If name is not the name of a subroutine uniform in the shader stage, GL_INVALID_INDEX            is returned, but no error is generated. If name is the name of a subroutine uniform in the shader stage,            a value between zero and the value of GL_ACTIVE_SUBROUTINES minus one will be returned. Subroutine indices            are assigned using consecutive integers in the range from zero to the value of GL_ACTIVE_SUBROUTINES minus            one for the shader stage.
        /// </summary>
        /// <param name="program">Specifies the name of the program containing shader stage.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for subroutine uniform index.                    shadertype                    must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER,                    GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or                    GL_FRAGMENT_SHADER.</param>
        /// <param name="name">Specifies the name of the subroutine uniform whose index to query.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetSubroutineIndex(uint program, ShaderType shadertype, void* name) => _GetSubroutineIndex_ptr(program, shadertype, name);

        /// <summary>
        /// glGetSubroutineIndex returns the index of a subroutine uniform within a shader stage attached to a program object.            program contains the name of the program to which the shader is attached. shadertype            specifies the stage from which to query shader subroutine index. name contains the null-terminated            name of the subroutine uniform whose name to query.
        /// If name is not the name of a subroutine uniform in the shader stage, GL_INVALID_INDEX            is returned, but no error is generated. If name is the name of a subroutine uniform in the shader stage,            a value between zero and the value of GL_ACTIVE_SUBROUTINES minus one will be returned. Subroutine indices            are assigned using consecutive integers in the range from zero to the value of GL_ACTIVE_SUBROUTINES minus            one for the shader stage.
        /// </summary>
        /// <param name="program">Specifies the name of the program containing shader stage.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for subroutine uniform index.                    shadertype                    must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER,                    GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or                    GL_FRAGMENT_SHADER.</param>
        /// <param name="name">Specifies the name of the subroutine uniform whose index to query.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetSubroutineIndex(uint program, ShaderType shadertype, IntPtr name) => _GetSubroutineIndex_intptr(program, shadertype, name);

        // ---

        /// <summary>
        /// glGetSubroutineUniformLocation returns the location of the subroutine uniform variable            name in the shader stage of type shadertype attached to            program, with behavior otherwise identical to            glGetUniformLocation.
        /// If name is not the name of a subroutine uniform in the shader stage, -1            is returned, but no error is generated. If name is the name of a subroutine uniform in the shader stage,            a value between zero and the value of GL_ACTIVE_SUBROUTINE_LOCATIONS minus one will be returned.            Subroutine locations are assigned using consecutive integers in the range from zero to the value            of GL_ACTIVE_SUBROUTINE_LOCATIONS minus one for the shader stage.  For active subroutine uniforms            declared as arrays, the declared array elements are assigned consecutive locations.
        /// </summary>
        /// <param name="program">Specifies the name of the program containing shader stage.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for subroutine uniform index.                    shadertype                    must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER,                    GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or                    GL_FRAGMENT_SHADER.</param>
        /// <param name="name">Specifies the name of the subroutine uniform whose index to query.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetSubroutineUniformLocation(uint program, ShaderType shadertype, string name) => _GetSubroutineUniformLocation(program, shadertype, name);

        /// <summary>
        /// glGetSubroutineUniformLocation returns the location of the subroutine uniform variable            name in the shader stage of type shadertype attached to            program, with behavior otherwise identical to            glGetUniformLocation.
        /// If name is not the name of a subroutine uniform in the shader stage, -1            is returned, but no error is generated. If name is the name of a subroutine uniform in the shader stage,            a value between zero and the value of GL_ACTIVE_SUBROUTINE_LOCATIONS minus one will be returned.            Subroutine locations are assigned using consecutive integers in the range from zero to the value            of GL_ACTIVE_SUBROUTINE_LOCATIONS minus one for the shader stage.  For active subroutine uniforms            declared as arrays, the declared array elements are assigned consecutive locations.
        /// </summary>
        /// <param name="program">Specifies the name of the program containing shader stage.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for subroutine uniform index.                    shadertype                    must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER,                    GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or                    GL_FRAGMENT_SHADER.</param>
        /// <param name="name">Specifies the name of the subroutine uniform whose index to query.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetSubroutineUniformLocation(uint program, ShaderType shadertype, void* name) => _GetSubroutineUniformLocation_ptr(program, shadertype, name);

        /// <summary>
        /// glGetSubroutineUniformLocation returns the location of the subroutine uniform variable            name in the shader stage of type shadertype attached to            program, with behavior otherwise identical to            glGetUniformLocation.
        /// If name is not the name of a subroutine uniform in the shader stage, -1            is returned, but no error is generated. If name is the name of a subroutine uniform in the shader stage,            a value between zero and the value of GL_ACTIVE_SUBROUTINE_LOCATIONS minus one will be returned.            Subroutine locations are assigned using consecutive integers in the range from zero to the value            of GL_ACTIVE_SUBROUTINE_LOCATIONS minus one for the shader stage.  For active subroutine uniforms            declared as arrays, the declared array elements are assigned consecutive locations.
        /// </summary>
        /// <param name="program">Specifies the name of the program containing shader stage.</param>
        /// <param name="shadertype">Specifies the shader stage from which to query for subroutine uniform index.                    shadertype                    must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER,                    GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or                    GL_FRAGMENT_SHADER.</param>
        /// <param name="name">Specifies the name of the subroutine uniform whose index to query.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetSubroutineUniformLocation(uint program, ShaderType shadertype, IntPtr name) => _GetSubroutineUniformLocation_intptr(program, shadertype, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSynciv(int sync, SyncParameterName pname, int count, out int length, int[] values) => _GetSynciv(sync, pname, count, out length, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSynciv(int sync, SyncParameterName pname, int count, out int length, void* values) => _GetSynciv_ptr(sync, pname, count, out length, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSynciv(int sync, SyncParameterName pname, int count, out int length, IntPtr values) => _GetSynciv_intptr(sync, pname, count, out length, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSyncivAPPLE(int sync, SyncParameterName pname, int count, int[] length, int[] values) => _GetSyncivAPPLE(sync, pname, count, length, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSyncivAPPLE(int sync, SyncParameterName pname, int count, void* length, void* values) => _GetSyncivAPPLE_ptr(sync, pname, count, length, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetSyncivAPPLE(int sync, SyncParameterName pname, int count, IntPtr length, IntPtr values) => _GetSyncivAPPLE_intptr(sync, pname, count, length, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexBumpParameterfvATI(GetTexBumpParameterATI pname, float[] param) => _GetTexBumpParameterfvATI(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexBumpParameterfvATI(GetTexBumpParameterATI pname, void* param) => _GetTexBumpParameterfvATI_ptr(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexBumpParameterfvATI(GetTexBumpParameterATI pname, IntPtr param) => _GetTexBumpParameterfvATI_intptr(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexBumpParameterivATI(GetTexBumpParameterATI pname, int[] param) => _GetTexBumpParameterivATI(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexBumpParameterivATI(GetTexBumpParameterATI pname, void* param) => _GetTexBumpParameterivATI_ptr(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexBumpParameterivATI(GetTexBumpParameterATI pname, IntPtr param) => _GetTexBumpParameterivATI_intptr(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexEnvfv(TextureEnvTarget target, TextureEnvParameter pname, float[] @params) => _GetTexEnvfv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexEnvfv(TextureEnvTarget target, TextureEnvParameter pname, void* @params) => _GetTexEnvfv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexEnvfv(TextureEnvTarget target, TextureEnvParameter pname, IntPtr @params) => _GetTexEnvfv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexEnviv(TextureEnvTarget target, TextureEnvParameter pname, int[] @params) => _GetTexEnviv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexEnviv(TextureEnvTarget target, TextureEnvParameter pname, void* @params) => _GetTexEnviv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexEnviv(TextureEnvTarget target, TextureEnvParameter pname, IntPtr @params) => _GetTexEnviv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexEnvxv(TextureEnvTarget target, TextureEnvParameter pname, float[] @params) => _GetTexEnvxv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexEnvxv(TextureEnvTarget target, TextureEnvParameter pname, void* @params) => _GetTexEnvxv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexEnvxv(TextureEnvTarget target, TextureEnvParameter pname, IntPtr @params) => _GetTexEnvxv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, float[] @params) => _GetTexEnvxvOES(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, void* @params) => _GetTexEnvxvOES_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, IntPtr @params) => _GetTexEnvxvOES_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, float[] weights) => _GetTexFilterFuncSGIS(target, filter, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, void* weights) => _GetTexFilterFuncSGIS_ptr(target, filter, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, IntPtr weights) => _GetTexFilterFuncSGIS_intptr(target, filter, weights);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGendv(TextureCoordName coord, TextureGenParameter pname, double[] @params) => _GetTexGendv(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGendv(TextureCoordName coord, TextureGenParameter pname, void* @params) => _GetTexGendv_ptr(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGendv(TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _GetTexGendv_intptr(coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGenfv(TextureCoordName coord, TextureGenParameter pname, float[] @params) => _GetTexGenfv(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGenfv(TextureCoordName coord, TextureGenParameter pname, void* @params) => _GetTexGenfv_ptr(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGenfv(TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _GetTexGenfv_intptr(coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGenfvOES(TextureCoordName coord, TextureGenParameter pname, float[] @params) => _GetTexGenfvOES(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGenfvOES(TextureCoordName coord, TextureGenParameter pname, void* @params) => _GetTexGenfvOES_ptr(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGenfvOES(TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _GetTexGenfvOES_intptr(coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGeniv(TextureCoordName coord, TextureGenParameter pname, int[] @params) => _GetTexGeniv(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGeniv(TextureCoordName coord, TextureGenParameter pname, void* @params) => _GetTexGeniv_ptr(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGeniv(TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _GetTexGeniv_intptr(coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGenivOES(TextureCoordName coord, TextureGenParameter pname, int[] @params) => _GetTexGenivOES(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGenivOES(TextureCoordName coord, TextureGenParameter pname, void* @params) => _GetTexGenivOES_ptr(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGenivOES(TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _GetTexGenivOES_intptr(coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGenxvOES(TextureCoordName coord, TextureGenParameter pname, float[] @params) => _GetTexGenxvOES(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGenxvOES(TextureCoordName coord, TextureGenParameter pname, void* @params) => _GetTexGenxvOES_ptr(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexGenxvOES(TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _GetTexGenxvOES_intptr(coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexImage(TextureTarget target, int level, PixelFormat format, PixelType type, IntPtr pixels) => _GetTexImage(target, level, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexLevelParameterfv(TextureTarget target, int level, GetTextureParameter pname, float[] @params) => _GetTexLevelParameterfv(target, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexLevelParameterfv(TextureTarget target, int level, GetTextureParameter pname, void* @params) => _GetTexLevelParameterfv_ptr(target, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexLevelParameterfv(TextureTarget target, int level, GetTextureParameter pname, IntPtr @params) => _GetTexLevelParameterfv_intptr(target, level, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexLevelParameteriv(TextureTarget target, int level, GetTextureParameter pname, int[] @params) => _GetTexLevelParameteriv(target, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexLevelParameteriv(TextureTarget target, int level, GetTextureParameter pname, void* @params) => _GetTexLevelParameteriv_ptr(target, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexLevelParameteriv(TextureTarget target, int level, GetTextureParameter pname, IntPtr @params) => _GetTexLevelParameteriv_intptr(target, level, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexLevelParameterxvOES(TextureTarget target, int level, GetTextureParameter pname, float[] @params) => _GetTexLevelParameterxvOES(target, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexLevelParameterxvOES(TextureTarget target, int level, GetTextureParameter pname, void* @params) => _GetTexLevelParameterxvOES_ptr(target, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexLevelParameterxvOES(TextureTarget target, int level, GetTextureParameter pname, IntPtr @params) => _GetTexLevelParameterxvOES_intptr(target, level, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIiv(TextureTarget target, GetTextureParameter pname, int[] @params) => _GetTexParameterIiv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIiv(TextureTarget target, GetTextureParameter pname, void* @params) => _GetTexParameterIiv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIiv(TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetTexParameterIiv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIivEXT(TextureTarget target, GetTextureParameter pname, int[] @params) => _GetTexParameterIivEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIivEXT(TextureTarget target, GetTextureParameter pname, void* @params) => _GetTexParameterIivEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIivEXT(TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetTexParameterIivEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIivOES(TextureTarget target, GetTextureParameter pname, int[] @params) => _GetTexParameterIivOES(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIivOES(TextureTarget target, GetTextureParameter pname, void* @params) => _GetTexParameterIivOES_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIivOES(TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetTexParameterIivOES_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIuiv(TextureTarget target, GetTextureParameter pname, uint[] @params) => _GetTexParameterIuiv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIuiv(TextureTarget target, GetTextureParameter pname, void* @params) => _GetTexParameterIuiv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIuiv(TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetTexParameterIuiv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIuivEXT(TextureTarget target, GetTextureParameter pname, uint[] @params) => _GetTexParameterIuivEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIuivEXT(TextureTarget target, GetTextureParameter pname, void* @params) => _GetTexParameterIuivEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIuivEXT(TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetTexParameterIuivEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIuivOES(TextureTarget target, GetTextureParameter pname, uint[] @params) => _GetTexParameterIuivOES(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIuivOES(TextureTarget target, GetTextureParameter pname, void* @params) => _GetTexParameterIuivOES_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterIuivOES(TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetTexParameterIuivOES_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterPointervAPPLE(int target, int pname, IntPtr* @params) => _GetTexParameterPointervAPPLE(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterfv(TextureTarget target, GetTextureParameter pname, float[] @params) => _GetTexParameterfv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterfv(TextureTarget target, GetTextureParameter pname, void* @params) => _GetTexParameterfv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterfv(TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetTexParameterfv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameteriv(TextureTarget target, GetTextureParameter pname, int[] @params) => _GetTexParameteriv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameteriv(TextureTarget target, GetTextureParameter pname, void* @params) => _GetTexParameteriv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameteriv(TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetTexParameteriv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterxv(TextureTarget target, GetTextureParameter pname, float[] @params) => _GetTexParameterxv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterxv(TextureTarget target, GetTextureParameter pname, void* @params) => _GetTexParameterxv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterxv(TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetTexParameterxv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterxvOES(TextureTarget target, GetTextureParameter pname, float[] @params) => _GetTexParameterxvOES(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterxvOES(TextureTarget target, GetTextureParameter pname, void* @params) => _GetTexParameterxvOES_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTexParameterxvOES(TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetTexParameterxvOES_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public UInt64 GetTextureHandleARB(uint texture) => _GetTextureHandleARB(texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public UInt64 GetTextureHandleIMG(uint texture) => _GetTextureHandleIMG(texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public UInt64 GetTextureHandleNV(uint texture) => _GetTextureHandleNV(texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureImage(uint texture, int level, PixelFormat format, PixelType type, int bufSize, IntPtr pixels) => _GetTextureImage(texture, level, format, type, bufSize, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureImageEXT(uint texture, TextureTarget target, int level, PixelFormat format, PixelType type, IntPtr pixels) => _GetTextureImageEXT(texture, target, level, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureLevelParameterfv(uint texture, int level, GetTextureParameter pname, float[] @params) => _GetTextureLevelParameterfv(texture, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureLevelParameterfv(uint texture, int level, GetTextureParameter pname, void* @params) => _GetTextureLevelParameterfv_ptr(texture, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureLevelParameterfv(uint texture, int level, GetTextureParameter pname, IntPtr @params) => _GetTextureLevelParameterfv_intptr(texture, level, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureLevelParameterfvEXT(uint texture, TextureTarget target, int level, GetTextureParameter pname, float[] @params) => _GetTextureLevelParameterfvEXT(texture, target, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureLevelParameterfvEXT(uint texture, TextureTarget target, int level, GetTextureParameter pname, void* @params) => _GetTextureLevelParameterfvEXT_ptr(texture, target, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureLevelParameterfvEXT(uint texture, TextureTarget target, int level, GetTextureParameter pname, IntPtr @params) => _GetTextureLevelParameterfvEXT_intptr(texture, target, level, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureLevelParameteriv(uint texture, int level, GetTextureParameter pname, int[] @params) => _GetTextureLevelParameteriv(texture, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureLevelParameteriv(uint texture, int level, GetTextureParameter pname, void* @params) => _GetTextureLevelParameteriv_ptr(texture, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureLevelParameteriv(uint texture, int level, GetTextureParameter pname, IntPtr @params) => _GetTextureLevelParameteriv_intptr(texture, level, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureLevelParameterivEXT(uint texture, TextureTarget target, int level, GetTextureParameter pname, int[] @params) => _GetTextureLevelParameterivEXT(texture, target, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureLevelParameterivEXT(uint texture, TextureTarget target, int level, GetTextureParameter pname, void* @params) => _GetTextureLevelParameterivEXT_ptr(texture, target, level, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureLevelParameterivEXT(uint texture, TextureTarget target, int level, GetTextureParameter pname, IntPtr @params) => _GetTextureLevelParameterivEXT_intptr(texture, target, level, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterIiv(uint texture, GetTextureParameter pname, int[] @params) => _GetTextureParameterIiv(texture, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterIiv(uint texture, GetTextureParameter pname, void* @params) => _GetTextureParameterIiv_ptr(texture, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterIiv(uint texture, GetTextureParameter pname, IntPtr @params) => _GetTextureParameterIiv_intptr(texture, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterIivEXT(uint texture, TextureTarget target, GetTextureParameter pname, int[] @params) => _GetTextureParameterIivEXT(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterIivEXT(uint texture, TextureTarget target, GetTextureParameter pname, void* @params) => _GetTextureParameterIivEXT_ptr(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterIivEXT(uint texture, TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetTextureParameterIivEXT_intptr(texture, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterIuiv(uint texture, GetTextureParameter pname, uint[] @params) => _GetTextureParameterIuiv(texture, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterIuiv(uint texture, GetTextureParameter pname, void* @params) => _GetTextureParameterIuiv_ptr(texture, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterIuiv(uint texture, GetTextureParameter pname, IntPtr @params) => _GetTextureParameterIuiv_intptr(texture, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterIuivEXT(uint texture, TextureTarget target, GetTextureParameter pname, uint[] @params) => _GetTextureParameterIuivEXT(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterIuivEXT(uint texture, TextureTarget target, GetTextureParameter pname, void* @params) => _GetTextureParameterIuivEXT_ptr(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterIuivEXT(uint texture, TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetTextureParameterIuivEXT_intptr(texture, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterfv(uint texture, GetTextureParameter pname, float[] @params) => _GetTextureParameterfv(texture, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterfv(uint texture, GetTextureParameter pname, void* @params) => _GetTextureParameterfv_ptr(texture, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterfv(uint texture, GetTextureParameter pname, IntPtr @params) => _GetTextureParameterfv_intptr(texture, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterfvEXT(uint texture, TextureTarget target, GetTextureParameter pname, float[] @params) => _GetTextureParameterfvEXT(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterfvEXT(uint texture, TextureTarget target, GetTextureParameter pname, void* @params) => _GetTextureParameterfvEXT_ptr(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterfvEXT(uint texture, TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetTextureParameterfvEXT_intptr(texture, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameteriv(uint texture, GetTextureParameter pname, int[] @params) => _GetTextureParameteriv(texture, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameteriv(uint texture, GetTextureParameter pname, void* @params) => _GetTextureParameteriv_ptr(texture, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameteriv(uint texture, GetTextureParameter pname, IntPtr @params) => _GetTextureParameteriv_intptr(texture, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterivEXT(uint texture, TextureTarget target, GetTextureParameter pname, int[] @params) => _GetTextureParameterivEXT(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterivEXT(uint texture, TextureTarget target, GetTextureParameter pname, void* @params) => _GetTextureParameterivEXT_ptr(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureParameterivEXT(uint texture, TextureTarget target, GetTextureParameter pname, IntPtr @params) => _GetTextureParameterivEXT_intptr(texture, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public UInt64 GetTextureSamplerHandleARB(uint texture, uint sampler) => _GetTextureSamplerHandleARB(texture, sampler);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public UInt64 GetTextureSamplerHandleIMG(uint texture, uint sampler) => _GetTextureSamplerHandleIMG(texture, sampler);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public UInt64 GetTextureSamplerHandleNV(uint texture, uint sampler) => _GetTextureSamplerHandleNV(texture, sampler);

        // ---

        /// <summary>
        /// glGetTextureSubImage returns a texture subimage    into pixels.
        /// texture is the name of the source texture    object and must not be a buffer or multisample texture. The effective    target parameter is the value of    GL_TEXTURE_TARGET for texture.    Level, format,    type and pixels have the    same meaning as for glGetTexImage.    bufSize is the size of the buffer to receive the    retrieved pixel data.
        /// For cube map textures, the behavior is as though    GetTextureImage were called, but only texels from the    requested cube map faces (selected by zoffset and    depth, as described below) were returned.
        /// xoffset, yoffset and    zoffset values indicate the position of the    subregion to return. width,    height and depth indicate    the size of the region to return. These parameters have the same meaning    as for glTexSubImage3D, though for one- and    two-dimensional textures there are extra restrictions, described in the    errors section below.
        /// For one-dimensional array textures, yoffset    is interpreted as the first layer to access and    height is the number of layers to access.
        /// For two-dimensional array textures, zoffset    is interpreted as the first layer to access and    depth is the number of layers to access.
        /// Cube map textures are treated as an array of six slices in the    z-dimension, where the value of zoffset is    interpreted as specifying the cube map face for the corresponding layer    (as presented in the table below) and depth is the    number of faces to access:
        /// Layer numberCube Map Face0GL_TEXTURE_CUBE_MAP_POSITIVE_X1GL_TEXTURE_CUBE_MAP_NEGATIVE_X2GL_TEXTURE_CUBE_MAP_POSITIVE_Y3GL_TEXTURE_CUBE_MAP_NEGATIVE_Y4GL_TEXTURE_CUBE_MAP_POSITIVE_Z5GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
        /// For cube map array textures, zoffset is the        first layer-face to access, and depth is the        number of layer-faces to access. A layer-face described by $k$ is        translated into an array layer and face according to            $$ layer = \left\lfloor { layer \over 6 } \right\rfloor$$        and            $$ face = k \bmod 6. $$
        /// Component groups from the specified sub-region are packed and placed    into memory as described for glGetTextureImage,    starting with the texel at (xoffset,    yoffset, zoffset).
        /// </summary>
        /// <param name="texture">Specifies the name of the source texture object. Must be          GL_TEXTURE_1D,          GL_TEXTURE_1D_ARRAY,          GL_TEXTURE_2D,          GL_TEXTURE_2D_ARRAY,          GL_TEXTURE_3D,          GL_TEXTURE_CUBE_MAP,          GL_TEXTURE_CUBE_MAP_ARRAY or          GL_TEXTURE_RECTANGLE. In specific, buffer and          multisample textures are not permitted.</param>
        /// <param name="level">Specifies the level-of-detail number. Level 0 is the base          image level. Level $n$ is the $n$th mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture          array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture          array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture          array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic          values are accepted: GL_RED,          GL_RG, GL_RGB,          GL_BGR, GL_RGBA,          GL_BGRA,          GL_DEPTH_COMPONENT and          GL_STENCIL_INDEX.</param>
        /// <param name="type">Specifies the data type of the pixel data. The following          symbolic values are accepted: GL_UNSIGNED_BYTE,          GL_BYTE,          GL_UNSIGNED_SHORT,          GL_SHORT, GL_UNSIGNED_INT,          GL_INT, GL_FLOAT,          GL_UNSIGNED_BYTE_3_3_2,          GL_UNSIGNED_BYTE_2_3_3_REV,          GL_UNSIGNED_SHORT_5_6_5,          GL_UNSIGNED_SHORT_5_6_5_REV,          GL_UNSIGNED_SHORT_4_4_4_4,          GL_UNSIGNED_SHORT_4_4_4_4_REV,          GL_UNSIGNED_SHORT_5_5_5_1,          GL_UNSIGNED_SHORT_1_5_5_5_REV,          GL_UNSIGNED_INT_8_8_8_8,          GL_UNSIGNED_INT_8_8_8_8_REV,          GL_UNSIGNED_INT_10_10_10_2, and          GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer to receive the retrieved          pixel data.</param>
        /// <param name="pixels">Returns the texture subimage. Should be a pointer to an array          of the type specified by type.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, int bufSize, IntPtr pixels) => _GetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTrackMatrixivNV(VertexAttribEnumNV target, uint address, VertexAttribEnumNV pname, out int @params) => _GetTrackMatrixivNV(target, address, pname, out @params);

        // ---

        /// <summary>
        /// Information about the set of varying variables in a linked program that will be captured            during transform feedback may be retrieved by calling glGetTransformFeedbackVarying.            glGetTransformFeedbackVarying provides information about the varying            variable selected by index. An index of 0 selects            the first varying variable specified in the varyings array passed            to glTransformFeedbackVaryings, and            an index of the value of            GL_TRANSFORM_FEEDBACK_VARYINGS minus one selects            the last such variable.
        /// The name of the selected varying is returned as a null-terminated string in            name. The actual number of characters written into name,            excluding the null terminator, is returned in length. If length            is NULL, no length is returned. The maximum number of characters that may be written into name,            including the null terminator, is specified by bufSize.
        /// The length of the longest varying name in program is given by GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH,            which can be queried with glGetProgram.
        /// For the selected varying variable, its type is returned into type. The size of            the varying is returned into size. The value in size is            in units of the type returned in type. The type returned can be any of the            scalar, vector, or matrix attribute types returned by glGetActiveAttrib.            If an error occurred, the return parameters length, size,            type and name will be unmodified. This command will return as much            information about the varying variables as possible. If no information is available, length            will be set to zero and name will be an empty string. This situation could            arise if glGetTransformFeedbackVarying is called after a failed link.
        /// </summary>
        /// <param name="program">The name of the target program object.</param>
        /// <param name="index">The index of the varying variable whose information to retrieve.</param>
        /// <param name="bufSize">The maximum number of characters, including the null terminator, that may be written into name.</param>
        /// <param name="length">The address of a variable which will receive the number of characters written into name,                    excluding the null-terminator. If length is NULL no length is returned.</param>
        /// <param name="size">The address of a variable that will receive the size of the varying.</param>
        /// <param name="type">The address of a variable that will receive the type of the varying.</param>
        /// <param name="name">The address of a buffer into which will be written the name of the varying.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbackVarying(uint program, uint index, int bufSize, out int length, out int size, out AttributeType type, string name) => _GetTransformFeedbackVarying(program, index, bufSize, out length, out size, out type, name);

        /// <summary>
        /// Information about the set of varying variables in a linked program that will be captured            during transform feedback may be retrieved by calling glGetTransformFeedbackVarying.            glGetTransformFeedbackVarying provides information about the varying            variable selected by index. An index of 0 selects            the first varying variable specified in the varyings array passed            to glTransformFeedbackVaryings, and            an index of the value of            GL_TRANSFORM_FEEDBACK_VARYINGS minus one selects            the last such variable.
        /// The name of the selected varying is returned as a null-terminated string in            name. The actual number of characters written into name,            excluding the null terminator, is returned in length. If length            is NULL, no length is returned. The maximum number of characters that may be written into name,            including the null terminator, is specified by bufSize.
        /// The length of the longest varying name in program is given by GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH,            which can be queried with glGetProgram.
        /// For the selected varying variable, its type is returned into type. The size of            the varying is returned into size. The value in size is            in units of the type returned in type. The type returned can be any of the            scalar, vector, or matrix attribute types returned by glGetActiveAttrib.            If an error occurred, the return parameters length, size,            type and name will be unmodified. This command will return as much            information about the varying variables as possible. If no information is available, length            will be set to zero and name will be an empty string. This situation could            arise if glGetTransformFeedbackVarying is called after a failed link.
        /// </summary>
        /// <param name="program">The name of the target program object.</param>
        /// <param name="index">The index of the varying variable whose information to retrieve.</param>
        /// <param name="bufSize">The maximum number of characters, including the null terminator, that may be written into name.</param>
        /// <param name="length">The address of a variable which will receive the number of characters written into name,                    excluding the null-terminator. If length is NULL no length is returned.</param>
        /// <param name="size">The address of a variable that will receive the size of the varying.</param>
        /// <param name="type">The address of a variable that will receive the type of the varying.</param>
        /// <param name="name">The address of a buffer into which will be written the name of the varying.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbackVarying(uint program, uint index, int bufSize, out int length, out int size, out AttributeType type, void* name) => _GetTransformFeedbackVarying_ptr(program, index, bufSize, out length, out size, out type, name);

        /// <summary>
        /// Information about the set of varying variables in a linked program that will be captured            during transform feedback may be retrieved by calling glGetTransformFeedbackVarying.            glGetTransformFeedbackVarying provides information about the varying            variable selected by index. An index of 0 selects            the first varying variable specified in the varyings array passed            to glTransformFeedbackVaryings, and            an index of the value of            GL_TRANSFORM_FEEDBACK_VARYINGS minus one selects            the last such variable.
        /// The name of the selected varying is returned as a null-terminated string in            name. The actual number of characters written into name,            excluding the null terminator, is returned in length. If length            is NULL, no length is returned. The maximum number of characters that may be written into name,            including the null terminator, is specified by bufSize.
        /// The length of the longest varying name in program is given by GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH,            which can be queried with glGetProgram.
        /// For the selected varying variable, its type is returned into type. The size of            the varying is returned into size. The value in size is            in units of the type returned in type. The type returned can be any of the            scalar, vector, or matrix attribute types returned by glGetActiveAttrib.            If an error occurred, the return parameters length, size,            type and name will be unmodified. This command will return as much            information about the varying variables as possible. If no information is available, length            will be set to zero and name will be an empty string. This situation could            arise if glGetTransformFeedbackVarying is called after a failed link.
        /// </summary>
        /// <param name="program">The name of the target program object.</param>
        /// <param name="index">The index of the varying variable whose information to retrieve.</param>
        /// <param name="bufSize">The maximum number of characters, including the null terminator, that may be written into name.</param>
        /// <param name="length">The address of a variable which will receive the number of characters written into name,                    excluding the null-terminator. If length is NULL no length is returned.</param>
        /// <param name="size">The address of a variable that will receive the size of the varying.</param>
        /// <param name="type">The address of a variable that will receive the type of the varying.</param>
        /// <param name="name">The address of a buffer into which will be written the name of the varying.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbackVarying(uint program, uint index, int bufSize, out int length, out int size, out AttributeType type, IntPtr name) => _GetTransformFeedbackVarying_intptr(program, index, bufSize, out length, out size, out type, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, out int length, out int size, out AttributeType type, string name) => _GetTransformFeedbackVaryingEXT(program, index, bufSize, out length, out size, out type, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, out int length, out int size, out AttributeType type, void* name) => _GetTransformFeedbackVaryingEXT_ptr(program, index, bufSize, out length, out size, out type, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, out int length, out int size, out AttributeType type, IntPtr name) => _GetTransformFeedbackVaryingEXT_intptr(program, index, bufSize, out length, out size, out type, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbackVaryingNV(uint program, uint index, out int location) => _GetTransformFeedbackVaryingNV(program, index, out location);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbacki64_v(uint xfb, TransformFeedbackPName pname, uint index, Int64[] param) => _GetTransformFeedbacki64_v(xfb, pname, index, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbacki64_v(uint xfb, TransformFeedbackPName pname, uint index, void* param) => _GetTransformFeedbacki64_v_ptr(xfb, pname, index, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbacki64_v(uint xfb, TransformFeedbackPName pname, uint index, IntPtr param) => _GetTransformFeedbacki64_v_intptr(xfb, pname, index, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbacki_v(uint xfb, TransformFeedbackPName pname, uint index, int[] param) => _GetTransformFeedbacki_v(xfb, pname, index, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbacki_v(uint xfb, TransformFeedbackPName pname, uint index, void* param) => _GetTransformFeedbacki_v_ptr(xfb, pname, index, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbacki_v(uint xfb, TransformFeedbackPName pname, uint index, IntPtr param) => _GetTransformFeedbacki_v_intptr(xfb, pname, index, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbackiv(uint xfb, TransformFeedbackPName pname, int[] param) => _GetTransformFeedbackiv(xfb, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbackiv(uint xfb, TransformFeedbackPName pname, void* param) => _GetTransformFeedbackiv_ptr(xfb, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTransformFeedbackiv(uint xfb, TransformFeedbackPName pname, IntPtr param) => _GetTransformFeedbackiv_intptr(xfb, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTranslatedShaderSourceANGLE(uint shader, int bufSize, out int length, string source) => _GetTranslatedShaderSourceANGLE(shader, bufSize, out length, source);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTranslatedShaderSourceANGLE(uint shader, int bufSize, out int length, void* source) => _GetTranslatedShaderSourceANGLE_ptr(shader, bufSize, out length, source);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetTranslatedShaderSourceANGLE(uint shader, int bufSize, out int length, IntPtr source) => _GetTranslatedShaderSourceANGLE_intptr(shader, bufSize, out length, source);

        // ---

        /// <summary>
        /// glGetUniformBlockIndex retrieves the index of a uniform block within program.
        /// program must be the name of a program object for which the command            glLinkProgram must have been called in the past, although it is not required that            glLinkProgram must have succeeded. The link could have failed because the number            of active uniforms exceeded the limit.
        /// uniformBlockName must contain a nul-terminated string specifying the name of the uniform block.
        /// glGetUniformBlockIndex returns the uniform block index for the uniform block named uniformBlockName            of program. If uniformBlockName does not identify an active uniform block of program,            glGetUniformBlockIndex returns the special identifier, GL_INVALID_INDEX. Indices of the active uniform            blocks of a program are assigned in consecutive order, beginning with zero.
        /// </summary>
        /// <param name="program">Specifies the name of a program containing the uniform block.</param>
        /// <param name="uniformBlockName">Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetUniformBlockIndex(uint program, string uniformBlockName) => _GetUniformBlockIndex(program, uniformBlockName);

        /// <summary>
        /// glGetUniformBlockIndex retrieves the index of a uniform block within program.
        /// program must be the name of a program object for which the command            glLinkProgram must have been called in the past, although it is not required that            glLinkProgram must have succeeded. The link could have failed because the number            of active uniforms exceeded the limit.
        /// uniformBlockName must contain a nul-terminated string specifying the name of the uniform block.
        /// glGetUniformBlockIndex returns the uniform block index for the uniform block named uniformBlockName            of program. If uniformBlockName does not identify an active uniform block of program,            glGetUniformBlockIndex returns the special identifier, GL_INVALID_INDEX. Indices of the active uniform            blocks of a program are assigned in consecutive order, beginning with zero.
        /// </summary>
        /// <param name="program">Specifies the name of a program containing the uniform block.</param>
        /// <param name="uniformBlockName">Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetUniformBlockIndex(uint program, void* uniformBlockName) => _GetUniformBlockIndex_ptr(program, uniformBlockName);

        /// <summary>
        /// glGetUniformBlockIndex retrieves the index of a uniform block within program.
        /// program must be the name of a program object for which the command            glLinkProgram must have been called in the past, although it is not required that            glLinkProgram must have succeeded. The link could have failed because the number            of active uniforms exceeded the limit.
        /// uniformBlockName must contain a nul-terminated string specifying the name of the uniform block.
        /// glGetUniformBlockIndex returns the uniform block index for the uniform block named uniformBlockName            of program. If uniformBlockName does not identify an active uniform block of program,            glGetUniformBlockIndex returns the special identifier, GL_INVALID_INDEX. Indices of the active uniform            blocks of a program are assigned in consecutive order, beginning with zero.
        /// </summary>
        /// <param name="program">Specifies the name of a program containing the uniform block.</param>
        /// <param name="uniformBlockName">Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint GetUniformBlockIndex(uint program, IntPtr uniformBlockName) => _GetUniformBlockIndex_intptr(program, uniformBlockName);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetUniformBufferSizeEXT(uint program, int location) => _GetUniformBufferSizeEXT(program, location);

        // ---

        /// <summary>
        /// glGetUniformIndices retrieves the indices of a number of uniforms within program.
        /// program must be the name of a program object for which the command            glLinkProgram must have been called in the past, although it is not required that            glLinkProgram must have succeeded. The link could have failed because the number            of active uniforms exceeded the limit.
        /// uniformCount indicates both the number of elements in the array of names uniformNames and the            number of indices that may be written to uniformIndices.
        /// uniformNames contains a list of uniformCount name strings identifying the uniform names to be            queried for indices. For each name string in uniformNames, the index assigned to the active uniform of that name will            be written to the corresponding element of uniformIndices. If a string in uniformNames is not            the name of an active uniform, the special value GL_INVALID_INDEX will be written to the corresponding element of            uniformIndices.
        /// If an error occurs, nothing is written to uniformIndices.
        /// </summary>
        /// <param name="program">Specifies the name of a program containing uniforms whose indices to query.</param>
        /// <param name="uniformCount">Specifies the number of uniforms whose indices to query.</param>
        /// <param name="uniformNames">Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.</param>
        /// <param name="uniformIndices">Specifies the address of an array that will receive the indices of the uniforms.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformIndices(uint program, int uniformCount, string[] uniformNames, uint[] uniformIndices) => _GetUniformIndices(program, uniformCount, uniformNames, uniformIndices);

        /// <summary>
        /// glGetUniformIndices retrieves the indices of a number of uniforms within program.
        /// program must be the name of a program object for which the command            glLinkProgram must have been called in the past, although it is not required that            glLinkProgram must have succeeded. The link could have failed because the number            of active uniforms exceeded the limit.
        /// uniformCount indicates both the number of elements in the array of names uniformNames and the            number of indices that may be written to uniformIndices.
        /// uniformNames contains a list of uniformCount name strings identifying the uniform names to be            queried for indices. For each name string in uniformNames, the index assigned to the active uniform of that name will            be written to the corresponding element of uniformIndices. If a string in uniformNames is not            the name of an active uniform, the special value GL_INVALID_INDEX will be written to the corresponding element of            uniformIndices.
        /// If an error occurs, nothing is written to uniformIndices.
        /// </summary>
        /// <param name="program">Specifies the name of a program containing uniforms whose indices to query.</param>
        /// <param name="uniformCount">Specifies the number of uniforms whose indices to query.</param>
        /// <param name="uniformNames">Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.</param>
        /// <param name="uniformIndices">Specifies the address of an array that will receive the indices of the uniforms.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformIndices(uint program, int uniformCount, void* uniformNames, void* uniformIndices) => _GetUniformIndices_ptr(program, uniformCount, uniformNames, uniformIndices);

        /// <summary>
        /// glGetUniformIndices retrieves the indices of a number of uniforms within program.
        /// program must be the name of a program object for which the command            glLinkProgram must have been called in the past, although it is not required that            glLinkProgram must have succeeded. The link could have failed because the number            of active uniforms exceeded the limit.
        /// uniformCount indicates both the number of elements in the array of names uniformNames and the            number of indices that may be written to uniformIndices.
        /// uniformNames contains a list of uniformCount name strings identifying the uniform names to be            queried for indices. For each name string in uniformNames, the index assigned to the active uniform of that name will            be written to the corresponding element of uniformIndices. If a string in uniformNames is not            the name of an active uniform, the special value GL_INVALID_INDEX will be written to the corresponding element of            uniformIndices.
        /// If an error occurs, nothing is written to uniformIndices.
        /// </summary>
        /// <param name="program">Specifies the name of a program containing uniforms whose indices to query.</param>
        /// <param name="uniformCount">Specifies the number of uniforms whose indices to query.</param>
        /// <param name="uniformNames">Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.</param>
        /// <param name="uniformIndices">Specifies the address of an array that will receive the indices of the uniforms.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformIndices(uint program, int uniformCount, IntPtr uniformNames, IntPtr uniformIndices) => _GetUniformIndices_intptr(program, uniformCount, uniformNames, uniformIndices);

        // ---

        /// <summary>
        /// glGetUniformLocation  returns an    integer that represents the location of a specific uniform    variable within a program object. name    must be a null terminated string that contains no white space.    name must be an active uniform variable    name in program that is not a structure,    an array of structures, or a subcomponent of a vector or a    matrix. This function returns -1 if name    does not correspond to an active uniform variable in    program, if name    starts with the reserved prefix "gl_", or if    name is associated with an atomic counter or    a named uniform block.
        /// Uniform variables that are structures or arrays of    structures may be queried by calling    glGetUniformLocation for each field within    the structure. The array element operator "[]" and the    structure field operator "." may be used in    name in order to select elements within    an array or fields within a structure. The result of using these    operators is not allowed to be another structure, an array of    structures, or a subcomponent of a vector or a matrix. Except if    the last part of name indicates a uniform    variable array, the location of the first element of an array    can be retrieved by using the name of the array, or by using the    name appended by "[0]".
        /// The actual locations assigned to uniform variables are not    known until the program object is linked successfully. After    linking has occurred, the command    glGetUniformLocation can be used to obtain    the location of a uniform variable. This location value can then    be passed to    glUniform    to set the value of the uniform variable or to    glGetUniform    in order to query the current value of the uniform variable.    After a program object has been linked successfully, the index    values for uniform variables remain fixed until the next link    command occurs. Uniform variable locations and values can only    be queried after a link if the link was successful.
        /// </summary>
        /// <param name="program">Specifies the program object to be            queried.</param>
        /// <param name="name">Points to a null terminated string containing            the name of the uniform variable whose location is            to be queried.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetUniformLocation(uint program, string name) => _GetUniformLocation(program, name);

        /// <summary>
        /// glGetUniformLocation  returns an    integer that represents the location of a specific uniform    variable within a program object. name    must be a null terminated string that contains no white space.    name must be an active uniform variable    name in program that is not a structure,    an array of structures, or a subcomponent of a vector or a    matrix. This function returns -1 if name    does not correspond to an active uniform variable in    program, if name    starts with the reserved prefix "gl_", or if    name is associated with an atomic counter or    a named uniform block.
        /// Uniform variables that are structures or arrays of    structures may be queried by calling    glGetUniformLocation for each field within    the structure. The array element operator "[]" and the    structure field operator "." may be used in    name in order to select elements within    an array or fields within a structure. The result of using these    operators is not allowed to be another structure, an array of    structures, or a subcomponent of a vector or a matrix. Except if    the last part of name indicates a uniform    variable array, the location of the first element of an array    can be retrieved by using the name of the array, or by using the    name appended by "[0]".
        /// The actual locations assigned to uniform variables are not    known until the program object is linked successfully. After    linking has occurred, the command    glGetUniformLocation can be used to obtain    the location of a uniform variable. This location value can then    be passed to    glUniform    to set the value of the uniform variable or to    glGetUniform    in order to query the current value of the uniform variable.    After a program object has been linked successfully, the index    values for uniform variables remain fixed until the next link    command occurs. Uniform variable locations and values can only    be queried after a link if the link was successful.
        /// </summary>
        /// <param name="program">Specifies the program object to be            queried.</param>
        /// <param name="name">Points to a null terminated string containing            the name of the uniform variable whose location is            to be queried.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetUniformLocation(uint program, void* name) => _GetUniformLocation_ptr(program, name);

        /// <summary>
        /// glGetUniformLocation  returns an    integer that represents the location of a specific uniform    variable within a program object. name    must be a null terminated string that contains no white space.    name must be an active uniform variable    name in program that is not a structure,    an array of structures, or a subcomponent of a vector or a    matrix. This function returns -1 if name    does not correspond to an active uniform variable in    program, if name    starts with the reserved prefix "gl_", or if    name is associated with an atomic counter or    a named uniform block.
        /// Uniform variables that are structures or arrays of    structures may be queried by calling    glGetUniformLocation for each field within    the structure. The array element operator "[]" and the    structure field operator "." may be used in    name in order to select elements within    an array or fields within a structure. The result of using these    operators is not allowed to be another structure, an array of    structures, or a subcomponent of a vector or a matrix. Except if    the last part of name indicates a uniform    variable array, the location of the first element of an array    can be retrieved by using the name of the array, or by using the    name appended by "[0]".
        /// The actual locations assigned to uniform variables are not    known until the program object is linked successfully. After    linking has occurred, the command    glGetUniformLocation can be used to obtain    the location of a uniform variable. This location value can then    be passed to    glUniform    to set the value of the uniform variable or to    glGetUniform    in order to query the current value of the uniform variable.    After a program object has been linked successfully, the index    values for uniform variables remain fixed until the next link    command occurs. Uniform variable locations and values can only    be queried after a link if the link was successful.
        /// </summary>
        /// <param name="program">Specifies the program object to be            queried.</param>
        /// <param name="name">Points to a null terminated string containing            the name of the uniform variable whose location is            to be queried.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetUniformLocation(uint program, IntPtr name) => _GetUniformLocation_intptr(program, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetUniformLocationARB(int programObj, string name) => _GetUniformLocationARB(programObj, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetUniformLocationARB(int programObj, void* name) => _GetUniformLocationARB_ptr(programObj, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetUniformLocationARB(int programObj, IntPtr name) => _GetUniformLocationARB_intptr(programObj, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IntPtr GetUniformOffsetEXT(uint program, int location) => _GetUniformOffsetEXT(program, location);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformSubroutineuiv(ShaderType shadertype, int location, out uint @params) => _GetUniformSubroutineuiv(shadertype, location, out @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformdv(uint program, int location, double[] @params) => _GetUniformdv(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformdv(uint program, int location, void* @params) => _GetUniformdv_ptr(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformdv(uint program, int location, IntPtr @params) => _GetUniformdv_intptr(program, location, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformfv(uint program, int location, float[] @params) => _GetUniformfv(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformfv(uint program, int location, void* @params) => _GetUniformfv_ptr(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformfv(uint program, int location, IntPtr @params) => _GetUniformfv_intptr(program, location, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformfvARB(int programObj, int location, float[] @params) => _GetUniformfvARB(programObj, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformfvARB(int programObj, int location, void* @params) => _GetUniformfvARB_ptr(programObj, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformfvARB(int programObj, int location, IntPtr @params) => _GetUniformfvARB_intptr(programObj, location, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformi64vARB(uint program, int location, Int64[] @params) => _GetUniformi64vARB(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformi64vARB(uint program, int location, void* @params) => _GetUniformi64vARB_ptr(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformi64vARB(uint program, int location, IntPtr @params) => _GetUniformi64vARB_intptr(program, location, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformi64vNV(uint program, int location, Int64[] @params) => _GetUniformi64vNV(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformi64vNV(uint program, int location, void* @params) => _GetUniformi64vNV_ptr(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformi64vNV(uint program, int location, IntPtr @params) => _GetUniformi64vNV_intptr(program, location, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformiv(uint program, int location, int[] @params) => _GetUniformiv(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformiv(uint program, int location, void* @params) => _GetUniformiv_ptr(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformiv(uint program, int location, IntPtr @params) => _GetUniformiv_intptr(program, location, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformivARB(int programObj, int location, int[] @params) => _GetUniformivARB(programObj, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformivARB(int programObj, int location, void* @params) => _GetUniformivARB_ptr(programObj, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformivARB(int programObj, int location, IntPtr @params) => _GetUniformivARB_intptr(programObj, location, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformui64vARB(uint program, int location, UInt64[] @params) => _GetUniformui64vARB(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformui64vARB(uint program, int location, void* @params) => _GetUniformui64vARB_ptr(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformui64vARB(uint program, int location, IntPtr @params) => _GetUniformui64vARB_intptr(program, location, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformui64vNV(uint program, int location, UInt64[] @params) => _GetUniformui64vNV(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformui64vNV(uint program, int location, void* @params) => _GetUniformui64vNV_ptr(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformui64vNV(uint program, int location, IntPtr @params) => _GetUniformui64vNV_intptr(program, location, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformuiv(uint program, int location, uint[] @params) => _GetUniformuiv(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformuiv(uint program, int location, void* @params) => _GetUniformuiv_ptr(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformuiv(uint program, int location, IntPtr @params) => _GetUniformuiv_intptr(program, location, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformuivEXT(uint program, int location, uint[] @params) => _GetUniformuivEXT(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformuivEXT(uint program, int location, void* @params) => _GetUniformuivEXT_ptr(program, location, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUniformuivEXT(uint program, int location, IntPtr @params) => _GetUniformuivEXT_intptr(program, location, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUnsignedBytevEXT(GetPName pname, byte[] data) => _GetUnsignedBytevEXT(pname, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUnsignedBytevEXT(GetPName pname, void* data) => _GetUnsignedBytevEXT_ptr(pname, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUnsignedBytevEXT(GetPName pname, IntPtr data) => _GetUnsignedBytevEXT_intptr(pname, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUnsignedBytei_vEXT(int target, uint index, byte[] data) => _GetUnsignedBytei_vEXT(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUnsignedBytei_vEXT(int target, uint index, void* data) => _GetUnsignedBytei_vEXT_ptr(target, index, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetUnsignedBytei_vEXT(int target, uint index, IntPtr data) => _GetUnsignedBytei_vEXT_intptr(target, index, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVariantArrayObjectfvATI(uint id, ArrayObjectPNameATI pname, out float @params) => _GetVariantArrayObjectfvATI(id, pname, out @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVariantArrayObjectivATI(uint id, ArrayObjectPNameATI pname, out int @params) => _GetVariantArrayObjectivATI(id, pname, out @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVariantBooleanvEXT(uint id, GetVariantValueEXT value, bool[] data) => _GetVariantBooleanvEXT(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVariantBooleanvEXT(uint id, GetVariantValueEXT value, void* data) => _GetVariantBooleanvEXT_ptr(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVariantBooleanvEXT(uint id, GetVariantValueEXT value, IntPtr data) => _GetVariantBooleanvEXT_intptr(id, value, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVariantFloatvEXT(uint id, GetVariantValueEXT value, float[] data) => _GetVariantFloatvEXT(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVariantFloatvEXT(uint id, GetVariantValueEXT value, void* data) => _GetVariantFloatvEXT_ptr(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVariantFloatvEXT(uint id, GetVariantValueEXT value, IntPtr data) => _GetVariantFloatvEXT_intptr(id, value, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVariantIntegervEXT(uint id, GetVariantValueEXT value, int[] data) => _GetVariantIntegervEXT(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVariantIntegervEXT(uint id, GetVariantValueEXT value, void* data) => _GetVariantIntegervEXT_ptr(id, value, data);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVariantIntegervEXT(uint id, GetVariantValueEXT value, IntPtr data) => _GetVariantIntegervEXT_intptr(id, value, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVariantPointervEXT(uint id, GetVariantValueEXT value, IntPtr* data) => _GetVariantPointervEXT(id, value, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetVaryingLocationNV(uint program, string name) => _GetVaryingLocationNV(program, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetVaryingLocationNV(uint program, void* name) => _GetVaryingLocationNV_ptr(program, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetVaryingLocationNV(uint program, IntPtr name) => _GetVaryingLocationNV_intptr(program, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayIndexed64iv(uint vaobj, uint index, VertexArrayPName pname, Int64[] param) => _GetVertexArrayIndexed64iv(vaobj, index, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayIndexed64iv(uint vaobj, uint index, VertexArrayPName pname, void* param) => _GetVertexArrayIndexed64iv_ptr(vaobj, index, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayIndexed64iv(uint vaobj, uint index, VertexArrayPName pname, IntPtr param) => _GetVertexArrayIndexed64iv_intptr(vaobj, index, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayIndexediv(uint vaobj, uint index, VertexArrayPName pname, int[] param) => _GetVertexArrayIndexediv(vaobj, index, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayIndexediv(uint vaobj, uint index, VertexArrayPName pname, void* param) => _GetVertexArrayIndexediv_ptr(vaobj, index, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayIndexediv(uint vaobj, uint index, VertexArrayPName pname, IntPtr param) => _GetVertexArrayIndexediv_intptr(vaobj, index, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayIntegeri_vEXT(uint vaobj, uint index, VertexArrayPName pname, int[] param) => _GetVertexArrayIntegeri_vEXT(vaobj, index, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayIntegeri_vEXT(uint vaobj, uint index, VertexArrayPName pname, void* param) => _GetVertexArrayIntegeri_vEXT_ptr(vaobj, index, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayIntegeri_vEXT(uint vaobj, uint index, VertexArrayPName pname, IntPtr param) => _GetVertexArrayIntegeri_vEXT_intptr(vaobj, index, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayIntegervEXT(uint vaobj, VertexArrayPName pname, int[] param) => _GetVertexArrayIntegervEXT(vaobj, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayIntegervEXT(uint vaobj, VertexArrayPName pname, void* param) => _GetVertexArrayIntegervEXT_ptr(vaobj, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayIntegervEXT(uint vaobj, VertexArrayPName pname, IntPtr param) => _GetVertexArrayIntegervEXT_intptr(vaobj, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayPointeri_vEXT(uint vaobj, uint index, VertexArrayPName pname, IntPtr* param) => _GetVertexArrayPointeri_vEXT(vaobj, index, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayPointervEXT(uint vaobj, VertexArrayPName pname, IntPtr* param) => _GetVertexArrayPointervEXT(vaobj, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayiv(uint vaobj, VertexArrayPName pname, int[] param) => _GetVertexArrayiv(vaobj, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayiv(uint vaobj, VertexArrayPName pname, void* param) => _GetVertexArrayiv_ptr(vaobj, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexArrayiv(uint vaobj, VertexArrayPName pname, IntPtr param) => _GetVertexArrayiv_intptr(vaobj, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribArrayObjectfvATI(uint index, ArrayObjectPNameATI pname, float[] @params) => _GetVertexAttribArrayObjectfvATI(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribArrayObjectfvATI(uint index, ArrayObjectPNameATI pname, void* @params) => _GetVertexAttribArrayObjectfvATI_ptr(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribArrayObjectfvATI(uint index, ArrayObjectPNameATI pname, IntPtr @params) => _GetVertexAttribArrayObjectfvATI_intptr(index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribArrayObjectivATI(uint index, ArrayObjectPNameATI pname, int[] @params) => _GetVertexAttribArrayObjectivATI(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribArrayObjectivATI(uint index, ArrayObjectPNameATI pname, void* @params) => _GetVertexAttribArrayObjectivATI_ptr(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribArrayObjectivATI(uint index, ArrayObjectPNameATI pname, IntPtr @params) => _GetVertexAttribArrayObjectivATI_intptr(index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribIiv(uint index, VertexAttribEnum pname, out int @params) => _GetVertexAttribIiv(index, pname, out @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribIivEXT(uint index, VertexAttribEnum pname, out int @params) => _GetVertexAttribIivEXT(index, pname, out @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribIuiv(uint index, VertexAttribEnum pname, out uint @params) => _GetVertexAttribIuiv(index, pname, out @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribIuivEXT(uint index, VertexAttribEnum pname, out uint @params) => _GetVertexAttribIuivEXT(index, pname, out @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribLdv(uint index, VertexAttribEnum pname, double[] @params) => _GetVertexAttribLdv(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribLdv(uint index, VertexAttribEnum pname, void* @params) => _GetVertexAttribLdv_ptr(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribLdv(uint index, VertexAttribEnum pname, IntPtr @params) => _GetVertexAttribLdv_intptr(index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribLdvEXT(uint index, VertexAttribEnum pname, double[] @params) => _GetVertexAttribLdvEXT(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribLdvEXT(uint index, VertexAttribEnum pname, void* @params) => _GetVertexAttribLdvEXT_ptr(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribLdvEXT(uint index, VertexAttribEnum pname, IntPtr @params) => _GetVertexAttribLdvEXT_intptr(index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribLi64vNV(uint index, VertexAttribEnum pname, Int64[] @params) => _GetVertexAttribLi64vNV(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribLi64vNV(uint index, VertexAttribEnum pname, void* @params) => _GetVertexAttribLi64vNV_ptr(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribLi64vNV(uint index, VertexAttribEnum pname, IntPtr @params) => _GetVertexAttribLi64vNV_intptr(index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribLui64vARB(uint index, VertexAttribEnum pname, UInt64[] @params) => _GetVertexAttribLui64vARB(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribLui64vARB(uint index, VertexAttribEnum pname, void* @params) => _GetVertexAttribLui64vARB_ptr(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribLui64vARB(uint index, VertexAttribEnum pname, IntPtr @params) => _GetVertexAttribLui64vARB_intptr(index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribLui64vNV(uint index, VertexAttribEnum pname, UInt64[] @params) => _GetVertexAttribLui64vNV(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribLui64vNV(uint index, VertexAttribEnum pname, void* @params) => _GetVertexAttribLui64vNV_ptr(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribLui64vNV(uint index, VertexAttribEnum pname, IntPtr @params) => _GetVertexAttribLui64vNV_intptr(index, pname, @params);

        // ---

        /// <summary>
        /// glGetVertexAttribPointerv returns    pointer information. index is the generic    vertex attribute to be queried, pname is    a symbolic constant indicating the pointer to be returned, and    params is a pointer to a location in    which to place the returned data.
        /// The pointer returned is a byte offset into the data store of the buffer object    that was bound to the GL_ARRAY_BUFFER target    (see glBindBuffer) when the desired pointer was previously specified.
        /// </summary>
        /// <param name="index">Specifies the generic vertex attribute            parameter to be returned.</param>
        /// <param name="pname">Specifies the symbolic name of the generic            vertex attribute parameter to be returned. Must be            GL_VERTEX_ATTRIB_ARRAY_POINTER.</param>
        /// <param name="pointer">Returns the pointer value.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribPointerv(uint index, VertexAttribPointerPropertyARB pname, IntPtr* pointer) => _GetVertexAttribPointerv(index, pname, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribPointervARB(uint index, VertexAttribPointerPropertyARB pname, IntPtr* pointer) => _GetVertexAttribPointervARB(index, pname, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribPointervNV(uint index, VertexAttribEnumNV pname, IntPtr* pointer) => _GetVertexAttribPointervNV(index, pname, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribdv(uint index, VertexAttribPropertyARB pname, double[] @params) => _GetVertexAttribdv(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribdv(uint index, VertexAttribPropertyARB pname, void* @params) => _GetVertexAttribdv_ptr(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribdv(uint index, VertexAttribPropertyARB pname, IntPtr @params) => _GetVertexAttribdv_intptr(index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribdvARB(uint index, VertexAttribPropertyARB pname, double[] @params) => _GetVertexAttribdvARB(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribdvARB(uint index, VertexAttribPropertyARB pname, void* @params) => _GetVertexAttribdvARB_ptr(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribdvARB(uint index, VertexAttribPropertyARB pname, IntPtr @params) => _GetVertexAttribdvARB_intptr(index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribdvNV(uint index, VertexAttribEnumNV pname, out double @params) => _GetVertexAttribdvNV(index, pname, out @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribfv(uint index, VertexAttribPropertyARB pname, float[] @params) => _GetVertexAttribfv(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribfv(uint index, VertexAttribPropertyARB pname, void* @params) => _GetVertexAttribfv_ptr(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribfv(uint index, VertexAttribPropertyARB pname, IntPtr @params) => _GetVertexAttribfv_intptr(index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribfvARB(uint index, VertexAttribPropertyARB pname, float[] @params) => _GetVertexAttribfvARB(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribfvARB(uint index, VertexAttribPropertyARB pname, void* @params) => _GetVertexAttribfvARB_ptr(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribfvARB(uint index, VertexAttribPropertyARB pname, IntPtr @params) => _GetVertexAttribfvARB_intptr(index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribfvNV(uint index, VertexAttribEnumNV pname, out float @params) => _GetVertexAttribfvNV(index, pname, out @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribiv(uint index, VertexAttribPropertyARB pname, int[] @params) => _GetVertexAttribiv(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribiv(uint index, VertexAttribPropertyARB pname, void* @params) => _GetVertexAttribiv_ptr(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribiv(uint index, VertexAttribPropertyARB pname, IntPtr @params) => _GetVertexAttribiv_intptr(index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribivARB(uint index, VertexAttribPropertyARB pname, int[] @params) => _GetVertexAttribivARB(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribivARB(uint index, VertexAttribPropertyARB pname, void* @params) => _GetVertexAttribivARB_ptr(index, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribivARB(uint index, VertexAttribPropertyARB pname, IntPtr @params) => _GetVertexAttribivARB_intptr(index, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVertexAttribivNV(uint index, VertexAttribEnumNV pname, out int @params) => _GetVertexAttribivNV(index, pname, out @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoCaptureStreamdvNV(uint video_capture_slot, uint stream, int pname, double[] @params) => _GetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoCaptureStreamdvNV(uint video_capture_slot, uint stream, int pname, void* @params) => _GetVideoCaptureStreamdvNV_ptr(video_capture_slot, stream, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoCaptureStreamdvNV(uint video_capture_slot, uint stream, int pname, IntPtr @params) => _GetVideoCaptureStreamdvNV_intptr(video_capture_slot, stream, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoCaptureStreamfvNV(uint video_capture_slot, uint stream, int pname, float[] @params) => _GetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoCaptureStreamfvNV(uint video_capture_slot, uint stream, int pname, void* @params) => _GetVideoCaptureStreamfvNV_ptr(video_capture_slot, stream, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoCaptureStreamfvNV(uint video_capture_slot, uint stream, int pname, IntPtr @params) => _GetVideoCaptureStreamfvNV_intptr(video_capture_slot, stream, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoCaptureStreamivNV(uint video_capture_slot, uint stream, int pname, int[] @params) => _GetVideoCaptureStreamivNV(video_capture_slot, stream, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoCaptureStreamivNV(uint video_capture_slot, uint stream, int pname, void* @params) => _GetVideoCaptureStreamivNV_ptr(video_capture_slot, stream, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoCaptureStreamivNV(uint video_capture_slot, uint stream, int pname, IntPtr @params) => _GetVideoCaptureStreamivNV_intptr(video_capture_slot, stream, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoCaptureivNV(uint video_capture_slot, int pname, int[] @params) => _GetVideoCaptureivNV(video_capture_slot, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoCaptureivNV(uint video_capture_slot, int pname, void* @params) => _GetVideoCaptureivNV_ptr(video_capture_slot, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoCaptureivNV(uint video_capture_slot, int pname, IntPtr @params) => _GetVideoCaptureivNV_intptr(video_capture_slot, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoi64vNV(uint video_slot, int pname, Int64[] @params) => _GetVideoi64vNV(video_slot, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoi64vNV(uint video_slot, int pname, void* @params) => _GetVideoi64vNV_ptr(video_slot, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoi64vNV(uint video_slot, int pname, IntPtr @params) => _GetVideoi64vNV_intptr(video_slot, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoivNV(uint video_slot, int pname, int[] @params) => _GetVideoivNV(video_slot, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoivNV(uint video_slot, int pname, void* @params) => _GetVideoivNV_ptr(video_slot, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoivNV(uint video_slot, int pname, IntPtr @params) => _GetVideoivNV_intptr(video_slot, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoui64vNV(uint video_slot, int pname, UInt64[] @params) => _GetVideoui64vNV(video_slot, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoui64vNV(uint video_slot, int pname, void* @params) => _GetVideoui64vNV_ptr(video_slot, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideoui64vNV(uint video_slot, int pname, IntPtr @params) => _GetVideoui64vNV_intptr(video_slot, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideouivNV(uint video_slot, int pname, uint[] @params) => _GetVideouivNV(video_slot, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideouivNV(uint video_slot, int pname, void* @params) => _GetVideouivNV_ptr(video_slot, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetVideouivNV(uint video_slot, int pname, IntPtr @params) => _GetVideouivNV_intptr(video_slot, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnColorTable(ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, IntPtr table) => _GetnColorTable(target, format, type, bufSize, table);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnColorTableARB(ColorTableTarget target, PixelFormat format, PixelType type, int bufSize, IntPtr table) => _GetnColorTableARB(target, format, type, bufSize, table);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnCompressedTexImage(TextureTarget target, int lod, int bufSize, IntPtr pixels) => _GetnCompressedTexImage(target, lod, bufSize, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnCompressedTexImageARB(TextureTarget target, int lod, int bufSize, IntPtr img) => _GetnCompressedTexImageARB(target, lod, bufSize, img);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnConvolutionFilter(ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, IntPtr image) => _GetnConvolutionFilter(target, format, type, bufSize, image);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnConvolutionFilterARB(ConvolutionTarget target, PixelFormat format, PixelType type, int bufSize, IntPtr image) => _GetnConvolutionFilterARB(target, format, type, bufSize, image);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnHistogram(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, int bufSize, IntPtr values) => _GetnHistogram(target, reset, format, type, bufSize, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnHistogramARB(HistogramTargetEXT target, bool reset, PixelFormat format, PixelType type, int bufSize, IntPtr values) => _GetnHistogramARB(target, reset, format, type, bufSize, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapdv(MapTarget target, MapQuery query, int bufSize, double[] v) => _GetnMapdv(target, query, bufSize, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapdv(MapTarget target, MapQuery query, int bufSize, void* v) => _GetnMapdv_ptr(target, query, bufSize, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapdv(MapTarget target, MapQuery query, int bufSize, IntPtr v) => _GetnMapdv_intptr(target, query, bufSize, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapdvARB(MapTarget target, MapQuery query, int bufSize, double[] v) => _GetnMapdvARB(target, query, bufSize, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapdvARB(MapTarget target, MapQuery query, int bufSize, void* v) => _GetnMapdvARB_ptr(target, query, bufSize, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapdvARB(MapTarget target, MapQuery query, int bufSize, IntPtr v) => _GetnMapdvARB_intptr(target, query, bufSize, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapfv(MapTarget target, MapQuery query, int bufSize, float[] v) => _GetnMapfv(target, query, bufSize, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapfv(MapTarget target, MapQuery query, int bufSize, void* v) => _GetnMapfv_ptr(target, query, bufSize, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapfv(MapTarget target, MapQuery query, int bufSize, IntPtr v) => _GetnMapfv_intptr(target, query, bufSize, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapfvARB(MapTarget target, MapQuery query, int bufSize, float[] v) => _GetnMapfvARB(target, query, bufSize, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapfvARB(MapTarget target, MapQuery query, int bufSize, void* v) => _GetnMapfvARB_ptr(target, query, bufSize, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapfvARB(MapTarget target, MapQuery query, int bufSize, IntPtr v) => _GetnMapfvARB_intptr(target, query, bufSize, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapiv(MapTarget target, MapQuery query, int bufSize, int[] v) => _GetnMapiv(target, query, bufSize, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapiv(MapTarget target, MapQuery query, int bufSize, void* v) => _GetnMapiv_ptr(target, query, bufSize, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapiv(MapTarget target, MapQuery query, int bufSize, IntPtr v) => _GetnMapiv_intptr(target, query, bufSize, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapivARB(MapTarget target, MapQuery query, int bufSize, int[] v) => _GetnMapivARB(target, query, bufSize, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapivARB(MapTarget target, MapQuery query, int bufSize, void* v) => _GetnMapivARB_ptr(target, query, bufSize, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMapivARB(MapTarget target, MapQuery query, int bufSize, IntPtr v) => _GetnMapivARB_intptr(target, query, bufSize, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMinmax(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, int bufSize, IntPtr values) => _GetnMinmax(target, reset, format, type, bufSize, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnMinmaxARB(MinmaxTargetEXT target, bool reset, PixelFormat format, PixelType type, int bufSize, IntPtr values) => _GetnMinmaxARB(target, reset, format, type, bufSize, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapfv(PixelMap map, int bufSize, float[] values) => _GetnPixelMapfv(map, bufSize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapfv(PixelMap map, int bufSize, void* values) => _GetnPixelMapfv_ptr(map, bufSize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapfv(PixelMap map, int bufSize, IntPtr values) => _GetnPixelMapfv_intptr(map, bufSize, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapfvARB(PixelMap map, int bufSize, float[] values) => _GetnPixelMapfvARB(map, bufSize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapfvARB(PixelMap map, int bufSize, void* values) => _GetnPixelMapfvARB_ptr(map, bufSize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapfvARB(PixelMap map, int bufSize, IntPtr values) => _GetnPixelMapfvARB_intptr(map, bufSize, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapuiv(PixelMap map, int bufSize, uint[] values) => _GetnPixelMapuiv(map, bufSize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapuiv(PixelMap map, int bufSize, void* values) => _GetnPixelMapuiv_ptr(map, bufSize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapuiv(PixelMap map, int bufSize, IntPtr values) => _GetnPixelMapuiv_intptr(map, bufSize, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapuivARB(PixelMap map, int bufSize, uint[] values) => _GetnPixelMapuivARB(map, bufSize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapuivARB(PixelMap map, int bufSize, void* values) => _GetnPixelMapuivARB_ptr(map, bufSize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapuivARB(PixelMap map, int bufSize, IntPtr values) => _GetnPixelMapuivARB_intptr(map, bufSize, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapusv(PixelMap map, int bufSize, ushort[] values) => _GetnPixelMapusv(map, bufSize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapusv(PixelMap map, int bufSize, void* values) => _GetnPixelMapusv_ptr(map, bufSize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapusv(PixelMap map, int bufSize, IntPtr values) => _GetnPixelMapusv_intptr(map, bufSize, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapusvARB(PixelMap map, int bufSize, ushort[] values) => _GetnPixelMapusvARB(map, bufSize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapusvARB(PixelMap map, int bufSize, void* values) => _GetnPixelMapusvARB_ptr(map, bufSize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPixelMapusvARB(PixelMap map, int bufSize, IntPtr values) => _GetnPixelMapusvARB_intptr(map, bufSize, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPolygonStipple(int bufSize, byte[] pattern) => _GetnPolygonStipple(bufSize, pattern);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPolygonStipple(int bufSize, void* pattern) => _GetnPolygonStipple_ptr(bufSize, pattern);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPolygonStipple(int bufSize, IntPtr pattern) => _GetnPolygonStipple_intptr(bufSize, pattern);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPolygonStippleARB(int bufSize, byte[] pattern) => _GetnPolygonStippleARB(bufSize, pattern);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPolygonStippleARB(int bufSize, void* pattern) => _GetnPolygonStippleARB_ptr(bufSize, pattern);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnPolygonStippleARB(int bufSize, IntPtr pattern) => _GetnPolygonStippleARB_intptr(bufSize, pattern);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnSeparableFilter(SeparableTargetEXT target, PixelFormat format, PixelType type, int rowBufSize, IntPtr row, int columnBufSize, IntPtr column, IntPtr span) => _GetnSeparableFilter(target, format, type, rowBufSize, row, columnBufSize, column, span);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnSeparableFilterARB(SeparableTargetEXT target, PixelFormat format, PixelType type, int rowBufSize, IntPtr row, int columnBufSize, IntPtr column, IntPtr span) => _GetnSeparableFilterARB(target, format, type, rowBufSize, row, columnBufSize, column, span);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnTexImage(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, IntPtr pixels) => _GetnTexImage(target, level, format, type, bufSize, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnTexImageARB(TextureTarget target, int level, PixelFormat format, PixelType type, int bufSize, IntPtr img) => _GetnTexImageARB(target, level, format, type, bufSize, img);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformdv(uint program, int location, int bufSize, double[] @params) => _GetnUniformdv(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformdv(uint program, int location, int bufSize, void* @params) => _GetnUniformdv_ptr(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformdv(uint program, int location, int bufSize, IntPtr @params) => _GetnUniformdv_intptr(program, location, bufSize, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformdvARB(uint program, int location, int bufSize, double[] @params) => _GetnUniformdvARB(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformdvARB(uint program, int location, int bufSize, void* @params) => _GetnUniformdvARB_ptr(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformdvARB(uint program, int location, int bufSize, IntPtr @params) => _GetnUniformdvARB_intptr(program, location, bufSize, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformfv(uint program, int location, int bufSize, float[] @params) => _GetnUniformfv(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformfv(uint program, int location, int bufSize, void* @params) => _GetnUniformfv_ptr(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformfv(uint program, int location, int bufSize, IntPtr @params) => _GetnUniformfv_intptr(program, location, bufSize, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformfvARB(uint program, int location, int bufSize, float[] @params) => _GetnUniformfvARB(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformfvARB(uint program, int location, int bufSize, void* @params) => _GetnUniformfvARB_ptr(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformfvARB(uint program, int location, int bufSize, IntPtr @params) => _GetnUniformfvARB_intptr(program, location, bufSize, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformfvEXT(uint program, int location, int bufSize, float[] @params) => _GetnUniformfvEXT(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformfvEXT(uint program, int location, int bufSize, void* @params) => _GetnUniformfvEXT_ptr(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformfvEXT(uint program, int location, int bufSize, IntPtr @params) => _GetnUniformfvEXT_intptr(program, location, bufSize, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformfvKHR(uint program, int location, int bufSize, float[] @params) => _GetnUniformfvKHR(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformfvKHR(uint program, int location, int bufSize, void* @params) => _GetnUniformfvKHR_ptr(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformfvKHR(uint program, int location, int bufSize, IntPtr @params) => _GetnUniformfvKHR_intptr(program, location, bufSize, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformi64vARB(uint program, int location, int bufSize, Int64[] @params) => _GetnUniformi64vARB(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformi64vARB(uint program, int location, int bufSize, void* @params) => _GetnUniformi64vARB_ptr(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformi64vARB(uint program, int location, int bufSize, IntPtr @params) => _GetnUniformi64vARB_intptr(program, location, bufSize, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformiv(uint program, int location, int bufSize, int[] @params) => _GetnUniformiv(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformiv(uint program, int location, int bufSize, void* @params) => _GetnUniformiv_ptr(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformiv(uint program, int location, int bufSize, IntPtr @params) => _GetnUniformiv_intptr(program, location, bufSize, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformivARB(uint program, int location, int bufSize, int[] @params) => _GetnUniformivARB(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformivARB(uint program, int location, int bufSize, void* @params) => _GetnUniformivARB_ptr(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformivARB(uint program, int location, int bufSize, IntPtr @params) => _GetnUniformivARB_intptr(program, location, bufSize, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformivEXT(uint program, int location, int bufSize, int[] @params) => _GetnUniformivEXT(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformivEXT(uint program, int location, int bufSize, void* @params) => _GetnUniformivEXT_ptr(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformivEXT(uint program, int location, int bufSize, IntPtr @params) => _GetnUniformivEXT_intptr(program, location, bufSize, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformivKHR(uint program, int location, int bufSize, int[] @params) => _GetnUniformivKHR(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformivKHR(uint program, int location, int bufSize, void* @params) => _GetnUniformivKHR_ptr(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformivKHR(uint program, int location, int bufSize, IntPtr @params) => _GetnUniformivKHR_intptr(program, location, bufSize, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformui64vARB(uint program, int location, int bufSize, UInt64[] @params) => _GetnUniformui64vARB(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformui64vARB(uint program, int location, int bufSize, void* @params) => _GetnUniformui64vARB_ptr(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformui64vARB(uint program, int location, int bufSize, IntPtr @params) => _GetnUniformui64vARB_intptr(program, location, bufSize, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformuiv(uint program, int location, int bufSize, uint[] @params) => _GetnUniformuiv(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformuiv(uint program, int location, int bufSize, void* @params) => _GetnUniformuiv_ptr(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformuiv(uint program, int location, int bufSize, IntPtr @params) => _GetnUniformuiv_intptr(program, location, bufSize, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformuivARB(uint program, int location, int bufSize, uint[] @params) => _GetnUniformuivARB(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformuivARB(uint program, int location, int bufSize, void* @params) => _GetnUniformuivARB_ptr(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformuivARB(uint program, int location, int bufSize, IntPtr @params) => _GetnUniformuivARB_intptr(program, location, bufSize, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformuivKHR(uint program, int location, int bufSize, uint[] @params) => _GetnUniformuivKHR(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformuivKHR(uint program, int location, int bufSize, void* @params) => _GetnUniformuivKHR_ptr(program, location, bufSize, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetnUniformuivKHR(uint program, int location, int bufSize, IntPtr @params) => _GetnUniformuivKHR_intptr(program, location, bufSize, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GlobalAlphaFactorbSUN(sbyte factor) => _GlobalAlphaFactorbSUN(factor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GlobalAlphaFactordSUN(double factor) => _GlobalAlphaFactordSUN(factor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GlobalAlphaFactorfSUN(float factor) => _GlobalAlphaFactorfSUN(factor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GlobalAlphaFactoriSUN(int factor) => _GlobalAlphaFactoriSUN(factor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GlobalAlphaFactorsSUN(short factor) => _GlobalAlphaFactorsSUN(factor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GlobalAlphaFactorubSUN(byte factor) => _GlobalAlphaFactorubSUN(factor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GlobalAlphaFactoruiSUN(uint factor) => _GlobalAlphaFactoruiSUN(factor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GlobalAlphaFactorusSUN(ushort factor) => _GlobalAlphaFactorusSUN(factor);

        // ---

        /// <summary>
        /// Certain aspects of GL behavior,            when there is room for interpretation,            can be controlled with hints.            A hint is specified with two arguments.            target is a symbolic            constant indicating the behavior to be controlled,            and mode is another symbolic constant indicating the desired            behavior. The initial value for each target is GL_DONT_CARE.            mode can be one of the following:
        /// GL_FASTEST                        The most efficient option should be chosen.                    GL_NICEST                        The most correct,                        or highest quality,                        option should be chosen.                    GL_DONT_CARE                        No preference.
        /// Though the implementation aspects that can be hinted are well defined,            the interpretation of the hints depends on the implementation.            The hint aspects that can be specified with target,            along with suggested semantics,            are as follows:
        /// GL_FRAGMENT_SHADER_DERIVATIVE_HINT                        Indicates the accuracy of the derivative calculation for the GL shading language fragment processing built-in functions:                        dFdx, dFdy, and fwidth.                    GL_LINE_SMOOTH_HINT                        Indicates the sampling quality of antialiased lines.                        If a larger filter function is applied, hinting GL_NICEST can                        result in more pixel fragments being generated during rasterization.                    GL_POLYGON_SMOOTH_HINT                        Indicates the sampling quality of antialiased polygons.                        Hinting GL_NICEST can result in more pixel fragments being generated                        during rasterization,                        if a larger filter function is applied.                    GL_TEXTURE_COMPRESSION_HINT                        Indicates the quality and performance of the compressing texture images.                        Hinting GL_FASTEST indicates that texture images should be compressed                        as quickly as possible, while GL_NICEST indicates that texture images                        should be compressed with as little image quality loss as possible.                        GL_NICEST should be selected if the texture is to be retrieved by                        glGetCompressedTexImage for reuse.
        /// </summary>
        /// <param name="target">Specifies a symbolic constant indicating the behavior to be controlled.                    GL_LINE_SMOOTH_HINT,                    GL_POLYGON_SMOOTH_HINT,                    GL_TEXTURE_COMPRESSION_HINT, and                    GL_FRAGMENT_SHADER_DERIVATIVE_HINT                    are accepted.</param>
        /// <param name="mode">Specifies a symbolic constant indicating the desired behavior.                    GL_FASTEST,                    GL_NICEST, and                    GL_DONT_CARE are accepted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Hint(HintTarget target, HintMode mode) => _Hint(target, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void HintPGI(HintTargetPGI target, int mode) => _HintPGI(target, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Histogram(HistogramTargetEXT target, int width, InternalFormat internalformat, bool sink) => _Histogram(target, width, internalformat, sink);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void HistogramEXT(HistogramTargetEXT target, int width, InternalFormat internalformat, bool sink) => _HistogramEXT(target, width, internalformat, sink);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void IglooInterfaceSGIX(int pname, IntPtr @params) => _IglooInterfaceSGIX(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ImageTransformParameterfHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float param) => _ImageTransformParameterfHP(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, float[] @params) => _ImageTransformParameterfvHP(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, void* @params) => _ImageTransformParameterfvHP_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ImageTransformParameterfvHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, IntPtr @params) => _ImageTransformParameterfvHP_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ImageTransformParameteriHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int param) => _ImageTransformParameteriHP(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, int[] @params) => _ImageTransformParameterivHP(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, void* @params) => _ImageTransformParameterivHP_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ImageTransformParameterivHP(ImageTransformTargetHP target, ImageTransformPNameHP pname, IntPtr @params) => _ImageTransformParameterivHP_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ImportMemoryFdEXT(uint memory, UInt64 size, ExternalHandleType handleType, int fd) => _ImportMemoryFdEXT(memory, size, handleType, fd);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ImportMemoryWin32HandleEXT(uint memory, UInt64 size, ExternalHandleType handleType, IntPtr handle) => _ImportMemoryWin32HandleEXT(memory, size, handleType, handle);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ImportMemoryWin32NameEXT(uint memory, UInt64 size, ExternalHandleType handleType, IntPtr name) => _ImportMemoryWin32NameEXT(memory, size, handleType, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ImportSemaphoreFdEXT(uint semaphore, ExternalHandleType handleType, int fd) => _ImportSemaphoreFdEXT(semaphore, handleType, fd);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ImportSemaphoreWin32HandleEXT(uint semaphore, ExternalHandleType handleType, IntPtr handle) => _ImportSemaphoreWin32HandleEXT(semaphore, handleType, handle);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ImportSemaphoreWin32NameEXT(uint semaphore, ExternalHandleType handleType, IntPtr name) => _ImportSemaphoreWin32NameEXT(semaphore, handleType, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int ImportSyncEXT(int external_sync_type, IntPtr external_sync, int flags) => _ImportSyncEXT(external_sync_type, external_sync, flags);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void IndexFormatNV(int type, int stride) => _IndexFormatNV(type, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void IndexFuncEXT(IndexFunctionEXT func, float @ref) => _IndexFuncEXT(func, @ref);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void IndexMask(uint mask) => _IndexMask(mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void IndexMaterialEXT(MaterialFace face, IndexMaterialParameterEXT mode) => _IndexMaterialEXT(face, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void IndexPointer(IndexPointerType type, int stride, IntPtr pointer) => _IndexPointer(type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void IndexPointerEXT(IndexPointerType type, int stride, int count, IntPtr pointer) => _IndexPointerEXT(type, stride, count, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void IndexPointerListIBM(IndexPointerType type, int stride, IntPtr* pointer, int ptrstride) => _IndexPointerListIBM(type, stride, pointer, ptrstride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexd(double c) => _Indexd(c);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexdv(double[] c) => _Indexdv(c);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexdv(void* c) => _Indexdv_ptr(c);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexdv(IntPtr c) => _Indexdv_intptr(c);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexf(float c) => _Indexf(c);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexfv(float[] c) => _Indexfv(c);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexfv(void* c) => _Indexfv_ptr(c);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexfv(IntPtr c) => _Indexfv_intptr(c);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexi(int c) => _Indexi(c);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexiv(int[] c) => _Indexiv(c);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexiv(void* c) => _Indexiv_ptr(c);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexiv(IntPtr c) => _Indexiv_intptr(c);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexs(short c) => _Indexs(c);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexsv(short[] c) => _Indexsv(c);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexsv(void* c) => _Indexsv_ptr(c);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexsv(IntPtr c) => _Indexsv_intptr(c);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexub(byte c) => _Indexub(c);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexubv(byte[] c) => _Indexubv(c);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexubv(void* c) => _Indexubv_ptr(c);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Indexubv(IntPtr c) => _Indexubv_intptr(c);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void IndexxOES(float component) => _IndexxOES(component);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void IndexxvOES(float[] component) => _IndexxvOES(component);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void IndexxvOES(void* component) => _IndexxvOES_ptr(component);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void IndexxvOES(IntPtr component) => _IndexxvOES_intptr(component);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InitNames() => _InitNames();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InsertComponentEXT(uint res, uint src, uint num) => _InsertComponentEXT(res, src, num);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InsertEventMarkerEXT(int length, string marker) => _InsertEventMarkerEXT(length, marker);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InsertEventMarkerEXT(int length, void* marker) => _InsertEventMarkerEXT_ptr(length, marker);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InsertEventMarkerEXT(int length, IntPtr marker) => _InsertEventMarkerEXT_intptr(length, marker);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InstrumentsBufferSGIX(int size, int[] buffer) => _InstrumentsBufferSGIX(size, buffer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InstrumentsBufferSGIX(int size, void* buffer) => _InstrumentsBufferSGIX_ptr(size, buffer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InstrumentsBufferSGIX(int size, IntPtr buffer) => _InstrumentsBufferSGIX_intptr(size, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InterleavedArrays(InterleavedArrayFormat format, int stride, IntPtr pointer) => _InterleavedArrays(format, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InterpolatePathsNV(uint resultPath, uint pathA, uint pathB, float weight) => _InterpolatePathsNV(resultPath, pathA, pathB, weight);

        // ---

        /// <summary>
        /// glInvalidateBufferData invalidates all of the            content of the data store of a buffer object. After invalidation, the content            of the buffer's data store becomes undefined.
        /// </summary>
        /// <param name="buffer">The name of a buffer object whose data store to invalidate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateBufferData(uint buffer) => _InvalidateBufferData(buffer);

        // ---

        /// <summary>
        /// glInvalidateBufferSubData invalidates all or part of the            content of the data store of a buffer object. After invalidation, the content            of the specified range of the buffer's data store becomes undefined. The            start of the range is given by offset and its size            is given by length, both measured in basic machine units.
        /// </summary>
        /// <param name="buffer">The name of a buffer object, a subrange of whose data store to invalidate.</param>
        /// <param name="offset">The offset within the buffer's data store of the start of the range to be invalidated.</param>
        /// <param name="length">The length of the range within the buffer's data store to be invalidated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateBufferSubData(uint buffer, IntPtr offset, IntPtr length) => _InvalidateBufferSubData(buffer, offset, length);

        // ---

        /// <summary>
        /// glInvalidateFramebuffer and            glInvalidateNamedFramebufferData invalidate            the entire contents of a specified set of attachments of a            framebuffer.
        /// For glInvalidateFramebuffer, the            framebuffer object is that bound to            target. target            must be GL_FRAMEBUFFER,            GL_READ_FRAMEBUFFER or            GL_DRAW_FRAMEBUFFER.            GL_FRAMEBUFFER is equivalent to            GL_DRAW_FRAMEBUFFER. Default framebuffers            may also be invalidated if bound to            target.
        /// For glInvalidateNamedFramebufferData,            framebuffer is the name of the            framebuffer object. If framebuffer is            zero, the default draw framebuffer is affected.
        /// The set of attachments whose contents are to be invalidated are            specified in the attachments array, which            contains numAttachments elements.
        /// If the specified framebuffer is a framebuffer object, each            element of attachments must be one of            GL_DEPTH_ATTACHMENT,            GL_STENCIL_ATTACHMENTGL_DEPTH_STENCIL_ATTACHMENT, or            GL_COLOR_ATTACHMENTi,            where i is between zero and the value of            GL_MAX_FRAMEBUFFER_ATTACHMENTS minus one.
        /// If the specified framebuffer is a default framebuffer, each            element of attachments must be one of            GL_FRONT_LEFT,            GL_FRONT_RIGHT,            GL_BACK_LEFT,            GL_BACK_RIGHT,            GL_AUXi,            GL_ACCUM, GL_COLOR,            GL_DEPTH, or            GL_STENCIL. GL_COLOR,            is treated as GL_BACK_LEFT for a            double-buffered context and GL_FRONT_LEFT            for a single-buffered context. The other attachments identify            the corresponding specific buffer.
        /// The entire contents of each specified attachment become            undefined after execution of            glInvalidateFramebuffer or            glInvalidateNamedFramebufferData.
        /// If the framebuffer object is not complete,            glInvalidateFramebuffer and            glInvalidateNamedFramebufferData may be            ignored. This is not an error.
        /// </summary>
        /// <param name="target">Specifies the target to which the framebuffer object is                    attached for                    glInvalidateFramebuffer.</param>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for                    glInvalidateNamedFramebufferData.</param>
        /// <param name="numAttachments">Specifies the number of entries in the                    attachments array.</param>
        /// <param name="attachments">Specifies a pointer to an array identifying the                    attachments to be invalidated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment[] attachments) => _InvalidateFramebuffer(target, numAttachments, attachments);

        /// <summary>
        /// glInvalidateFramebuffer and            glInvalidateNamedFramebufferData invalidate            the entire contents of a specified set of attachments of a            framebuffer.
        /// For glInvalidateFramebuffer, the            framebuffer object is that bound to            target. target            must be GL_FRAMEBUFFER,            GL_READ_FRAMEBUFFER or            GL_DRAW_FRAMEBUFFER.            GL_FRAMEBUFFER is equivalent to            GL_DRAW_FRAMEBUFFER. Default framebuffers            may also be invalidated if bound to            target.
        /// For glInvalidateNamedFramebufferData,            framebuffer is the name of the            framebuffer object. If framebuffer is            zero, the default draw framebuffer is affected.
        /// The set of attachments whose contents are to be invalidated are            specified in the attachments array, which            contains numAttachments elements.
        /// If the specified framebuffer is a framebuffer object, each            element of attachments must be one of            GL_DEPTH_ATTACHMENT,            GL_STENCIL_ATTACHMENTGL_DEPTH_STENCIL_ATTACHMENT, or            GL_COLOR_ATTACHMENTi,            where i is between zero and the value of            GL_MAX_FRAMEBUFFER_ATTACHMENTS minus one.
        /// If the specified framebuffer is a default framebuffer, each            element of attachments must be one of            GL_FRONT_LEFT,            GL_FRONT_RIGHT,            GL_BACK_LEFT,            GL_BACK_RIGHT,            GL_AUXi,            GL_ACCUM, GL_COLOR,            GL_DEPTH, or            GL_STENCIL. GL_COLOR,            is treated as GL_BACK_LEFT for a            double-buffered context and GL_FRONT_LEFT            for a single-buffered context. The other attachments identify            the corresponding specific buffer.
        /// The entire contents of each specified attachment become            undefined after execution of            glInvalidateFramebuffer or            glInvalidateNamedFramebufferData.
        /// If the framebuffer object is not complete,            glInvalidateFramebuffer and            glInvalidateNamedFramebufferData may be            ignored. This is not an error.
        /// </summary>
        /// <param name="target">Specifies the target to which the framebuffer object is                    attached for                    glInvalidateFramebuffer.</param>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for                    glInvalidateNamedFramebufferData.</param>
        /// <param name="numAttachments">Specifies the number of entries in the                    attachments array.</param>
        /// <param name="attachments">Specifies a pointer to an array identifying the                    attachments to be invalidated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateFramebuffer(FramebufferTarget target, int numAttachments, void* attachments) => _InvalidateFramebuffer_ptr(target, numAttachments, attachments);

        /// <summary>
        /// glInvalidateFramebuffer and            glInvalidateNamedFramebufferData invalidate            the entire contents of a specified set of attachments of a            framebuffer.
        /// For glInvalidateFramebuffer, the            framebuffer object is that bound to            target. target            must be GL_FRAMEBUFFER,            GL_READ_FRAMEBUFFER or            GL_DRAW_FRAMEBUFFER.            GL_FRAMEBUFFER is equivalent to            GL_DRAW_FRAMEBUFFER. Default framebuffers            may also be invalidated if bound to            target.
        /// For glInvalidateNamedFramebufferData,            framebuffer is the name of the            framebuffer object. If framebuffer is            zero, the default draw framebuffer is affected.
        /// The set of attachments whose contents are to be invalidated are            specified in the attachments array, which            contains numAttachments elements.
        /// If the specified framebuffer is a framebuffer object, each            element of attachments must be one of            GL_DEPTH_ATTACHMENT,            GL_STENCIL_ATTACHMENTGL_DEPTH_STENCIL_ATTACHMENT, or            GL_COLOR_ATTACHMENTi,            where i is between zero and the value of            GL_MAX_FRAMEBUFFER_ATTACHMENTS minus one.
        /// If the specified framebuffer is a default framebuffer, each            element of attachments must be one of            GL_FRONT_LEFT,            GL_FRONT_RIGHT,            GL_BACK_LEFT,            GL_BACK_RIGHT,            GL_AUXi,            GL_ACCUM, GL_COLOR,            GL_DEPTH, or            GL_STENCIL. GL_COLOR,            is treated as GL_BACK_LEFT for a            double-buffered context and GL_FRONT_LEFT            for a single-buffered context. The other attachments identify            the corresponding specific buffer.
        /// The entire contents of each specified attachment become            undefined after execution of            glInvalidateFramebuffer or            glInvalidateNamedFramebufferData.
        /// If the framebuffer object is not complete,            glInvalidateFramebuffer and            glInvalidateNamedFramebufferData may be            ignored. This is not an error.
        /// </summary>
        /// <param name="target">Specifies the target to which the framebuffer object is                    attached for                    glInvalidateFramebuffer.</param>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for                    glInvalidateNamedFramebufferData.</param>
        /// <param name="numAttachments">Specifies the number of entries in the                    attachments array.</param>
        /// <param name="attachments">Specifies a pointer to an array identifying the                    attachments to be invalidated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateFramebuffer(FramebufferTarget target, int numAttachments, IntPtr attachments) => _InvalidateFramebuffer_intptr(target, numAttachments, attachments);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateNamedFramebufferData(uint framebuffer, int numAttachments, FramebufferAttachment[] attachments) => _InvalidateNamedFramebufferData(framebuffer, numAttachments, attachments);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateNamedFramebufferData(uint framebuffer, int numAttachments, void* attachments) => _InvalidateNamedFramebufferData_ptr(framebuffer, numAttachments, attachments);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateNamedFramebufferData(uint framebuffer, int numAttachments, IntPtr attachments) => _InvalidateNamedFramebufferData_intptr(framebuffer, numAttachments, attachments);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateNamedFramebufferSubData(uint framebuffer, int numAttachments, FramebufferAttachment[] attachments, int x, int y, int width, int height) => _InvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, width, height);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateNamedFramebufferSubData(uint framebuffer, int numAttachments, void* attachments, int x, int y, int width, int height) => _InvalidateNamedFramebufferSubData_ptr(framebuffer, numAttachments, attachments, x, y, width, height);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateNamedFramebufferSubData(uint framebuffer, int numAttachments, IntPtr attachments, int x, int y, int width, int height) => _InvalidateNamedFramebufferSubData_intptr(framebuffer, numAttachments, attachments, x, y, width, height);

        // ---

        /// <summary>
        /// glInvalidateSubFramebuffer and            glInvalidateNamedFramebufferSubData            invalidate the contents of a specified region of a specified set            of attachments of a framebuffer.
        /// For glInvalidateSubFramebuffer, the            framebuffer object is that bound to            target, which must be one of            GL_FRAMEBUFFER,            GL_READ_FRAMEBUFFER or            GL_DRAW_FRAMEBUFFER.            GL_FRAMEBUFFER is equivalent to            GL_DRAW_FRAMEBUFFER. Default framebuffers            may also be invalidated if bound to            target.
        /// For glInvalidateNamedFramebufferSubData,            framebuffer is the name of the            framebuffer object. If framebuffer is            zero, the default draw framebuffer is affected.
        /// The set of attachments of which a region is to be invalidated            are specified in the attachments array,            which contains numAttachments elements.
        /// If the specified framebuffer is a framebuffer object, each            element of attachments must be one of            GL_DEPTH_ATTACHMENT,            GL_STENCIL_ATTACHMENTGL_DEPTH_STENCIL_ATTACHMENT, or            GL_COLOR_ATTACHMENTi,            where i is between zero and the value of            GL_MAX_FRAMEBUFFER_ATTACHMENTS minus one.
        /// If the specified framebuffer is a default framebuffer, each            element of attachments must be one of            GL_FRONT_LEFT,            GL_FRONT_RIGHT,            GL_BACK_LEFT,            GL_BACK_RIGHT,            GL_AUXi,            GL_ACCUM, GL_COLOR,            GL_DEPTH, or            GL_STENCIL. GL_COLOR,            is treated as GL_BACK_LEFT for a            double-buffered context and GL_FRONT_LEFT            for a single-buffered context. The other attachments identify            the corresponding specific buffer.
        /// The contents of the specified region of each specified            attachment become undefined after execution of            glInvalidateSubFramebuffer or            glInvalidateNamedFramebufferSubData. The            region to be invalidated is specified by            x, y,            width and height            where x and y give            the offset from the origin (with lower-left corner at $(0,0)$)            and width and            height are the width and height,            respectively, of the region. Any pixels lying outside of the            window allocated to the current GL context (for the default            framebuffer), or outside of the attachments of the framebuffer            object, are ignored. If the framebuffer object is not complete,            these commands may be ignored.
        /// If the framebuffer object is not complete,            glInvalidateSubFramebuffer and            glInvalidateNamedFramebufferSubData may be            ignored. This is not an error.
        /// </summary>
        /// <param name="target">Specifies the target to which the framebuffer object is                    attached for                    glInvalidateSubFramebuffer.</param>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for                    glInvalidateNamedFramebufferSubData.</param>
        /// <param name="numAttachments">Specifies the number of entries in the                    attachments array.</param>
        /// <param name="attachments">Specifies a pointer to an array identifying the                    attachments to be invalidated.</param>
        /// <param name="x">Specifies the X offset of the region to be invalidated.</param>
        /// <param name="y">Specifies the Y offset of the region to be invalidated.</param>
        /// <param name="width">Specifies the width of the region to be invalidated.</param>
        /// <param name="height">Specifies the height of the region to be invalidated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateSubFramebuffer(FramebufferTarget target, int numAttachments, InvalidateFramebufferAttachment[] attachments, int x, int y, int width, int height) => _InvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);

        /// <summary>
        /// glInvalidateSubFramebuffer and            glInvalidateNamedFramebufferSubData            invalidate the contents of a specified region of a specified set            of attachments of a framebuffer.
        /// For glInvalidateSubFramebuffer, the            framebuffer object is that bound to            target, which must be one of            GL_FRAMEBUFFER,            GL_READ_FRAMEBUFFER or            GL_DRAW_FRAMEBUFFER.            GL_FRAMEBUFFER is equivalent to            GL_DRAW_FRAMEBUFFER. Default framebuffers            may also be invalidated if bound to            target.
        /// For glInvalidateNamedFramebufferSubData,            framebuffer is the name of the            framebuffer object. If framebuffer is            zero, the default draw framebuffer is affected.
        /// The set of attachments of which a region is to be invalidated            are specified in the attachments array,            which contains numAttachments elements.
        /// If the specified framebuffer is a framebuffer object, each            element of attachments must be one of            GL_DEPTH_ATTACHMENT,            GL_STENCIL_ATTACHMENTGL_DEPTH_STENCIL_ATTACHMENT, or            GL_COLOR_ATTACHMENTi,            where i is between zero and the value of            GL_MAX_FRAMEBUFFER_ATTACHMENTS minus one.
        /// If the specified framebuffer is a default framebuffer, each            element of attachments must be one of            GL_FRONT_LEFT,            GL_FRONT_RIGHT,            GL_BACK_LEFT,            GL_BACK_RIGHT,            GL_AUXi,            GL_ACCUM, GL_COLOR,            GL_DEPTH, or            GL_STENCIL. GL_COLOR,            is treated as GL_BACK_LEFT for a            double-buffered context and GL_FRONT_LEFT            for a single-buffered context. The other attachments identify            the corresponding specific buffer.
        /// The contents of the specified region of each specified            attachment become undefined after execution of            glInvalidateSubFramebuffer or            glInvalidateNamedFramebufferSubData. The            region to be invalidated is specified by            x, y,            width and height            where x and y give            the offset from the origin (with lower-left corner at $(0,0)$)            and width and            height are the width and height,            respectively, of the region. Any pixels lying outside of the            window allocated to the current GL context (for the default            framebuffer), or outside of the attachments of the framebuffer            object, are ignored. If the framebuffer object is not complete,            these commands may be ignored.
        /// If the framebuffer object is not complete,            glInvalidateSubFramebuffer and            glInvalidateNamedFramebufferSubData may be            ignored. This is not an error.
        /// </summary>
        /// <param name="target">Specifies the target to which the framebuffer object is                    attached for                    glInvalidateSubFramebuffer.</param>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for                    glInvalidateNamedFramebufferSubData.</param>
        /// <param name="numAttachments">Specifies the number of entries in the                    attachments array.</param>
        /// <param name="attachments">Specifies a pointer to an array identifying the                    attachments to be invalidated.</param>
        /// <param name="x">Specifies the X offset of the region to be invalidated.</param>
        /// <param name="y">Specifies the Y offset of the region to be invalidated.</param>
        /// <param name="width">Specifies the width of the region to be invalidated.</param>
        /// <param name="height">Specifies the height of the region to be invalidated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateSubFramebuffer(FramebufferTarget target, int numAttachments, void* attachments, int x, int y, int width, int height) => _InvalidateSubFramebuffer_ptr(target, numAttachments, attachments, x, y, width, height);

        /// <summary>
        /// glInvalidateSubFramebuffer and            glInvalidateNamedFramebufferSubData            invalidate the contents of a specified region of a specified set            of attachments of a framebuffer.
        /// For glInvalidateSubFramebuffer, the            framebuffer object is that bound to            target, which must be one of            GL_FRAMEBUFFER,            GL_READ_FRAMEBUFFER or            GL_DRAW_FRAMEBUFFER.            GL_FRAMEBUFFER is equivalent to            GL_DRAW_FRAMEBUFFER. Default framebuffers            may also be invalidated if bound to            target.
        /// For glInvalidateNamedFramebufferSubData,            framebuffer is the name of the            framebuffer object. If framebuffer is            zero, the default draw framebuffer is affected.
        /// The set of attachments of which a region is to be invalidated            are specified in the attachments array,            which contains numAttachments elements.
        /// If the specified framebuffer is a framebuffer object, each            element of attachments must be one of            GL_DEPTH_ATTACHMENT,            GL_STENCIL_ATTACHMENTGL_DEPTH_STENCIL_ATTACHMENT, or            GL_COLOR_ATTACHMENTi,            where i is between zero and the value of            GL_MAX_FRAMEBUFFER_ATTACHMENTS minus one.
        /// If the specified framebuffer is a default framebuffer, each            element of attachments must be one of            GL_FRONT_LEFT,            GL_FRONT_RIGHT,            GL_BACK_LEFT,            GL_BACK_RIGHT,            GL_AUXi,            GL_ACCUM, GL_COLOR,            GL_DEPTH, or            GL_STENCIL. GL_COLOR,            is treated as GL_BACK_LEFT for a            double-buffered context and GL_FRONT_LEFT            for a single-buffered context. The other attachments identify            the corresponding specific buffer.
        /// The contents of the specified region of each specified            attachment become undefined after execution of            glInvalidateSubFramebuffer or            glInvalidateNamedFramebufferSubData. The            region to be invalidated is specified by            x, y,            width and height            where x and y give            the offset from the origin (with lower-left corner at $(0,0)$)            and width and            height are the width and height,            respectively, of the region. Any pixels lying outside of the            window allocated to the current GL context (for the default            framebuffer), or outside of the attachments of the framebuffer            object, are ignored. If the framebuffer object is not complete,            these commands may be ignored.
        /// If the framebuffer object is not complete,            glInvalidateSubFramebuffer and            glInvalidateNamedFramebufferSubData may be            ignored. This is not an error.
        /// </summary>
        /// <param name="target">Specifies the target to which the framebuffer object is                    attached for                    glInvalidateSubFramebuffer.</param>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for                    glInvalidateNamedFramebufferSubData.</param>
        /// <param name="numAttachments">Specifies the number of entries in the                    attachments array.</param>
        /// <param name="attachments">Specifies a pointer to an array identifying the                    attachments to be invalidated.</param>
        /// <param name="x">Specifies the X offset of the region to be invalidated.</param>
        /// <param name="y">Specifies the Y offset of the region to be invalidated.</param>
        /// <param name="width">Specifies the width of the region to be invalidated.</param>
        /// <param name="height">Specifies the height of the region to be invalidated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateSubFramebuffer(FramebufferTarget target, int numAttachments, IntPtr attachments, int x, int y, int width, int height) => _InvalidateSubFramebuffer_intptr(target, numAttachments, attachments, x, y, width, height);

        // ---

        /// <summary>
        /// glInvalidateTexSubImage invalidates all of            a texture image. texture and level indicated            which texture image is being invalidated. After this command, data in the texture image has undefined            values.
        /// level must be greater than or equal to zero and be            less than the base 2 logarithm of the maximum texture width, height, or depth.
        /// For textures of targets GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE, or            GL_TEXTURE_2D_MULTISAMPLE_ARRAY, level must be zero.
        /// </summary>
        /// <param name="texture">The name of a texture object to invalidate.</param>
        /// <param name="level">The level of detail of the texture object to invalidate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateTexImage(uint texture, int level) => _InvalidateTexImage(texture, level);

        // ---

        /// <summary>
        /// glInvalidateTexSubImage invalidates all or part of            a texture image. texture and level indicated            which texture image is being invalidated. After this command, data in that subregion have undefined            values. xoffset, yoffset, zoffset, width, height, and depth            are interpreted as they are in glTexSubImage3D. For texture targets that            don't have certain dimensions, this command treats those dimensions as            having a size of 1. For example, to invalidate a portion of a two-            dimensional texture, the application would use zoffset equal to zero and            depth equal to one. Cube map textures are treated as an array of six            slices in the z-dimension, where a value of zoffset is interpreted as            specifying face GL_TEXTURE_CUBE_MAP_POSITIVE_X + zoffset.
        /// level must be greater than or equal to zero and be            less than the base 2 logarithm of the maximum texture width, height, or depth.            xoffset, yoffset and zoffset            must be greater than or equal to zero and be less than the width, height or depth            of the image, respectively. Furthermore, xoffset + width,            yoffset + height, and            zoffset + depth must be less            than or equal to the width, height or depth of the image, respectively.
        /// For textures of targets GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE, or            GL_TEXTURE_2D_MULTISAMPLE_ARRAY, level must be zero.
        /// </summary>
        /// <param name="texture">The name of a texture object a subregion of which to invalidate.</param>
        /// <param name="level">The level of detail of the texture object within which the region resides.</param>
        /// <param name="xoffset">The X offset of the region to be invalidated.</param>
        /// <param name="yoffset">The Y offset of the region to be invalidated.</param>
        /// <param name="zoffset">The Z offset of the region to be invalidated.</param>
        /// <param name="width">The width of the region to be invalidated.</param>
        /// <param name="height">The height of the region to be invalidated.</param>
        /// <param name="depth">The depth of the region to be invalidated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void InvalidateTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth) => _InvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsAsyncMarkerSGIX(uint marker) => _IsAsyncMarkerSGIX(marker);

        // ---

        /// <summary>
        /// glIsBuffer returns GL_TRUE if buffer is currently the name of a buffer object.            If buffer is zero, or is a non-zero value that is not currently the            name of a buffer object, or if an error occurs, glIsBuffer returns GL_FALSE.
        /// A name returned by glGenBuffers, but not yet associated with a buffer object            by calling glBindBuffer, is not the name of a buffer object.
        /// </summary>
        /// <param name="buffer">Specifies a value that may be the name of a buffer object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsBuffer(uint buffer) => _IsBuffer(buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsBufferARB(uint buffer) => _IsBufferARB(buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsBufferResidentNV(int target) => _IsBufferResidentNV(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsCommandListNV(uint list) => _IsCommandListNV(list);

        // ---

        /// <summary>
        /// glIsEnabled returns GL_TRUE if cap is an enabled capability            and returns GL_FALSE otherwise. Boolean states that are indexed may be tested with glIsEnabledi.            For glIsEnabledi, index specifies the index of the capability to test. index            must be between zero and the count of indexed capabilities for cap.            Initially all capabilities except GL_DITHER are disabled;            GL_DITHER is initially enabled.
        /// The following capabilities are accepted for cap:
        /// Constant  See GL_BLENDglBlendFunc,                             glLogicOpGL_CLIP_DISTANCEiglEnableGL_COLOR_LOGIC_OPglLogicOpGL_CULL_FACEglCullFaceGL_DEPTH_CLAMPglEnableGL_DEBUG_OUTPUTglEnableGL_DEBUG_OUTPUT_SYNCHRONOUSglEnableGL_DEPTH_TESTglDepthFunc,                             glDepthRangeGL_DITHERglEnableGL_FRAMEBUFFER_SRGBglEnableGL_LINE_SMOOTHglLineWidthGL_MULTISAMPLEglSampleCoverageGL_POLYGON_SMOOTHglPolygonModeGL_POLYGON_OFFSET_FILLglPolygonOffsetGL_POLYGON_OFFSET_LINEglPolygonOffsetGL_POLYGON_OFFSET_POINTglPolygonOffsetGL_PROGRAM_POINT_SIZEglEnableGL_PRIMITIVE_RESTARTglEnable,                             glPrimitiveRestartIndexGL_SAMPLE_ALPHA_TO_COVERAGEglSampleCoverageGL_SAMPLE_ALPHA_TO_ONEglSampleCoverageGL_SAMPLE_COVERAGEglSampleCoverageGL_SAMPLE_MASKglEnableGL_SCISSOR_TESTglScissorGL_STENCIL_TESTglStencilFunc,                             glStencilOpGL_TEXTURE_CUBE_MAP_SEAMLESSglEnable
        /// </summary>
        /// <param name="cap">Specifies a symbolic constant indicating a GL capability.</param>
        /// <param name="index">Specifies the index of the capability.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsEnabled(EnableCap cap) => _IsEnabled(cap);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsEnabledIndexedEXT(EnableCap target, uint index) => _IsEnabledIndexedEXT(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsEnabledi(EnableCap target, uint index) => _IsEnabledi(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsEnablediEXT(EnableCap target, uint index) => _IsEnablediEXT(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsEnablediNV(EnableCap target, uint index) => _IsEnablediNV(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsEnablediOES(EnableCap target, uint index) => _IsEnablediOES(target, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsFenceAPPLE(uint fence) => _IsFenceAPPLE(fence);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsFenceNV(uint fence) => _IsFenceNV(fence);

        // ---

        /// <summary>
        /// glIsFramebuffer returns GL_TRUE if framebuffer is currently the name of a framebuffer            object. If framebuffer is zero, or if framebuffer is not the name of a framebuffer object, or if an error            occurs, glIsFramebuffer returns GL_FALSE. If framebuffer is a name returned by            glGenFramebuffers, by that has not yet been bound through a call to            glBindFramebuffer, then the name is not a framebuffer object and glIsFramebuffer            returns GL_FALSE.
        /// </summary>
        /// <param name="framebuffer">Specifies a value that may be the name of a framebuffer object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsFramebuffer(uint framebuffer) => _IsFramebuffer(framebuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsFramebufferEXT(uint framebuffer) => _IsFramebufferEXT(framebuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsFramebufferOES(uint framebuffer) => _IsFramebufferOES(framebuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsImageHandleResidentARB(UInt64 handle) => _IsImageHandleResidentARB(handle);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsImageHandleResidentNV(UInt64 handle) => _IsImageHandleResidentNV(handle);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsList(uint list) => _IsList(list);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsMemoryObjectEXT(uint memoryObject) => _IsMemoryObjectEXT(memoryObject);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsNameAMD(int identifier, uint name) => _IsNameAMD(identifier, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsNamedBufferResidentNV(uint buffer) => _IsNamedBufferResidentNV(buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsNamedStringARB(int namelen, string name) => _IsNamedStringARB(namelen, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsNamedStringARB(int namelen, void* name) => _IsNamedStringARB_ptr(namelen, name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsNamedStringARB(int namelen, IntPtr name) => _IsNamedStringARB_intptr(namelen, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsObjectBufferATI(uint buffer) => _IsObjectBufferATI(buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsOcclusionQueryNV(uint id) => _IsOcclusionQueryNV(id);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsPathNV(uint path) => _IsPathNV(path);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsPointInFillPathNV(uint path, uint mask, float x, float y) => _IsPointInFillPathNV(path, mask, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsPointInStrokePathNV(uint path, float x, float y) => _IsPointInStrokePathNV(path, x, y);

        // ---

        /// <summary>
        /// glIsProgram returns    GL_TRUE if program    is the name of a program object previously created with        glCreateProgram        and not yet deleted with glDeleteProgram.    If program is zero or a non-zero value that    is not the name of a program object, or if an error occurs,        glIsProgram returns GL_FALSE.
        /// </summary>
        /// <param name="program">Specifies a potential program object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsProgram(uint program) => _IsProgram(program);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsProgramARB(uint program) => _IsProgramARB(program);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsProgramNV(uint id) => _IsProgramNV(id);

        // ---

        /// <summary>
        /// glIsProgramPipeline returns GL_TRUE if            pipeline is currently the name of a program pipeline object.            If pipeline is zero, or if pipeline is not the            name of a program pipeline object, or if an error occurs, glIsProgramPipeline            returns GL_FALSE. If pipeline is a name returned by            glGenProgramPipelines, but that            has not yet been bound through a call to glBindProgramPipeline,            then the name is not a program pipeline object and glIsProgramPipeline            returns GL_FALSE.
        /// </summary>
        /// <param name="pipeline">Specifies a value that may be the name of a program pipeline object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsProgramPipeline(uint pipeline) => _IsProgramPipeline(pipeline);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsProgramPipelineEXT(uint pipeline) => _IsProgramPipelineEXT(pipeline);

        // ---

        /// <summary>
        /// glIsQuery returns GL_TRUE if id is currently the name of a query object.            If id is zero, or is a non-zero value that is not currently the            name of a query object, or if an error occurs, glIsQuery returns GL_FALSE.
        /// A name returned by glGenQueries, but not yet associated with a query object            by calling glBeginQuery, is not the name of a query object.
        /// </summary>
        /// <param name="id">Specifies a value that may be the name of a query object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsQuery(uint id) => _IsQuery(id);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsQueryARB(uint id) => _IsQueryARB(id);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsQueryEXT(uint id) => _IsQueryEXT(id);

        // ---

        /// <summary>
        /// glIsRenderbuffer returns GL_TRUE if renderbuffer is currently the name of a renderbuffer            object. If renderbuffer is zero, or if renderbuffer is not the name of a renderbuffer object, or if an error            occurs, glIsRenderbuffer returns GL_FALSE. If renderbuffer is a name returned by            glGenRenderbuffers, by that has not yet been bound through a call to            glBindRenderbuffer or glFramebufferRenderbuffer,            then the name is not a renderbuffer object and glIsRenderbuffer returns GL_FALSE.
        /// </summary>
        /// <param name="renderbuffer">Specifies a value that may be the name of a renderbuffer object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsRenderbuffer(uint renderbuffer) => _IsRenderbuffer(renderbuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsRenderbufferEXT(uint renderbuffer) => _IsRenderbufferEXT(renderbuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsRenderbufferOES(uint renderbuffer) => _IsRenderbufferOES(renderbuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsSemaphoreEXT(uint semaphore) => _IsSemaphoreEXT(semaphore);

        // ---

        /// <summary>
        /// glIsSampler returns GL_TRUE if id is currently the name of a sampler object.            If id is zero, or is a non-zero value that is not currently the            name of a sampler object, or if an error occurs, glIsSampler returns GL_FALSE.
        /// A name returned by glGenSamplers, is the name of a sampler object.
        /// </summary>
        /// <param name="id">Specifies a value that may be the name of a sampler object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsSampler(uint sampler) => _IsSampler(sampler);

        // ---

        /// <summary>
        /// glIsShader returns    GL_TRUE if shader is    the name of a shader object previously created with        glCreateShader        and not yet deleted with glDeleteShader.        If shader is    zero or a non-zero value that is not the name of a shader    object, or if an error occurs, glIsShader  returns    GL_FALSE.
        /// </summary>
        /// <param name="shader">Specifies a potential shader object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsShader(uint shader) => _IsShader(shader);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsStateNV(uint state) => _IsStateNV(state);

        // ---

        /// <summary>
        /// glIsSync returns GL_TRUE if sync is currently the name of a sync object.            If sync is not the name of a sync object, or if an error occurs, glIsSync returns            GL_FALSE. Note that zero is not the name of a sync object.
        /// </summary>
        /// <param name="sync">Specifies a value that may be the name of a sync object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsSync(int sync) => _IsSync(sync);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsSyncAPPLE(int sync) => _IsSyncAPPLE(sync);

        // ---

        /// <summary>
        /// glIsTexture returns GL_TRUE if texture is currently the name of a texture.            If texture is zero, or is a non-zero value that is not currently the            name of a texture, or if an error occurs, glIsTexture returns GL_FALSE.
        /// A name returned by glGenTextures, but not yet associated with a texture            by calling glBindTexture, is not the name of a texture.
        /// </summary>
        /// <param name="texture">Specifies a value that may be the name of a texture.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsTexture(uint texture) => _IsTexture(texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsTextureEXT(uint texture) => _IsTextureEXT(texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsTextureHandleResidentARB(UInt64 handle) => _IsTextureHandleResidentARB(handle);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsTextureHandleResidentNV(UInt64 handle) => _IsTextureHandleResidentNV(handle);

        // ---

        /// <summary>
        /// glIsTransformFeedback returns GL_TRUE if id is currently the name of a transform feedback            object. If id is zero, or if id is not the name of a transform feedback object, or if an error            occurs, glIsTransformFeedback returns GL_FALSE. If id is a name returned by            glGenTransformFeedbacks, but that has not yet been bound through a call to            glBindTransformFeedback, then the name is not a transform feedback object and glIsTransformFeedback            returns GL_FALSE.
        /// </summary>
        /// <param name="id">Specifies a value that may be the name of a transform feedback object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsTransformFeedback(uint id) => _IsTransformFeedback(id);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsTransformFeedbackNV(uint id) => _IsTransformFeedbackNV(id);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsVariantEnabledEXT(uint id, VariantCapEXT cap) => _IsVariantEnabledEXT(id, cap);

        // ---

        /// <summary>
        /// glIsVertexArray returns GL_TRUE if array is currently the name of a vertex array            object. If array is zero, or if array is not the name of a vertex array object, or if an error            occurs, glIsVertexArray returns GL_FALSE. If array is a name returned by            glGenVertexArrays, by that has not yet been bound through a call to            glBindVertexArray, then the name is not a vertex array object and            glIsVertexArray returns GL_FALSE.
        /// </summary>
        /// <param name="array">Specifies a value that may be the name of a vertex array object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsVertexArray(uint array) => _IsVertexArray(array);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsVertexArrayAPPLE(uint array) => _IsVertexArrayAPPLE(array);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsVertexArrayOES(uint array) => _IsVertexArrayOES(array);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsVertexAttribEnabledAPPLE(uint index, int pname) => _IsVertexAttribEnabledAPPLE(index, pname);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LGPUCopyImageSubDataNVX(uint sourceGpu, int destinationGpuMask, uint srcName, int srcTarget, int srcLevel, int srcX, int srxY, int srcZ, uint dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) => _LGPUCopyImageSubDataNVX(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LGPUInterlockNVX() => _LGPUInterlockNVX();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LGPUNamedBufferSubDataNVX(int gpuMask, uint buffer, IntPtr offset, IntPtr size, IntPtr data) => _LGPUNamedBufferSubDataNVX(gpuMask, buffer, offset, size, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LabelObjectEXT(int type, uint @object, int length, string label) => _LabelObjectEXT(type, @object, length, label);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LabelObjectEXT(int type, uint @object, int length, void* label) => _LabelObjectEXT_ptr(type, @object, length, label);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LabelObjectEXT(int type, uint @object, int length, IntPtr label) => _LabelObjectEXT_intptr(type, @object, length, label);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightEnviSGIX(LightEnvParameterSGIX pname, int param) => _LightEnviSGIX(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModelf(LightModelParameter pname, float param) => _LightModelf(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModelfv(LightModelParameter pname, float[] @params) => _LightModelfv(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModelfv(LightModelParameter pname, void* @params) => _LightModelfv_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModelfv(LightModelParameter pname, IntPtr @params) => _LightModelfv_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModeli(LightModelParameter pname, int param) => _LightModeli(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModeliv(LightModelParameter pname, int[] @params) => _LightModeliv(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModeliv(LightModelParameter pname, void* @params) => _LightModeliv_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModeliv(LightModelParameter pname, IntPtr @params) => _LightModeliv_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModelx(LightModelParameter pname, float param) => _LightModelx(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModelxOES(LightModelParameter pname, float param) => _LightModelxOES(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModelxv(LightModelParameter pname, float[] param) => _LightModelxv(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModelxv(LightModelParameter pname, void* param) => _LightModelxv_ptr(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModelxv(LightModelParameter pname, IntPtr param) => _LightModelxv_intptr(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModelxvOES(LightModelParameter pname, float[] param) => _LightModelxvOES(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModelxvOES(LightModelParameter pname, void* param) => _LightModelxvOES_ptr(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightModelxvOES(LightModelParameter pname, IntPtr param) => _LightModelxvOES_intptr(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Lightf(LightName light, LightParameter pname, float param) => _Lightf(light, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Lightfv(LightName light, LightParameter pname, float[] @params) => _Lightfv(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Lightfv(LightName light, LightParameter pname, void* @params) => _Lightfv_ptr(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Lightfv(LightName light, LightParameter pname, IntPtr @params) => _Lightfv_intptr(light, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Lighti(LightName light, LightParameter pname, int param) => _Lighti(light, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Lightiv(LightName light, LightParameter pname, int[] @params) => _Lightiv(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Lightiv(LightName light, LightParameter pname, void* @params) => _Lightiv_ptr(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Lightiv(LightName light, LightParameter pname, IntPtr @params) => _Lightiv_intptr(light, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Lightx(LightName light, LightParameter pname, float param) => _Lightx(light, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightxOES(LightName light, LightParameter pname, float param) => _LightxOES(light, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Lightxv(LightName light, LightParameter pname, float[] @params) => _Lightxv(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Lightxv(LightName light, LightParameter pname, void* @params) => _Lightxv_ptr(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Lightxv(LightName light, LightParameter pname, IntPtr @params) => _Lightxv_intptr(light, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightxvOES(LightName light, LightParameter pname, float[] @params) => _LightxvOES(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightxvOES(LightName light, LightParameter pname, void* @params) => _LightxvOES_ptr(light, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LightxvOES(LightName light, LightParameter pname, IntPtr @params) => _LightxvOES_intptr(light, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LineStipple(int factor, ushort pattern) => _LineStipple(factor, pattern);

        // ---

        /// <summary>
        /// glLineWidth specifies the rasterized width of both aliased and antialiased            lines.            Using a line width other than 1 has different effects,            depending on whether line antialiasing is enabled.            To enable and disable line antialiasing, call            glEnable and glDisable            with argument GL_LINE_SMOOTH. Line antialiasing is initially            disabled.
        /// If line antialiasing is disabled,            the actual width is determined by rounding the supplied width            to the nearest integer.            (If the rounding results in the value 0,            it is as if the line width were 1.)            If            ,            i pixels are filled in each column that is rasterized,            where i is the rounded value of width.            Otherwise,            i pixels are filled in each row that is rasterized.
        /// If antialiasing is enabled,            line rasterization produces a fragment for each pixel square            that intersects the region lying within the rectangle having width            equal to the current line width,            length equal to the actual length of the line,            and centered on the mathematical line segment.            The coverage value for each fragment is the window coordinate area            of the intersection of the rectangular region with the corresponding            pixel square.            This value is saved and used in the final rasterization step.
        /// Not all widths can be supported when line antialiasing is enabled. If an            unsupported width is requested, the nearest supported width is used.            Only width 1 is guaranteed to be supported; others depend on the            implementation.  Likewise, there is a range for aliased line widths as well.            To query the range of supported widths and the size            difference between supported widths within the range, call glGet            with arguments GL_ALIASED_LINE_WIDTH_RANGE,            GL_SMOOTH_LINE_WIDTH_RANGE, and GL_SMOOTH_LINE_WIDTH_GRANULARITY.
        /// </summary>
        /// <param name="width">Specifies the width of rasterized lines.                    The initial value is 1.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LineWidth(float width) => _LineWidth(width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LineWidthx(float width) => _LineWidthx(width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LineWidthxOES(float width) => _LineWidthxOES(width);

        // ---

        /// <summary>
        /// glLinkProgram links the program    object specified by program. If any    shader objects of type GL_VERTEX_SHADER are    attached to program, they will be used to    create an executable that will run on the programmable vertex    processor. If any shader objects of type GL_GEOMETRY_SHADER    are attached to program, they will be used to create    an executable that will run on the programmable geometry processor.    If any shader objects of type    GL_FRAGMENT_SHADER are attached to    program, they will be used to create an    executable that will run on the programmable fragment    processor.
        /// The status of the link operation will be stored as part of    the program object's state. This value will be set to    GL_TRUE if the program object was linked    without errors and is ready for use, and    GL_FALSE otherwise. It can be queried by    calling    glGetProgram    with arguments program and    GL_LINK_STATUS.
        /// As a result of a successful link operation, all active    user-defined uniform variables belonging to    program will be initialized to 0, and    each of the program object's active uniform variables will be    assigned a location that can be queried by calling    glGetUniformLocation.    Also, any active user-defined attribute variables that have not    been bound to a generic vertex attribute index will be bound to    one at this time.
        /// Linking of a program object can fail for a number of    reasons as specified in the OpenGL Shading Language    Specification. The following lists some of the    conditions that will cause a link error.
        /// The number of active attribute variables supported        by the implementation has been exceeded.The storage limit for uniform variables has been        exceeded.The number of active uniform variables supported        by the implementation has been exceeded.The main function is missing        for the vertex, geometry or fragment shader.A varying variable actually used in the fragment        shader is not declared in the same way (or is not        declared at all) in the vertex shader, or geometry shader if present.A reference to a function or variable name is        unresolved.A shared global is declared with two different        types or two different initial values.One or more of the attached shader objects has not        been successfully compiled.Binding a generic attribute matrix caused some        rows of the matrix to fall outside the allowed maximum        of GL_MAX_VERTEX_ATTRIBS.Not enough contiguous vertex attribute slots could        be found to bind attribute matrices.The program object contains objects to form a fragment shader but        does not contain objects to form a vertex shader.The program object contains objects to form a geometry shader        but does not contain objects to form a vertex shader.The program object contains objects to form a geometry shader        and the input primitive type, output primitive type, or maximum output        vertex count is not specified in any compiled geometry shader        object.The program object contains objects to form a geometry shader        and the input primitive type, output primitive type, or maximum output        vertex count is specified differently in multiple geometry shader        objects.The number of active outputs in the fragment shader is greater        than the value of GL_MAX_DRAW_BUFFERS.The program has an active output assigned to a location greater        than or equal to the value of GL_MAX_DUAL_SOURCE_DRAW_BUFFERS        and has an active output assigned an index greater than or equal to one.More than one varying out variable is bound to the same number and index.The explicit binding assigments do not leave enough space for the linker        to automatically assign a location for a varying out array, which requires        multiple contiguous locations.The count specified by glTransformFeedbackVaryings        is non-zero, but the program object has no vertex or geometry shader.Any variable name specified to glTransformFeedbackVaryings        in the varyings array is not declared as an output in the vertex shader (or the geometry shader, if active).Any two entries in the varyings array given        glTransformFeedbackVaryings        specify the same varying variable.The total number of components to capture in any transform feedback varying variable        is  greater  than  the  constant GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS        and the buffer mode is GL_SEPARATE_ATTRIBS.
        /// When a program object has been successfully linked, the    program object can be made part of current state by calling    glUseProgram.    Whether or not the link operation was successful, the program    object's information log will be overwritten. The information    log can be retrieved by calling    glGetProgramInfoLog.
        /// glLinkProgram will also install the    generated executables as part of the current rendering state if    the link operation was successful and the specified program    object is already currently in use as a result of a previous    call to    glUseProgram.    If the program object currently in use is relinked    unsuccessfully, its link status will be set to    GL_FALSE , but the executables and    associated state will remain part of the current state until a    subsequent call to glUseProgram removes it    from use. After it is removed from use, it cannot be made part    of current state until it has been successfully relinked.
        /// If program contains shader objects    of type GL_VERTEX_SHADER, and optionally of type GL_GEOMETRY_SHADER,    but does not contain shader objects of type    GL_FRAGMENT_SHADER, the vertex shader executable will    be installed on the programmable vertex processor, the geometry shader executable, if present,    will be installed on the programmable geometry processor, but no executable will    be installed on the fragment processor. The results of    rasterizing primitives with such a program will be undefined.
        /// The program object's information log is updated and the    program is generated at the time of the link operation. After    the link operation, applications are free to modify attached    shader objects, compile attached shader objects, detach shader    objects, delete shader objects, and attach additional shader    objects. None of these operations affects the information log or    the program that is part of the program object.
        /// </summary>
        /// <param name="program">Specifies the handle of the program object to be linked.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LinkProgram(uint program) => _LinkProgram(program);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LinkProgramARB(int programObj) => _LinkProgramARB(programObj);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ListBase(uint @base) => _ListBase(@base);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr* indirects, int[] sizes, uint[] states, uint[] fbos, uint count) => _ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states, fbos, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr* indirects, void* sizes, void* states, void* fbos, uint count) => _ListDrawCommandsStatesClientNV_ptr(list, segment, indirects, sizes, states, fbos, count);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr* indirects, IntPtr sizes, IntPtr states, IntPtr fbos, uint count) => _ListDrawCommandsStatesClientNV_intptr(list, segment, indirects, sizes, states, fbos, count);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ListParameterfSGIX(uint list, ListParameterName pname, float param) => _ListParameterfSGIX(list, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ListParameterfvSGIX(uint list, ListParameterName pname, float[] @params) => _ListParameterfvSGIX(list, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ListParameterfvSGIX(uint list, ListParameterName pname, void* @params) => _ListParameterfvSGIX_ptr(list, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ListParameterfvSGIX(uint list, ListParameterName pname, IntPtr @params) => _ListParameterfvSGIX_intptr(list, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ListParameteriSGIX(uint list, ListParameterName pname, int param) => _ListParameteriSGIX(list, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ListParameterivSGIX(uint list, ListParameterName pname, int[] @params) => _ListParameterivSGIX(list, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ListParameterivSGIX(uint list, ListParameterName pname, void* @params) => _ListParameterivSGIX_ptr(list, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ListParameterivSGIX(uint list, ListParameterName pname, IntPtr @params) => _ListParameterivSGIX_intptr(list, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadIdentity() => _LoadIdentity();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadIdentityDeformationMapSGIX(int mask) => _LoadIdentityDeformationMapSGIX(mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadMatrixd(double[] m) => _LoadMatrixd(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadMatrixd(void* m) => _LoadMatrixd_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadMatrixd(IntPtr m) => _LoadMatrixd_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadMatrixf(float[] m) => _LoadMatrixf(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadMatrixf(void* m) => _LoadMatrixf_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadMatrixf(IntPtr m) => _LoadMatrixf_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadMatrixx(float[] m) => _LoadMatrixx(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadMatrixx(void* m) => _LoadMatrixx_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadMatrixx(IntPtr m) => _LoadMatrixx_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadMatrixxOES(float[] m) => _LoadMatrixxOES(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadMatrixxOES(void* m) => _LoadMatrixxOES_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadMatrixxOES(IntPtr m) => _LoadMatrixxOES_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadName(uint name) => _LoadName(name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadPaletteFromModelViewMatrixOES() => _LoadPaletteFromModelViewMatrixOES();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadProgramNV(VertexAttribEnumNV target, uint id, int len, byte[] program) => _LoadProgramNV(target, id, len, program);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadProgramNV(VertexAttribEnumNV target, uint id, int len, void* program) => _LoadProgramNV_ptr(target, id, len, program);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadProgramNV(VertexAttribEnumNV target, uint id, int len, IntPtr program) => _LoadProgramNV_intptr(target, id, len, program);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadTransposeMatrixd(double[] m) => _LoadTransposeMatrixd(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadTransposeMatrixd(void* m) => _LoadTransposeMatrixd_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadTransposeMatrixd(IntPtr m) => _LoadTransposeMatrixd_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadTransposeMatrixdARB(double[] m) => _LoadTransposeMatrixdARB(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadTransposeMatrixdARB(void* m) => _LoadTransposeMatrixdARB_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadTransposeMatrixdARB(IntPtr m) => _LoadTransposeMatrixdARB_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadTransposeMatrixf(float[] m) => _LoadTransposeMatrixf(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadTransposeMatrixf(void* m) => _LoadTransposeMatrixf_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadTransposeMatrixf(IntPtr m) => _LoadTransposeMatrixf_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadTransposeMatrixfARB(float[] m) => _LoadTransposeMatrixfARB(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadTransposeMatrixfARB(void* m) => _LoadTransposeMatrixfARB_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadTransposeMatrixfARB(IntPtr m) => _LoadTransposeMatrixfARB_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadTransposeMatrixxOES(float[] m) => _LoadTransposeMatrixxOES(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadTransposeMatrixxOES(void* m) => _LoadTransposeMatrixxOES_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LoadTransposeMatrixxOES(IntPtr m) => _LoadTransposeMatrixxOES_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LockArraysEXT(int first, int count) => _LockArraysEXT(first, count);

        // ---

        /// <summary>
        /// glLogicOp specifies a logical operation that,            when enabled,            is applied between the incoming RGBA color            and the RGBA color at the corresponding location in the            frame buffer.            To enable or disable the logical operation, call            glEnable and glDisable            using the symbolic constant GL_COLOR_LOGIC_OP. The initial value is            disabled.
        /// Opcode  Resulting Operation GL_CLEAR                            0                        GL_SET                            1                        GL_COPY                            s                        GL_COPY_INVERTED                            ~s                        GL_NOOP                            d                        GL_INVERT                            ~d                        GL_AND                            s & d                        GL_NAND                            ~(s & d)                        GL_OR                            s | d                        GL_NOR                            ~(s | d)                        GL_XOR                            s ^ d                        GL_EQUIV                            ~(s ^ d)                        GL_AND_REVERSE                            s & ~d                        GL_AND_INVERTED                            ~s & d                        GL_OR_REVERSE                            s | ~d                        GL_OR_INVERTED                            ~s | d
        /// opcode is a symbolic constant chosen from the list above.            In the explanation of the logical operations,            s represents the incoming color and            d represents the color in the frame buffer.            Standard C-language operators are used.            As these bitwise operators suggest,            the logical operation is applied independently to each bit pair of the            source and destination colors.
        /// </summary>
        /// <param name="opcode">Specifies a symbolic constant that selects a logical operation.                    The following symbols are accepted:                    GL_CLEAR,                    GL_SET,                    GL_COPY,                    GL_COPY_INVERTED,                    GL_NOOP,                    GL_INVERT,                    GL_AND,                    GL_NAND,                    GL_OR,                    GL_NOR,                    GL_XOR,                    GL_EQUIV,                    GL_AND_REVERSE,                    GL_AND_INVERTED,                    GL_OR_REVERSE, and                    GL_OR_INVERTED. The initial value is GL_COPY.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LogicOp(LogicOp opcode) => _LogicOp(opcode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MakeBufferNonResidentNV(int target) => _MakeBufferNonResidentNV(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MakeBufferResidentNV(int target, int access) => _MakeBufferResidentNV(target, access);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MakeImageHandleNonResidentARB(UInt64 handle) => _MakeImageHandleNonResidentARB(handle);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MakeImageHandleNonResidentNV(UInt64 handle) => _MakeImageHandleNonResidentNV(handle);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MakeImageHandleResidentARB(UInt64 handle, int access) => _MakeImageHandleResidentARB(handle, access);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MakeImageHandleResidentNV(UInt64 handle, int access) => _MakeImageHandleResidentNV(handle, access);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MakeNamedBufferNonResidentNV(uint buffer) => _MakeNamedBufferNonResidentNV(buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MakeNamedBufferResidentNV(uint buffer, int access) => _MakeNamedBufferResidentNV(buffer, access);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MakeTextureHandleNonResidentARB(UInt64 handle) => _MakeTextureHandleNonResidentARB(handle);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MakeTextureHandleNonResidentNV(UInt64 handle) => _MakeTextureHandleNonResidentNV(handle);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MakeTextureHandleResidentARB(UInt64 handle) => _MakeTextureHandleResidentARB(handle);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MakeTextureHandleResidentNV(UInt64 handle) => _MakeTextureHandleResidentNV(handle);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Map1d(MapTarget target, double u1, double u2, int stride, int order, double[] points) => _Map1d(target, u1, u2, stride, order, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Map1d(MapTarget target, double u1, double u2, int stride, int order, void* points) => _Map1d_ptr(target, u1, u2, stride, order, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Map1d(MapTarget target, double u1, double u2, int stride, int order, IntPtr points) => _Map1d_intptr(target, u1, u2, stride, order, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Map1f(MapTarget target, float u1, float u2, int stride, int order, float[] points) => _Map1f(target, u1, u2, stride, order, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Map1f(MapTarget target, float u1, float u2, int stride, int order, void* points) => _Map1f_ptr(target, u1, u2, stride, order, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Map1f(MapTarget target, float u1, float u2, int stride, int order, IntPtr points) => _Map1f_intptr(target, u1, u2, stride, order, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Map1xOES(MapTarget target, float u1, float u2, int stride, int order, float points) => _Map1xOES(target, u1, u2, stride, order, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Map2d(MapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double[] points) => _Map2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Map2d(MapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, void* points) => _Map2d_ptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Map2d(MapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, IntPtr points) => _Map2d_intptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Map2f(MapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float[] points) => _Map2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Map2f(MapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, void* points) => _Map2f_ptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Map2f(MapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, IntPtr points) => _Map2f_intptr(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Map2xOES(MapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float points) => _Map2xOES(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);

        // ---

        /// <summary>
        /// glMapBuffer and            glMapNamedBuffer map the entire data store            of a specified buffer object into the client's address space.            The data can then be directly read and/or written relative to            the returned pointer, depending on the specified            access policy.
        /// A pointer to the beginning of the mapped range is returned once            all pending operations on that buffer object have completed, and            may be used to modify and/or query the corresponding range of            the data store according to the value of            access:            GL_READ_ONLY indicates that                        the returned pointer may be used to read buffer                        object data.                     GL_WRITE_ONLY indicates that                        the returned pointer may be used to modify buffer                        object data.                     GL_READ_WRITE indicates that                        the returned pointer may be used to read and to                        modify buffer object data.
        /// If an error is generated, a NULL pointer is            returned.
        /// If no error occurs, the returned pointer will reflect an            allocation aligned to the value of            GL_MIN_MAP_BUFFER_ALIGNMENT basic machine            units.
        /// The returned pointer values may not be passed as parameter            values to GL commands. For example, they may not be used to            specify array pointers, or to specify or query pixel or texture            image data; such actions produce undefined results, although            implementations may not check for such behavior for performance            reasons.
        /// No GL error is generated if the returned pointer is accessed in            a way inconsistent with access (e.g. used            to read from a mapping made with accessGL_WRITE_ONLY or write to a mapping made            with accessGL_READ_ONLY), but the result is undefined            and system errors (possibly including program termination) may            occur.
        /// Mappings to the data stores of buffer objects may have            nonstandard performance characteristics. For example, such            mappings may be marked as uncacheable regions of memory, and in            such cases reading from them may be very slow. To ensure optimal            performance, the client should use the mapping in a fashion            consistent with the values of            GL_BUFFER_USAGE for the buffer object and            of access. Using a mapping in a fashion            inconsistent with these values is liable to be multiple orders            of magnitude slower than using normal memory.
        /// </summary>
        /// <param name="target">Specifies the target to which the buffer object is bound                    for glMapBuffer, which must be one                    of the buffer binding targets in the following table:</param>
        /// <param name="buffer">Specifies the name of the buffer object for                    glMapNamedBuffer.</param>
        /// <param name="access">Specifies the access policy for                    glMapBuffer and                    glMapNamedBuffer, indicating                    whether it will be possible to read from, write to, or                    both read from and write to the buffer object's mapped                    data store. The symbolic constant must be                    GL_READ_ONLY,                    GL_WRITE_ONLY, or                    GL_READ_WRITE.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapBuffer(BufferTargetARB target, BufferAccessARB access) => _MapBuffer(target, access);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapBufferARB(BufferTargetARB target, BufferAccessARB access) => _MapBufferARB(target, access);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapBufferOES(BufferTargetARB target, BufferAccessARB access) => _MapBufferOES(target, access);

        // ---

        /// <summary>
        /// glMapBufferRange and            glMapNamedBufferRange map all or part of            the data store of a specified buffer object into the client's            address space. offset and            length indicate the range of data in the            buffer object that is to be mapped, in terms of basic machine            units. access is a bitfield containing            flags which describe the requested mapping. These flags are            described below.
        /// A pointer to the beginning of the mapped range is returned once            all pending operations on the buffer object have completed, and            may be used to modify and/or query the corresponding range of            the data store according to the following flag bits set in            access:            GL_MAP_READ_BIT indicates that                        the returned pointer may be used to read buffer                        object data. No GL error is generated if the pointer                        is used to query a mapping which excludes this flag,                        but the result is undefined and system errors                        (possibly including program termination) may occur.                    GL_MAP_WRITE_BIT indicates that                        the returned pointer may be used to modify buffer                        object data. No GL error is generated if the pointer                        is used to modify a mapping which excludes this                        flag, but the result is undefined and system errors                        (possibly including program termination) may occur.                    GL_MAP_PERSISTENT_BIT indicates                        that the mapping is to be made in a persistent                        fashion and that the client intends to hold and use                        the returned pointer during subsequent GL operation.                        It is not an error to call drawing commands (render)                        while buffers are mapped using this flag. It is an                        error to specify this flag if the buffer's data                        store was not allocated through a call to the                        glBufferStorage                        command in which the                        GL_MAP_PERSISTENT_BIT was also                        set.                    GL_MAP_COHERENT_BIT indicates                        that a persistent mapping is also to be coherent.                        Coherent maps guarantee that the effect of writes to                        a buffer's data store by either the client or server                        will eventually become visible to the other without                        further intervention from the application. In the                        absence of this bit, persistent mappings are not                        coherent and modified ranges of the buffer store                        must be explicitly communicated to the GL, either by                        unmapping the buffer, or through a call to                        glFlushMappedBufferRange                        or                        glMemoryBarrier.
        /// The following optional flag bits in            access may be used to modify the mapping:            GL_MAP_INVALIDATE_RANGE_BIT                        indicates that the previous contents of the                        specified range may be discarded. Data within this                        range are undefined with the exception of                        subsequently written data. No GL error is generated                        if subsequent GL operations access unwritten data,                        but the result is undefined and system errors                        (possibly including program termination) may occur.                        This flag may not be used in combination with                        GL_MAP_READ_BIT.                    GL_MAP_INVALIDATE_BUFFER_BIT                        indicates that the previous contents of the entire                        buffer may be discarded. Data within the entire                        buffer are undefined with the exception of                        subsequently written data. No GL error is generated                        if subsequent GL operations access unwritten data,                        but the result is undefined and system errors                        (possibly including program termination) may occur.                        This flag may not be used in combination with                        GL_MAP_READ_BIT.                    GL_MAP_FLUSH_EXPLICIT_BIT                        indicates that one or more discrete subranges of the                        mapping may be modified. When this flag is set,                        modifications to each subrange must be explicitly                        flushed by calling                        glFlushMappedBufferRange.                        No GL error is set if a subrange of the mapping is                        modified and not flushed, but data within the                        corresponding subrange of the buffer are undefined.                        This flag may only be used in conjunction with                        GL_MAP_WRITE_BIT. When this                        option is selected, flushing is strictly limited to                        regions that are explicitly indicated with calls to                        glFlushMappedBufferRange                        prior to unmap; if this option is not selected                        glUnmapBuffer                        will automatically flush the entire mapped range                        when called.                    GL_MAP_UNSYNCHRONIZED_BIT                        indicates that the GL should not attempt to                        synchronize pending operations on the buffer prior                        to returning from                        glMapBufferRange or                        glMapNamedBufferRange. No GL                        error is generated if pending operations which                        source or modify the buffer overlap the mapped                        region, but the result of such previous and any                        subsequent operations is undefined.
        /// If an error occurs, a NULL pointer is returned.
        /// If no error occurs, the returned pointer will reflect an            allocation aligned to the value of            GL_MIN_MAP_BUFFER_ALIGNMENT basic machine            units. Subtracting offset from this            returned pointer will always produce a multiple of the value of            GL_MIN_MAP_BUFFER_ALIGNMENT.
        /// The returned pointer values may not be passed as parameter            values to GL commands. For example, they may not be used to            specify array pointers, or to specify or query pixel or texture            image data; such actions produce undefined results, although            implementations may not check for such behavior for performance            reasons.
        /// Mappings to the data stores of buffer objects may have            nonstandard performance characteristics. For example, such            mappings may be marked as uncacheable regions of memory, and in            such cases reading from them may be very slow. To ensure optimal            performance, the client should use the mapping in a fashion            consistent with the values of            GL_BUFFER_USAGE for the buffer object and            of access. Using a mapping in a fashion            inconsistent with these values is liable to be multiple orders            of magnitude slower than using normal memory.
        /// </summary>
        /// <param name="target">Specifies the target to which the buffer object is bound                    for glMapBufferRange, which must be                    one of the buffer binding targets in the following                    table:</param>
        /// <param name="buffer">Specifies the name of the buffer object for                    glMapNamedBufferRange.</param>
        /// <param name="offset">Specifies the starting offset within the buffer of the                    range to be mapped.</param>
        /// <param name="length">Specifies the length of the range to be mapped.</param>
        /// <param name="access">Specifies a combination of access flags indicating the                    desired access to the mapped range.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapBufferRange(BufferTargetARB target, IntPtr offset, IntPtr length, int access) => _MapBufferRange(target, offset, length, access);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapBufferRangeEXT(BufferTargetARB target, IntPtr offset, IntPtr length, int access) => _MapBufferRangeEXT(target, offset, length, access);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapControlPointsNV(EvalTargetNV target, uint index, MapTypeNV type, int ustride, int vstride, int uorder, int vorder, bool packed, IntPtr points) => _MapControlPointsNV(target, index, type, ustride, vstride, uorder, vorder, packed, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapGrid1d(int un, double u1, double u2) => _MapGrid1d(un, u1, u2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapGrid1f(int un, float u1, float u2) => _MapGrid1f(un, u1, u2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapGrid1xOES(int n, float u1, float u2) => _MapGrid1xOES(n, u1, u2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapGrid2d(int un, double u1, double u2, int vn, double v1, double v2) => _MapGrid2d(un, u1, u2, vn, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapGrid2f(int un, float u1, float u2, int vn, float v1, float v2) => _MapGrid2f(un, u1, u2, vn, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapGrid2xOES(int n, float u1, float u2, float v1, float v2) => _MapGrid2xOES(n, u1, u2, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapNamedBuffer(uint buffer, BufferAccessARB access) => _MapNamedBuffer(buffer, access);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapNamedBufferEXT(uint buffer, BufferAccessARB access) => _MapNamedBufferEXT(buffer, access);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapNamedBufferRange(uint buffer, IntPtr offset, IntPtr length, int access) => _MapNamedBufferRange(buffer, offset, length, access);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapNamedBufferRangeEXT(uint buffer, IntPtr offset, IntPtr length, int access) => _MapNamedBufferRangeEXT(buffer, offset, length, access);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapObjectBufferATI(uint buffer) => _MapObjectBufferATI(buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapParameterfvNV(EvalTargetNV target, MapParameterNV pname, float[] @params) => _MapParameterfvNV(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapParameterfvNV(EvalTargetNV target, MapParameterNV pname, void* @params) => _MapParameterfvNV_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapParameterfvNV(EvalTargetNV target, MapParameterNV pname, IntPtr @params) => _MapParameterfvNV_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapParameterivNV(EvalTargetNV target, MapParameterNV pname, int[] @params) => _MapParameterivNV(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapParameterivNV(EvalTargetNV target, MapParameterNV pname, void* @params) => _MapParameterivNV_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapParameterivNV(EvalTargetNV target, MapParameterNV pname, IntPtr @params) => _MapParameterivNV_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapTexture2DINTEL(uint texture, int level, int access, out int stride, out int layout) => _MapTexture2DINTEL(texture, level, access, out stride, out layout);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapVertexAttrib1dAPPLE(uint index, uint size, double u1, double u2, int stride, int order, double[] points) => _MapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapVertexAttrib1dAPPLE(uint index, uint size, double u1, double u2, int stride, int order, void* points) => _MapVertexAttrib1dAPPLE_ptr(index, size, u1, u2, stride, order, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapVertexAttrib1dAPPLE(uint index, uint size, double u1, double u2, int stride, int order, IntPtr points) => _MapVertexAttrib1dAPPLE_intptr(index, size, u1, u2, stride, order, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapVertexAttrib1fAPPLE(uint index, uint size, float u1, float u2, int stride, int order, float[] points) => _MapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapVertexAttrib1fAPPLE(uint index, uint size, float u1, float u2, int stride, int order, void* points) => _MapVertexAttrib1fAPPLE_ptr(index, size, u1, u2, stride, order, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapVertexAttrib1fAPPLE(uint index, uint size, float u1, float u2, int stride, int order, IntPtr points) => _MapVertexAttrib1fAPPLE_intptr(index, size, u1, u2, stride, order, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapVertexAttrib2dAPPLE(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double[] points) => _MapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapVertexAttrib2dAPPLE(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, void* points) => _MapVertexAttrib2dAPPLE_ptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapVertexAttrib2dAPPLE(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, IntPtr points) => _MapVertexAttrib2dAPPLE_intptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapVertexAttrib2fAPPLE(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float[] points) => _MapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapVertexAttrib2fAPPLE(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, void* points) => _MapVertexAttrib2fAPPLE_ptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MapVertexAttrib2fAPPLE(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, IntPtr points) => _MapVertexAttrib2fAPPLE_intptr(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Materialf(MaterialFace face, MaterialParameter pname, float param) => _Materialf(face, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Materialfv(MaterialFace face, MaterialParameter pname, float[] @params) => _Materialfv(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Materialfv(MaterialFace face, MaterialParameter pname, void* @params) => _Materialfv_ptr(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Materialfv(MaterialFace face, MaterialParameter pname, IntPtr @params) => _Materialfv_intptr(face, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Materiali(MaterialFace face, MaterialParameter pname, int param) => _Materiali(face, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Materialiv(MaterialFace face, MaterialParameter pname, int[] @params) => _Materialiv(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Materialiv(MaterialFace face, MaterialParameter pname, void* @params) => _Materialiv_ptr(face, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Materialiv(MaterialFace face, MaterialParameter pname, IntPtr @params) => _Materialiv_intptr(face, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Materialx(MaterialFace face, MaterialParameter pname, float param) => _Materialx(face, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MaterialxOES(MaterialFace face, MaterialParameter pname, float param) => _MaterialxOES(face, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Materialxv(MaterialFace face, MaterialParameter pname, float[] param) => _Materialxv(face, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Materialxv(MaterialFace face, MaterialParameter pname, void* param) => _Materialxv_ptr(face, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Materialxv(MaterialFace face, MaterialParameter pname, IntPtr param) => _Materialxv_intptr(face, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MaterialxvOES(MaterialFace face, MaterialParameter pname, float[] param) => _MaterialxvOES(face, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MaterialxvOES(MaterialFace face, MaterialParameter pname, void* param) => _MaterialxvOES_ptr(face, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MaterialxvOES(MaterialFace face, MaterialParameter pname, IntPtr param) => _MaterialxvOES_intptr(face, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixFrustumEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => _MatrixFrustumEXT(mode, left, right, bottom, top, zNear, zFar);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixIndexPointerARB(int size, MatrixIndexPointerTypeARB type, int stride, IntPtr pointer) => _MatrixIndexPointerARB(size, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixIndexPointerOES(int size, MatrixIndexPointerTypeARB type, int stride, IntPtr pointer) => _MatrixIndexPointerOES(size, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixIndexubvARB(int size, byte[] indices) => _MatrixIndexubvARB(size, indices);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixIndexubvARB(int size, void* indices) => _MatrixIndexubvARB_ptr(size, indices);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixIndexubvARB(int size, IntPtr indices) => _MatrixIndexubvARB_intptr(size, indices);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixIndexuivARB(int size, uint[] indices) => _MatrixIndexuivARB(size, indices);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixIndexuivARB(int size, void* indices) => _MatrixIndexuivARB_ptr(size, indices);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixIndexuivARB(int size, IntPtr indices) => _MatrixIndexuivARB_intptr(size, indices);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixIndexusvARB(int size, ushort[] indices) => _MatrixIndexusvARB(size, indices);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixIndexusvARB(int size, void* indices) => _MatrixIndexusvARB_ptr(size, indices);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixIndexusvARB(int size, IntPtr indices) => _MatrixIndexusvARB_intptr(size, indices);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoad3x2fNV(int matrixMode, float[] m) => _MatrixLoad3x2fNV(matrixMode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoad3x2fNV(int matrixMode, void* m) => _MatrixLoad3x2fNV_ptr(matrixMode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoad3x2fNV(int matrixMode, IntPtr m) => _MatrixLoad3x2fNV_intptr(matrixMode, m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoad3x3fNV(int matrixMode, float[] m) => _MatrixLoad3x3fNV(matrixMode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoad3x3fNV(int matrixMode, void* m) => _MatrixLoad3x3fNV_ptr(matrixMode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoad3x3fNV(int matrixMode, IntPtr m) => _MatrixLoad3x3fNV_intptr(matrixMode, m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoadIdentityEXT(MatrixMode mode) => _MatrixLoadIdentityEXT(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoadTranspose3x3fNV(int matrixMode, float[] m) => _MatrixLoadTranspose3x3fNV(matrixMode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoadTranspose3x3fNV(int matrixMode, void* m) => _MatrixLoadTranspose3x3fNV_ptr(matrixMode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoadTranspose3x3fNV(int matrixMode, IntPtr m) => _MatrixLoadTranspose3x3fNV_intptr(matrixMode, m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoadTransposedEXT(MatrixMode mode, double[] m) => _MatrixLoadTransposedEXT(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoadTransposedEXT(MatrixMode mode, void* m) => _MatrixLoadTransposedEXT_ptr(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoadTransposedEXT(MatrixMode mode, IntPtr m) => _MatrixLoadTransposedEXT_intptr(mode, m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoadTransposefEXT(MatrixMode mode, float[] m) => _MatrixLoadTransposefEXT(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoadTransposefEXT(MatrixMode mode, void* m) => _MatrixLoadTransposefEXT_ptr(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoadTransposefEXT(MatrixMode mode, IntPtr m) => _MatrixLoadTransposefEXT_intptr(mode, m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoaddEXT(MatrixMode mode, double[] m) => _MatrixLoaddEXT(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoaddEXT(MatrixMode mode, void* m) => _MatrixLoaddEXT_ptr(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoaddEXT(MatrixMode mode, IntPtr m) => _MatrixLoaddEXT_intptr(mode, m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoadfEXT(MatrixMode mode, float[] m) => _MatrixLoadfEXT(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoadfEXT(MatrixMode mode, void* m) => _MatrixLoadfEXT_ptr(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixLoadfEXT(MatrixMode mode, IntPtr m) => _MatrixLoadfEXT_intptr(mode, m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMode(MatrixMode mode) => _MatrixMode(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMult3x2fNV(int matrixMode, float[] m) => _MatrixMult3x2fNV(matrixMode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMult3x2fNV(int matrixMode, void* m) => _MatrixMult3x2fNV_ptr(matrixMode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMult3x2fNV(int matrixMode, IntPtr m) => _MatrixMult3x2fNV_intptr(matrixMode, m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMult3x3fNV(int matrixMode, float[] m) => _MatrixMult3x3fNV(matrixMode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMult3x3fNV(int matrixMode, void* m) => _MatrixMult3x3fNV_ptr(matrixMode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMult3x3fNV(int matrixMode, IntPtr m) => _MatrixMult3x3fNV_intptr(matrixMode, m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMultTranspose3x3fNV(int matrixMode, float[] m) => _MatrixMultTranspose3x3fNV(matrixMode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMultTranspose3x3fNV(int matrixMode, void* m) => _MatrixMultTranspose3x3fNV_ptr(matrixMode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMultTranspose3x3fNV(int matrixMode, IntPtr m) => _MatrixMultTranspose3x3fNV_intptr(matrixMode, m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMultTransposedEXT(MatrixMode mode, double[] m) => _MatrixMultTransposedEXT(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMultTransposedEXT(MatrixMode mode, void* m) => _MatrixMultTransposedEXT_ptr(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMultTransposedEXT(MatrixMode mode, IntPtr m) => _MatrixMultTransposedEXT_intptr(mode, m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMultTransposefEXT(MatrixMode mode, float[] m) => _MatrixMultTransposefEXT(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMultTransposefEXT(MatrixMode mode, void* m) => _MatrixMultTransposefEXT_ptr(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMultTransposefEXT(MatrixMode mode, IntPtr m) => _MatrixMultTransposefEXT_intptr(mode, m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMultdEXT(MatrixMode mode, double[] m) => _MatrixMultdEXT(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMultdEXT(MatrixMode mode, void* m) => _MatrixMultdEXT_ptr(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMultdEXT(MatrixMode mode, IntPtr m) => _MatrixMultdEXT_intptr(mode, m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMultfEXT(MatrixMode mode, float[] m) => _MatrixMultfEXT(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMultfEXT(MatrixMode mode, void* m) => _MatrixMultfEXT_ptr(mode, m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixMultfEXT(MatrixMode mode, IntPtr m) => _MatrixMultfEXT_intptr(mode, m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixOrthoEXT(MatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar) => _MatrixOrthoEXT(mode, left, right, bottom, top, zNear, zFar);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixPopEXT(MatrixMode mode) => _MatrixPopEXT(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixPushEXT(MatrixMode mode) => _MatrixPushEXT(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixRotatedEXT(MatrixMode mode, double angle, double x, double y, double z) => _MatrixRotatedEXT(mode, angle, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixRotatefEXT(MatrixMode mode, float angle, float x, float y, float z) => _MatrixRotatefEXT(mode, angle, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixScaledEXT(MatrixMode mode, double x, double y, double z) => _MatrixScaledEXT(mode, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixScalefEXT(MatrixMode mode, float x, float y, float z) => _MatrixScalefEXT(mode, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixTranslatedEXT(MatrixMode mode, double x, double y, double z) => _MatrixTranslatedEXT(mode, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MatrixTranslatefEXT(MatrixMode mode, float x, float y, float z) => _MatrixTranslatefEXT(mode, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MaxShaderCompilerThreadsKHR(uint count) => _MaxShaderCompilerThreadsKHR(count);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MaxShaderCompilerThreadsARB(uint count) => _MaxShaderCompilerThreadsARB(count);

        // ---

        /// <summary>
        /// glMemoryBarrier defines a barrier ordering            the memory transactions issued prior to the command relative to            those issued after the barrier. For the purposes of this            ordering, memory transactions performed by shaders are            considered to be issued by the rendering command that triggered            the execution of the shader. barriers is            a bitfield indicating the set of operations that are            synchronized with shader stores; the bits used in            barriers are as follows:
        /// GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT                        If set, vertex data sourced from                        buffer objects after the barrier will reflect data written by shaders                        prior to the barrier.  The set of buffer objects affected by this bit                        is derived from the buffer object bindings used for                        generic vertex attributes derived from the GL_VERTEX_ATTRIB_ARRAY_BUFFER bindings.                    GL_ELEMENT_ARRAY_BARRIER_BIT                        If set, vertex array indices sourced from                        buffer objects after the barrier will reflect data written by shaders                        prior to the barrier.  The buffer objects affected by this bit are                        derived from the GL_ELEMENT_ARRAY_BUFFER binding.                    GL_UNIFORM_BARRIER_BIT                        Shader uniforms sourced from buffer objects after the barrier will reflect data                        written by shaders prior to the barrier.                    GL_TEXTURE_FETCH_BARRIER_BIT                        Texture fetches from shaders, including                        fetches from buffer object memory via buffer textures, after the                        barrier will reflect data written by shaders prior to the barrier.                    GL_SHADER_IMAGE_ACCESS_BARRIER_BIT                        Memory accesses using shader image                        load, store, and atomic built-in functions issued after the barrier                        will reflect data written by shaders prior to the barrier.                        Additionally, image stores and atomics issued after the barrier will                        not execute until all memory accesses (e.g., loads, stores, texture                        fetches, vertex fetches) initiated prior to the barrier complete.                    GL_COMMAND_BARRIER_BIT                        Command data sourced from buffer objects by                        Draw*Indirect commands after the barrier will reflect data written by                        shaders prior to the barrier.  The buffer objects affected by this bit                        are derived from the GL_DRAW_INDIRECT_BUFFER binding.                     GL_PIXEL_BUFFER_BARRIER_BIT                        Reads and writes of buffer objects via the                        GL_PIXEL_PACK_BUFFER and                        GL_PIXEL_UNPACK_BUFFER bindings                        (via                        glReadPixels,                        glTexSubImage1D,                        etc.) after the barrier will reflect data written by                        shaders prior to the barrier. Additionally, buffer                        object writes issued after the barrier will wait on                        the completion of all shader writes initiated prior                        to the barrier.                    GL_TEXTURE_UPDATE_BARRIER_BIT                        Writes to a texture via glTex(Sub)Image*,                        glCopyTex(Sub)Image*, glCompressedTex(Sub)Image*, and reads via                        glGetTexImage after the barrier will reflect data written by shaders                        prior to the barrier.  Additionally, texture writes from these                        commands issued after the barrier will not execute until all shader                        writes initiated prior to the barrier complete.                    GL_BUFFER_UPDATE_BARRIER_BIT                        Reads or writes via glBufferSubData,                        glCopyBufferSubData,                        or glGetBufferSubData, or                        to buffer object memory mapped by glMapBuffer                        or glMapBufferRange after the barrier                        will reflect data written by shaders prior to the barrier.                        Additionally, writes via these commands issued after the barrier will                        wait on the completion of any shader writes to the same memory                        initiated prior to the barrier.                    GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT                        Access by the client to persistent mapped regions of buffer objects                        will reflect data written by shaders prior to the barrier. Note that                        this may cause additional synchronization operations.                    GL_FRAMEBUFFER_BARRIER_BIT                        Reads and writes via framebuffer object                        attachments after the barrier will reflect data written by shaders                        prior to the barrier.  Additionally, framebuffer writes issued after                        the barrier will wait on the completion of all shader writes issued                        prior to the barrier.                    GL_TRANSFORM_FEEDBACK_BARRIER_BIT                        Writes via transform feedback                        bindings after the barrier will reflect data written by shaders prior                        to the barrier.  Additionally, transform feedback writes issued after                        the barrier will wait on the completion of all shader writes issued                        prior to the barrier.                    GL_ATOMIC_COUNTER_BARRIER_BIT                        Accesses to atomic counters after the                        barrier will reflect writes prior to the barrier.                    GL_SHADER_STORAGE_BARRIER_BIT                        Accesses to shader storage blocks after the                        barrier will reflect writes prior to the barrier.                    GL_QUERY_BUFFER_BARRIER_BIT                        Writes of buffer objects via the GL_QUERY_BUFFER                        binding after the barrier will reflect data written                        by shaders prior to the barrier. Additionally, buffer object writes                        issued after the barrier will wait on the completion of all shader                        writes initiated prior to the barrier.
        /// If barriers is            GL_ALL_BARRIER_BITS, shader memory accesses            will be synchronized relative to all the operations described            above.
        /// Implementations may cache buffer object and texture image memory that            could be written by shaders in multiple caches; for example, there may be            separate caches for texture, vertex fetching, and one or more caches for            shader memory accesses.  Implementations are not required to keep these            caches coherent with shader memory writes.  Stores issued by one            invocation may not be immediately observable by other pipeline stages or            other shader invocations because the value stored may remain in a cache            local to the processor executing the store, or because data overwritten by            the store is still in a cache elsewhere in the system. When            glMemoryBarrier is called, the GL flushes            and/or invalidates any caches relevant to the operations            specified by the barriers parameter to            ensure consistent ordering of operations across the barrier.
        /// To allow for independent shader invocations to communicate by reads and            writes to a common memory address, image variables in the OpenGL Shading            Language may be declared as "coherent".  Buffer object or texture image            memory accessed through such variables may be cached only if caches are            automatically updated due to stores issued by any other shader invocation.            If the same address is accessed using both coherent and non-coherent            variables, the accesses using variables declared as coherent will observe            the results stored using coherent variables in other invocations.  Using            variables declared as "coherent" guarantees only that the results of            stores will be immediately visible to shader invocations using            similarly-declared variables; calling            glMemoryBarrier is required to ensure that            the stores are visible to other operations.
        /// The following guidelines may be helpful in choosing when to use coherent            memory accesses and when to use barriers.
        /// Data that are read-only or constant may be accessed                        without using coherent variables or calling                        MemoryBarrier(). Updates to the                        read-only data via API calls such as                        glBufferSubData will invalidate                        shader caches implicitly as required.                                            Data that are shared between shader invocations at a                        fine granularity (e.g., written by one invocation,                        consumed by another invocation) should use coherent                        variables to read and write the shared data.                                            Data written by one shader invocation and consumed                        by other shader invocations launched as a result of                        its execution ("dependent invocations")                        should use coherent variables in the producing                        shader invocation and call                        memoryBarrier() after the last                        write. The consuming shader invocation should also                        use coherent variables.                                            Data written to image variables in one rendering                        pass and read by the shader in a later pass need not                        use coherent variables or memoryBarrier(). Calling                        glMemoryBarrier with the                        SHADER_IMAGE_ACCESS_BARRIER_BIT set in                        barriers between passes is                        necessary.                                            Data written by the shader in one rendering pass and                        read by another mechanism (e.g., vertex or index                        buffer pulling) in a later pass need not use                        coherent variables or                        memoryBarrier(). Calling                        glMemoryBarrier with the                        appropriate bits set in                        barriers between passes is                        necessary.
        /// </summary>
        /// <param name="barriers">Specifies the barriers to insert.                                    For glMemoryBarrier, must be a                    bitwise combination of any of                    GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT,                    GL_ELEMENT_ARRAY_BARRIER_BIT,                    GL_UNIFORM_BARRIER_BIT,                    GL_TEXTURE_FETCH_BARRIER_BIT,                    GL_SHADER_IMAGE_ACCESS_BARRIER_BIT,                    GL_COMMAND_BARRIER_BIT,                    GL_PIXEL_BUFFER_BARRIER_BIT,                    GL_TEXTURE_UPDATE_BARRIER_BIT,                    GL_BUFFER_UPDATE_BARRIER_BIT,                    GL_FRAMEBUFFER_BARRIER_BIT,                    GL_TRANSFORM_FEEDBACK_BARRIER_BIT,                    GL_ATOMIC_COUNTER_BARRIER_BIT, or                    GL_SHADER_STORAGE_BARRIER_BIT.                                    For glMemoryBarrier, must be a                    bitwise combination of any of                    GL_ATOMIC_COUNTER_BARRIER_BIT, or                    GL_FRAMEBUFFER_BARRIER_BIT,                    GL_SHADER_IMAGE_ACCESS_BARRIER_BIT,                    GL_SHADER_STORAGE_BARRIER_BIT.                    GL_TEXTURE_FETCH_BARRIER_BIT, or                    GL_UNIFORM_BARRIER_BIT.                                    If the special value                    GL_ALL_BARRIER_BITS is specified,                    all supported barriers for the corresponding command                    will be inserted.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MemoryBarrier(int barriers) => _MemoryBarrier(barriers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MemoryBarrierByRegion(int barriers) => _MemoryBarrierByRegion(barriers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MemoryBarrierEXT(int barriers) => _MemoryBarrierEXT(barriers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, int[] @params) => _MemoryObjectParameterivEXT(memoryObject, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, void* @params) => _MemoryObjectParameterivEXT_ptr(memoryObject, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MemoryObjectParameterivEXT(uint memoryObject, MemoryObjectParameterName pname, IntPtr @params) => _MemoryObjectParameterivEXT_intptr(memoryObject, pname, @params);

        // ---

        /// <summary>
        /// glMinSampleShading specifies the rate at which samples are shaded within            a covered pixel. Sample-rate shading is enabled by calling glEnable            with the parameter GL_SAMPLE_SHADING. If GL_MULTISAMPLE            or GL_SAMPLE_SHADING is disabled, sample shading has no effect.            Otherwise, an implementation must provide at least as many unique color values for            each covered fragment as specified by value times samples where            samples is the value of GL_SAMPLES for the current            framebuffer. At least 1 sample for each covered fragment is generated.
        /// A value of 1.0 indicates that each sample in the framebuffer should be            independently shaded. A value of 0.0 effectively allows the GL to ignore            sample rate shading. Any value between 0.0 and 1.0 allows the GL to shade only a subset            of the total samples within each covered fragment. Which samples are shaded and the algorithm            used to select that subset of the fragment's samples is implementation dependent.
        /// </summary>
        /// <param name="value">Specifies the rate at which samples are shaded within each covered pixel.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MinSampleShading(float value) => _MinSampleShading(value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MinSampleShadingARB(float value) => _MinSampleShadingARB(value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MinSampleShadingOES(float value) => _MinSampleShadingOES(value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Minmax(MinmaxTargetEXT target, InternalFormat internalformat, bool sink) => _Minmax(target, internalformat, sink);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MinmaxEXT(MinmaxTargetEXT target, InternalFormat internalformat, bool sink) => _MinmaxEXT(target, internalformat, sink);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultMatrixd(double[] m) => _MultMatrixd(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultMatrixd(void* m) => _MultMatrixd_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultMatrixd(IntPtr m) => _MultMatrixd_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultMatrixf(float[] m) => _MultMatrixf(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultMatrixf(void* m) => _MultMatrixf_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultMatrixf(IntPtr m) => _MultMatrixf_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultMatrixx(float[] m) => _MultMatrixx(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultMatrixx(void* m) => _MultMatrixx_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultMatrixx(IntPtr m) => _MultMatrixx_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultMatrixxOES(float[] m) => _MultMatrixxOES(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultMatrixxOES(void* m) => _MultMatrixxOES_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultMatrixxOES(IntPtr m) => _MultMatrixxOES_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultTransposeMatrixd(double[] m) => _MultTransposeMatrixd(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultTransposeMatrixd(void* m) => _MultTransposeMatrixd_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultTransposeMatrixd(IntPtr m) => _MultTransposeMatrixd_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultTransposeMatrixdARB(double[] m) => _MultTransposeMatrixdARB(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultTransposeMatrixdARB(void* m) => _MultTransposeMatrixdARB_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultTransposeMatrixdARB(IntPtr m) => _MultTransposeMatrixdARB_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultTransposeMatrixf(float[] m) => _MultTransposeMatrixf(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultTransposeMatrixf(void* m) => _MultTransposeMatrixf_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultTransposeMatrixf(IntPtr m) => _MultTransposeMatrixf_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultTransposeMatrixfARB(float[] m) => _MultTransposeMatrixfARB(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultTransposeMatrixfARB(void* m) => _MultTransposeMatrixfARB_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultTransposeMatrixfARB(IntPtr m) => _MultTransposeMatrixfARB_intptr(m);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultTransposeMatrixxOES(float[] m) => _MultTransposeMatrixxOES(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultTransposeMatrixxOES(void* m) => _MultTransposeMatrixxOES_ptr(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultTransposeMatrixxOES(IntPtr m) => _MultTransposeMatrixxOES_intptr(m);

        // ---

        /// <summary>
        /// glMultiDrawArrays specifies multiple sets of geometric primitives            with very few subroutine calls. Instead of calling a GL procedure            to pass each individual vertex, normal, texture coordinate, edge            flag, or color, you can prespecify            separate arrays of vertices, normals, and colors and use them to            construct a sequence of primitives with a single            call to glMultiDrawArrays.
        /// glMultiDrawArrays behaves identically to glDrawArrays except that drawcount            separate ranges of elements are specified instead.
        /// When glMultiDrawArrays is called, it uses count sequential elements from each            enabled array to construct a sequence of geometric primitives,            beginning with element first. mode specifies what kind of            primitives are constructed, and how the array elements            construct those primitives.
        /// Vertex attributes that are modified by glMultiDrawArrays have an            unspecified value after glMultiDrawArrays returns. Attributes that aren't            modified remain well defined.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="first">Points to an array of starting indices in the enabled arrays.</param>
        /// <param name="count">Points to an array of the number of indices to be rendered.</param>
        /// <param name="drawcount">Specifies the size of the first and count</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawArrays(PrimitiveType mode, int[] first, int[] count, int drawcount) => _MultiDrawArrays(mode, first, count, drawcount);

        /// <summary>
        /// glMultiDrawArrays specifies multiple sets of geometric primitives            with very few subroutine calls. Instead of calling a GL procedure            to pass each individual vertex, normal, texture coordinate, edge            flag, or color, you can prespecify            separate arrays of vertices, normals, and colors and use them to            construct a sequence of primitives with a single            call to glMultiDrawArrays.
        /// glMultiDrawArrays behaves identically to glDrawArrays except that drawcount            separate ranges of elements are specified instead.
        /// When glMultiDrawArrays is called, it uses count sequential elements from each            enabled array to construct a sequence of geometric primitives,            beginning with element first. mode specifies what kind of            primitives are constructed, and how the array elements            construct those primitives.
        /// Vertex attributes that are modified by glMultiDrawArrays have an            unspecified value after glMultiDrawArrays returns. Attributes that aren't            modified remain well defined.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="first">Points to an array of starting indices in the enabled arrays.</param>
        /// <param name="count">Points to an array of the number of indices to be rendered.</param>
        /// <param name="drawcount">Specifies the size of the first and count</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawArrays(PrimitiveType mode, void* first, void* count, int drawcount) => _MultiDrawArrays_ptr(mode, first, count, drawcount);

        /// <summary>
        /// glMultiDrawArrays specifies multiple sets of geometric primitives            with very few subroutine calls. Instead of calling a GL procedure            to pass each individual vertex, normal, texture coordinate, edge            flag, or color, you can prespecify            separate arrays of vertices, normals, and colors and use them to            construct a sequence of primitives with a single            call to glMultiDrawArrays.
        /// glMultiDrawArrays behaves identically to glDrawArrays except that drawcount            separate ranges of elements are specified instead.
        /// When glMultiDrawArrays is called, it uses count sequential elements from each            enabled array to construct a sequence of geometric primitives,            beginning with element first. mode specifies what kind of            primitives are constructed, and how the array elements            construct those primitives.
        /// Vertex attributes that are modified by glMultiDrawArrays have an            unspecified value after glMultiDrawArrays returns. Attributes that aren't            modified remain well defined.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="first">Points to an array of starting indices in the enabled arrays.</param>
        /// <param name="count">Points to an array of the number of indices to be rendered.</param>
        /// <param name="drawcount">Specifies the size of the first and count</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawArrays(PrimitiveType mode, IntPtr first, IntPtr count, int drawcount) => _MultiDrawArrays_intptr(mode, first, count, drawcount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawArraysEXT(PrimitiveType mode, int[] first, int[] count, int primcount) => _MultiDrawArraysEXT(mode, first, count, primcount);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawArraysEXT(PrimitiveType mode, void* first, void* count, int primcount) => _MultiDrawArraysEXT_ptr(mode, first, count, primcount);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawArraysEXT(PrimitiveType mode, IntPtr first, IntPtr count, int primcount) => _MultiDrawArraysEXT_intptr(mode, first, count, primcount);

        // ---

        /// <summary>
        /// glMultiDrawArraysIndirect specifies multiple geometric primitives            with very few subroutine calls. glMultiDrawArraysIndirect behaves            similarly to a multitude of calls to glDrawArraysInstancedBaseInstance,            execept that the parameters to each call to glDrawArraysInstancedBaseInstance            are stored in an array in memory at the address given by indirect, separated            by the stride, in basic machine units, specified by stride. If stride            is zero, then the array is assumed to be tightly packed in memory.
        /// The parameters addressed by indirect are packed into an array of structures,            each element of which takes the form (in C):                typedef  struct {        uint  count;        uint  instanceCount;        uint  first;        uint  baseInstance;    } DrawArraysIndirectCommand;
        /// A single call to glMultiDrawArraysIndirect is equivalent, assuming no errors            are generated to:                GLsizei n;    for (n = 0; n < drawcount; n++) {        const DrawArraysIndirectCommand *cmd;        if (stride != 0) {            cmd = (const DrawArraysIndirectCommand  *)((uintptr)indirect + n * stride);        } else  {            cmd = (const DrawArraysIndirectCommand  *)indirect + n;        }        glDrawArraysInstancedBaseInstance(mode, cmd->first, cmd->count, cmd->instanceCount, cmd->baseInstance);    }
        /// If a buffer is bound to the GL_DRAW_INDIRECT_BUFFER binding at the time            of a call to glMultiDrawArraysIndirect, indirect            is interpreted as an offset, in basic machine units, into that buffer and the parameter            data is read from the buffer rather than from client memory.
        /// In contrast to glDrawArraysInstancedBaseInstance,            the first member of the parameter structure is unsigned, and out-of-range indices            do not generate an error.
        /// Vertex attributes that are modified by glMultiDrawArraysIndirect have an            unspecified value after glMultiDrawArraysIndirect returns. Attributes that aren't            modified remain well defined.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY, and                    GL_PATCHES                    are accepted.</param>
        /// <param name="indirect">Specifies the address of an array of structures containing the draw parameters.</param>
        /// <param name="drawcount">Specifies the number of elements in the array of draw parameter structures.</param>
        /// <param name="stride">Specifies the distance in basic machine units between elements of the draw parameter array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawArraysIndirect(PrimitiveType mode, IntPtr indirect, int drawcount, int stride) => _MultiDrawArraysIndirect(mode, indirect, drawcount, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawArraysIndirectAMD(PrimitiveType mode, IntPtr indirect, int primcount, int stride) => _MultiDrawArraysIndirectAMD(mode, indirect, primcount, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawArraysIndirectBindlessCountNV(PrimitiveType mode, IntPtr indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) => _MultiDrawArraysIndirectBindlessCountNV(mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawArraysIndirectBindlessNV(PrimitiveType mode, IntPtr indirect, int drawCount, int stride, int vertexBufferCount) => _MultiDrawArraysIndirectBindlessNV(mode, indirect, drawCount, stride, vertexBufferCount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawArraysIndirectCount(PrimitiveType mode, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) => _MultiDrawArraysIndirectCount(mode, indirect, drawcount, maxdrawcount, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawArraysIndirectCountARB(PrimitiveType mode, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) => _MultiDrawArraysIndirectCountARB(mode, indirect, drawcount, maxdrawcount, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawArraysIndirectEXT(PrimitiveType mode, IntPtr indirect, int drawcount, int stride) => _MultiDrawArraysIndirectEXT(mode, indirect, drawcount, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementArrayAPPLE(PrimitiveType mode, int[] first, int[] count, int primcount) => _MultiDrawElementArrayAPPLE(mode, first, count, primcount);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementArrayAPPLE(PrimitiveType mode, void* first, void* count, int primcount) => _MultiDrawElementArrayAPPLE_ptr(mode, first, count, primcount);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementArrayAPPLE(PrimitiveType mode, IntPtr first, IntPtr count, int primcount) => _MultiDrawElementArrayAPPLE_intptr(mode, first, count, primcount);

        // ---

        /// <summary>
        /// glMultiDrawElements specifies multiple sets of geometric primitives with very few subroutine            calls. Instead of calling a GL function to pass each individual vertex,            normal, texture coordinate, edge flag, or color, you can prespecify            separate arrays of vertices, normals, and so on, and use them to construct a            sequence of primitives with a single call to glMultiDrawElements.
        /// glMultiDrawElements is identical in operation to glDrawElements except that            drawcount separate lists of elements are specified.
        /// Vertex attributes that are modified by glMultiDrawElements have an            unspecified value after glMultiDrawElements returns. Attributes that aren't            modified maintain their previous values.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="count">Points to an array of the elements counts.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of                    GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or                    GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="drawcount">Specifies the size of the count and indices arrays.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElements(PrimitiveType mode, int[] count, DrawElementsType type, IntPtr* indices, int drawcount) => _MultiDrawElements(mode, count, type, indices, drawcount);

        /// <summary>
        /// glMultiDrawElements specifies multiple sets of geometric primitives with very few subroutine            calls. Instead of calling a GL function to pass each individual vertex,            normal, texture coordinate, edge flag, or color, you can prespecify            separate arrays of vertices, normals, and so on, and use them to construct a            sequence of primitives with a single call to glMultiDrawElements.
        /// glMultiDrawElements is identical in operation to glDrawElements except that            drawcount separate lists of elements are specified.
        /// Vertex attributes that are modified by glMultiDrawElements have an            unspecified value after glMultiDrawElements returns. Attributes that aren't            modified maintain their previous values.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="count">Points to an array of the elements counts.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of                    GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or                    GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="drawcount">Specifies the size of the count and indices arrays.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElements(PrimitiveType mode, void* count, DrawElementsType type, IntPtr* indices, int drawcount) => _MultiDrawElements_ptr(mode, count, type, indices, drawcount);

        /// <summary>
        /// glMultiDrawElements specifies multiple sets of geometric primitives with very few subroutine            calls. Instead of calling a GL function to pass each individual vertex,            normal, texture coordinate, edge flag, or color, you can prespecify            separate arrays of vertices, normals, and so on, and use them to construct a            sequence of primitives with a single call to glMultiDrawElements.
        /// glMultiDrawElements is identical in operation to glDrawElements except that            drawcount separate lists of elements are specified.
        /// Vertex attributes that are modified by glMultiDrawElements have an            unspecified value after glMultiDrawElements returns. Attributes that aren't            modified maintain their previous values.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="count">Points to an array of the elements counts.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of                    GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or                    GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="drawcount">Specifies the size of the count and indices arrays.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElements(PrimitiveType mode, IntPtr count, DrawElementsType type, IntPtr* indices, int drawcount) => _MultiDrawElements_intptr(mode, count, type, indices, drawcount);

        // ---

        /// <summary>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex,            except that drawcount separate lists of elements are specifried instead.
        /// It has the same effect as:            for (int i = 0; i < drawcount; i++)        if (count[i] > 0)            glDrawElementsBaseVertex(mode,                                     count[i],                                     type,                                     indices[i],                                     basevertex[i]);
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="count">Points to an array of the elements counts.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of                    GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or                    GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="drawcount">Specifies the size of the count, indices and basevertex arrays.</param>
        /// <param name="basevertex">Specifies a pointer to the location where the base vertices are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsBaseVertex(PrimitiveType mode, int[] count, DrawElementsType type, IntPtr* indices, int drawcount, int[] basevertex) => _MultiDrawElementsBaseVertex(mode, count, type, indices, drawcount, basevertex);

        /// <summary>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex,            except that drawcount separate lists of elements are specifried instead.
        /// It has the same effect as:            for (int i = 0; i < drawcount; i++)        if (count[i] > 0)            glDrawElementsBaseVertex(mode,                                     count[i],                                     type,                                     indices[i],                                     basevertex[i]);
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="count">Points to an array of the elements counts.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of                    GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or                    GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="drawcount">Specifies the size of the count, indices and basevertex arrays.</param>
        /// <param name="basevertex">Specifies a pointer to the location where the base vertices are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsBaseVertex(PrimitiveType mode, void* count, DrawElementsType type, IntPtr* indices, int drawcount, void* basevertex) => _MultiDrawElementsBaseVertex_ptr(mode, count, type, indices, drawcount, basevertex);

        /// <summary>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex,            except that drawcount separate lists of elements are specifried instead.
        /// It has the same effect as:            for (int i = 0; i < drawcount; i++)        if (count[i] > 0)            glDrawElementsBaseVertex(mode,                                     count[i],                                     type,                                     indices[i],                                     basevertex[i]);
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY and GL_PATCHES                    are accepted.</param>
        /// <param name="count">Points to an array of the elements counts.</param>
        /// <param name="type">Specifies the type of the values in indices. Must be one of                    GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or                    GL_UNSIGNED_INT.</param>
        /// <param name="indices">Specifies a pointer to the location where the indices are stored.</param>
        /// <param name="drawcount">Specifies the size of the count, indices and basevertex arrays.</param>
        /// <param name="basevertex">Specifies a pointer to the location where the base vertices are stored.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsBaseVertex(PrimitiveType mode, IntPtr count, DrawElementsType type, IntPtr* indices, int drawcount, IntPtr basevertex) => _MultiDrawElementsBaseVertex_intptr(mode, count, type, indices, drawcount, basevertex);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsBaseVertexEXT(PrimitiveType mode, int[] count, DrawElementsType type, IntPtr* indices, int primcount, int[] basevertex) => _MultiDrawElementsBaseVertexEXT(mode, count, type, indices, primcount, basevertex);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsBaseVertexEXT(PrimitiveType mode, void* count, DrawElementsType type, IntPtr* indices, int primcount, void* basevertex) => _MultiDrawElementsBaseVertexEXT_ptr(mode, count, type, indices, primcount, basevertex);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsBaseVertexEXT(PrimitiveType mode, IntPtr count, DrawElementsType type, IntPtr* indices, int primcount, IntPtr basevertex) => _MultiDrawElementsBaseVertexEXT_intptr(mode, count, type, indices, primcount, basevertex);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsEXT(PrimitiveType mode, int[] count, DrawElementsType type, IntPtr* indices, int primcount) => _MultiDrawElementsEXT(mode, count, type, indices, primcount);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsEXT(PrimitiveType mode, void* count, DrawElementsType type, IntPtr* indices, int primcount) => _MultiDrawElementsEXT_ptr(mode, count, type, indices, primcount);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsEXT(PrimitiveType mode, IntPtr count, DrawElementsType type, IntPtr* indices, int primcount) => _MultiDrawElementsEXT_intptr(mode, count, type, indices, primcount);

        // ---

        /// <summary>
        /// glMultiDrawElementsIndirect specifies multiple indexed geometric primitives            with very few subroutine calls. glMultiDrawElementsIndirect behaves            similarly to a multitude of calls to glDrawElementsInstancedBaseVertexBaseInstance,            execpt that the parameters to glDrawElementsInstancedBaseVertexBaseInstance            are stored in an array in memory at the address given by indirect, separated            by the stride, in basic machine units, specified by stride. If stride            is zero, then the array is assumed to be tightly packed in memory.
        /// The parameters addressed by indirect are packed into a structure            that takes the form (in C):                typedef  struct {        uint  count;        uint  instanceCount;        uint  firstIndex;        uint  baseVertex;        uint  baseInstance;    } DrawElementsIndirectCommand;
        /// A single call to glMultiDrawElementsIndirect is equivalent, assuming no errors            are generated to:                GLsizei n;    for (n = 0; n < drawcount; n++) {        const DrawElementsIndirectCommand *cmd;        if (stride != 0) {            cmd = (const DrawElementsIndirectCommand  *)((uintptr)indirect + n * stride);        } else {            cmd = (const DrawElementsIndirectCommand  *)indirect + n;        }        glDrawElementsInstancedBaseVertexBaseInstance(mode,                                                      cmd->count,                                                      type,                                                      cmd->firstIndex * size-of-type,                                                      cmd->instanceCount,                                                      cmd->baseVertex,                                                      cmd->baseInstance);    }
        /// If a buffer is bound to the GL_DRAW_INDIRECT_BUFFER binding at the time            of a call to glDrawElementsIndirect, indirect            is interpreted as an offset, in basic machine units, into that buffer and the parameter            data is read from the buffer rather than from client memory.
        /// Note that indices stored in client memory are not supported. If no buffer is bound to the            GL_ELEMENT_ARRAY_BUFFER binding, an error will be generated.
        /// The results of the operation are undefined if the reservedMustBeZero member            of the parameter structure is non-zero. However, no error is generated in this case.
        /// Vertex attributes that are modified by glDrawElementsIndirect have an            unspecified value after glDrawElementsIndirect returns. Attributes that aren't            modified remain well defined.
        /// </summary>
        /// <param name="mode">Specifies what kind of primitives to render.                    Symbolic constants                    GL_POINTS,                    GL_LINE_STRIP,                    GL_LINE_LOOP,                    GL_LINES,                    GL_LINE_STRIP_ADJACENCY,                    GL_LINES_ADJACENCY,                    GL_TRIANGLE_STRIP,                    GL_TRIANGLE_FAN,                    GL_TRIANGLES,                    GL_TRIANGLE_STRIP_ADJACENCY,                    GL_TRIANGLES_ADJACENCY, and                    GL_PATCHES                    are accepted.</param>
        /// <param name="type">Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding.</param>
        /// <param name="indirect">Specifies the address of a structure containing an array of draw parameters.</param>
        /// <param name="drawcount">Specifies the number of elements in the array addressed by indirect.</param>
        /// <param name="stride">Specifies the distance in basic machine units between elements of the draw parameter array.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsIndirect(PrimitiveType mode, DrawElementsType type, IntPtr indirect, int drawcount, int stride) => _MultiDrawElementsIndirect(mode, type, indirect, drawcount, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsIndirectAMD(PrimitiveType mode, DrawElementsType type, IntPtr indirect, int primcount, int stride) => _MultiDrawElementsIndirectAMD(mode, type, indirect, primcount, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsIndirectBindlessCountNV(PrimitiveType mode, DrawElementsType type, IntPtr indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) => _MultiDrawElementsIndirectBindlessCountNV(mode, type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsIndirectBindlessNV(PrimitiveType mode, DrawElementsType type, IntPtr indirect, int drawCount, int stride, int vertexBufferCount) => _MultiDrawElementsIndirectBindlessNV(mode, type, indirect, drawCount, stride, vertexBufferCount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsIndirectCount(PrimitiveType mode, DrawElementsType type, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) => _MultiDrawElementsIndirectCount(mode, type, indirect, drawcount, maxdrawcount, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsIndirectCountARB(PrimitiveType mode, DrawElementsType type, IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) => _MultiDrawElementsIndirectCountARB(mode, type, indirect, drawcount, maxdrawcount, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawElementsIndirectEXT(PrimitiveType mode, DrawElementsType type, IntPtr indirect, int drawcount, int stride) => _MultiDrawElementsIndirectEXT(mode, type, indirect, drawcount, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawMeshTasksIndirectNV(IntPtr indirect, int drawcount, int stride) => _MultiDrawMeshTasksIndirectNV(indirect, drawcount, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawMeshTasksIndirectCountNV(IntPtr indirect, IntPtr drawcount, int maxdrawcount, int stride) => _MultiDrawMeshTasksIndirectCountNV(indirect, drawcount, maxdrawcount, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawRangeElementArrayAPPLE(PrimitiveType mode, uint start, uint end, int[] first, int[] count, int primcount) => _MultiDrawRangeElementArrayAPPLE(mode, start, end, first, count, primcount);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawRangeElementArrayAPPLE(PrimitiveType mode, uint start, uint end, void* first, void* count, int primcount) => _MultiDrawRangeElementArrayAPPLE_ptr(mode, start, end, first, count, primcount);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiDrawRangeElementArrayAPPLE(PrimitiveType mode, uint start, uint end, IntPtr first, IntPtr count, int primcount) => _MultiDrawRangeElementArrayAPPLE_intptr(mode, start, end, first, count, primcount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiModeDrawArraysIBM(PrimitiveType[] mode, int[] first, int[] count, int primcount, int modestride) => _MultiModeDrawArraysIBM(mode, first, count, primcount, modestride);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiModeDrawArraysIBM(void* mode, void* first, void* count, int primcount, int modestride) => _MultiModeDrawArraysIBM_ptr(mode, first, count, primcount, modestride);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiModeDrawArraysIBM(IntPtr mode, IntPtr first, IntPtr count, int primcount, int modestride) => _MultiModeDrawArraysIBM_intptr(mode, first, count, primcount, modestride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiModeDrawElementsIBM(PrimitiveType[] mode, int[] count, DrawElementsType type, IntPtr* indices, int primcount, int modestride) => _MultiModeDrawElementsIBM(mode, count, type, indices, primcount, modestride);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiModeDrawElementsIBM(void* mode, void* count, DrawElementsType type, IntPtr* indices, int primcount, int modestride) => _MultiModeDrawElementsIBM_ptr(mode, count, type, indices, primcount, modestride);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiModeDrawElementsIBM(IntPtr mode, IntPtr count, DrawElementsType type, IntPtr* indices, int primcount, int modestride) => _MultiModeDrawElementsIBM_intptr(mode, count, type, indices, primcount, modestride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexBufferEXT(TextureUnit texunit, TextureTarget target, int internalformat, uint buffer) => _MultiTexBufferEXT(texunit, target, internalformat, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1bOES(TextureUnit texture, sbyte s) => _MultiTexCoord1bOES(texture, s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1bvOES(TextureUnit texture, sbyte[] coords) => _MultiTexCoord1bvOES(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1bvOES(TextureUnit texture, void* coords) => _MultiTexCoord1bvOES_ptr(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1bvOES(TextureUnit texture, IntPtr coords) => _MultiTexCoord1bvOES_intptr(texture, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1d(TextureUnit target, double s) => _MultiTexCoord1d(target, s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1dARB(TextureUnit target, double s) => _MultiTexCoord1dARB(target, s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1dv(TextureUnit target, double[] v) => _MultiTexCoord1dv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1dv(TextureUnit target, void* v) => _MultiTexCoord1dv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1dv(TextureUnit target, IntPtr v) => _MultiTexCoord1dv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1dvARB(TextureUnit target, double[] v) => _MultiTexCoord1dvARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1dvARB(TextureUnit target, void* v) => _MultiTexCoord1dvARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1dvARB(TextureUnit target, IntPtr v) => _MultiTexCoord1dvARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1f(TextureUnit target, float s) => _MultiTexCoord1f(target, s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1fARB(TextureUnit target, float s) => _MultiTexCoord1fARB(target, s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1fv(TextureUnit target, float[] v) => _MultiTexCoord1fv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1fv(TextureUnit target, void* v) => _MultiTexCoord1fv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1fv(TextureUnit target, IntPtr v) => _MultiTexCoord1fv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1fvARB(TextureUnit target, float[] v) => _MultiTexCoord1fvARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1fvARB(TextureUnit target, void* v) => _MultiTexCoord1fvARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1fvARB(TextureUnit target, IntPtr v) => _MultiTexCoord1fvARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1hNV(TextureUnit target, float s) => _MultiTexCoord1hNV(target, s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1hvNV(TextureUnit target, float[] v) => _MultiTexCoord1hvNV(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1hvNV(TextureUnit target, void* v) => _MultiTexCoord1hvNV_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1hvNV(TextureUnit target, IntPtr v) => _MultiTexCoord1hvNV_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1i(TextureUnit target, int s) => _MultiTexCoord1i(target, s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1iARB(TextureUnit target, int s) => _MultiTexCoord1iARB(target, s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1iv(TextureUnit target, int[] v) => _MultiTexCoord1iv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1iv(TextureUnit target, void* v) => _MultiTexCoord1iv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1iv(TextureUnit target, IntPtr v) => _MultiTexCoord1iv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1ivARB(TextureUnit target, int[] v) => _MultiTexCoord1ivARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1ivARB(TextureUnit target, void* v) => _MultiTexCoord1ivARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1ivARB(TextureUnit target, IntPtr v) => _MultiTexCoord1ivARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1s(TextureUnit target, short s) => _MultiTexCoord1s(target, s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1sARB(TextureUnit target, short s) => _MultiTexCoord1sARB(target, s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1sv(TextureUnit target, short[] v) => _MultiTexCoord1sv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1sv(TextureUnit target, void* v) => _MultiTexCoord1sv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1sv(TextureUnit target, IntPtr v) => _MultiTexCoord1sv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1svARB(TextureUnit target, short[] v) => _MultiTexCoord1svARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1svARB(TextureUnit target, void* v) => _MultiTexCoord1svARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1svARB(TextureUnit target, IntPtr v) => _MultiTexCoord1svARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1xOES(TextureUnit texture, float s) => _MultiTexCoord1xOES(texture, s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1xvOES(TextureUnit texture, float[] coords) => _MultiTexCoord1xvOES(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1xvOES(TextureUnit texture, void* coords) => _MultiTexCoord1xvOES_ptr(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord1xvOES(TextureUnit texture, IntPtr coords) => _MultiTexCoord1xvOES_intptr(texture, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2bOES(TextureUnit texture, sbyte s, sbyte t) => _MultiTexCoord2bOES(texture, s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2bvOES(TextureUnit texture, sbyte[] coords) => _MultiTexCoord2bvOES(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2bvOES(TextureUnit texture, void* coords) => _MultiTexCoord2bvOES_ptr(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2bvOES(TextureUnit texture, IntPtr coords) => _MultiTexCoord2bvOES_intptr(texture, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2d(TextureUnit target, double s, double t) => _MultiTexCoord2d(target, s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2dARB(TextureUnit target, double s, double t) => _MultiTexCoord2dARB(target, s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2dv(TextureUnit target, double[] v) => _MultiTexCoord2dv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2dv(TextureUnit target, void* v) => _MultiTexCoord2dv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2dv(TextureUnit target, IntPtr v) => _MultiTexCoord2dv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2dvARB(TextureUnit target, double[] v) => _MultiTexCoord2dvARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2dvARB(TextureUnit target, void* v) => _MultiTexCoord2dvARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2dvARB(TextureUnit target, IntPtr v) => _MultiTexCoord2dvARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2f(TextureUnit target, float s, float t) => _MultiTexCoord2f(target, s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2fARB(TextureUnit target, float s, float t) => _MultiTexCoord2fARB(target, s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2fv(TextureUnit target, float[] v) => _MultiTexCoord2fv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2fv(TextureUnit target, void* v) => _MultiTexCoord2fv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2fv(TextureUnit target, IntPtr v) => _MultiTexCoord2fv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2fvARB(TextureUnit target, float[] v) => _MultiTexCoord2fvARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2fvARB(TextureUnit target, void* v) => _MultiTexCoord2fvARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2fvARB(TextureUnit target, IntPtr v) => _MultiTexCoord2fvARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2hNV(TextureUnit target, float s, float t) => _MultiTexCoord2hNV(target, s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2hvNV(TextureUnit target, float[] v) => _MultiTexCoord2hvNV(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2hvNV(TextureUnit target, void* v) => _MultiTexCoord2hvNV_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2hvNV(TextureUnit target, IntPtr v) => _MultiTexCoord2hvNV_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2i(TextureUnit target, int s, int t) => _MultiTexCoord2i(target, s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2iARB(TextureUnit target, int s, int t) => _MultiTexCoord2iARB(target, s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2iv(TextureUnit target, int[] v) => _MultiTexCoord2iv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2iv(TextureUnit target, void* v) => _MultiTexCoord2iv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2iv(TextureUnit target, IntPtr v) => _MultiTexCoord2iv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2ivARB(TextureUnit target, int[] v) => _MultiTexCoord2ivARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2ivARB(TextureUnit target, void* v) => _MultiTexCoord2ivARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2ivARB(TextureUnit target, IntPtr v) => _MultiTexCoord2ivARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2s(TextureUnit target, short s, short t) => _MultiTexCoord2s(target, s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2sARB(TextureUnit target, short s, short t) => _MultiTexCoord2sARB(target, s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2sv(TextureUnit target, short[] v) => _MultiTexCoord2sv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2sv(TextureUnit target, void* v) => _MultiTexCoord2sv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2sv(TextureUnit target, IntPtr v) => _MultiTexCoord2sv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2svARB(TextureUnit target, short[] v) => _MultiTexCoord2svARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2svARB(TextureUnit target, void* v) => _MultiTexCoord2svARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2svARB(TextureUnit target, IntPtr v) => _MultiTexCoord2svARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2xOES(TextureUnit texture, float s, float t) => _MultiTexCoord2xOES(texture, s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2xvOES(TextureUnit texture, float[] coords) => _MultiTexCoord2xvOES(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2xvOES(TextureUnit texture, void* coords) => _MultiTexCoord2xvOES_ptr(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord2xvOES(TextureUnit texture, IntPtr coords) => _MultiTexCoord2xvOES_intptr(texture, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3bOES(TextureUnit texture, sbyte s, sbyte t, sbyte r) => _MultiTexCoord3bOES(texture, s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3bvOES(TextureUnit texture, sbyte[] coords) => _MultiTexCoord3bvOES(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3bvOES(TextureUnit texture, void* coords) => _MultiTexCoord3bvOES_ptr(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3bvOES(TextureUnit texture, IntPtr coords) => _MultiTexCoord3bvOES_intptr(texture, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3d(TextureUnit target, double s, double t, double r) => _MultiTexCoord3d(target, s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3dARB(TextureUnit target, double s, double t, double r) => _MultiTexCoord3dARB(target, s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3dv(TextureUnit target, double[] v) => _MultiTexCoord3dv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3dv(TextureUnit target, void* v) => _MultiTexCoord3dv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3dv(TextureUnit target, IntPtr v) => _MultiTexCoord3dv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3dvARB(TextureUnit target, double[] v) => _MultiTexCoord3dvARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3dvARB(TextureUnit target, void* v) => _MultiTexCoord3dvARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3dvARB(TextureUnit target, IntPtr v) => _MultiTexCoord3dvARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3f(TextureUnit target, float s, float t, float r) => _MultiTexCoord3f(target, s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3fARB(TextureUnit target, float s, float t, float r) => _MultiTexCoord3fARB(target, s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3fv(TextureUnit target, float[] v) => _MultiTexCoord3fv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3fv(TextureUnit target, void* v) => _MultiTexCoord3fv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3fv(TextureUnit target, IntPtr v) => _MultiTexCoord3fv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3fvARB(TextureUnit target, float[] v) => _MultiTexCoord3fvARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3fvARB(TextureUnit target, void* v) => _MultiTexCoord3fvARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3fvARB(TextureUnit target, IntPtr v) => _MultiTexCoord3fvARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3hNV(TextureUnit target, float s, float t, float r) => _MultiTexCoord3hNV(target, s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3hvNV(TextureUnit target, float[] v) => _MultiTexCoord3hvNV(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3hvNV(TextureUnit target, void* v) => _MultiTexCoord3hvNV_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3hvNV(TextureUnit target, IntPtr v) => _MultiTexCoord3hvNV_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3i(TextureUnit target, int s, int t, int r) => _MultiTexCoord3i(target, s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3iARB(TextureUnit target, int s, int t, int r) => _MultiTexCoord3iARB(target, s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3iv(TextureUnit target, int[] v) => _MultiTexCoord3iv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3iv(TextureUnit target, void* v) => _MultiTexCoord3iv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3iv(TextureUnit target, IntPtr v) => _MultiTexCoord3iv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3ivARB(TextureUnit target, int[] v) => _MultiTexCoord3ivARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3ivARB(TextureUnit target, void* v) => _MultiTexCoord3ivARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3ivARB(TextureUnit target, IntPtr v) => _MultiTexCoord3ivARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3s(TextureUnit target, short s, short t, short r) => _MultiTexCoord3s(target, s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3sARB(TextureUnit target, short s, short t, short r) => _MultiTexCoord3sARB(target, s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3sv(TextureUnit target, short[] v) => _MultiTexCoord3sv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3sv(TextureUnit target, void* v) => _MultiTexCoord3sv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3sv(TextureUnit target, IntPtr v) => _MultiTexCoord3sv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3svARB(TextureUnit target, short[] v) => _MultiTexCoord3svARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3svARB(TextureUnit target, void* v) => _MultiTexCoord3svARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3svARB(TextureUnit target, IntPtr v) => _MultiTexCoord3svARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3xOES(TextureUnit texture, float s, float t, float r) => _MultiTexCoord3xOES(texture, s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3xvOES(TextureUnit texture, float[] coords) => _MultiTexCoord3xvOES(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3xvOES(TextureUnit texture, void* coords) => _MultiTexCoord3xvOES_ptr(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord3xvOES(TextureUnit texture, IntPtr coords) => _MultiTexCoord3xvOES_intptr(texture, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4bOES(TextureUnit texture, sbyte s, sbyte t, sbyte r, sbyte q) => _MultiTexCoord4bOES(texture, s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4bvOES(TextureUnit texture, sbyte[] coords) => _MultiTexCoord4bvOES(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4bvOES(TextureUnit texture, void* coords) => _MultiTexCoord4bvOES_ptr(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4bvOES(TextureUnit texture, IntPtr coords) => _MultiTexCoord4bvOES_intptr(texture, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4d(TextureUnit target, double s, double t, double r, double q) => _MultiTexCoord4d(target, s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4dARB(TextureUnit target, double s, double t, double r, double q) => _MultiTexCoord4dARB(target, s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4dv(TextureUnit target, double[] v) => _MultiTexCoord4dv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4dv(TextureUnit target, void* v) => _MultiTexCoord4dv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4dv(TextureUnit target, IntPtr v) => _MultiTexCoord4dv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4dvARB(TextureUnit target, double[] v) => _MultiTexCoord4dvARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4dvARB(TextureUnit target, void* v) => _MultiTexCoord4dvARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4dvARB(TextureUnit target, IntPtr v) => _MultiTexCoord4dvARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4f(TextureUnit target, float s, float t, float r, float q) => _MultiTexCoord4f(target, s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4fARB(TextureUnit target, float s, float t, float r, float q) => _MultiTexCoord4fARB(target, s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4fv(TextureUnit target, float[] v) => _MultiTexCoord4fv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4fv(TextureUnit target, void* v) => _MultiTexCoord4fv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4fv(TextureUnit target, IntPtr v) => _MultiTexCoord4fv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4fvARB(TextureUnit target, float[] v) => _MultiTexCoord4fvARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4fvARB(TextureUnit target, void* v) => _MultiTexCoord4fvARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4fvARB(TextureUnit target, IntPtr v) => _MultiTexCoord4fvARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4hNV(TextureUnit target, float s, float t, float r, float q) => _MultiTexCoord4hNV(target, s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4hvNV(TextureUnit target, float[] v) => _MultiTexCoord4hvNV(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4hvNV(TextureUnit target, void* v) => _MultiTexCoord4hvNV_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4hvNV(TextureUnit target, IntPtr v) => _MultiTexCoord4hvNV_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4i(TextureUnit target, int s, int t, int r, int q) => _MultiTexCoord4i(target, s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4iARB(TextureUnit target, int s, int t, int r, int q) => _MultiTexCoord4iARB(target, s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4iv(TextureUnit target, int[] v) => _MultiTexCoord4iv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4iv(TextureUnit target, void* v) => _MultiTexCoord4iv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4iv(TextureUnit target, IntPtr v) => _MultiTexCoord4iv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4ivARB(TextureUnit target, int[] v) => _MultiTexCoord4ivARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4ivARB(TextureUnit target, void* v) => _MultiTexCoord4ivARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4ivARB(TextureUnit target, IntPtr v) => _MultiTexCoord4ivARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4s(TextureUnit target, short s, short t, short r, short q) => _MultiTexCoord4s(target, s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4sARB(TextureUnit target, short s, short t, short r, short q) => _MultiTexCoord4sARB(target, s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4sv(TextureUnit target, short[] v) => _MultiTexCoord4sv(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4sv(TextureUnit target, void* v) => _MultiTexCoord4sv_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4sv(TextureUnit target, IntPtr v) => _MultiTexCoord4sv_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4svARB(TextureUnit target, short[] v) => _MultiTexCoord4svARB(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4svARB(TextureUnit target, void* v) => _MultiTexCoord4svARB_ptr(target, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4svARB(TextureUnit target, IntPtr v) => _MultiTexCoord4svARB_intptr(target, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4x(TextureUnit texture, float s, float t, float r, float q) => _MultiTexCoord4x(texture, s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4xOES(TextureUnit texture, float s, float t, float r, float q) => _MultiTexCoord4xOES(texture, s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4xvOES(TextureUnit texture, float[] coords) => _MultiTexCoord4xvOES(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4xvOES(TextureUnit texture, void* coords) => _MultiTexCoord4xvOES_ptr(texture, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoord4xvOES(TextureUnit texture, IntPtr coords) => _MultiTexCoord4xvOES_intptr(texture, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP1ui(TextureUnit texture, TexCoordPointerType type, uint coords) => _MultiTexCoordP1ui(texture, type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP1uiv(TextureUnit texture, TexCoordPointerType type, uint[] coords) => _MultiTexCoordP1uiv(texture, type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP1uiv(TextureUnit texture, TexCoordPointerType type, void* coords) => _MultiTexCoordP1uiv_ptr(texture, type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP1uiv(TextureUnit texture, TexCoordPointerType type, IntPtr coords) => _MultiTexCoordP1uiv_intptr(texture, type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP2ui(TextureUnit texture, TexCoordPointerType type, uint coords) => _MultiTexCoordP2ui(texture, type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP2uiv(TextureUnit texture, TexCoordPointerType type, uint[] coords) => _MultiTexCoordP2uiv(texture, type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP2uiv(TextureUnit texture, TexCoordPointerType type, void* coords) => _MultiTexCoordP2uiv_ptr(texture, type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP2uiv(TextureUnit texture, TexCoordPointerType type, IntPtr coords) => _MultiTexCoordP2uiv_intptr(texture, type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP3ui(TextureUnit texture, TexCoordPointerType type, uint coords) => _MultiTexCoordP3ui(texture, type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP3uiv(TextureUnit texture, TexCoordPointerType type, uint[] coords) => _MultiTexCoordP3uiv(texture, type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP3uiv(TextureUnit texture, TexCoordPointerType type, void* coords) => _MultiTexCoordP3uiv_ptr(texture, type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP3uiv(TextureUnit texture, TexCoordPointerType type, IntPtr coords) => _MultiTexCoordP3uiv_intptr(texture, type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP4ui(TextureUnit texture, TexCoordPointerType type, uint coords) => _MultiTexCoordP4ui(texture, type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP4uiv(TextureUnit texture, TexCoordPointerType type, uint[] coords) => _MultiTexCoordP4uiv(texture, type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP4uiv(TextureUnit texture, TexCoordPointerType type, void* coords) => _MultiTexCoordP4uiv_ptr(texture, type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordP4uiv(TextureUnit texture, TexCoordPointerType type, IntPtr coords) => _MultiTexCoordP4uiv_intptr(texture, type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexCoordPointerEXT(TextureUnit texunit, int size, TexCoordPointerType type, int stride, IntPtr pointer) => _MultiTexCoordPointerEXT(texunit, size, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexEnvfEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float param) => _MultiTexEnvfEXT(texunit, target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, float[] @params) => _MultiTexEnvfvEXT(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, void* @params) => _MultiTexEnvfvEXT_ptr(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexEnvfvEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, IntPtr @params) => _MultiTexEnvfvEXT_intptr(texunit, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexEnviEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int param) => _MultiTexEnviEXT(texunit, target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, int[] @params) => _MultiTexEnvivEXT(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, void* @params) => _MultiTexEnvivEXT_ptr(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexEnvivEXT(TextureUnit texunit, TextureEnvTarget target, TextureEnvParameter pname, IntPtr @params) => _MultiTexEnvivEXT_intptr(texunit, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexGendEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double param) => _MultiTexGendEXT(texunit, coord, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, double[] @params) => _MultiTexGendvEXT(texunit, coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, void* @params) => _MultiTexGendvEXT_ptr(texunit, coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexGendvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _MultiTexGendvEXT_intptr(texunit, coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexGenfEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float param) => _MultiTexGenfEXT(texunit, coord, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, float[] @params) => _MultiTexGenfvEXT(texunit, coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, void* @params) => _MultiTexGenfvEXT_ptr(texunit, coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexGenfvEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _MultiTexGenfvEXT_intptr(texunit, coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexGeniEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int param) => _MultiTexGeniEXT(texunit, coord, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, int[] @params) => _MultiTexGenivEXT(texunit, coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, void* @params) => _MultiTexGenivEXT_ptr(texunit, coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexGenivEXT(TextureUnit texunit, TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _MultiTexGenivEXT_intptr(texunit, coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, IntPtr pixels) => _MultiTexImage1DEXT(texunit, target, level, internalformat, width, border, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, IntPtr pixels) => _MultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, IntPtr pixels) => _MultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int[] @params) => _MultiTexParameterIivEXT(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, void* @params) => _MultiTexParameterIivEXT_ptr(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexParameterIivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, IntPtr @params) => _MultiTexParameterIivEXT_intptr(texunit, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, uint[] @params) => _MultiTexParameterIuivEXT(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, void* @params) => _MultiTexParameterIuivEXT_ptr(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexParameterIuivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, IntPtr @params) => _MultiTexParameterIuivEXT_intptr(texunit, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexParameterfEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, float param) => _MultiTexParameterfEXT(texunit, target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, float[] @params) => _MultiTexParameterfvEXT(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, void* @params) => _MultiTexParameterfvEXT_ptr(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexParameterfvEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, IntPtr @params) => _MultiTexParameterfvEXT_intptr(texunit, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexParameteriEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int param) => _MultiTexParameteriEXT(texunit, target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, int[] @params) => _MultiTexParameterivEXT(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, void* @params) => _MultiTexParameterivEXT_ptr(texunit, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexParameterivEXT(TextureUnit texunit, TextureTarget target, TextureParameterName pname, IntPtr @params) => _MultiTexParameterivEXT_intptr(texunit, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexRenderbufferEXT(TextureUnit texunit, TextureTarget target, uint renderbuffer) => _MultiTexRenderbufferEXT(texunit, target, renderbuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexSubImage1DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, IntPtr pixels) => _MultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexSubImage2DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, IntPtr pixels) => _MultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MultiTexSubImage3DEXT(TextureUnit texunit, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels) => _MultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastBarrierNV() => _MulticastBarrierNV();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastBlitFramebufferNV(uint srcGpu, uint dstGpu, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter) => _MulticastBlitFramebufferNV(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastBufferSubDataNV(int gpuMask, uint buffer, IntPtr offset, IntPtr size, IntPtr data) => _MulticastBufferSubDataNV(gpuMask, buffer, offset, size, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastCopyBufferSubDataNV(uint readGpu, int writeGpuMask, uint readBuffer, uint writeBuffer, IntPtr readOffset, IntPtr writeOffset, IntPtr size) => _MulticastCopyBufferSubDataNV(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastCopyImageSubDataNV(uint srcGpu, int dstGpuMask, uint srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) => _MulticastCopyImageSubDataNV(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastFramebufferSampleLocationsfvNV(uint gpu, uint framebuffer, uint start, int count, float[] v) => _MulticastFramebufferSampleLocationsfvNV(gpu, framebuffer, start, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastFramebufferSampleLocationsfvNV(uint gpu, uint framebuffer, uint start, int count, void* v) => _MulticastFramebufferSampleLocationsfvNV_ptr(gpu, framebuffer, start, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastFramebufferSampleLocationsfvNV(uint gpu, uint framebuffer, uint start, int count, IntPtr v) => _MulticastFramebufferSampleLocationsfvNV_intptr(gpu, framebuffer, start, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastGetQueryObjecti64vNV(uint gpu, uint id, int pname, Int64[] @params) => _MulticastGetQueryObjecti64vNV(gpu, id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastGetQueryObjecti64vNV(uint gpu, uint id, int pname, void* @params) => _MulticastGetQueryObjecti64vNV_ptr(gpu, id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastGetQueryObjecti64vNV(uint gpu, uint id, int pname, IntPtr @params) => _MulticastGetQueryObjecti64vNV_intptr(gpu, id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastGetQueryObjectivNV(uint gpu, uint id, int pname, int[] @params) => _MulticastGetQueryObjectivNV(gpu, id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastGetQueryObjectivNV(uint gpu, uint id, int pname, void* @params) => _MulticastGetQueryObjectivNV_ptr(gpu, id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastGetQueryObjectivNV(uint gpu, uint id, int pname, IntPtr @params) => _MulticastGetQueryObjectivNV_intptr(gpu, id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastGetQueryObjectui64vNV(uint gpu, uint id, int pname, UInt64[] @params) => _MulticastGetQueryObjectui64vNV(gpu, id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastGetQueryObjectui64vNV(uint gpu, uint id, int pname, void* @params) => _MulticastGetQueryObjectui64vNV_ptr(gpu, id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastGetQueryObjectui64vNV(uint gpu, uint id, int pname, IntPtr @params) => _MulticastGetQueryObjectui64vNV_intptr(gpu, id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastGetQueryObjectuivNV(uint gpu, uint id, int pname, uint[] @params) => _MulticastGetQueryObjectuivNV(gpu, id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastGetQueryObjectuivNV(uint gpu, uint id, int pname, void* @params) => _MulticastGetQueryObjectuivNV_ptr(gpu, id, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastGetQueryObjectuivNV(uint gpu, uint id, int pname, IntPtr @params) => _MulticastGetQueryObjectuivNV_intptr(gpu, id, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastScissorArrayvNVX(uint gpu, uint first, int count, int[] v) => _MulticastScissorArrayvNVX(gpu, first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastScissorArrayvNVX(uint gpu, uint first, int count, void* v) => _MulticastScissorArrayvNVX_ptr(gpu, first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastScissorArrayvNVX(uint gpu, uint first, int count, IntPtr v) => _MulticastScissorArrayvNVX_intptr(gpu, first, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastViewportArrayvNVX(uint gpu, uint first, int count, float[] v) => _MulticastViewportArrayvNVX(gpu, first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastViewportArrayvNVX(uint gpu, uint first, int count, void* v) => _MulticastViewportArrayvNVX_ptr(gpu, first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastViewportArrayvNVX(uint gpu, uint first, int count, IntPtr v) => _MulticastViewportArrayvNVX_intptr(gpu, first, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastViewportPositionWScaleNVX(uint gpu, uint index, float xcoeff, float ycoeff) => _MulticastViewportPositionWScaleNVX(gpu, index, xcoeff, ycoeff);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MulticastWaitSyncNV(uint signalGpu, int waitGpuMask) => _MulticastWaitSyncNV(signalGpu, waitGpuMask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedBufferAttachMemoryNV(uint buffer, uint memory, UInt64 offset) => _NamedBufferAttachMemoryNV(buffer, memory, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedBufferData(uint buffer, IntPtr size, IntPtr data, VertexBufferObjectUsage usage) => _NamedBufferData(buffer, size, data, usage);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedBufferDataEXT(uint buffer, IntPtr size, IntPtr data, VertexBufferObjectUsage usage) => _NamedBufferDataEXT(buffer, size, data, usage);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedBufferPageCommitmentARB(uint buffer, IntPtr offset, IntPtr size, bool commit) => _NamedBufferPageCommitmentARB(buffer, offset, size, commit);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedBufferPageCommitmentEXT(uint buffer, IntPtr offset, IntPtr size, bool commit) => _NamedBufferPageCommitmentEXT(buffer, offset, size, commit);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedBufferStorage(uint buffer, IntPtr size, IntPtr data, int flags) => _NamedBufferStorage(buffer, size, data, flags);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedBufferStorageExternalEXT(uint buffer, IntPtr offset, IntPtr size, IntPtr clientBuffer, int flags) => _NamedBufferStorageExternalEXT(buffer, offset, size, clientBuffer, flags);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedBufferStorageEXT(uint buffer, IntPtr size, IntPtr data, int flags) => _NamedBufferStorageEXT(buffer, size, data, flags);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedBufferStorageMemEXT(uint buffer, IntPtr size, uint memory, UInt64 offset) => _NamedBufferStorageMemEXT(buffer, size, memory, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedBufferSubData(uint buffer, IntPtr offset, IntPtr size, IntPtr data) => _NamedBufferSubData(buffer, offset, size, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedBufferSubDataEXT(uint buffer, IntPtr offset, IntPtr size, IntPtr data) => _NamedBufferSubDataEXT(buffer, offset, size, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedCopyBufferSubDataEXT(uint readBuffer, uint writeBuffer, IntPtr readOffset, IntPtr writeOffset, IntPtr size) => _NamedCopyBufferSubDataEXT(readBuffer, writeBuffer, readOffset, writeOffset, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferDrawBuffer(uint framebuffer, ColorBuffer buf) => _NamedFramebufferDrawBuffer(framebuffer, buf);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferDrawBuffers(uint framebuffer, int n, ColorBuffer[] bufs) => _NamedFramebufferDrawBuffers(framebuffer, n, bufs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferDrawBuffers(uint framebuffer, int n, void* bufs) => _NamedFramebufferDrawBuffers_ptr(framebuffer, n, bufs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferDrawBuffers(uint framebuffer, int n, IntPtr bufs) => _NamedFramebufferDrawBuffers_intptr(framebuffer, n, bufs);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferParameteri(uint framebuffer, FramebufferParameterName pname, int param) => _NamedFramebufferParameteri(framebuffer, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferParameteriEXT(uint framebuffer, FramebufferParameterName pname, int param) => _NamedFramebufferParameteriEXT(framebuffer, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferReadBuffer(uint framebuffer, ColorBuffer src) => _NamedFramebufferReadBuffer(framebuffer, src);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferRenderbuffer(uint framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, uint renderbuffer) => _NamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferRenderbufferEXT(uint framebuffer, FramebufferAttachment attachment, RenderbufferTarget renderbuffertarget, uint renderbuffer) => _NamedFramebufferRenderbufferEXT(framebuffer, attachment, renderbuffertarget, renderbuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferSampleLocationsfvARB(uint framebuffer, uint start, int count, float[] v) => _NamedFramebufferSampleLocationsfvARB(framebuffer, start, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferSampleLocationsfvARB(uint framebuffer, uint start, int count, void* v) => _NamedFramebufferSampleLocationsfvARB_ptr(framebuffer, start, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferSampleLocationsfvARB(uint framebuffer, uint start, int count, IntPtr v) => _NamedFramebufferSampleLocationsfvARB_intptr(framebuffer, start, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferSampleLocationsfvNV(uint framebuffer, uint start, int count, float[] v) => _NamedFramebufferSampleLocationsfvNV(framebuffer, start, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferSampleLocationsfvNV(uint framebuffer, uint start, int count, void* v) => _NamedFramebufferSampleLocationsfvNV_ptr(framebuffer, start, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferSampleLocationsfvNV(uint framebuffer, uint start, int count, IntPtr v) => _NamedFramebufferSampleLocationsfvNV_intptr(framebuffer, start, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferTexture(uint framebuffer, FramebufferAttachment attachment, uint texture, int level) => _NamedFramebufferTexture(framebuffer, attachment, texture, level);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferSamplePositionsfvAMD(uint framebuffer, uint numsamples, uint pixelindex, float[] values) => _NamedFramebufferSamplePositionsfvAMD(framebuffer, numsamples, pixelindex, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferSamplePositionsfvAMD(uint framebuffer, uint numsamples, uint pixelindex, void* values) => _NamedFramebufferSamplePositionsfvAMD_ptr(framebuffer, numsamples, pixelindex, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferSamplePositionsfvAMD(uint framebuffer, uint numsamples, uint pixelindex, IntPtr values) => _NamedFramebufferSamplePositionsfvAMD_intptr(framebuffer, numsamples, pixelindex, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferTexture1DEXT(uint framebuffer, FramebufferAttachment attachment, TextureTarget textarget, uint texture, int level) => _NamedFramebufferTexture1DEXT(framebuffer, attachment, textarget, texture, level);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferTexture2DEXT(uint framebuffer, FramebufferAttachment attachment, TextureTarget textarget, uint texture, int level) => _NamedFramebufferTexture2DEXT(framebuffer, attachment, textarget, texture, level);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferTexture3DEXT(uint framebuffer, FramebufferAttachment attachment, TextureTarget textarget, uint texture, int level, int zoffset) => _NamedFramebufferTexture3DEXT(framebuffer, attachment, textarget, texture, level, zoffset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferTextureEXT(uint framebuffer, FramebufferAttachment attachment, uint texture, int level) => _NamedFramebufferTextureEXT(framebuffer, attachment, texture, level);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferTextureFaceEXT(uint framebuffer, FramebufferAttachment attachment, uint texture, int level, TextureTarget face) => _NamedFramebufferTextureFaceEXT(framebuffer, attachment, texture, level, face);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferTextureLayer(uint framebuffer, FramebufferAttachment attachment, uint texture, int level, int layer) => _NamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedFramebufferTextureLayerEXT(uint framebuffer, FramebufferAttachment attachment, uint texture, int level, int layer) => _NamedFramebufferTextureLayerEXT(framebuffer, attachment, texture, level, layer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameter4dEXT(uint program, ProgramTarget target, uint index, double x, double y, double z, double w) => _NamedProgramLocalParameter4dEXT(program, target, index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameter4dvEXT(uint program, ProgramTarget target, uint index, double[] @params) => _NamedProgramLocalParameter4dvEXT(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameter4dvEXT(uint program, ProgramTarget target, uint index, void* @params) => _NamedProgramLocalParameter4dvEXT_ptr(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameter4dvEXT(uint program, ProgramTarget target, uint index, IntPtr @params) => _NamedProgramLocalParameter4dvEXT_intptr(program, target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameter4fEXT(uint program, ProgramTarget target, uint index, float x, float y, float z, float w) => _NamedProgramLocalParameter4fEXT(program, target, index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameter4fvEXT(uint program, ProgramTarget target, uint index, float[] @params) => _NamedProgramLocalParameter4fvEXT(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameter4fvEXT(uint program, ProgramTarget target, uint index, void* @params) => _NamedProgramLocalParameter4fvEXT_ptr(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameter4fvEXT(uint program, ProgramTarget target, uint index, IntPtr @params) => _NamedProgramLocalParameter4fvEXT_intptr(program, target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameterI4iEXT(uint program, ProgramTarget target, uint index, int x, int y, int z, int w) => _NamedProgramLocalParameterI4iEXT(program, target, index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameterI4ivEXT(uint program, ProgramTarget target, uint index, int[] @params) => _NamedProgramLocalParameterI4ivEXT(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameterI4ivEXT(uint program, ProgramTarget target, uint index, void* @params) => _NamedProgramLocalParameterI4ivEXT_ptr(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameterI4ivEXT(uint program, ProgramTarget target, uint index, IntPtr @params) => _NamedProgramLocalParameterI4ivEXT_intptr(program, target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameterI4uiEXT(uint program, ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => _NamedProgramLocalParameterI4uiEXT(program, target, index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameterI4uivEXT(uint program, ProgramTarget target, uint index, uint[] @params) => _NamedProgramLocalParameterI4uivEXT(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameterI4uivEXT(uint program, ProgramTarget target, uint index, void* @params) => _NamedProgramLocalParameterI4uivEXT_ptr(program, target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameterI4uivEXT(uint program, ProgramTarget target, uint index, IntPtr @params) => _NamedProgramLocalParameterI4uivEXT_intptr(program, target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameters4fvEXT(uint program, ProgramTarget target, uint index, int count, float[] @params) => _NamedProgramLocalParameters4fvEXT(program, target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameters4fvEXT(uint program, ProgramTarget target, uint index, int count, void* @params) => _NamedProgramLocalParameters4fvEXT_ptr(program, target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParameters4fvEXT(uint program, ProgramTarget target, uint index, int count, IntPtr @params) => _NamedProgramLocalParameters4fvEXT_intptr(program, target, index, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParametersI4ivEXT(uint program, ProgramTarget target, uint index, int count, int[] @params) => _NamedProgramLocalParametersI4ivEXT(program, target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParametersI4ivEXT(uint program, ProgramTarget target, uint index, int count, void* @params) => _NamedProgramLocalParametersI4ivEXT_ptr(program, target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParametersI4ivEXT(uint program, ProgramTarget target, uint index, int count, IntPtr @params) => _NamedProgramLocalParametersI4ivEXT_intptr(program, target, index, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParametersI4uivEXT(uint program, ProgramTarget target, uint index, int count, uint[] @params) => _NamedProgramLocalParametersI4uivEXT(program, target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParametersI4uivEXT(uint program, ProgramTarget target, uint index, int count, void* @params) => _NamedProgramLocalParametersI4uivEXT_ptr(program, target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramLocalParametersI4uivEXT(uint program, ProgramTarget target, uint index, int count, IntPtr @params) => _NamedProgramLocalParametersI4uivEXT_intptr(program, target, index, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedProgramStringEXT(uint program, ProgramTarget target, ProgramFormat format, int len, IntPtr @string) => _NamedProgramStringEXT(program, target, format, len, @string);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedRenderbufferStorage(uint renderbuffer, InternalFormat internalformat, int width, int height) => _NamedRenderbufferStorage(renderbuffer, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedRenderbufferStorageEXT(uint renderbuffer, InternalFormat internalformat, int width, int height) => _NamedRenderbufferStorageEXT(renderbuffer, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedRenderbufferStorageMultisample(uint renderbuffer, int samples, InternalFormat internalformat, int width, int height) => _NamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedRenderbufferStorageMultisampleAdvancedAMD(uint renderbuffer, int samples, int storageSamples, InternalFormat internalformat, int width, int height) => _NamedRenderbufferStorageMultisampleAdvancedAMD(renderbuffer, samples, storageSamples, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedRenderbufferStorageMultisampleCoverageEXT(uint renderbuffer, int coverageSamples, int colorSamples, InternalFormat internalformat, int width, int height) => _NamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedRenderbufferStorageMultisampleEXT(uint renderbuffer, int samples, InternalFormat internalformat, int width, int height) => _NamedRenderbufferStorageMultisampleEXT(renderbuffer, samples, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedStringARB(int type, int namelen, string name, int stringlen, string @string) => _NamedStringARB(type, namelen, name, stringlen, @string);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedStringARB(int type, int namelen, void* name, int stringlen, void* @string) => _NamedStringARB_ptr(type, namelen, name, stringlen, @string);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NamedStringARB(int type, int namelen, IntPtr name, int stringlen, IntPtr @string) => _NamedStringARB_intptr(type, namelen, name, stringlen, @string);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NewList(uint list, ListMode mode) => _NewList(list, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint NewObjectBufferATI(int size, IntPtr pointer, ArrayObjectUsageATI usage) => _NewObjectBufferATI(size, pointer, usage);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3b(sbyte nx, sbyte ny, sbyte nz) => _Normal3b(nx, ny, nz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3bv(sbyte[] v) => _Normal3bv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3bv(void* v) => _Normal3bv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3bv(IntPtr v) => _Normal3bv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3d(double nx, double ny, double nz) => _Normal3d(nx, ny, nz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3dv(double[] v) => _Normal3dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3dv(void* v) => _Normal3dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3dv(IntPtr v) => _Normal3dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3f(float nx, float ny, float nz) => _Normal3f(nx, ny, nz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3fVertex3fSUN(float nx, float ny, float nz, float x, float y, float z) => _Normal3fVertex3fSUN(nx, ny, nz, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3fVertex3fvSUN(float[] n, float[] v) => _Normal3fVertex3fvSUN(n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3fVertex3fvSUN(void* n, void* v) => _Normal3fVertex3fvSUN_ptr(n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3fVertex3fvSUN(IntPtr n, IntPtr v) => _Normal3fVertex3fvSUN_intptr(n, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3fv(float[] v) => _Normal3fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3fv(void* v) => _Normal3fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3fv(IntPtr v) => _Normal3fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3hNV(float nx, float ny, float nz) => _Normal3hNV(nx, ny, nz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3hvNV(float[] v) => _Normal3hvNV(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3hvNV(void* v) => _Normal3hvNV_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3hvNV(IntPtr v) => _Normal3hvNV_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3i(int nx, int ny, int nz) => _Normal3i(nx, ny, nz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3iv(int[] v) => _Normal3iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3iv(void* v) => _Normal3iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3iv(IntPtr v) => _Normal3iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3s(short nx, short ny, short nz) => _Normal3s(nx, ny, nz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3sv(short[] v) => _Normal3sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3sv(void* v) => _Normal3sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3sv(IntPtr v) => _Normal3sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3x(float nx, float ny, float nz) => _Normal3x(nx, ny, nz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3xOES(float nx, float ny, float nz) => _Normal3xOES(nx, ny, nz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3xvOES(float[] coords) => _Normal3xvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3xvOES(void* coords) => _Normal3xvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Normal3xvOES(IntPtr coords) => _Normal3xvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalFormatNV(int type, int stride) => _NormalFormatNV(type, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalP3ui(NormalPointerType type, uint coords) => _NormalP3ui(type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalP3uiv(NormalPointerType type, uint[] coords) => _NormalP3uiv(type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalP3uiv(NormalPointerType type, void* coords) => _NormalP3uiv_ptr(type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalP3uiv(NormalPointerType type, IntPtr coords) => _NormalP3uiv_intptr(type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalPointer(NormalPointerType type, int stride, IntPtr pointer) => _NormalPointer(type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalPointerEXT(NormalPointerType type, int stride, int count, IntPtr pointer) => _NormalPointerEXT(type, stride, count, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalPointerListIBM(NormalPointerType type, int stride, IntPtr* pointer, int ptrstride) => _NormalPointerListIBM(type, stride, pointer, ptrstride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalPointervINTEL(NormalPointerType type, IntPtr* pointer) => _NormalPointervINTEL(type, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3bATI(VertexStreamATI stream, sbyte nx, sbyte ny, sbyte nz) => _NormalStream3bATI(stream, nx, ny, nz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3bvATI(VertexStreamATI stream, sbyte[] coords) => _NormalStream3bvATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3bvATI(VertexStreamATI stream, void* coords) => _NormalStream3bvATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3bvATI(VertexStreamATI stream, IntPtr coords) => _NormalStream3bvATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3dATI(VertexStreamATI stream, double nx, double ny, double nz) => _NormalStream3dATI(stream, nx, ny, nz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3dvATI(VertexStreamATI stream, double[] coords) => _NormalStream3dvATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3dvATI(VertexStreamATI stream, void* coords) => _NormalStream3dvATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3dvATI(VertexStreamATI stream, IntPtr coords) => _NormalStream3dvATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3fATI(VertexStreamATI stream, float nx, float ny, float nz) => _NormalStream3fATI(stream, nx, ny, nz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3fvATI(VertexStreamATI stream, float[] coords) => _NormalStream3fvATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3fvATI(VertexStreamATI stream, void* coords) => _NormalStream3fvATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3fvATI(VertexStreamATI stream, IntPtr coords) => _NormalStream3fvATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3iATI(VertexStreamATI stream, int nx, int ny, int nz) => _NormalStream3iATI(stream, nx, ny, nz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3ivATI(VertexStreamATI stream, int[] coords) => _NormalStream3ivATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3ivATI(VertexStreamATI stream, void* coords) => _NormalStream3ivATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3ivATI(VertexStreamATI stream, IntPtr coords) => _NormalStream3ivATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3sATI(VertexStreamATI stream, short nx, short ny, short nz) => _NormalStream3sATI(stream, nx, ny, nz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3svATI(VertexStreamATI stream, short[] coords) => _NormalStream3svATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3svATI(VertexStreamATI stream, void* coords) => _NormalStream3svATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void NormalStream3svATI(VertexStreamATI stream, IntPtr coords) => _NormalStream3svATI_intptr(stream, coords);

        // ---

        /// <summary>
        /// glObjectLabel labels the object identified by            name within the namespace given by identifier.            identifier must be one of GL_BUFFER, GL_SHADER,            GL_PROGRAM, GL_VERTEX_ARRAY, GL_QUERY,            GL_PROGRAM_PIPELINE, GL_TRANSFORM_FEEDBACK, GL_SAMPLER,            GL_TEXTURE, GL_RENDERBUFFER, GL_FRAMEBUFFER,            to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects, query objects,            program pipelines, transform feedback objects, samplers, textures, renderbuffers and frame            buffers, respectively.
        /// label is the address of a string that will be used to label an object.            length contains the number of characters in label.            If length is negative, it is implied that            label contains a null-terminated string. If label            is NULL, any debug label is effectively removed from the object.
        /// </summary>
        /// <param name="identifier">The namespace from which the name of the object is allocated.</param>
        /// <param name="name">The name of the object to label.</param>
        /// <param name="length">The length of the label to be used for the object.</param>
        /// <param name="label">The address of a string containing the label to assign to the object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ObjectLabel(ObjectIdentifier identifier, uint name, int length, string label) => _ObjectLabel(identifier, name, length, label);

        /// <summary>
        /// glObjectLabel labels the object identified by            name within the namespace given by identifier.            identifier must be one of GL_BUFFER, GL_SHADER,            GL_PROGRAM, GL_VERTEX_ARRAY, GL_QUERY,            GL_PROGRAM_PIPELINE, GL_TRANSFORM_FEEDBACK, GL_SAMPLER,            GL_TEXTURE, GL_RENDERBUFFER, GL_FRAMEBUFFER,            to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects, query objects,            program pipelines, transform feedback objects, samplers, textures, renderbuffers and frame            buffers, respectively.
        /// label is the address of a string that will be used to label an object.            length contains the number of characters in label.            If length is negative, it is implied that            label contains a null-terminated string. If label            is NULL, any debug label is effectively removed from the object.
        /// </summary>
        /// <param name="identifier">The namespace from which the name of the object is allocated.</param>
        /// <param name="name">The name of the object to label.</param>
        /// <param name="length">The length of the label to be used for the object.</param>
        /// <param name="label">The address of a string containing the label to assign to the object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ObjectLabel(ObjectIdentifier identifier, uint name, int length, void* label) => _ObjectLabel_ptr(identifier, name, length, label);

        /// <summary>
        /// glObjectLabel labels the object identified by            name within the namespace given by identifier.            identifier must be one of GL_BUFFER, GL_SHADER,            GL_PROGRAM, GL_VERTEX_ARRAY, GL_QUERY,            GL_PROGRAM_PIPELINE, GL_TRANSFORM_FEEDBACK, GL_SAMPLER,            GL_TEXTURE, GL_RENDERBUFFER, GL_FRAMEBUFFER,            to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects, query objects,            program pipelines, transform feedback objects, samplers, textures, renderbuffers and frame            buffers, respectively.
        /// label is the address of a string that will be used to label an object.            length contains the number of characters in label.            If length is negative, it is implied that            label contains a null-terminated string. If label            is NULL, any debug label is effectively removed from the object.
        /// </summary>
        /// <param name="identifier">The namespace from which the name of the object is allocated.</param>
        /// <param name="name">The name of the object to label.</param>
        /// <param name="length">The length of the label to be used for the object.</param>
        /// <param name="label">The address of a string containing the label to assign to the object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ObjectLabel(ObjectIdentifier identifier, uint name, int length, IntPtr label) => _ObjectLabel_intptr(identifier, name, length, label);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ObjectLabelKHR(ObjectIdentifier identifier, uint name, int length, string label) => _ObjectLabelKHR(identifier, name, length, label);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ObjectLabelKHR(ObjectIdentifier identifier, uint name, int length, void* label) => _ObjectLabelKHR_ptr(identifier, name, length, label);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ObjectLabelKHR(ObjectIdentifier identifier, uint name, int length, IntPtr label) => _ObjectLabelKHR_intptr(identifier, name, length, label);

        // ---

        /// <summary>
        /// glObjectPtrLabel labels the sync object identified by            ptr.
        /// label is the address of a string that will be used to label the object.            length contains the number of characters in label.            If length is negative, it is implied that            label contains a null-terminated string. If label            is NULL, any debug label is effectively removed from the object.
        /// </summary>
        /// <param name="ptr">A pointer identifying a sync object.</param>
        /// <param name="length">The length of the label to be used for the object.</param>
        /// <param name="label">The address of a string containing the label to assign to the object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ObjectPtrLabel(IntPtr ptr, int length, string label) => _ObjectPtrLabel(ptr, length, label);

        /// <summary>
        /// glObjectPtrLabel labels the sync object identified by            ptr.
        /// label is the address of a string that will be used to label the object.            length contains the number of characters in label.            If length is negative, it is implied that            label contains a null-terminated string. If label            is NULL, any debug label is effectively removed from the object.
        /// </summary>
        /// <param name="ptr">A pointer identifying a sync object.</param>
        /// <param name="length">The length of the label to be used for the object.</param>
        /// <param name="label">The address of a string containing the label to assign to the object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ObjectPtrLabel(IntPtr ptr, int length, void* label) => _ObjectPtrLabel_ptr(ptr, length, label);

        /// <summary>
        /// glObjectPtrLabel labels the sync object identified by            ptr.
        /// label is the address of a string that will be used to label the object.            length contains the number of characters in label.            If length is negative, it is implied that            label contains a null-terminated string. If label            is NULL, any debug label is effectively removed from the object.
        /// </summary>
        /// <param name="ptr">A pointer identifying a sync object.</param>
        /// <param name="length">The length of the label to be used for the object.</param>
        /// <param name="label">The address of a string containing the label to assign to the object.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ObjectPtrLabel(IntPtr ptr, int length, IntPtr label) => _ObjectPtrLabel_intptr(ptr, length, label);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ObjectPtrLabelKHR(IntPtr ptr, int length, string label) => _ObjectPtrLabelKHR(ptr, length, label);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ObjectPtrLabelKHR(IntPtr ptr, int length, void* label) => _ObjectPtrLabelKHR_ptr(ptr, length, label);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ObjectPtrLabelKHR(IntPtr ptr, int length, IntPtr label) => _ObjectPtrLabelKHR_intptr(ptr, length, label);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int ObjectPurgeableAPPLE(int objectType, uint name, int option) => _ObjectPurgeableAPPLE(objectType, name, option);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int ObjectUnpurgeableAPPLE(int objectType, uint name, int option) => _ObjectUnpurgeableAPPLE(objectType, name, option);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Ortho(double left, double right, double bottom, double top, double zNear, double zFar) => _Ortho(left, right, bottom, top, zNear, zFar);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Orthof(float l, float r, float b, float t, float n, float f) => _Orthof(l, r, b, t, n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void OrthofOES(float l, float r, float b, float t, float n, float f) => _OrthofOES(l, r, b, t, n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Orthox(float l, float r, float b, float t, float n, float f) => _Orthox(l, r, b, t, n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void OrthoxOES(float l, float r, float b, float t, float n, float f) => _OrthoxOES(l, r, b, t, n, f);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PNTrianglesfATI(PNTrianglesPNameATI pname, float param) => _PNTrianglesfATI(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PNTrianglesiATI(PNTrianglesPNameATI pname, int param) => _PNTrianglesiATI(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PassTexCoordATI(uint dst, uint coord, SwizzleOpATI swizzle) => _PassTexCoordATI(dst, coord, swizzle);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PassThrough(float token) => _PassThrough(token);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PassThroughxOES(float token) => _PassThroughxOES(token);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PatchParameterfv(PatchParameterName pname, float[] values) => _PatchParameterfv(pname, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PatchParameterfv(PatchParameterName pname, void* values) => _PatchParameterfv_ptr(pname, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PatchParameterfv(PatchParameterName pname, IntPtr values) => _PatchParameterfv_intptr(pname, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PatchParameteri(PatchParameterName pname, int value) => _PatchParameteri(pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PatchParameteriEXT(PatchParameterName pname, int value) => _PatchParameteriEXT(pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PatchParameteriOES(PatchParameterName pname, int value) => _PatchParameteriOES(pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathColorGenNV(PathColor color, PathGenMode genMode, PathColorFormat colorFormat, float[] coeffs) => _PathColorGenNV(color, genMode, colorFormat, coeffs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathColorGenNV(PathColor color, PathGenMode genMode, PathColorFormat colorFormat, void* coeffs) => _PathColorGenNV_ptr(color, genMode, colorFormat, coeffs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathColorGenNV(PathColor color, PathGenMode genMode, PathColorFormat colorFormat, IntPtr coeffs) => _PathColorGenNV_intptr(color, genMode, colorFormat, coeffs);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathCommandsNV(uint path, int numCommands, byte[] commands, int numCoords, PathCoordType coordType, IntPtr coords) => _PathCommandsNV(path, numCommands, commands, numCoords, coordType, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathCommandsNV(uint path, int numCommands, void* commands, int numCoords, PathCoordType coordType, IntPtr coords) => _PathCommandsNV_ptr(path, numCommands, commands, numCoords, coordType, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathCommandsNV(uint path, int numCommands, IntPtr commands, int numCoords, PathCoordType coordType, IntPtr coords) => _PathCommandsNV_intptr(path, numCommands, commands, numCoords, coordType, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathCoordsNV(uint path, int numCoords, PathCoordType coordType, IntPtr coords) => _PathCoordsNV(path, numCoords, coordType, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathCoverDepthFuncNV(DepthFunction func) => _PathCoverDepthFuncNV(func);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathDashArrayNV(uint path, int dashCount, float[] dashArray) => _PathDashArrayNV(path, dashCount, dashArray);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathDashArrayNV(uint path, int dashCount, void* dashArray) => _PathDashArrayNV_ptr(path, dashCount, dashArray);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathDashArrayNV(uint path, int dashCount, IntPtr dashArray) => _PathDashArrayNV_intptr(path, dashCount, dashArray);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathFogGenNV(PathGenMode genMode) => _PathFogGenNV(genMode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int PathGlyphIndexArrayNV(uint firstPathName, int fontTarget, IntPtr fontName, int fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) => _PathGlyphIndexArrayNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int PathGlyphIndexRangeNV(int fontTarget, IntPtr fontName, int fontStyle, uint pathParameterTemplate, float emScale, uint baseAndCount) => _PathGlyphIndexRangeNV(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathGlyphRangeNV(uint firstPathName, PathFontTarget fontTarget, IntPtr fontName, int fontStyle, uint firstGlyph, int numGlyphs, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) => _PathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathGlyphsNV(uint firstPathName, PathFontTarget fontTarget, IntPtr fontName, int fontStyle, int numGlyphs, PathElementType type, IntPtr charcodes, PathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) => _PathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int PathMemoryGlyphIndexArrayNV(uint firstPathName, int fontTarget, IntPtr fontSize, IntPtr fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) => _PathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathParameterfNV(uint path, PathParameter pname, float value) => _PathParameterfNV(path, pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathParameterfvNV(uint path, PathParameter pname, float[] value) => _PathParameterfvNV(path, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathParameterfvNV(uint path, PathParameter pname, void* value) => _PathParameterfvNV_ptr(path, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathParameterfvNV(uint path, PathParameter pname, IntPtr value) => _PathParameterfvNV_intptr(path, pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathParameteriNV(uint path, PathParameter pname, int value) => _PathParameteriNV(path, pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathParameterivNV(uint path, PathParameter pname, int[] value) => _PathParameterivNV(path, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathParameterivNV(uint path, PathParameter pname, void* value) => _PathParameterivNV_ptr(path, pname, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathParameterivNV(uint path, PathParameter pname, IntPtr value) => _PathParameterivNV_intptr(path, pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathStencilDepthOffsetNV(float factor, float units) => _PathStencilDepthOffsetNV(factor, units);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathStencilFuncNV(StencilFunction func, int @ref, uint mask) => _PathStencilFuncNV(func, @ref, mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathStringNV(uint path, PathStringFormat format, int length, IntPtr pathString) => _PathStringNV(path, format, length, pathString);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, byte[] commands, int numCoords, PathCoordType coordType, IntPtr coords) => _PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, void* commands, int numCoords, PathCoordType coordType, IntPtr coords) => _PathSubCommandsNV_ptr(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, IntPtr commands, int numCoords, PathCoordType coordType, IntPtr coords) => _PathSubCommandsNV_intptr(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathSubCoordsNV(uint path, int coordStart, int numCoords, PathCoordType coordType, IntPtr coords) => _PathSubCoordsNV(path, coordStart, numCoords, coordType, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathTexGenNV(PathColor texCoordSet, PathGenMode genMode, int components, float[] coeffs) => _PathTexGenNV(texCoordSet, genMode, components, coeffs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathTexGenNV(PathColor texCoordSet, PathGenMode genMode, int components, void* coeffs) => _PathTexGenNV_ptr(texCoordSet, genMode, components, coeffs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PathTexGenNV(PathColor texCoordSet, PathGenMode genMode, int components, IntPtr coeffs) => _PathTexGenNV_intptr(texCoordSet, genMode, components, coeffs);

        // ---

        /// <summary>
        /// glPauseTransformFeedback pauses transform feedback operations on the currently active transform feedback            object. When transform feedback operations are paused, transform feedback is still considered active and changing most            transform feedback state related to the object results in an error. However, a new transform feedback object may be bound            while transform feedback is paused.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PauseTransformFeedback() => _PauseTransformFeedback();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PauseTransformFeedbackNV() => _PauseTransformFeedbackNV();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelDataRangeNV(PixelDataRangeTargetNV target, int length, IntPtr pointer) => _PixelDataRangeNV(target, length, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelMapfv(PixelMap map, int mapsize, float[] values) => _PixelMapfv(map, mapsize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelMapfv(PixelMap map, int mapsize, void* values) => _PixelMapfv_ptr(map, mapsize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelMapfv(PixelMap map, int mapsize, IntPtr values) => _PixelMapfv_intptr(map, mapsize, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelMapuiv(PixelMap map, int mapsize, uint[] values) => _PixelMapuiv(map, mapsize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelMapuiv(PixelMap map, int mapsize, void* values) => _PixelMapuiv_ptr(map, mapsize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelMapuiv(PixelMap map, int mapsize, IntPtr values) => _PixelMapuiv_intptr(map, mapsize, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelMapusv(PixelMap map, int mapsize, ushort[] values) => _PixelMapusv(map, mapsize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelMapusv(PixelMap map, int mapsize, void* values) => _PixelMapusv_ptr(map, mapsize, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelMapusv(PixelMap map, int mapsize, IntPtr values) => _PixelMapusv_intptr(map, mapsize, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelMapx(PixelMap map, int size, float[] values) => _PixelMapx(map, size, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelMapx(PixelMap map, int size, void* values) => _PixelMapx_ptr(map, size, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelMapx(PixelMap map, int size, IntPtr values) => _PixelMapx_intptr(map, size, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelStoref(PixelStoreParameter pname, float param) => _PixelStoref(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelStorei(PixelStoreParameter pname, int param) => _PixelStorei(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelStorex(PixelStoreParameter pname, float param) => _PixelStorex(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTexGenParameterfSGIS(PixelTexGenParameterNameSGIS pname, float param) => _PixelTexGenParameterfSGIS(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, float[] @params) => _PixelTexGenParameterfvSGIS(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, void* @params) => _PixelTexGenParameterfvSGIS_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTexGenParameterfvSGIS(PixelTexGenParameterNameSGIS pname, IntPtr @params) => _PixelTexGenParameterfvSGIS_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTexGenParameteriSGIS(PixelTexGenParameterNameSGIS pname, int param) => _PixelTexGenParameteriSGIS(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, int[] @params) => _PixelTexGenParameterivSGIS(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, void* @params) => _PixelTexGenParameterivSGIS_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTexGenParameterivSGIS(PixelTexGenParameterNameSGIS pname, IntPtr @params) => _PixelTexGenParameterivSGIS_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTexGenSGIX(PixelTexGenModeSGIX mode) => _PixelTexGenSGIX(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTransferf(PixelTransferParameter pname, float param) => _PixelTransferf(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTransferi(PixelTransferParameter pname, int param) => _PixelTransferi(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTransferxOES(PixelTransferParameter pname, float param) => _PixelTransferxOES(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTransformParameterfEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, float param) => _PixelTransformParameterfEXT(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTransformParameterfvEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, float[] @params) => _PixelTransformParameterfvEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTransformParameterfvEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, void* @params) => _PixelTransformParameterfvEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTransformParameterfvEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, IntPtr @params) => _PixelTransformParameterfvEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTransformParameteriEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, int param) => _PixelTransformParameteriEXT(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTransformParameterivEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, int[] @params) => _PixelTransformParameterivEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTransformParameterivEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, void* @params) => _PixelTransformParameterivEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelTransformParameterivEXT(PixelTransformTargetEXT target, PixelTransformPNameEXT pname, IntPtr @params) => _PixelTransformParameterivEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelZoom(float xfactor, float yfactor) => _PixelZoom(xfactor, yfactor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PixelZoomxOES(float xfactor, float yfactor) => _PixelZoomxOES(xfactor, yfactor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, out float x, out float y, out float tangentX, out float tangentY) => _PointAlongPathNV(path, startSegment, numSegments, distance, out x, out y, out tangentX, out tangentY);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterf(PointParameterNameARB pname, float param) => _PointParameterf(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterfARB(PointParameterNameARB pname, float param) => _PointParameterfARB(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterfEXT(PointParameterNameARB pname, float param) => _PointParameterfEXT(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterfSGIS(PointParameterNameARB pname, float param) => _PointParameterfSGIS(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterfv(PointParameterNameARB pname, float[] @params) => _PointParameterfv(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterfv(PointParameterNameARB pname, void* @params) => _PointParameterfv_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterfv(PointParameterNameARB pname, IntPtr @params) => _PointParameterfv_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterfvARB(PointParameterNameARB pname, float[] @params) => _PointParameterfvARB(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterfvARB(PointParameterNameARB pname, void* @params) => _PointParameterfvARB_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterfvARB(PointParameterNameARB pname, IntPtr @params) => _PointParameterfvARB_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterfvEXT(PointParameterNameARB pname, float[] @params) => _PointParameterfvEXT(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterfvEXT(PointParameterNameARB pname, void* @params) => _PointParameterfvEXT_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterfvEXT(PointParameterNameARB pname, IntPtr @params) => _PointParameterfvEXT_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterfvSGIS(PointParameterNameARB pname, float[] @params) => _PointParameterfvSGIS(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterfvSGIS(PointParameterNameARB pname, void* @params) => _PointParameterfvSGIS_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterfvSGIS(PointParameterNameARB pname, IntPtr @params) => _PointParameterfvSGIS_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameteri(PointParameterNameARB pname, int param) => _PointParameteri(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameteriNV(PointParameterNameARB pname, int param) => _PointParameteriNV(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameteriv(PointParameterNameARB pname, int[] @params) => _PointParameteriv(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameteriv(PointParameterNameARB pname, void* @params) => _PointParameteriv_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameteriv(PointParameterNameARB pname, IntPtr @params) => _PointParameteriv_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterivNV(PointParameterNameARB pname, int[] @params) => _PointParameterivNV(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterivNV(PointParameterNameARB pname, void* @params) => _PointParameterivNV_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterivNV(PointParameterNameARB pname, IntPtr @params) => _PointParameterivNV_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterx(PointParameterNameARB pname, float param) => _PointParameterx(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterxOES(PointParameterNameARB pname, float param) => _PointParameterxOES(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterxv(PointParameterNameARB pname, float[] @params) => _PointParameterxv(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterxv(PointParameterNameARB pname, void* @params) => _PointParameterxv_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterxv(PointParameterNameARB pname, IntPtr @params) => _PointParameterxv_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterxvOES(PointParameterNameARB pname, float[] @params) => _PointParameterxvOES(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterxvOES(PointParameterNameARB pname, void* @params) => _PointParameterxvOES_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointParameterxvOES(PointParameterNameARB pname, IntPtr @params) => _PointParameterxvOES_intptr(pname, @params);

        // ---

        /// <summary>
        /// glPointSize specifies the rasterized diameter of points. If point size mode            is disabled (see glEnable with parameter            GL_PROGRAM_POINT_SIZE), this value will be used to rasterize points. Otherwise,            the value written to the shading language built-in variable gl_PointSize will be used.
        /// </summary>
        /// <param name="size">Specifies the diameter of rasterized points.                    The initial value is 1.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointSize(float size) => _PointSize(size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointSizePointerOES(int type, int stride, IntPtr pointer) => _PointSizePointerOES(type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointSizex(float size) => _PointSizex(size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PointSizexOES(float size) => _PointSizexOES(size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int PollAsyncSGIX(out uint markerp) => _PollAsyncSGIX(out markerp);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int PollInstrumentsSGIX(out int marker_p) => _PollInstrumentsSGIX(out marker_p);

        // ---

        /// <summary>
        /// glPolygonMode controls the interpretation of polygons for rasterization.            face describes which polygons mode applies to:            both front and back-facing polygons (GL_FRONT_AND_BACK).            The polygon mode affects only the final rasterization of polygons.            In particular,            a polygon's vertices are lit and            the polygon is clipped and possibly culled before these modes are applied.
        /// Three modes are defined and can be specified in mode:
        /// GL_POINT                        Polygon vertices that are marked as the start of a boundary edge                        are drawn as points.                        Point attributes such as                        GL_POINT_SIZE and                        GL_POINT_SMOOTH control                        the rasterization of the points.                        Polygon rasterization attributes other than GL_POLYGON_MODE have no effect.                    GL_LINE                        Boundary edges of the polygon are drawn as line segments.                        Line attributes such as                        GL_LINE_WIDTH and                        GL_LINE_SMOOTH control                        the rasterization of the lines.                        Polygon rasterization attributes other than GL_POLYGON_MODE have no effect.                    GL_FILL                        The interior of the polygon is filled.                        Polygon attributes such as GL_POLYGON_SMOOTH control the rasterization of the polygon.
        /// </summary>
        /// <param name="face">Specifies the polygons that mode applies to.                    Must be GL_FRONT_AND_BACK for front- and back-facing polygons.</param>
        /// <param name="mode">Specifies how polygons will be rasterized.                    Accepted values are                    GL_POINT,                    GL_LINE, and                    GL_FILL.                    The initial value is GL_FILL for both front- and back-facing polygons.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PolygonMode(MaterialFace face, PolygonMode mode) => _PolygonMode(face, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PolygonModeNV(MaterialFace face, PolygonMode mode) => _PolygonModeNV(face, mode);

        // ---

        /// <summary>
        /// When GL_POLYGON_OFFSET_FILL, GL_POLYGON_OFFSET_LINE, or            GL_POLYGON_OFFSET_POINT is enabled, each            fragment's depth value will be offset after it is interpolated            from the depth values of the appropriate vertices.            The value of the offset is                        is the smallest value that is guaranteed to            produce a resolvable offset for a given implementation.            The offset is added before the depth test is performed and before            the value is written into the depth buffer.
        /// glPolygonOffset is useful for rendering hidden-line images, for applying decals            to surfaces, and for rendering solids with highlighted edges.
        /// </summary>
        /// <param name="factor">Specifies a scale factor that is used to create a variable                    depth offset for each polygon. The initial value is 0.</param>
        /// <param name="units">Is multiplied by an implementation-specific value to                    create a constant depth offset. The initial value is 0.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PolygonOffset(float factor, float units) => _PolygonOffset(factor, units);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PolygonOffsetClamp(float factor, float units, float clamp) => _PolygonOffsetClamp(factor, units, clamp);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PolygonOffsetClampEXT(float factor, float units, float clamp) => _PolygonOffsetClampEXT(factor, units, clamp);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PolygonOffsetEXT(float factor, float bias) => _PolygonOffsetEXT(factor, bias);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PolygonOffsetx(float factor, float units) => _PolygonOffsetx(factor, units);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PolygonOffsetxOES(float factor, float units) => _PolygonOffsetxOES(factor, units);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PolygonStipple(byte[] mask) => _PolygonStipple(mask);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PolygonStipple(void* mask) => _PolygonStipple_ptr(mask);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PolygonStipple(IntPtr mask) => _PolygonStipple_intptr(mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PopAttrib() => _PopAttrib();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PopClientAttrib() => _PopClientAttrib();

        // ---

        /// <summary>
        /// glPopDebugGroup pops the active debug group.            After popping a debug group, the GL will also generate a debug            output message describing its cause based on the message            string, the source source, and an ID id            submitted to the corresponding glPushDebugGroup            command. GL_DEBUG_TYPE_PUSH_GROUP and GL_DEBUG_TYPE_POP_GROUP            share a single namespace for message id.            severity has the value GL_DEBUG_SEVERITY_NOTIFICATION. The type            has the value GL_DEBUG_TYPE_POP_GROUP. Popping a debug group restores            the debug output volume control of the parent debug group.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PopDebugGroup() => _PopDebugGroup();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PopDebugGroupKHR() => _PopDebugGroupKHR();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PopGroupMarkerEXT() => _PopGroupMarkerEXT();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PopMatrix() => _PopMatrix();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PopName() => _PopName();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PresentFrameDualFillNV(uint video_slot, UInt64 minPresentTime, uint beginPresentTimeId, uint presentDurationId, int type, int target0, uint fill0, int target1, uint fill1, int target2, uint fill2, int target3, uint fill3) => _PresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PresentFrameKeyedNV(uint video_slot, UInt64 minPresentTime, uint beginPresentTimeId, uint presentDurationId, int type, int target0, uint fill0, uint key0, int target1, uint fill1, uint key1) => _PresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrimitiveBoundingBox(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW) => _PrimitiveBoundingBox(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrimitiveBoundingBoxARB(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW) => _PrimitiveBoundingBoxARB(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrimitiveBoundingBoxEXT(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW) => _PrimitiveBoundingBoxEXT(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrimitiveBoundingBoxOES(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW) => _PrimitiveBoundingBoxOES(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);

        // ---

        /// <summary>
        /// glPrimitiveRestartIndex specifies a vertex array element that is treated specially when            primitive restarting is enabled. This is known as the primitive restart index.
        /// When one of the Draw* commands transfers a set of generic attribute array elements to            the GL, if the index within the vertex arrays corresponding to that set is equal to the primitive restart            index, then the GL does not process those elements as a vertex. Instead, it is as if the drawing command            ended with the immediately preceding transfer, and another drawing command is immediately started with            the same parameters, but only transferring the immediately following element through the end of the            originally specified elements.
        /// When either glDrawElementsBaseVertex,            glDrawElementsInstancedBaseVertex or            glMultiDrawElementsBaseVertex is used, the primitive restart            comparison occurs before the basevertex offset is added to the array index.
        /// </summary>
        /// <param name="index">Specifies the value to be interpreted as the primitive restart index.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrimitiveRestartIndex(uint index) => _PrimitiveRestartIndex(index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrimitiveRestartIndexNV(uint index) => _PrimitiveRestartIndexNV(index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrimitiveRestartNV() => _PrimitiveRestartNV();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrioritizeTextures(int n, uint[] textures, float[] priorities) => _PrioritizeTextures(n, textures, priorities);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrioritizeTextures(int n, void* textures, void* priorities) => _PrioritizeTextures_ptr(n, textures, priorities);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrioritizeTextures(int n, IntPtr textures, IntPtr priorities) => _PrioritizeTextures_intptr(n, textures, priorities);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrioritizeTexturesEXT(int n, uint[] textures, float[] priorities) => _PrioritizeTexturesEXT(n, textures, priorities);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrioritizeTexturesEXT(int n, void* textures, void* priorities) => _PrioritizeTexturesEXT_ptr(n, textures, priorities);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrioritizeTexturesEXT(int n, IntPtr textures, IntPtr priorities) => _PrioritizeTexturesEXT_intptr(n, textures, priorities);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrioritizeTexturesxOES(int n, uint[] textures, float[] priorities) => _PrioritizeTexturesxOES(n, textures, priorities);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrioritizeTexturesxOES(int n, void* textures, void* priorities) => _PrioritizeTexturesxOES_ptr(n, textures, priorities);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PrioritizeTexturesxOES(int n, IntPtr textures, IntPtr priorities) => _PrioritizeTexturesxOES_intptr(n, textures, priorities);

        // ---

        /// <summary>
        /// glProgramBinary loads a program object with a program binary previously            returned from glGetProgramBinary.            binaryFormat and binary must be those returned            by a previous call to glGetProgramBinary,            and length must be the length returned by            glGetProgramBinary, or by            glGetProgram when called with            pname set to GL_PROGRAM_BINARY_LENGTH.            If these conditions are not met, loading the program binary will fail and program's            GL_LINK_STATUS will be set to GL_FALSE.
        /// A program object's program binary is replaced by calls to            glLinkProgram or            glProgramBinary. When linking success or failure is concerned, glProgramBinary            can be considered to perform an implicit linking operation.            glLinkProgram and glProgramBinary            both set the program object's GL_LINK_STATUS to GL_TRUE            or GL_FALSE.
        /// A successful call to glProgramBinary will reset all uniform variables to their            initial values. The initial value is either the value of the variable's initializer as specified in the            original shader source, or zero if no initializer was present. Additionally, all vertex shader input            and fragment shader output assignments that were in effect when the program was linked before saving are            restored with glProgramBinary is called.
        /// </summary>
        /// <param name="program">Specifies the name of a program object into which to load a program binary.</param>
        /// <param name="binaryFormat">Specifies the format of the binary data in binary.</param>
        /// <param name="binary">Specifies the address an array containing the binary to be loaded into program.</param>
        /// <param name="length">Specifies the number of bytes contained in binary.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramBinary(uint program, int binaryFormat, IntPtr binary, int length) => _ProgramBinary(program, binaryFormat, binary, length);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramBinaryOES(uint program, int binaryFormat, IntPtr binary, int length) => _ProgramBinaryOES(program, binaryFormat, binary, length);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramBufferParametersIivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, int[] @params) => _ProgramBufferParametersIivNV(target, bindingIndex, wordIndex, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramBufferParametersIivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, void* @params) => _ProgramBufferParametersIivNV_ptr(target, bindingIndex, wordIndex, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramBufferParametersIivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, IntPtr @params) => _ProgramBufferParametersIivNV_intptr(target, bindingIndex, wordIndex, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramBufferParametersIuivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, uint[] @params) => _ProgramBufferParametersIuivNV(target, bindingIndex, wordIndex, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramBufferParametersIuivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, void* @params) => _ProgramBufferParametersIuivNV_ptr(target, bindingIndex, wordIndex, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramBufferParametersIuivNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, IntPtr @params) => _ProgramBufferParametersIuivNV_intptr(target, bindingIndex, wordIndex, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramBufferParametersfvNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, float[] @params) => _ProgramBufferParametersfvNV(target, bindingIndex, wordIndex, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramBufferParametersfvNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, void* @params) => _ProgramBufferParametersfvNV_ptr(target, bindingIndex, wordIndex, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramBufferParametersfvNV(ProgramTarget target, uint bindingIndex, uint wordIndex, int count, IntPtr @params) => _ProgramBufferParametersfvNV_intptr(target, bindingIndex, wordIndex, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameter4dARB(ProgramTarget target, uint index, double x, double y, double z, double w) => _ProgramEnvParameter4dARB(target, index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameter4dvARB(ProgramTarget target, uint index, double[] @params) => _ProgramEnvParameter4dvARB(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameter4dvARB(ProgramTarget target, uint index, void* @params) => _ProgramEnvParameter4dvARB_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameter4dvARB(ProgramTarget target, uint index, IntPtr @params) => _ProgramEnvParameter4dvARB_intptr(target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameter4fARB(ProgramTarget target, uint index, float x, float y, float z, float w) => _ProgramEnvParameter4fARB(target, index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameter4fvARB(ProgramTarget target, uint index, float[] @params) => _ProgramEnvParameter4fvARB(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameter4fvARB(ProgramTarget target, uint index, void* @params) => _ProgramEnvParameter4fvARB_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameter4fvARB(ProgramTarget target, uint index, IntPtr @params) => _ProgramEnvParameter4fvARB_intptr(target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameterI4iNV(ProgramTarget target, uint index, int x, int y, int z, int w) => _ProgramEnvParameterI4iNV(target, index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameterI4ivNV(ProgramTarget target, uint index, int[] @params) => _ProgramEnvParameterI4ivNV(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameterI4ivNV(ProgramTarget target, uint index, void* @params) => _ProgramEnvParameterI4ivNV_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameterI4ivNV(ProgramTarget target, uint index, IntPtr @params) => _ProgramEnvParameterI4ivNV_intptr(target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameterI4uiNV(ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => _ProgramEnvParameterI4uiNV(target, index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameterI4uivNV(ProgramTarget target, uint index, uint[] @params) => _ProgramEnvParameterI4uivNV(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameterI4uivNV(ProgramTarget target, uint index, void* @params) => _ProgramEnvParameterI4uivNV_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameterI4uivNV(ProgramTarget target, uint index, IntPtr @params) => _ProgramEnvParameterI4uivNV_intptr(target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameters4fvEXT(ProgramTarget target, uint index, int count, float[] @params) => _ProgramEnvParameters4fvEXT(target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameters4fvEXT(ProgramTarget target, uint index, int count, void* @params) => _ProgramEnvParameters4fvEXT_ptr(target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParameters4fvEXT(ProgramTarget target, uint index, int count, IntPtr @params) => _ProgramEnvParameters4fvEXT_intptr(target, index, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParametersI4ivNV(ProgramTarget target, uint index, int count, int[] @params) => _ProgramEnvParametersI4ivNV(target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParametersI4ivNV(ProgramTarget target, uint index, int count, void* @params) => _ProgramEnvParametersI4ivNV_ptr(target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParametersI4ivNV(ProgramTarget target, uint index, int count, IntPtr @params) => _ProgramEnvParametersI4ivNV_intptr(target, index, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParametersI4uivNV(ProgramTarget target, uint index, int count, uint[] @params) => _ProgramEnvParametersI4uivNV(target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParametersI4uivNV(ProgramTarget target, uint index, int count, void* @params) => _ProgramEnvParametersI4uivNV_ptr(target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramEnvParametersI4uivNV(ProgramTarget target, uint index, int count, IntPtr @params) => _ProgramEnvParametersI4uivNV_intptr(target, index, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameter4dARB(ProgramTarget target, uint index, double x, double y, double z, double w) => _ProgramLocalParameter4dARB(target, index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameter4dvARB(ProgramTarget target, uint index, double[] @params) => _ProgramLocalParameter4dvARB(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameter4dvARB(ProgramTarget target, uint index, void* @params) => _ProgramLocalParameter4dvARB_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameter4dvARB(ProgramTarget target, uint index, IntPtr @params) => _ProgramLocalParameter4dvARB_intptr(target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameter4fARB(ProgramTarget target, uint index, float x, float y, float z, float w) => _ProgramLocalParameter4fARB(target, index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameter4fvARB(ProgramTarget target, uint index, float[] @params) => _ProgramLocalParameter4fvARB(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameter4fvARB(ProgramTarget target, uint index, void* @params) => _ProgramLocalParameter4fvARB_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameter4fvARB(ProgramTarget target, uint index, IntPtr @params) => _ProgramLocalParameter4fvARB_intptr(target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameterI4iNV(ProgramTarget target, uint index, int x, int y, int z, int w) => _ProgramLocalParameterI4iNV(target, index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameterI4ivNV(ProgramTarget target, uint index, int[] @params) => _ProgramLocalParameterI4ivNV(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameterI4ivNV(ProgramTarget target, uint index, void* @params) => _ProgramLocalParameterI4ivNV_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameterI4ivNV(ProgramTarget target, uint index, IntPtr @params) => _ProgramLocalParameterI4ivNV_intptr(target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameterI4uiNV(ProgramTarget target, uint index, uint x, uint y, uint z, uint w) => _ProgramLocalParameterI4uiNV(target, index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameterI4uivNV(ProgramTarget target, uint index, uint[] @params) => _ProgramLocalParameterI4uivNV(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameterI4uivNV(ProgramTarget target, uint index, void* @params) => _ProgramLocalParameterI4uivNV_ptr(target, index, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameterI4uivNV(ProgramTarget target, uint index, IntPtr @params) => _ProgramLocalParameterI4uivNV_intptr(target, index, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameters4fvEXT(ProgramTarget target, uint index, int count, float[] @params) => _ProgramLocalParameters4fvEXT(target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameters4fvEXT(ProgramTarget target, uint index, int count, void* @params) => _ProgramLocalParameters4fvEXT_ptr(target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParameters4fvEXT(ProgramTarget target, uint index, int count, IntPtr @params) => _ProgramLocalParameters4fvEXT_intptr(target, index, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParametersI4ivNV(ProgramTarget target, uint index, int count, int[] @params) => _ProgramLocalParametersI4ivNV(target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParametersI4ivNV(ProgramTarget target, uint index, int count, void* @params) => _ProgramLocalParametersI4ivNV_ptr(target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParametersI4ivNV(ProgramTarget target, uint index, int count, IntPtr @params) => _ProgramLocalParametersI4ivNV_intptr(target, index, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParametersI4uivNV(ProgramTarget target, uint index, int count, uint[] @params) => _ProgramLocalParametersI4uivNV(target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParametersI4uivNV(ProgramTarget target, uint index, int count, void* @params) => _ProgramLocalParametersI4uivNV_ptr(target, index, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramLocalParametersI4uivNV(ProgramTarget target, uint index, int count, IntPtr @params) => _ProgramLocalParametersI4uivNV_intptr(target, index, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramNamedParameter4dNV(uint id, int len, byte[] name, double x, double y, double z, double w) => _ProgramNamedParameter4dNV(id, len, name, x, y, z, w);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramNamedParameter4dNV(uint id, int len, void* name, double x, double y, double z, double w) => _ProgramNamedParameter4dNV_ptr(id, len, name, x, y, z, w);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramNamedParameter4dNV(uint id, int len, IntPtr name, double x, double y, double z, double w) => _ProgramNamedParameter4dNV_intptr(id, len, name, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramNamedParameter4dvNV(uint id, int len, byte[] name, double[] v) => _ProgramNamedParameter4dvNV(id, len, name, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramNamedParameter4dvNV(uint id, int len, void* name, void* v) => _ProgramNamedParameter4dvNV_ptr(id, len, name, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramNamedParameter4dvNV(uint id, int len, IntPtr name, IntPtr v) => _ProgramNamedParameter4dvNV_intptr(id, len, name, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramNamedParameter4fNV(uint id, int len, byte[] name, float x, float y, float z, float w) => _ProgramNamedParameter4fNV(id, len, name, x, y, z, w);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramNamedParameter4fNV(uint id, int len, void* name, float x, float y, float z, float w) => _ProgramNamedParameter4fNV_ptr(id, len, name, x, y, z, w);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramNamedParameter4fNV(uint id, int len, IntPtr name, float x, float y, float z, float w) => _ProgramNamedParameter4fNV_intptr(id, len, name, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramNamedParameter4fvNV(uint id, int len, byte[] name, float[] v) => _ProgramNamedParameter4fvNV(id, len, name, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramNamedParameter4fvNV(uint id, int len, void* name, void* v) => _ProgramNamedParameter4fvNV_ptr(id, len, name, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramNamedParameter4fvNV(uint id, int len, IntPtr name, IntPtr v) => _ProgramNamedParameter4fvNV_intptr(id, len, name, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameter4dNV(VertexAttribEnumNV target, uint index, double x, double y, double z, double w) => _ProgramParameter4dNV(target, index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameter4dvNV(VertexAttribEnumNV target, uint index, double[] v) => _ProgramParameter4dvNV(target, index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameter4dvNV(VertexAttribEnumNV target, uint index, void* v) => _ProgramParameter4dvNV_ptr(target, index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameter4dvNV(VertexAttribEnumNV target, uint index, IntPtr v) => _ProgramParameter4dvNV_intptr(target, index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameter4fNV(VertexAttribEnumNV target, uint index, float x, float y, float z, float w) => _ProgramParameter4fNV(target, index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameter4fvNV(VertexAttribEnumNV target, uint index, float[] v) => _ProgramParameter4fvNV(target, index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameter4fvNV(VertexAttribEnumNV target, uint index, void* v) => _ProgramParameter4fvNV_ptr(target, index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameter4fvNV(VertexAttribEnumNV target, uint index, IntPtr v) => _ProgramParameter4fvNV_intptr(target, index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameteri(uint program, ProgramParameterPName pname, int value) => _ProgramParameteri(program, pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameteriARB(uint program, ProgramParameterPName pname, int value) => _ProgramParameteriARB(program, pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameteriEXT(uint program, ProgramParameterPName pname, int value) => _ProgramParameteriEXT(program, pname, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameters4dvNV(VertexAttribEnumNV target, uint index, int count, double[] v) => _ProgramParameters4dvNV(target, index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameters4dvNV(VertexAttribEnumNV target, uint index, int count, void* v) => _ProgramParameters4dvNV_ptr(target, index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameters4dvNV(VertexAttribEnumNV target, uint index, int count, IntPtr v) => _ProgramParameters4dvNV_intptr(target, index, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameters4fvNV(VertexAttribEnumNV target, uint index, int count, float[] v) => _ProgramParameters4fvNV(target, index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameters4fvNV(VertexAttribEnumNV target, uint index, int count, void* v) => _ProgramParameters4fvNV_ptr(target, index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramParameters4fvNV(VertexAttribEnumNV target, uint index, int count, IntPtr v) => _ProgramParameters4fvNV_intptr(target, index, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramPathFragmentInputGenNV(uint program, int location, int genMode, int components, float[] coeffs) => _ProgramPathFragmentInputGenNV(program, location, genMode, components, coeffs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramPathFragmentInputGenNV(uint program, int location, int genMode, int components, void* coeffs) => _ProgramPathFragmentInputGenNV_ptr(program, location, genMode, components, coeffs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramPathFragmentInputGenNV(uint program, int location, int genMode, int components, IntPtr coeffs) => _ProgramPathFragmentInputGenNV_intptr(program, location, genMode, components, coeffs);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramStringARB(ProgramTarget target, ProgramFormat format, int len, IntPtr @string) => _ProgramStringARB(target, format, len, @string);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramSubroutineParametersuivNV(int target, int count, uint[] @params) => _ProgramSubroutineParametersuivNV(target, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramSubroutineParametersuivNV(int target, int count, void* @params) => _ProgramSubroutineParametersuivNV_ptr(target, count, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramSubroutineParametersuivNV(int target, int count, IntPtr @params) => _ProgramSubroutineParametersuivNV_intptr(target, count, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1d(uint program, int location, double v0) => _ProgramUniform1d(program, location, v0);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1dEXT(uint program, int location, double x) => _ProgramUniform1dEXT(program, location, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1dv(uint program, int location, int count, double[] value) => _ProgramUniform1dv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1dv(uint program, int location, int count, void* value) => _ProgramUniform1dv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1dv(uint program, int location, int count, IntPtr value) => _ProgramUniform1dv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1dvEXT(uint program, int location, int count, double[] value) => _ProgramUniform1dvEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1dvEXT(uint program, int location, int count, void* value) => _ProgramUniform1dvEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1dvEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform1dvEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1f(uint program, int location, float v0) => _ProgramUniform1f(program, location, v0);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1fEXT(uint program, int location, float v0) => _ProgramUniform1fEXT(program, location, v0);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1fv(uint program, int location, int count, float[] value) => _ProgramUniform1fv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1fv(uint program, int location, int count, void* value) => _ProgramUniform1fv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1fv(uint program, int location, int count, IntPtr value) => _ProgramUniform1fv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1fvEXT(uint program, int location, int count, float[] value) => _ProgramUniform1fvEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1fvEXT(uint program, int location, int count, void* value) => _ProgramUniform1fvEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1fvEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform1fvEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1i(uint program, int location, int v0) => _ProgramUniform1i(program, location, v0);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1i64ARB(uint program, int location, Int64 x) => _ProgramUniform1i64ARB(program, location, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1i64NV(uint program, int location, Int64 x) => _ProgramUniform1i64NV(program, location, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1i64vARB(uint program, int location, int count, Int64[] value) => _ProgramUniform1i64vARB(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1i64vARB(uint program, int location, int count, void* value) => _ProgramUniform1i64vARB_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1i64vARB(uint program, int location, int count, IntPtr value) => _ProgramUniform1i64vARB_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1i64vNV(uint program, int location, int count, Int64[] value) => _ProgramUniform1i64vNV(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1i64vNV(uint program, int location, int count, void* value) => _ProgramUniform1i64vNV_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1i64vNV(uint program, int location, int count, IntPtr value) => _ProgramUniform1i64vNV_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1iEXT(uint program, int location, int v0) => _ProgramUniform1iEXT(program, location, v0);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1iv(uint program, int location, int count, int[] value) => _ProgramUniform1iv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1iv(uint program, int location, int count, void* value) => _ProgramUniform1iv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1iv(uint program, int location, int count, IntPtr value) => _ProgramUniform1iv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1ivEXT(uint program, int location, int count, int[] value) => _ProgramUniform1ivEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1ivEXT(uint program, int location, int count, void* value) => _ProgramUniform1ivEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1ivEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform1ivEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1ui(uint program, int location, uint v0) => _ProgramUniform1ui(program, location, v0);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1ui64ARB(uint program, int location, UInt64 x) => _ProgramUniform1ui64ARB(program, location, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1ui64NV(uint program, int location, UInt64 x) => _ProgramUniform1ui64NV(program, location, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1ui64vARB(uint program, int location, int count, UInt64[] value) => _ProgramUniform1ui64vARB(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1ui64vARB(uint program, int location, int count, void* value) => _ProgramUniform1ui64vARB_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1ui64vARB(uint program, int location, int count, IntPtr value) => _ProgramUniform1ui64vARB_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1ui64vNV(uint program, int location, int count, UInt64[] value) => _ProgramUniform1ui64vNV(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1ui64vNV(uint program, int location, int count, void* value) => _ProgramUniform1ui64vNV_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1ui64vNV(uint program, int location, int count, IntPtr value) => _ProgramUniform1ui64vNV_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1uiEXT(uint program, int location, uint v0) => _ProgramUniform1uiEXT(program, location, v0);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1uiv(uint program, int location, int count, uint[] value) => _ProgramUniform1uiv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1uiv(uint program, int location, int count, void* value) => _ProgramUniform1uiv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1uiv(uint program, int location, int count, IntPtr value) => _ProgramUniform1uiv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1uivEXT(uint program, int location, int count, uint[] value) => _ProgramUniform1uivEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1uivEXT(uint program, int location, int count, void* value) => _ProgramUniform1uivEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform1uivEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform1uivEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2d(uint program, int location, double v0, double v1) => _ProgramUniform2d(program, location, v0, v1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2dEXT(uint program, int location, double x, double y) => _ProgramUniform2dEXT(program, location, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2dv(uint program, int location, int count, double[] value) => _ProgramUniform2dv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2dv(uint program, int location, int count, void* value) => _ProgramUniform2dv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2dv(uint program, int location, int count, IntPtr value) => _ProgramUniform2dv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2dvEXT(uint program, int location, int count, double[] value) => _ProgramUniform2dvEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2dvEXT(uint program, int location, int count, void* value) => _ProgramUniform2dvEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2dvEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform2dvEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2f(uint program, int location, float v0, float v1) => _ProgramUniform2f(program, location, v0, v1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2fEXT(uint program, int location, float v0, float v1) => _ProgramUniform2fEXT(program, location, v0, v1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2fv(uint program, int location, int count, float[] value) => _ProgramUniform2fv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2fv(uint program, int location, int count, void* value) => _ProgramUniform2fv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2fv(uint program, int location, int count, IntPtr value) => _ProgramUniform2fv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2fvEXT(uint program, int location, int count, float[] value) => _ProgramUniform2fvEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2fvEXT(uint program, int location, int count, void* value) => _ProgramUniform2fvEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2fvEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform2fvEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2i(uint program, int location, int v0, int v1) => _ProgramUniform2i(program, location, v0, v1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2i64ARB(uint program, int location, Int64 x, Int64 y) => _ProgramUniform2i64ARB(program, location, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2i64NV(uint program, int location, Int64 x, Int64 y) => _ProgramUniform2i64NV(program, location, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2i64vARB(uint program, int location, int count, Int64[] value) => _ProgramUniform2i64vARB(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2i64vARB(uint program, int location, int count, void* value) => _ProgramUniform2i64vARB_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2i64vARB(uint program, int location, int count, IntPtr value) => _ProgramUniform2i64vARB_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2i64vNV(uint program, int location, int count, Int64[] value) => _ProgramUniform2i64vNV(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2i64vNV(uint program, int location, int count, void* value) => _ProgramUniform2i64vNV_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2i64vNV(uint program, int location, int count, IntPtr value) => _ProgramUniform2i64vNV_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2iEXT(uint program, int location, int v0, int v1) => _ProgramUniform2iEXT(program, location, v0, v1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2iv(uint program, int location, int count, int[] value) => _ProgramUniform2iv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2iv(uint program, int location, int count, void* value) => _ProgramUniform2iv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2iv(uint program, int location, int count, IntPtr value) => _ProgramUniform2iv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2ivEXT(uint program, int location, int count, int[] value) => _ProgramUniform2ivEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2ivEXT(uint program, int location, int count, void* value) => _ProgramUniform2ivEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2ivEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform2ivEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2ui(uint program, int location, uint v0, uint v1) => _ProgramUniform2ui(program, location, v0, v1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2ui64ARB(uint program, int location, UInt64 x, UInt64 y) => _ProgramUniform2ui64ARB(program, location, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2ui64NV(uint program, int location, UInt64 x, UInt64 y) => _ProgramUniform2ui64NV(program, location, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2ui64vARB(uint program, int location, int count, UInt64[] value) => _ProgramUniform2ui64vARB(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2ui64vARB(uint program, int location, int count, void* value) => _ProgramUniform2ui64vARB_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2ui64vARB(uint program, int location, int count, IntPtr value) => _ProgramUniform2ui64vARB_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2ui64vNV(uint program, int location, int count, UInt64[] value) => _ProgramUniform2ui64vNV(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2ui64vNV(uint program, int location, int count, void* value) => _ProgramUniform2ui64vNV_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2ui64vNV(uint program, int location, int count, IntPtr value) => _ProgramUniform2ui64vNV_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2uiEXT(uint program, int location, uint v0, uint v1) => _ProgramUniform2uiEXT(program, location, v0, v1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2uiv(uint program, int location, int count, uint[] value) => _ProgramUniform2uiv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2uiv(uint program, int location, int count, void* value) => _ProgramUniform2uiv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2uiv(uint program, int location, int count, IntPtr value) => _ProgramUniform2uiv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2uivEXT(uint program, int location, int count, uint[] value) => _ProgramUniform2uivEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2uivEXT(uint program, int location, int count, void* value) => _ProgramUniform2uivEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform2uivEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform2uivEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3d(uint program, int location, double v0, double v1, double v2) => _ProgramUniform3d(program, location, v0, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3dEXT(uint program, int location, double x, double y, double z) => _ProgramUniform3dEXT(program, location, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3dv(uint program, int location, int count, double[] value) => _ProgramUniform3dv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3dv(uint program, int location, int count, void* value) => _ProgramUniform3dv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3dv(uint program, int location, int count, IntPtr value) => _ProgramUniform3dv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3dvEXT(uint program, int location, int count, double[] value) => _ProgramUniform3dvEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3dvEXT(uint program, int location, int count, void* value) => _ProgramUniform3dvEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3dvEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform3dvEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3f(uint program, int location, float v0, float v1, float v2) => _ProgramUniform3f(program, location, v0, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3fEXT(uint program, int location, float v0, float v1, float v2) => _ProgramUniform3fEXT(program, location, v0, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3fv(uint program, int location, int count, float[] value) => _ProgramUniform3fv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3fv(uint program, int location, int count, void* value) => _ProgramUniform3fv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3fv(uint program, int location, int count, IntPtr value) => _ProgramUniform3fv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3fvEXT(uint program, int location, int count, float[] value) => _ProgramUniform3fvEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3fvEXT(uint program, int location, int count, void* value) => _ProgramUniform3fvEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3fvEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform3fvEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3i(uint program, int location, int v0, int v1, int v2) => _ProgramUniform3i(program, location, v0, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3i64ARB(uint program, int location, Int64 x, Int64 y, Int64 z) => _ProgramUniform3i64ARB(program, location, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3i64NV(uint program, int location, Int64 x, Int64 y, Int64 z) => _ProgramUniform3i64NV(program, location, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3i64vARB(uint program, int location, int count, Int64[] value) => _ProgramUniform3i64vARB(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3i64vARB(uint program, int location, int count, void* value) => _ProgramUniform3i64vARB_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3i64vARB(uint program, int location, int count, IntPtr value) => _ProgramUniform3i64vARB_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3i64vNV(uint program, int location, int count, Int64[] value) => _ProgramUniform3i64vNV(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3i64vNV(uint program, int location, int count, void* value) => _ProgramUniform3i64vNV_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3i64vNV(uint program, int location, int count, IntPtr value) => _ProgramUniform3i64vNV_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3iEXT(uint program, int location, int v0, int v1, int v2) => _ProgramUniform3iEXT(program, location, v0, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3iv(uint program, int location, int count, int[] value) => _ProgramUniform3iv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3iv(uint program, int location, int count, void* value) => _ProgramUniform3iv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3iv(uint program, int location, int count, IntPtr value) => _ProgramUniform3iv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3ivEXT(uint program, int location, int count, int[] value) => _ProgramUniform3ivEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3ivEXT(uint program, int location, int count, void* value) => _ProgramUniform3ivEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3ivEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform3ivEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3ui(uint program, int location, uint v0, uint v1, uint v2) => _ProgramUniform3ui(program, location, v0, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3ui64ARB(uint program, int location, UInt64 x, UInt64 y, UInt64 z) => _ProgramUniform3ui64ARB(program, location, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3ui64NV(uint program, int location, UInt64 x, UInt64 y, UInt64 z) => _ProgramUniform3ui64NV(program, location, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3ui64vARB(uint program, int location, int count, UInt64[] value) => _ProgramUniform3ui64vARB(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3ui64vARB(uint program, int location, int count, void* value) => _ProgramUniform3ui64vARB_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3ui64vARB(uint program, int location, int count, IntPtr value) => _ProgramUniform3ui64vARB_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3ui64vNV(uint program, int location, int count, UInt64[] value) => _ProgramUniform3ui64vNV(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3ui64vNV(uint program, int location, int count, void* value) => _ProgramUniform3ui64vNV_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3ui64vNV(uint program, int location, int count, IntPtr value) => _ProgramUniform3ui64vNV_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3uiEXT(uint program, int location, uint v0, uint v1, uint v2) => _ProgramUniform3uiEXT(program, location, v0, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3uiv(uint program, int location, int count, uint[] value) => _ProgramUniform3uiv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3uiv(uint program, int location, int count, void* value) => _ProgramUniform3uiv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3uiv(uint program, int location, int count, IntPtr value) => _ProgramUniform3uiv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3uivEXT(uint program, int location, int count, uint[] value) => _ProgramUniform3uivEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3uivEXT(uint program, int location, int count, void* value) => _ProgramUniform3uivEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform3uivEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform3uivEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4d(uint program, int location, double v0, double v1, double v2, double v3) => _ProgramUniform4d(program, location, v0, v1, v2, v3);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4dEXT(uint program, int location, double x, double y, double z, double w) => _ProgramUniform4dEXT(program, location, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4dv(uint program, int location, int count, double[] value) => _ProgramUniform4dv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4dv(uint program, int location, int count, void* value) => _ProgramUniform4dv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4dv(uint program, int location, int count, IntPtr value) => _ProgramUniform4dv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4dvEXT(uint program, int location, int count, double[] value) => _ProgramUniform4dvEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4dvEXT(uint program, int location, int count, void* value) => _ProgramUniform4dvEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4dvEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform4dvEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4f(uint program, int location, float v0, float v1, float v2, float v3) => _ProgramUniform4f(program, location, v0, v1, v2, v3);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4fEXT(uint program, int location, float v0, float v1, float v2, float v3) => _ProgramUniform4fEXT(program, location, v0, v1, v2, v3);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4fv(uint program, int location, int count, float[] value) => _ProgramUniform4fv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4fv(uint program, int location, int count, void* value) => _ProgramUniform4fv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4fv(uint program, int location, int count, IntPtr value) => _ProgramUniform4fv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4fvEXT(uint program, int location, int count, float[] value) => _ProgramUniform4fvEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4fvEXT(uint program, int location, int count, void* value) => _ProgramUniform4fvEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4fvEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform4fvEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4i(uint program, int location, int v0, int v1, int v2, int v3) => _ProgramUniform4i(program, location, v0, v1, v2, v3);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4i64ARB(uint program, int location, Int64 x, Int64 y, Int64 z, Int64 w) => _ProgramUniform4i64ARB(program, location, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4i64NV(uint program, int location, Int64 x, Int64 y, Int64 z, Int64 w) => _ProgramUniform4i64NV(program, location, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4i64vARB(uint program, int location, int count, Int64[] value) => _ProgramUniform4i64vARB(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4i64vARB(uint program, int location, int count, void* value) => _ProgramUniform4i64vARB_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4i64vARB(uint program, int location, int count, IntPtr value) => _ProgramUniform4i64vARB_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4i64vNV(uint program, int location, int count, Int64[] value) => _ProgramUniform4i64vNV(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4i64vNV(uint program, int location, int count, void* value) => _ProgramUniform4i64vNV_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4i64vNV(uint program, int location, int count, IntPtr value) => _ProgramUniform4i64vNV_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4iEXT(uint program, int location, int v0, int v1, int v2, int v3) => _ProgramUniform4iEXT(program, location, v0, v1, v2, v3);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4iv(uint program, int location, int count, int[] value) => _ProgramUniform4iv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4iv(uint program, int location, int count, void* value) => _ProgramUniform4iv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4iv(uint program, int location, int count, IntPtr value) => _ProgramUniform4iv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4ivEXT(uint program, int location, int count, int[] value) => _ProgramUniform4ivEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4ivEXT(uint program, int location, int count, void* value) => _ProgramUniform4ivEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4ivEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform4ivEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4ui(uint program, int location, uint v0, uint v1, uint v2, uint v3) => _ProgramUniform4ui(program, location, v0, v1, v2, v3);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4ui64ARB(uint program, int location, UInt64 x, UInt64 y, UInt64 z, UInt64 w) => _ProgramUniform4ui64ARB(program, location, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4ui64NV(uint program, int location, UInt64 x, UInt64 y, UInt64 z, UInt64 w) => _ProgramUniform4ui64NV(program, location, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4ui64vARB(uint program, int location, int count, UInt64[] value) => _ProgramUniform4ui64vARB(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4ui64vARB(uint program, int location, int count, void* value) => _ProgramUniform4ui64vARB_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4ui64vARB(uint program, int location, int count, IntPtr value) => _ProgramUniform4ui64vARB_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4ui64vNV(uint program, int location, int count, UInt64[] value) => _ProgramUniform4ui64vNV(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4ui64vNV(uint program, int location, int count, void* value) => _ProgramUniform4ui64vNV_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4ui64vNV(uint program, int location, int count, IntPtr value) => _ProgramUniform4ui64vNV_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4uiEXT(uint program, int location, uint v0, uint v1, uint v2, uint v3) => _ProgramUniform4uiEXT(program, location, v0, v1, v2, v3);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4uiv(uint program, int location, int count, uint[] value) => _ProgramUniform4uiv(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4uiv(uint program, int location, int count, void* value) => _ProgramUniform4uiv_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4uiv(uint program, int location, int count, IntPtr value) => _ProgramUniform4uiv_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4uivEXT(uint program, int location, int count, uint[] value) => _ProgramUniform4uivEXT(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4uivEXT(uint program, int location, int count, void* value) => _ProgramUniform4uivEXT_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniform4uivEXT(uint program, int location, int count, IntPtr value) => _ProgramUniform4uivEXT_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformHandleui64ARB(uint program, int location, UInt64 value) => _ProgramUniformHandleui64ARB(program, location, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformHandleui64IMG(uint program, int location, UInt64 value) => _ProgramUniformHandleui64IMG(program, location, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformHandleui64NV(uint program, int location, UInt64 value) => _ProgramUniformHandleui64NV(program, location, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformHandleui64vARB(uint program, int location, int count, UInt64[] values) => _ProgramUniformHandleui64vARB(program, location, count, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformHandleui64vARB(uint program, int location, int count, void* values) => _ProgramUniformHandleui64vARB_ptr(program, location, count, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformHandleui64vARB(uint program, int location, int count, IntPtr values) => _ProgramUniformHandleui64vARB_intptr(program, location, count, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformHandleui64vIMG(uint program, int location, int count, UInt64[] values) => _ProgramUniformHandleui64vIMG(program, location, count, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformHandleui64vIMG(uint program, int location, int count, void* values) => _ProgramUniformHandleui64vIMG_ptr(program, location, count, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformHandleui64vIMG(uint program, int location, int count, IntPtr values) => _ProgramUniformHandleui64vIMG_intptr(program, location, count, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformHandleui64vNV(uint program, int location, int count, UInt64[] values) => _ProgramUniformHandleui64vNV(program, location, count, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformHandleui64vNV(uint program, int location, int count, void* values) => _ProgramUniformHandleui64vNV_ptr(program, location, count, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformHandleui64vNV(uint program, int location, int count, IntPtr values) => _ProgramUniformHandleui64vNV_intptr(program, location, count, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2dv(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix2dv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2dv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix2dv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2dv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix2dv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2dvEXT(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix2dvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2dvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix2dvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2dvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix2dvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2fv(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix2fv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2fv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix2fv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2fv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix2fv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2fvEXT(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix2fvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2fvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix2fvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2fvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix2fvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x3dv(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix2x3dv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x3dv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix2x3dv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x3dv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix2x3dv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x3dvEXT(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix2x3dvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x3dvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix2x3dvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x3dvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix2x3dvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x3fv(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix2x3fv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x3fv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix2x3fv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x3fv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix2x3fv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x3fvEXT(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix2x3fvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x3fvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix2x3fvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x3fvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix2x3fvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x4dv(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix2x4dv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x4dv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix2x4dv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x4dv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix2x4dv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x4dvEXT(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix2x4dvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x4dvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix2x4dvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x4dvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix2x4dvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x4fv(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix2x4fv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x4fv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix2x4fv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x4fv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix2x4fv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x4fvEXT(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix2x4fvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x4fvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix2x4fvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix2x4fvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix2x4fvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3dv(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix3dv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3dv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix3dv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3dv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix3dv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3dvEXT(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix3dvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3dvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix3dvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3dvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix3dvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3fv(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix3fv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3fv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix3fv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3fv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix3fv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3fvEXT(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix3fvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3fvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix3fvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3fvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix3fvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x2dv(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix3x2dv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x2dv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix3x2dv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x2dv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix3x2dv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x2dvEXT(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix3x2dvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x2dvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix3x2dvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x2dvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix3x2dvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x2fv(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix3x2fv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x2fv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix3x2fv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x2fv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix3x2fv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x2fvEXT(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix3x2fvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x2fvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix3x2fvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x2fvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix3x2fvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x4dv(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix3x4dv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x4dv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix3x4dv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x4dv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix3x4dv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x4dvEXT(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix3x4dvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x4dvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix3x4dvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x4dvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix3x4dvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x4fv(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix3x4fv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x4fv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix3x4fv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x4fv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix3x4fv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x4fvEXT(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix3x4fvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x4fvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix3x4fvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix3x4fvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix3x4fvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4dv(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix4dv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4dv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix4dv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4dv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix4dv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4dvEXT(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix4dvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4dvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix4dvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4dvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix4dvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4fv(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix4fv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4fv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix4fv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4fv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix4fv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4fvEXT(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix4fvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4fvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix4fvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4fvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix4fvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x2dv(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix4x2dv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x2dv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix4x2dv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x2dv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix4x2dv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x2dvEXT(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix4x2dvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x2dvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix4x2dvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x2dvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix4x2dvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x2fv(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix4x2fv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x2fv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix4x2fv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x2fv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix4x2fv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x2fvEXT(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix4x2fvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x2fvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix4x2fvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x2fvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix4x2fvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x3dv(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix4x3dv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x3dv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix4x3dv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x3dv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix4x3dv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x3dvEXT(uint program, int location, int count, bool transpose, double[] value) => _ProgramUniformMatrix4x3dvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x3dvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix4x3dvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x3dvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix4x3dvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x3fv(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix4x3fv(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x3fv(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix4x3fv_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x3fv(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix4x3fv_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x3fvEXT(uint program, int location, int count, bool transpose, float[] value) => _ProgramUniformMatrix4x3fvEXT(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x3fvEXT(uint program, int location, int count, bool transpose, void* value) => _ProgramUniformMatrix4x3fvEXT_ptr(program, location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformMatrix4x3fvEXT(uint program, int location, int count, bool transpose, IntPtr value) => _ProgramUniformMatrix4x3fvEXT_intptr(program, location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformui64NV(uint program, int location, UInt64 value) => _ProgramUniformui64NV(program, location, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformui64vNV(uint program, int location, int count, UInt64[] value) => _ProgramUniformui64vNV(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformui64vNV(uint program, int location, int count, void* value) => _ProgramUniformui64vNV_ptr(program, location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramUniformui64vNV(uint program, int location, int count, IntPtr value) => _ProgramUniformui64vNV_intptr(program, location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProgramVertexLimitNV(ProgramTarget target, int limit) => _ProgramVertexLimitNV(target, limit);

        // ---

        /// <summary>
        /// Flatshading a vertex shader varying output means to assign all vetices of the primitive the same value            for that output. The vertex from which these values is derived is known as the provoking vertex and            glProvokingVertex specifies which vertex is to be used as the source of data for flat shaded varyings.
        /// provokeMode must be either GL_FIRST_VERTEX_CONVENTION or            GL_LAST_VERTEX_CONVENTION, and controls the selection of the vertex whose values are assigned to flatshaded            varying outputs. The interpretation of these values for the supported primitive types is:             Primitive Type of Polygon i First Vertex Convention  Last Vertex Convention                                 point                            ii                                independent line                                                            2i - 1                                                            2i                                line loop                            ii + 1, if i < n                                1, if i = n                                line strip                            ii + 1                                                            independent triangle                                                            3i - 2                                                            3i                                triangle strip                            ii + 2                                                            triangle fan                            i + 1                            i + 2                                                            line adjacency                                                            4i - 2                                                            4i - 1                                                            line strip adjacency                            i + 1                            i + 2                                                            triangle adjacency                                                            6i - 5                                                            6i - 1                                                            triangle strip adjacency                                                            2i - 1                                                            2i + 3
        /// If a vertex or geometry shader is active, user-defined varying outputs may be flatshaded by using the            flat qualifier when declaring the output.
        /// </summary>
        /// <param name="provokeMode">Specifies the vertex to be used as the source of data for flat shaded varyings.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProvokingVertex(VertexProvokingMode mode) => _ProvokingVertex(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ProvokingVertexEXT(VertexProvokingMode mode) => _ProvokingVertexEXT(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushAttrib(int mask) => _PushAttrib(mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushClientAttrib(int mask) => _PushClientAttrib(mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushClientAttribDefaultEXT(int mask) => _PushClientAttribDefaultEXT(mask);

        // ---

        /// <summary>
        /// glPushDebugGroup pushes a debug group described by the string            message into the command stream. The value of            id specifies the ID of messages generated. The parameter            length contains the number of characters in message.            If length is negative, it is implied that message            contains a null terminated string. The message has the specified source            and id, the typeGL_DEBUG_TYPE_PUSH_GROUP, and severityGL_DEBUG_SEVERITY_NOTIFICATION. The GL will put a new debug group            on top of the debug group stack which inherits the control of the            volume of debug output of the debug group previously residing on the            top of the debug group stack. Because debug groups are strictly            hierarchical, any additional control of the debug output volume will            only apply within the active debug group and the debug groups pushed            on top of the active debug group.
        /// </summary>
        /// <param name="source">The source of the debug message.</param>
        /// <param name="id">The identifier of the message.</param>
        /// <param name="length">The length of the message to be sent to the debug output stream.</param>
        /// <param name="message">The a string containing the message to be sent to the debug output stream.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushDebugGroup(DebugSource source, uint id, int length, string message) => _PushDebugGroup(source, id, length, message);

        /// <summary>
        /// glPushDebugGroup pushes a debug group described by the string            message into the command stream. The value of            id specifies the ID of messages generated. The parameter            length contains the number of characters in message.            If length is negative, it is implied that message            contains a null terminated string. The message has the specified source            and id, the typeGL_DEBUG_TYPE_PUSH_GROUP, and severityGL_DEBUG_SEVERITY_NOTIFICATION. The GL will put a new debug group            on top of the debug group stack which inherits the control of the            volume of debug output of the debug group previously residing on the            top of the debug group stack. Because debug groups are strictly            hierarchical, any additional control of the debug output volume will            only apply within the active debug group and the debug groups pushed            on top of the active debug group.
        /// </summary>
        /// <param name="source">The source of the debug message.</param>
        /// <param name="id">The identifier of the message.</param>
        /// <param name="length">The length of the message to be sent to the debug output stream.</param>
        /// <param name="message">The a string containing the message to be sent to the debug output stream.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushDebugGroup(DebugSource source, uint id, int length, void* message) => _PushDebugGroup_ptr(source, id, length, message);

        /// <summary>
        /// glPushDebugGroup pushes a debug group described by the string            message into the command stream. The value of            id specifies the ID of messages generated. The parameter            length contains the number of characters in message.            If length is negative, it is implied that message            contains a null terminated string. The message has the specified source            and id, the typeGL_DEBUG_TYPE_PUSH_GROUP, and severityGL_DEBUG_SEVERITY_NOTIFICATION. The GL will put a new debug group            on top of the debug group stack which inherits the control of the            volume of debug output of the debug group previously residing on the            top of the debug group stack. Because debug groups are strictly            hierarchical, any additional control of the debug output volume will            only apply within the active debug group and the debug groups pushed            on top of the active debug group.
        /// </summary>
        /// <param name="source">The source of the debug message.</param>
        /// <param name="id">The identifier of the message.</param>
        /// <param name="length">The length of the message to be sent to the debug output stream.</param>
        /// <param name="message">The a string containing the message to be sent to the debug output stream.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushDebugGroup(DebugSource source, uint id, int length, IntPtr message) => _PushDebugGroup_intptr(source, id, length, message);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushDebugGroupKHR(DebugSource source, uint id, int length, string message) => _PushDebugGroupKHR(source, id, length, message);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushDebugGroupKHR(DebugSource source, uint id, int length, void* message) => _PushDebugGroupKHR_ptr(source, id, length, message);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushDebugGroupKHR(DebugSource source, uint id, int length, IntPtr message) => _PushDebugGroupKHR_intptr(source, id, length, message);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushGroupMarkerEXT(int length, string marker) => _PushGroupMarkerEXT(length, marker);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushGroupMarkerEXT(int length, void* marker) => _PushGroupMarkerEXT_ptr(length, marker);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushGroupMarkerEXT(int length, IntPtr marker) => _PushGroupMarkerEXT_intptr(length, marker);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushMatrix() => _PushMatrix();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushName(uint name) => _PushName(name);

        // ---

        /// <summary>
        /// glQueryCounter causes the GL to record the current time into the query object named id.            target must be GL_TIMESTAMP. The time is recorded after all previous commands on the            GL client and server state and the framebuffer have been fully realized. When the time is recorded, the query result for that object            is marked available. glQueryCounter timer queries can be used within a glBeginQuery /            glEndQuery block where the target is GL_TIME_ELAPSED and it does            not affect the result of that query object.
        /// </summary>
        /// <param name="id">Specify the name of a query object into which to record the GL time.</param>
        /// <param name="target">Specify the counter to query. target must be GL_TIMESTAMP.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void QueryCounter(uint id, QueryCounterTarget target) => _QueryCounter(id, target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void QueryCounterEXT(uint id, QueryCounterTarget target) => _QueryCounterEXT(id, target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int QueryMatrixxOES(float[] mantissa, int[] exponent) => _QueryMatrixxOES(mantissa, exponent);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int QueryMatrixxOES(void* mantissa, void* exponent) => _QueryMatrixxOES_ptr(mantissa, exponent);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int QueryMatrixxOES(IntPtr mantissa, IntPtr exponent) => _QueryMatrixxOES_intptr(mantissa, exponent);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void QueryObjectParameteruiAMD(QueryTarget target, uint id, int pname, uint param) => _QueryObjectParameteruiAMD(target, id, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int QueryResourceNV(int queryType, int tagId, uint count, int[] buffer) => _QueryResourceNV(queryType, tagId, count, buffer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int QueryResourceNV(int queryType, int tagId, uint count, void* buffer) => _QueryResourceNV_ptr(queryType, tagId, count, buffer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int QueryResourceNV(int queryType, int tagId, uint count, IntPtr buffer) => _QueryResourceNV_intptr(queryType, tagId, count, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void QueryResourceTagNV(int tagId, string tagString) => _QueryResourceTagNV(tagId, tagString);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void QueryResourceTagNV(int tagId, void* tagString) => _QueryResourceTagNV_ptr(tagId, tagString);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void QueryResourceTagNV(int tagId, IntPtr tagString) => _QueryResourceTagNV_intptr(tagId, tagString);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2d(double x, double y) => _RasterPos2d(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2dv(double[] v) => _RasterPos2dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2dv(void* v) => _RasterPos2dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2dv(IntPtr v) => _RasterPos2dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2f(float x, float y) => _RasterPos2f(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2fv(float[] v) => _RasterPos2fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2fv(void* v) => _RasterPos2fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2fv(IntPtr v) => _RasterPos2fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2i(int x, int y) => _RasterPos2i(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2iv(int[] v) => _RasterPos2iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2iv(void* v) => _RasterPos2iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2iv(IntPtr v) => _RasterPos2iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2s(short x, short y) => _RasterPos2s(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2sv(short[] v) => _RasterPos2sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2sv(void* v) => _RasterPos2sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2sv(IntPtr v) => _RasterPos2sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2xOES(float x, float y) => _RasterPos2xOES(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2xvOES(float[] coords) => _RasterPos2xvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2xvOES(void* coords) => _RasterPos2xvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos2xvOES(IntPtr coords) => _RasterPos2xvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3d(double x, double y, double z) => _RasterPos3d(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3dv(double[] v) => _RasterPos3dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3dv(void* v) => _RasterPos3dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3dv(IntPtr v) => _RasterPos3dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3f(float x, float y, float z) => _RasterPos3f(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3fv(float[] v) => _RasterPos3fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3fv(void* v) => _RasterPos3fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3fv(IntPtr v) => _RasterPos3fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3i(int x, int y, int z) => _RasterPos3i(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3iv(int[] v) => _RasterPos3iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3iv(void* v) => _RasterPos3iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3iv(IntPtr v) => _RasterPos3iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3s(short x, short y, short z) => _RasterPos3s(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3sv(short[] v) => _RasterPos3sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3sv(void* v) => _RasterPos3sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3sv(IntPtr v) => _RasterPos3sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3xOES(float x, float y, float z) => _RasterPos3xOES(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3xvOES(float[] coords) => _RasterPos3xvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3xvOES(void* coords) => _RasterPos3xvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos3xvOES(IntPtr coords) => _RasterPos3xvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4d(double x, double y, double z, double w) => _RasterPos4d(x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4dv(double[] v) => _RasterPos4dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4dv(void* v) => _RasterPos4dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4dv(IntPtr v) => _RasterPos4dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4f(float x, float y, float z, float w) => _RasterPos4f(x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4fv(float[] v) => _RasterPos4fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4fv(void* v) => _RasterPos4fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4fv(IntPtr v) => _RasterPos4fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4i(int x, int y, int z, int w) => _RasterPos4i(x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4iv(int[] v) => _RasterPos4iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4iv(void* v) => _RasterPos4iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4iv(IntPtr v) => _RasterPos4iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4s(short x, short y, short z, short w) => _RasterPos4s(x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4sv(short[] v) => _RasterPos4sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4sv(void* v) => _RasterPos4sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4sv(IntPtr v) => _RasterPos4sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4xOES(float x, float y, float z, float w) => _RasterPos4xOES(x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4xvOES(float[] coords) => _RasterPos4xvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4xvOES(void* coords) => _RasterPos4xvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterPos4xvOES(IntPtr coords) => _RasterPos4xvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RasterSamplesEXT(uint samples, bool fixedsamplelocations) => _RasterSamplesEXT(samples, fixedsamplelocations);

        // ---

        /// <summary>
        /// glReadBuffer specifies a color buffer as the    source for subsequent    glReadPixels,    glCopyTexImage1D,    glCopyTexImage2D,    glCopyTexSubImage1D,    glCopyTexSubImage2D,    and    glCopyTexSubImage3D    commands. mode accepts one of twelve or more    predefined values. In a fully configured system,    GL_FRONT, GL_LEFT, and    GL_FRONT_LEFT all name the front left buffer,    GL_FRONT_RIGHT and GL_RIGHT    name the front right buffer, and GL_BACK_LEFT and    GL_BACK name the back left buffer. Further more,    the constants    GL_COLOR_ATTACHMENTi may be    used to indicate the ith    color attachment where i ranges from zero to the    value of GL_MAX_COLOR_ATTACHMENTS minus one.
        /// Nonstereo double-buffered configurations have only a front left and    a back left buffer. Single-buffered configurations have a front left and a    front right buffer if stereo, and only a front left buffer if nonstereo.    It is an error to specify a nonexistent buffer to    glReadBuffer.
        /// mode is initially    GL_FRONT in single-buffered configurations and    GL_BACK in double-buffered configurations.
        /// For glReadBuffer, the target framebuffer object    is that bound to GL_READ_FRAMEBUFFER. For    glNamedFramebufferReadBuffer,    framebuffer must either be zero or the name of the    target framebuffer object. If framebuffer is zero,    then the default read framebuffer is affected.
        /// </summary>
        /// <param name="framebuffer">Specifies the name of the framebuffer object for          glNamedFramebufferReadBuffer function.</param>
        /// <param name="mode">Specifies a color buffer. Accepted values are          GL_FRONT_LEFT,          GL_FRONT_RIGHT,          GL_BACK_LEFT,          GL_BACK_RIGHT, GL_FRONT,          GL_BACK, GL_LEFT,          GL_RIGHT, and the constants          GL_COLOR_ATTACHMENTi.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReadBuffer(ReadBufferMode src) => _ReadBuffer(src);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReadBufferIndexedEXT(ReadBufferMode src, int index) => _ReadBufferIndexedEXT(src, index);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReadBufferNV(int mode) => _ReadBufferNV(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReadInstrumentsSGIX(int marker) => _ReadInstrumentsSGIX(marker);

        // ---

        /// <summary>
        /// glReadPixels and    glReadnPixels return pixel data from the frame    buffer, starting with the pixel whose lower left corner is at location    (x, y), into client memory    starting at location data. Several parameters    control the processing of the pixel data before it is placed into client    memory. These parameters are set with    glPixelStore.    This reference page describes the effects on    glReadPixels and glReadnPixels    of most, but not all of the parameters specified by these three    commands.
        /// If a non-zero named buffer object is bound to the    GL_PIXEL_PACK_BUFFER target (see    glBindBuffer)    while a block of pixels is requested, data is    treated as a byte offset into the buffer object's data store rather than    a pointer to client memory.
        /// glReadPixels and    glReadnPixels return values from each pixel with    lower left corner at . GL_RGB and    GL_BGR return three values,    GL_RGBA and GL_BGRA return four    values for each pixel, with all values corresponding to a single pixel    occupying contiguous space in data. Storage    parameters set by    glPixelStore,    such as GL_PACK_LSB_FIRST and    GL_PACK_SWAP_BYTES, affect the way that data is    written into memory. See    glPixelStore for a description.
        /// glReadnPixels function will only handle the    call if bufSize is at least of the size required to    store the requested data. Otherwise, it will generate a    GL_INVALID_OPERATION error.
        /// </summary>
        /// <param name="y">Specify the window coordinates of the first pixel that is read          from the frame buffer. This location is the lower left corner of a          rectangular block of pixels.</param>
        /// <param name="height">Specify the dimensions of the pixel rectangle.          width and height of          one correspond to a single pixel.</param>
        /// <param name="format">Specifies the format of the pixel data. The following symbolic          values are accepted: GL_STENCIL_INDEX,          GL_DEPTH_COMPONENT,          GL_DEPTH_STENCIL, GL_RED,          GL_GREEN, GL_BLUE,          GL_RGB, GL_BGR,          GL_RGBA, and          GL_BGRA.</param>
        /// <param name="type">Specifies the data type of the pixel data. Must be one of          GL_UNSIGNED_BYTE, GL_BYTE,          GL_UNSIGNED_SHORT,          GL_SHORT, GL_UNSIGNED_INT,          GL_INT, GL_HALF_FLOAT,          GL_FLOAT,          GL_UNSIGNED_BYTE_3_3_2,          GL_UNSIGNED_BYTE_2_3_3_REV,          GL_UNSIGNED_SHORT_5_6_5,          GL_UNSIGNED_SHORT_5_6_5_REV,          GL_UNSIGNED_SHORT_4_4_4_4,          GL_UNSIGNED_SHORT_4_4_4_4_REV,          GL_UNSIGNED_SHORT_5_5_5_1,          GL_UNSIGNED_SHORT_1_5_5_5_REV,          GL_UNSIGNED_INT_8_8_8_8,          GL_UNSIGNED_INT_8_8_8_8_REV,          GL_UNSIGNED_INT_10_10_10_2,          GL_UNSIGNED_INT_2_10_10_10_REV,          GL_UNSIGNED_INT_24_8,          GL_UNSIGNED_INT_10F_11F_11F_REV,          GL_UNSIGNED_INT_5_9_9_9_REV, or          GL_FLOAT_32_UNSIGNED_INT_24_8_REV.</param>
        /// <param name="bufSize">Specifies the size of the buffer data          for glReadnPixels function.</param>
        /// <param name="data">Returns the pixel data.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReadPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, IntPtr pixels) => _ReadPixels(x, y, width, height, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReadnPixels(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, IntPtr data) => _ReadnPixels(x, y, width, height, format, type, bufSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReadnPixelsARB(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, IntPtr data) => _ReadnPixelsARB(x, y, width, height, format, type, bufSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReadnPixelsEXT(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, IntPtr data) => _ReadnPixelsEXT(x, y, width, height, format, type, bufSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReadnPixelsKHR(int x, int y, int width, int height, PixelFormat format, PixelType type, int bufSize, IntPtr data) => _ReadnPixelsKHR(x, y, width, height, format, type, bufSize, data);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool ReleaseKeyedMutexWin32EXT(uint memory, UInt64 key) => _ReleaseKeyedMutexWin32EXT(memory, key);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rectd(double x1, double y1, double x2, double y2) => _Rectd(x1, y1, x2, y2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rectdv(double[] v1, double[] v2) => _Rectdv(v1, v2);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rectdv(void* v1, void* v2) => _Rectdv_ptr(v1, v2);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rectdv(IntPtr v1, IntPtr v2) => _Rectdv_intptr(v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rectf(float x1, float y1, float x2, float y2) => _Rectf(x1, y1, x2, y2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rectfv(float[] v1, float[] v2) => _Rectfv(v1, v2);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rectfv(void* v1, void* v2) => _Rectfv_ptr(v1, v2);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rectfv(IntPtr v1, IntPtr v2) => _Rectfv_intptr(v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Recti(int x1, int y1, int x2, int y2) => _Recti(x1, y1, x2, y2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rectiv(int[] v1, int[] v2) => _Rectiv(v1, v2);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rectiv(void* v1, void* v2) => _Rectiv_ptr(v1, v2);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rectiv(IntPtr v1, IntPtr v2) => _Rectiv_intptr(v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rects(short x1, short y1, short x2, short y2) => _Rects(x1, y1, x2, y2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rectsv(short[] v1, short[] v2) => _Rectsv(v1, v2);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rectsv(void* v1, void* v2) => _Rectsv_ptr(v1, v2);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rectsv(IntPtr v1, IntPtr v2) => _Rectsv_intptr(v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RectxOES(float x1, float y1, float x2, float y2) => _RectxOES(x1, y1, x2, y2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RectxvOES(float[] v1, float[] v2) => _RectxvOES(v1, v2);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RectxvOES(void* v1, void* v2) => _RectxvOES_ptr(v1, v2);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RectxvOES(IntPtr v1, IntPtr v2) => _RectxvOES_intptr(v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReferencePlaneSGIX(double[] equation) => _ReferencePlaneSGIX(equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReferencePlaneSGIX(void* equation) => _ReferencePlaneSGIX_ptr(equation);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReferencePlaneSGIX(IntPtr equation) => _ReferencePlaneSGIX_intptr(equation);

        // ---

        /// <summary>
        /// glReleaseShaderCompiler provides a hint to the implementation that it            may free internal resources associated with its shader compiler. glCompileShader            may subsequently be called and the implementation may at that time reallocate resources            previously freed by the call to glReleaseShaderCompiler.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReleaseShaderCompiler() => _ReleaseShaderCompiler();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RenderGpuMaskNV(int mask) => _RenderGpuMaskNV(mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int RenderMode(RenderingMode mode) => _RenderMode(mode);

        // ---

        /// <summary>
        /// glRenderbufferStorage is equivalent to calling    glRenderbufferStorageMultisample    with the samples set to zero, and    glNamedRenderbufferStorage is equivalent to calling    glNamedRenderbufferStorageMultisample with the    samples set to zero.
        /// For glRenderbufferStorage, the target of the    operation, specified by target must be    GL_RENDERBUFFER. For    glNamedRenderbufferStorage,    renderbuffer must be a name of an existing    renderbuffer object. internalformat specifies the    internal format to be used for the renderbuffer object's storage and must    be a color-renderable, depth-renderable, or stencil-renderable format.    width and height are the    dimensions, in pixels, of the renderbuffer. Both    width and height must be    less than or equal to the value of    GL_MAX_RENDERBUFFER_SIZE.
        /// Upon success, glRenderbufferStorage and    glNamedRenderbufferStorage delete any existing data    store for the renderbuffer image and the contents of the data store after    calling glRenderbufferStorage are undefined.
        /// </summary>
        /// <param name="target">Specifies a binding target of the allocation for          glRenderbufferStorage function. Must be          GL_RENDERBUFFER.</param>
        /// <param name="renderbuffer">Specifies the name of the renderbuffer object for          glNamedRenderbufferStorage function.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer          object's image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RenderbufferStorage(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => _RenderbufferStorage(target, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RenderbufferStorageEXT(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => _RenderbufferStorageEXT(target, internalformat, width, height);

        // ---

        /// <summary>
        /// glRenderbufferStorageMultisample and    glNamedRenderbufferStorageMultisample establish the    data storage, format, dimensions and number of samples of a renderbuffer    object's image.
        /// For glRenderbufferStorageMultisample, the    target of the operation, specified by target must    be GL_RENDERBUFFER. For    glNamedRenderbufferStorageMultisample,    renderbuffer must be an ID of an existing    renderbuffer object. internalformat specifies the    internal format to be used for the renderbuffer object's storage and must    be a color-renderable, depth-renderable, or stencil-renderable format.    width and height are the    dimensions, in pixels, of the renderbuffer. Both    width and height must be    less than or equal to the value of    GL_MAX_RENDERBUFFER_SIZE.    samples specifies the number of samples to be used    for the renderbuffer object's image, and must be less than or equal to the    value of GL_MAX_SAMPLES. If    internalformat is a signed or unsigned integer    format then samples must be less than or equal to    the value of GL_MAX_INTEGER_SAMPLES.
        /// Upon success, glRenderbufferStorageMultisample    and glNamedRenderbufferStorageMultisample delete any    existing data store for the renderbuffer image and the contents of the    data store after calling either of the functions are undefined.
        /// </summary>
        /// <param name="target">Specifies a binding target of the allocation for          glRenderbufferStorageMultisample function. Must          be GL_RENDERBUFFER.</param>
        /// <param name="renderbuffer">Specifies the name of the renderbuffer object for          glNamedRenderbufferStorageMultisample          function.</param>
        /// <param name="samples">Specifies the number of samples to be used for the          renderbuffer object's storage.</param>
        /// <param name="internalformat">Specifies the internal format to use for the renderbuffer          object's image.</param>
        /// <param name="width">Specifies the width of the renderbuffer, in pixels.</param>
        /// <param name="height">Specifies the height of the renderbuffer, in pixels.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RenderbufferStorageMultisample(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => _RenderbufferStorageMultisample(target, samples, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RenderbufferStorageMultisampleANGLE(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => _RenderbufferStorageMultisampleANGLE(target, samples, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RenderbufferStorageMultisampleAPPLE(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => _RenderbufferStorageMultisampleAPPLE(target, samples, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RenderbufferStorageMultisampleAdvancedAMD(RenderbufferTarget target, int samples, int storageSamples, InternalFormat internalformat, int width, int height) => _RenderbufferStorageMultisampleAdvancedAMD(target, samples, storageSamples, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RenderbufferStorageMultisampleCoverageNV(RenderbufferTarget target, int coverageSamples, int colorSamples, InternalFormat internalformat, int width, int height) => _RenderbufferStorageMultisampleCoverageNV(target, coverageSamples, colorSamples, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RenderbufferStorageMultisampleEXT(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => _RenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RenderbufferStorageMultisampleIMG(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => _RenderbufferStorageMultisampleIMG(target, samples, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RenderbufferStorageMultisampleNV(RenderbufferTarget target, int samples, InternalFormat internalformat, int width, int height) => _RenderbufferStorageMultisampleNV(target, samples, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RenderbufferStorageOES(RenderbufferTarget target, InternalFormat internalformat, int width, int height) => _RenderbufferStorageOES(target, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodePointerSUN(ReplacementCodeTypeSUN type, int stride, IntPtr* pointer) => _ReplacementCodePointerSUN(type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeubSUN(byte code) => _ReplacementCodeubSUN(code);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeubvSUN(byte[] code) => _ReplacementCodeubvSUN(code);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeubvSUN(void* code) => _ReplacementCodeubvSUN_ptr(code);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeubvSUN(IntPtr code) => _ReplacementCodeubvSUN_intptr(code);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiColor3fVertex3fSUN(uint rc, float r, float g, float b, float x, float y, float z) => _ReplacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiColor3fVertex3fvSUN(uint[] rc, float[] c, float[] v) => _ReplacementCodeuiColor3fVertex3fvSUN(rc, c, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiColor3fVertex3fvSUN(void* rc, void* c, void* v) => _ReplacementCodeuiColor3fVertex3fvSUN_ptr(rc, c, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiColor3fVertex3fvSUN(IntPtr rc, IntPtr c, IntPtr v) => _ReplacementCodeuiColor3fVertex3fvSUN_intptr(rc, c, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiColor4fNormal3fVertex3fSUN(uint rc, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => _ReplacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiColor4fNormal3fVertex3fvSUN(uint[] rc, float[] c, float[] n, float[] v) => _ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiColor4fNormal3fVertex3fvSUN(void* rc, void* c, void* n, void* v) => _ReplacementCodeuiColor4fNormal3fVertex3fvSUN_ptr(rc, c, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiColor4fNormal3fVertex3fvSUN(IntPtr rc, IntPtr c, IntPtr n, IntPtr v) => _ReplacementCodeuiColor4fNormal3fVertex3fvSUN_intptr(rc, c, n, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiColor4ubVertex3fSUN(uint rc, byte r, byte g, byte b, byte a, float x, float y, float z) => _ReplacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiColor4ubVertex3fvSUN(uint[] rc, byte[] c, float[] v) => _ReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiColor4ubVertex3fvSUN(void* rc, void* c, void* v) => _ReplacementCodeuiColor4ubVertex3fvSUN_ptr(rc, c, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiColor4ubVertex3fvSUN(IntPtr rc, IntPtr c, IntPtr v) => _ReplacementCodeuiColor4ubVertex3fvSUN_intptr(rc, c, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiNormal3fVertex3fSUN(uint rc, float nx, float ny, float nz, float x, float y, float z) => _ReplacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiNormal3fVertex3fvSUN(uint[] rc, float[] n, float[] v) => _ReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiNormal3fVertex3fvSUN(void* rc, void* n, void* v) => _ReplacementCodeuiNormal3fVertex3fvSUN_ptr(rc, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiNormal3fVertex3fvSUN(IntPtr rc, IntPtr n, IntPtr v) => _ReplacementCodeuiNormal3fVertex3fvSUN_intptr(rc, n, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiSUN(uint code) => _ReplacementCodeuiSUN(code);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(uint rc, float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint[] rc, float[] tc, float[] c, float[] n, float[] v) => _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(void* rc, void* tc, void* c, void* n, void* v) => _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ptr(rc, tc, c, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(IntPtr rc, IntPtr tc, IntPtr c, IntPtr n, IntPtr v) => _ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_intptr(rc, tc, c, n, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(uint rc, float s, float t, float nx, float ny, float nz, float x, float y, float z) => _ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(uint[] rc, float[] tc, float[] n, float[] v) => _ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(void* rc, void* tc, void* n, void* v) => _ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ptr(rc, tc, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(IntPtr rc, IntPtr tc, IntPtr n, IntPtr v) => _ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_intptr(rc, tc, n, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiTexCoord2fVertex3fSUN(uint rc, float s, float t, float x, float y, float z) => _ReplacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiTexCoord2fVertex3fvSUN(uint[] rc, float[] tc, float[] v) => _ReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiTexCoord2fVertex3fvSUN(void* rc, void* tc, void* v) => _ReplacementCodeuiTexCoord2fVertex3fvSUN_ptr(rc, tc, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiTexCoord2fVertex3fvSUN(IntPtr rc, IntPtr tc, IntPtr v) => _ReplacementCodeuiTexCoord2fVertex3fvSUN_intptr(rc, tc, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiVertex3fSUN(uint rc, float x, float y, float z) => _ReplacementCodeuiVertex3fSUN(rc, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiVertex3fvSUN(uint[] rc, float[] v) => _ReplacementCodeuiVertex3fvSUN(rc, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiVertex3fvSUN(void* rc, void* v) => _ReplacementCodeuiVertex3fvSUN_ptr(rc, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuiVertex3fvSUN(IntPtr rc, IntPtr v) => _ReplacementCodeuiVertex3fvSUN_intptr(rc, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuivSUN(uint[] code) => _ReplacementCodeuivSUN(code);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuivSUN(void* code) => _ReplacementCodeuivSUN_ptr(code);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeuivSUN(IntPtr code) => _ReplacementCodeuivSUN_intptr(code);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeusSUN(ushort code) => _ReplacementCodeusSUN(code);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeusvSUN(ushort[] code) => _ReplacementCodeusvSUN(code);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeusvSUN(void* code) => _ReplacementCodeusvSUN_ptr(code);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ReplacementCodeusvSUN(IntPtr code) => _ReplacementCodeusvSUN_intptr(code);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RequestResidentProgramsNV(int n, uint[] programs) => _RequestResidentProgramsNV(n, programs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RequestResidentProgramsNV(int n, void* programs) => _RequestResidentProgramsNV_ptr(n, programs);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RequestResidentProgramsNV(int n, IntPtr programs) => _RequestResidentProgramsNV_intptr(n, programs);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ResetHistogram(HistogramTargetEXT target) => _ResetHistogram(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ResetHistogramEXT(HistogramTargetEXT target) => _ResetHistogramEXT(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ResetMemoryObjectParameterNV(uint memory, int pname) => _ResetMemoryObjectParameterNV(memory, pname);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ResetMinmax(MinmaxTargetEXT target) => _ResetMinmax(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ResetMinmaxEXT(MinmaxTargetEXT target) => _ResetMinmaxEXT(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ResizeBuffersMESA() => _ResizeBuffersMESA();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ResolveDepthValuesNV() => _ResolveDepthValuesNV();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ResolveMultisampleFramebufferAPPLE() => _ResolveMultisampleFramebufferAPPLE();

        // ---

        /// <summary>
        /// glResumeTransformFeedback resumes transform feedback operations on the currently active transform feedback            object. When transform feedback operations are paused, transform feedback is still considered active and changing most            transform feedback state related to the object results in an error. However, a new transform feedback object may be bound            while transform feedback is paused.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ResumeTransformFeedback() => _ResumeTransformFeedback();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ResumeTransformFeedbackNV() => _ResumeTransformFeedbackNV();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rotated(double angle, double x, double y, double z) => _Rotated(angle, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rotatef(float angle, float x, float y, float z) => _Rotatef(angle, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rotatex(float angle, float x, float y, float z) => _Rotatex(angle, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RotatexOES(float angle, float x, float y, float z) => _RotatexOES(angle, x, y, z);

        // ---

        /// <summary>
        /// Multisampling samples a pixel multiple times at various            implementation-dependent subpixel locations to generate antialiasing            effects.  Multisampling transparently antialiases points, lines, polygons,            and images if it is enabled.
        /// value is used in constructing a temporary mask used in determining which            samples will be used in resolving the final fragment color.  This mask is            bitwise-anded with the coverage mask generated from the multisampling            computation.  If the invert flag is set, the temporary mask is inverted            (all bits flipped) and then the bitwise-and is computed.
        /// If an implementation does not have any multisample buffers available, or            multisampling is disabled, rasterization occurs with only a single sample            computing a pixel's final RGB color.
        /// Provided an implementation supports multisample buffers, and multisampling            is enabled, then a pixel's final color is generated by combining several            samples per pixel.  Each sample contains color, depth, and stencil            information, allowing those operations to be performed on each sample.
        /// </summary>
        /// <param name="value">Specify a single floating-point sample coverage value.  The value is                    clamped to the range                    .                    The initial value is 1.0.</param>
        /// <param name="invert">Specify a single boolean value representing if the coverage masks should be                    inverted.  GL_TRUE and GL_FALSE are accepted.  The initial value                    is GL_FALSE.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SampleCoverage(float value, bool invert) => _SampleCoverage(value, invert);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SampleCoverageARB(float value, bool invert) => _SampleCoverageARB(value, invert);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SampleCoveragex(int value, bool invert) => _SampleCoveragex(value, invert);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SampleCoveragexOES(int value, bool invert) => _SampleCoveragexOES(value, invert);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SampleMapATI(uint dst, uint interp, SwizzleOpATI swizzle) => _SampleMapATI(dst, interp, swizzle);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SampleMaskEXT(float value, bool invert) => _SampleMaskEXT(value, invert);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SampleMaskIndexedNV(uint index, int mask) => _SampleMaskIndexedNV(index, mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SampleMaskSGIS(float value, bool invert) => _SampleMaskSGIS(value, invert);

        // ---

        /// <summary>
        /// glSampleMaski sets one 32-bit sub-word of the multi-word sample mask, GL_SAMPLE_MASK_VALUE.
        /// maskIndex specifies which 32-bit sub-word of the sample mask to update, and mask specifies            the new value to use for that sub-word. maskIndex must be less than the value of            GL_MAX_SAMPLE_MASK_WORDS. Bit B of mask word M corresponds to sample            32 x M + B.
        /// </summary>
        /// <param name="maskNumber">Specifies which 32-bit sub-word of the sample mask to update.</param>
        /// <param name="mask">Specifies the new value of the mask sub-word.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SampleMaski(uint maskNumber, int mask) => _SampleMaski(maskNumber, mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplePatternEXT(SamplePatternEXT pattern) => _SamplePatternEXT(pattern);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplePatternSGIS(SamplePatternSGIS pattern) => _SamplePatternSGIS(pattern);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIiv(uint sampler, SamplerParameterI pname, int[] param) => _SamplerParameterIiv(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIiv(uint sampler, SamplerParameterI pname, void* param) => _SamplerParameterIiv_ptr(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIiv(uint sampler, SamplerParameterI pname, IntPtr param) => _SamplerParameterIiv_intptr(sampler, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIivEXT(uint sampler, SamplerParameterI pname, int[] param) => _SamplerParameterIivEXT(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIivEXT(uint sampler, SamplerParameterI pname, void* param) => _SamplerParameterIivEXT_ptr(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIivEXT(uint sampler, SamplerParameterI pname, IntPtr param) => _SamplerParameterIivEXT_intptr(sampler, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIivOES(uint sampler, SamplerParameterI pname, int[] param) => _SamplerParameterIivOES(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIivOES(uint sampler, SamplerParameterI pname, void* param) => _SamplerParameterIivOES_ptr(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIivOES(uint sampler, SamplerParameterI pname, IntPtr param) => _SamplerParameterIivOES_intptr(sampler, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIuiv(uint sampler, SamplerParameterI pname, uint[] param) => _SamplerParameterIuiv(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIuiv(uint sampler, SamplerParameterI pname, void* param) => _SamplerParameterIuiv_ptr(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIuiv(uint sampler, SamplerParameterI pname, IntPtr param) => _SamplerParameterIuiv_intptr(sampler, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIuivEXT(uint sampler, SamplerParameterI pname, uint[] param) => _SamplerParameterIuivEXT(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIuivEXT(uint sampler, SamplerParameterI pname, void* param) => _SamplerParameterIuivEXT_ptr(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIuivEXT(uint sampler, SamplerParameterI pname, IntPtr param) => _SamplerParameterIuivEXT_intptr(sampler, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIuivOES(uint sampler, SamplerParameterI pname, uint[] param) => _SamplerParameterIuivOES(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIuivOES(uint sampler, SamplerParameterI pname, void* param) => _SamplerParameterIuivOES_ptr(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterIuivOES(uint sampler, SamplerParameterI pname, IntPtr param) => _SamplerParameterIuivOES_intptr(sampler, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterf(uint sampler, SamplerParameterF pname, float param) => _SamplerParameterf(sampler, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterfv(uint sampler, SamplerParameterF pname, float[] param) => _SamplerParameterfv(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterfv(uint sampler, SamplerParameterF pname, void* param) => _SamplerParameterfv_ptr(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameterfv(uint sampler, SamplerParameterF pname, IntPtr param) => _SamplerParameterfv_intptr(sampler, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameteri(uint sampler, SamplerParameterI pname, int param) => _SamplerParameteri(sampler, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameteriv(uint sampler, SamplerParameterI pname, int[] param) => _SamplerParameteriv(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameteriv(uint sampler, SamplerParameterI pname, void* param) => _SamplerParameteriv_ptr(sampler, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SamplerParameteriv(uint sampler, SamplerParameterI pname, IntPtr param) => _SamplerParameteriv_intptr(sampler, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scaled(double x, double y, double z) => _Scaled(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scalef(float x, float y, float z) => _Scalef(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scalex(float x, float y, float z) => _Scalex(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScalexOES(float x, float y, float z) => _ScalexOES(x, y, z);

        // ---

        /// <summary>
        /// glScissor defines a rectangle, called the scissor box,            in window coordinates.            The first two arguments,            x and y,            specify the lower left corner of the box.            width and height specify the width and height of the box.
        /// To enable and disable the scissor test, call            glEnable and glDisable with argument            GL_SCISSOR_TEST. The test is initially disabled.            While the test is enabled, only pixels that lie within the scissor box            can be modified by drawing commands.            Window coordinates have integer values at the shared corners of            frame buffer pixels.            glScissor(0,0,1,1) allows modification of only the lower left            pixel in the window, and glScissor(0,0,0,0) doesn't allow            modification of any pixels in the window.
        /// When the scissor test is disabled,            it is as though the scissor box includes the entire window.
        /// </summary>
        /// <param name="y">Specify the lower left corner of the scissor box.                    Initially (0, 0).</param>
        /// <param name="height">Specify the width and height of the scissor box.                    When a GL context is first attached to a window,                    width and height are set to the dimensions of that                    window.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Scissor(int x, int y, int width, int height) => _Scissor(x, y, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorArrayv(uint first, int count, int[] v) => _ScissorArrayv(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorArrayv(uint first, int count, void* v) => _ScissorArrayv_ptr(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorArrayv(uint first, int count, IntPtr v) => _ScissorArrayv_intptr(first, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorArrayvNV(uint first, int count, int[] v) => _ScissorArrayvNV(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorArrayvNV(uint first, int count, void* v) => _ScissorArrayvNV_ptr(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorArrayvNV(uint first, int count, IntPtr v) => _ScissorArrayvNV_intptr(first, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorArrayvOES(uint first, int count, int[] v) => _ScissorArrayvOES(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorArrayvOES(uint first, int count, void* v) => _ScissorArrayvOES_ptr(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorArrayvOES(uint first, int count, IntPtr v) => _ScissorArrayvOES_intptr(first, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorExclusiveArrayvNV(uint first, int count, int[] v) => _ScissorExclusiveArrayvNV(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorExclusiveArrayvNV(uint first, int count, void* v) => _ScissorExclusiveArrayvNV_ptr(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorExclusiveArrayvNV(uint first, int count, IntPtr v) => _ScissorExclusiveArrayvNV_intptr(first, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorExclusiveNV(int x, int y, int width, int height) => _ScissorExclusiveNV(x, y, width, height);

        // ---

        /// <summary>
        /// glScissorIndexed defines the scissor box for a specified viewport.            index specifies the index of scissor box to modify.            index must be less than the value of GL_MAX_VIEWPORTS.            For glScissorIndexed, left, bottom,            width and height specify the left, bottom, width            and height of the scissor box, in pixels, respectively.            For glScissorIndexedv, v specifies the address of an            array containing integers specifying the lower left corner of the scissor box, and the width and            height of the scissor box, in that order.
        /// To enable and disable the scissor test, call            glEnable and glDisable with argument            GL_SCISSOR_TEST. The test is initially disabled for all viewports.            While the test is enabled, only pixels that lie within the scissor box            can be modified by drawing commands.            Window coordinates have integer values at the shared corners of            frame buffer pixels.            glScissor(0,0,1,1) allows modification of only the lower left            pixel in the window, and glScissor(0,0,0,0) doesn't allow            modification of any pixels in the window.
        /// When the scissor test is disabled,            it is as though the scissor box includes the entire window.
        /// </summary>
        /// <param name="index">Specifies the index of the viewport whose scissor box to modify.</param>
        /// <param name="bottom">Specify the coordinate of the bottom left corner of the scissor box, in pixels.</param>
        /// <param name="height">Specify ths dimensions of the scissor box, in pixels.</param>
        /// <param name="v">For glScissorIndexedv, specifies the address of an array containing the left, bottom, width and height of each                scissor box, in that order.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorIndexed(uint index, int left, int bottom, int width, int height) => _ScissorIndexed(index, left, bottom, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorIndexedNV(uint index, int left, int bottom, int width, int height) => _ScissorIndexedNV(index, left, bottom, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorIndexedOES(uint index, int left, int bottom, int width, int height) => _ScissorIndexedOES(index, left, bottom, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorIndexedv(uint index, int[] v) => _ScissorIndexedv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorIndexedv(uint index, void* v) => _ScissorIndexedv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorIndexedv(uint index, IntPtr v) => _ScissorIndexedv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorIndexedvNV(uint index, int[] v) => _ScissorIndexedvNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorIndexedvNV(uint index, void* v) => _ScissorIndexedvNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorIndexedvNV(uint index, IntPtr v) => _ScissorIndexedvNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorIndexedvOES(uint index, int[] v) => _ScissorIndexedvOES(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorIndexedvOES(uint index, void* v) => _ScissorIndexedvOES_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScissorIndexedvOES(uint index, IntPtr v) => _ScissorIndexedvOES_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3b(sbyte red, sbyte green, sbyte blue) => _SecondaryColor3b(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3bEXT(sbyte red, sbyte green, sbyte blue) => _SecondaryColor3bEXT(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3bv(sbyte[] v) => _SecondaryColor3bv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3bv(void* v) => _SecondaryColor3bv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3bv(IntPtr v) => _SecondaryColor3bv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3bvEXT(sbyte[] v) => _SecondaryColor3bvEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3bvEXT(void* v) => _SecondaryColor3bvEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3bvEXT(IntPtr v) => _SecondaryColor3bvEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3d(double red, double green, double blue) => _SecondaryColor3d(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3dEXT(double red, double green, double blue) => _SecondaryColor3dEXT(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3dv(double[] v) => _SecondaryColor3dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3dv(void* v) => _SecondaryColor3dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3dv(IntPtr v) => _SecondaryColor3dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3dvEXT(double[] v) => _SecondaryColor3dvEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3dvEXT(void* v) => _SecondaryColor3dvEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3dvEXT(IntPtr v) => _SecondaryColor3dvEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3f(float red, float green, float blue) => _SecondaryColor3f(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3fEXT(float red, float green, float blue) => _SecondaryColor3fEXT(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3fv(float[] v) => _SecondaryColor3fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3fv(void* v) => _SecondaryColor3fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3fv(IntPtr v) => _SecondaryColor3fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3fvEXT(float[] v) => _SecondaryColor3fvEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3fvEXT(void* v) => _SecondaryColor3fvEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3fvEXT(IntPtr v) => _SecondaryColor3fvEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3hNV(float red, float green, float blue) => _SecondaryColor3hNV(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3hvNV(float[] v) => _SecondaryColor3hvNV(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3hvNV(void* v) => _SecondaryColor3hvNV_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3hvNV(IntPtr v) => _SecondaryColor3hvNV_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3i(int red, int green, int blue) => _SecondaryColor3i(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3iEXT(int red, int green, int blue) => _SecondaryColor3iEXT(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3iv(int[] v) => _SecondaryColor3iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3iv(void* v) => _SecondaryColor3iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3iv(IntPtr v) => _SecondaryColor3iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3ivEXT(int[] v) => _SecondaryColor3ivEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3ivEXT(void* v) => _SecondaryColor3ivEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3ivEXT(IntPtr v) => _SecondaryColor3ivEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3s(short red, short green, short blue) => _SecondaryColor3s(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3sEXT(short red, short green, short blue) => _SecondaryColor3sEXT(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3sv(short[] v) => _SecondaryColor3sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3sv(void* v) => _SecondaryColor3sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3sv(IntPtr v) => _SecondaryColor3sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3svEXT(short[] v) => _SecondaryColor3svEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3svEXT(void* v) => _SecondaryColor3svEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3svEXT(IntPtr v) => _SecondaryColor3svEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3ub(byte red, byte green, byte blue) => _SecondaryColor3ub(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3ubEXT(byte red, byte green, byte blue) => _SecondaryColor3ubEXT(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3ubv(byte[] v) => _SecondaryColor3ubv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3ubv(void* v) => _SecondaryColor3ubv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3ubv(IntPtr v) => _SecondaryColor3ubv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3ubvEXT(byte[] v) => _SecondaryColor3ubvEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3ubvEXT(void* v) => _SecondaryColor3ubvEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3ubvEXT(IntPtr v) => _SecondaryColor3ubvEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3ui(uint red, uint green, uint blue) => _SecondaryColor3ui(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3uiEXT(uint red, uint green, uint blue) => _SecondaryColor3uiEXT(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3uiv(uint[] v) => _SecondaryColor3uiv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3uiv(void* v) => _SecondaryColor3uiv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3uiv(IntPtr v) => _SecondaryColor3uiv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3uivEXT(uint[] v) => _SecondaryColor3uivEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3uivEXT(void* v) => _SecondaryColor3uivEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3uivEXT(IntPtr v) => _SecondaryColor3uivEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3us(ushort red, ushort green, ushort blue) => _SecondaryColor3us(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3usEXT(ushort red, ushort green, ushort blue) => _SecondaryColor3usEXT(red, green, blue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3usv(ushort[] v) => _SecondaryColor3usv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3usv(void* v) => _SecondaryColor3usv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3usv(IntPtr v) => _SecondaryColor3usv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3usvEXT(ushort[] v) => _SecondaryColor3usvEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3usvEXT(void* v) => _SecondaryColor3usvEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColor3usvEXT(IntPtr v) => _SecondaryColor3usvEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColorFormatNV(int size, ColorPointerType type, int stride) => _SecondaryColorFormatNV(size, type, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColorP3ui(ColorPointerType type, uint color) => _SecondaryColorP3ui(type, color);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColorP3uiv(ColorPointerType type, uint[] color) => _SecondaryColorP3uiv(type, color);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColorP3uiv(ColorPointerType type, void* color) => _SecondaryColorP3uiv_ptr(type, color);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColorP3uiv(ColorPointerType type, IntPtr color) => _SecondaryColorP3uiv_intptr(type, color);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColorPointer(int size, ColorPointerType type, int stride, IntPtr pointer) => _SecondaryColorPointer(size, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColorPointerEXT(int size, ColorPointerType type, int stride, IntPtr pointer) => _SecondaryColorPointerEXT(size, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SecondaryColorPointerListIBM(int size, SecondaryColorPointerTypeIBM type, int stride, IntPtr* pointer, int ptrstride) => _SecondaryColorPointerListIBM(size, type, stride, pointer, ptrstride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SelectBuffer(int size, uint[] buffer) => _SelectBuffer(size, buffer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SelectBuffer(int size, void* buffer) => _SelectBuffer_ptr(size, buffer);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SelectBuffer(int size, IntPtr buffer) => _SelectBuffer_intptr(size, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SelectPerfMonitorCountersAMD(uint monitor, bool enable, uint group, int numCounters, uint[] counterList) => _SelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SelectPerfMonitorCountersAMD(uint monitor, bool enable, uint group, int numCounters, void* counterList) => _SelectPerfMonitorCountersAMD_ptr(monitor, enable, group, numCounters, counterList);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SelectPerfMonitorCountersAMD(uint monitor, bool enable, uint group, int numCounters, IntPtr counterList) => _SelectPerfMonitorCountersAMD_intptr(monitor, enable, group, numCounters, counterList);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, UInt64[] @params) => _SemaphoreParameterui64vEXT(semaphore, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, void* @params) => _SemaphoreParameterui64vEXT_ptr(semaphore, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SemaphoreParameterui64vEXT(uint semaphore, SemaphoreParameterName pname, IntPtr @params) => _SemaphoreParameterui64vEXT_intptr(semaphore, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SeparableFilter2D(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, IntPtr row, IntPtr column) => _SeparableFilter2D(target, internalformat, width, height, format, type, row, column);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SeparableFilter2DEXT(SeparableTargetEXT target, InternalFormat internalformat, int width, int height, PixelFormat format, PixelType type, IntPtr row, IntPtr column) => _SeparableFilter2DEXT(target, internalformat, width, height, format, type, row, column);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetFenceAPPLE(uint fence) => _SetFenceAPPLE(fence);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetFenceNV(uint fence, FenceConditionNV condition) => _SetFenceNV(fence, condition);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetFragmentShaderConstantATI(uint dst, float[] value) => _SetFragmentShaderConstantATI(dst, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetFragmentShaderConstantATI(uint dst, void* value) => _SetFragmentShaderConstantATI_ptr(dst, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetFragmentShaderConstantATI(uint dst, IntPtr value) => _SetFragmentShaderConstantATI_intptr(dst, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetInvariantEXT(uint id, ScalarType type, IntPtr addr) => _SetInvariantEXT(id, type, addr);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetLocalConstantEXT(uint id, ScalarType type, IntPtr addr) => _SetLocalConstantEXT(id, type, addr);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetMultisamplefvAMD(int pname, uint index, float[] val) => _SetMultisamplefvAMD(pname, index, val);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetMultisamplefvAMD(int pname, uint index, void* val) => _SetMultisamplefvAMD_ptr(pname, index, val);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SetMultisamplefvAMD(int pname, uint index, IntPtr val) => _SetMultisamplefvAMD_intptr(pname, index, val);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShadeModel(ShadingModel mode) => _ShadeModel(mode);

        // ---

        /// <summary>
        /// glShaderBinary loads pre-compiled shader binary code into the count            shader objects whose handles are given in shaders. binary            points to length bytes of binary shader code stored in client memory.            binaryFormat specifies the format of the pre-compiled code.
        /// The binary image contained in binary will be decoded according to the extension            specification defining the specified binaryFormat token. OpenGL            does not define any specific binary formats, but it does provide a mechanism to obtain token            vaues for such formats provided by such extensions.
        /// Depending on the types of the shader objects in shaders, glShaderBinary            will individually load binary vertex or fragment shaders, or load an executable binary that contains an optimized            pair of vertex and fragment shaders stored in the same binary.
        /// </summary>
        /// <param name="count">Specifies the number of shader object handles contained in shaders.</param>
        /// <param name="shaders">Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.</param>
        /// <param name="binaryFormat">Specifies the format of the shader binaries contained in binary.</param>
        /// <param name="binary">Specifies the address of an array of bytes containing pre-compiled binary shader code.</param>
        /// <param name="length">Specifies the length of the array whose address is given in binary.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShaderBinary(int count, uint[] shaders, int binaryformat, IntPtr binary, int length) => _ShaderBinary(count, shaders, binaryformat, binary, length);

        /// <summary>
        /// glShaderBinary loads pre-compiled shader binary code into the count            shader objects whose handles are given in shaders. binary            points to length bytes of binary shader code stored in client memory.            binaryFormat specifies the format of the pre-compiled code.
        /// The binary image contained in binary will be decoded according to the extension            specification defining the specified binaryFormat token. OpenGL            does not define any specific binary formats, but it does provide a mechanism to obtain token            vaues for such formats provided by such extensions.
        /// Depending on the types of the shader objects in shaders, glShaderBinary            will individually load binary vertex or fragment shaders, or load an executable binary that contains an optimized            pair of vertex and fragment shaders stored in the same binary.
        /// </summary>
        /// <param name="count">Specifies the number of shader object handles contained in shaders.</param>
        /// <param name="shaders">Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.</param>
        /// <param name="binaryFormat">Specifies the format of the shader binaries contained in binary.</param>
        /// <param name="binary">Specifies the address of an array of bytes containing pre-compiled binary shader code.</param>
        /// <param name="length">Specifies the length of the array whose address is given in binary.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShaderBinary(int count, void* shaders, int binaryformat, IntPtr binary, int length) => _ShaderBinary_ptr(count, shaders, binaryformat, binary, length);

        /// <summary>
        /// glShaderBinary loads pre-compiled shader binary code into the count            shader objects whose handles are given in shaders. binary            points to length bytes of binary shader code stored in client memory.            binaryFormat specifies the format of the pre-compiled code.
        /// The binary image contained in binary will be decoded according to the extension            specification defining the specified binaryFormat token. OpenGL            does not define any specific binary formats, but it does provide a mechanism to obtain token            vaues for such formats provided by such extensions.
        /// Depending on the types of the shader objects in shaders, glShaderBinary            will individually load binary vertex or fragment shaders, or load an executable binary that contains an optimized            pair of vertex and fragment shaders stored in the same binary.
        /// </summary>
        /// <param name="count">Specifies the number of shader object handles contained in shaders.</param>
        /// <param name="shaders">Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.</param>
        /// <param name="binaryFormat">Specifies the format of the shader binaries contained in binary.</param>
        /// <param name="binary">Specifies the address of an array of bytes containing pre-compiled binary shader code.</param>
        /// <param name="length">Specifies the length of the array whose address is given in binary.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShaderBinary(int count, IntPtr shaders, int binaryformat, IntPtr binary, int length) => _ShaderBinary_intptr(count, shaders, binaryformat, binary, length);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShaderOp1EXT(VertexShaderOpEXT op, uint res, uint arg1) => _ShaderOp1EXT(op, res, arg1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShaderOp2EXT(VertexShaderOpEXT op, uint res, uint arg1, uint arg2) => _ShaderOp2EXT(op, res, arg1, arg2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShaderOp3EXT(VertexShaderOpEXT op, uint res, uint arg1, uint arg2, uint arg3) => _ShaderOp3EXT(op, res, arg1, arg2, arg3);

        // ---

        /// <summary>
        /// glShaderSource sets the source code        in shader to the source code in the array        of strings specified by string. Any        source code previously stored in the shader object is completely        replaced. The number of strings in the array is specified by        count. If length        is NULL, each string is assumed to be null        terminated. If length is a value other        than NULL, it points to an array containing        a string length for each of the corresponding elements of        string. Each element in the        length array may contain the length of        the corresponding string (the null character is not counted as        part of the string length) or a value less than 0 to indicate        that the string is null terminated. The source code strings are        not scanned or parsed at this time; they are simply copied into        the specified shader object.
        /// </summary>
        /// <param name="shader">Specifies the handle of the shader object                    whose source code is to be replaced.</param>
        /// <param name="count">Specifies the number of elements in the                    string and                    length                    arrays.</param>
        /// <param name="string">Specifies an array of pointers to strings                    containing the source code to be loaded into the                    shader.</param>
        /// <param name="length">Specifies an array of string lengths.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShaderSource(uint shader, int count, string[] @string, int[] length) => _ShaderSource(shader, count, @string, length);

        /// <summary>
        /// glShaderSource sets the source code        in shader to the source code in the array        of strings specified by string. Any        source code previously stored in the shader object is completely        replaced. The number of strings in the array is specified by        count. If length        is NULL, each string is assumed to be null        terminated. If length is a value other        than NULL, it points to an array containing        a string length for each of the corresponding elements of        string. Each element in the        length array may contain the length of        the corresponding string (the null character is not counted as        part of the string length) or a value less than 0 to indicate        that the string is null terminated. The source code strings are        not scanned or parsed at this time; they are simply copied into        the specified shader object.
        /// </summary>
        /// <param name="shader">Specifies the handle of the shader object                    whose source code is to be replaced.</param>
        /// <param name="count">Specifies the number of elements in the                    string and                    length                    arrays.</param>
        /// <param name="string">Specifies an array of pointers to strings                    containing the source code to be loaded into the                    shader.</param>
        /// <param name="length">Specifies an array of string lengths.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShaderSource(uint shader, int count, void* @string, void* length) => _ShaderSource_ptr(shader, count, @string, length);

        /// <summary>
        /// glShaderSource sets the source code        in shader to the source code in the array        of strings specified by string. Any        source code previously stored in the shader object is completely        replaced. The number of strings in the array is specified by        count. If length        is NULL, each string is assumed to be null        terminated. If length is a value other        than NULL, it points to an array containing        a string length for each of the corresponding elements of        string. Each element in the        length array may contain the length of        the corresponding string (the null character is not counted as        part of the string length) or a value less than 0 to indicate        that the string is null terminated. The source code strings are        not scanned or parsed at this time; they are simply copied into        the specified shader object.
        /// </summary>
        /// <param name="shader">Specifies the handle of the shader object                    whose source code is to be replaced.</param>
        /// <param name="count">Specifies the number of elements in the                    string and                    length                    arrays.</param>
        /// <param name="string">Specifies an array of pointers to strings                    containing the source code to be loaded into the                    shader.</param>
        /// <param name="length">Specifies an array of string lengths.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShaderSource(uint shader, int count, IntPtr @string, IntPtr length) => _ShaderSource_intptr(shader, count, @string, length);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShaderSourceARB(int shaderObj, int count, IntPtr* @string, int[] length) => _ShaderSourceARB(shaderObj, count, @string, length);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShaderSourceARB(int shaderObj, int count, IntPtr* @string, void* length) => _ShaderSourceARB_ptr(shaderObj, count, @string, length);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShaderSourceARB(int shaderObj, int count, IntPtr* @string, IntPtr length) => _ShaderSourceARB_intptr(shaderObj, count, @string, length);

        // ---

        /// <summary>
        /// glShaderStorageBlockBinding, changes the active            shader storage block with an assigned index of storageBlockIndex            in program object program.  storageBlockIndex must be an active shader storage block            index in program. storageBlockBinding must be less than the value of GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS.            If successful, glShaderStorageBlockBinding specifies that program will use the data store of            the buffer object bound to the binding point storageBlockBinding to read            and write the values of the buffer variables in the shader storage block identified by storageBlockIndex.
        /// </summary>
        /// <param name="program">The name of the program containing the block whose binding to change.</param>
        /// <param name="storageBlockIndex">The index storage block within the program.</param>
        /// <param name="storageBlockBinding">The index storage block binding to associate with the specified storage block.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShaderStorageBlockBinding(uint program, uint storageBlockIndex, uint storageBlockBinding) => _ShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShadingRateImageBarrierNV(bool synchronize) => _ShadingRateImageBarrierNV(synchronize);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShadingRateQCOM(ShadingRateQCOM rate) => _ShadingRateQCOM(rate);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShadingRateImagePaletteNV(uint viewport, uint first, int count, int[] rates) => _ShadingRateImagePaletteNV(viewport, first, count, rates);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShadingRateImagePaletteNV(uint viewport, uint first, int count, void* rates) => _ShadingRateImagePaletteNV_ptr(viewport, first, count, rates);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShadingRateImagePaletteNV(uint viewport, uint first, int count, IntPtr rates) => _ShadingRateImagePaletteNV_intptr(viewport, first, count, rates);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShadingRateSampleOrderNV(int order) => _ShadingRateSampleOrderNV(order);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShadingRateSampleOrderCustomNV(int rate, uint samples, int[] locations) => _ShadingRateSampleOrderCustomNV(rate, samples, locations);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShadingRateSampleOrderCustomNV(int rate, uint samples, void* locations) => _ShadingRateSampleOrderCustomNV_ptr(rate, samples, locations);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShadingRateSampleOrderCustomNV(int rate, uint samples, IntPtr locations) => _ShadingRateSampleOrderCustomNV_intptr(rate, samples, locations);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SharpenTexFuncSGIS(TextureTarget target, int n, float[] points) => _SharpenTexFuncSGIS(target, n, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SharpenTexFuncSGIS(TextureTarget target, int n, void* points) => _SharpenTexFuncSGIS_ptr(target, n, points);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SharpenTexFuncSGIS(TextureTarget target, int n, IntPtr points) => _SharpenTexFuncSGIS_intptr(target, n, points);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint[] buffers, uint numTextureBarriers, uint[] textures, TextureLayout[] dstLayouts) => _SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, void* buffers, uint numTextureBarriers, void* textures, void* dstLayouts) => _SignalSemaphoreEXT_ptr(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, IntPtr buffers, uint numTextureBarriers, IntPtr textures, IntPtr dstLayouts) => _SignalSemaphoreEXT_intptr(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, uint[] semaphoreArray, UInt64[] fenceValueArray) => _SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, void* semaphoreArray, void* fenceValueArray) => _SignalSemaphoreui64NVX_ptr(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, IntPtr semaphoreArray, IntPtr fenceValueArray) => _SignalSemaphoreui64NVX_intptr(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SpecializeShader(uint shader, string pEntryPoint, uint numSpecializationConstants, uint[] pConstantIndex, uint[] pConstantValue) => _SpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SpecializeShader(uint shader, void* pEntryPoint, uint numSpecializationConstants, void* pConstantIndex, void* pConstantValue) => _SpecializeShader_ptr(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SpecializeShader(uint shader, IntPtr pEntryPoint, uint numSpecializationConstants, IntPtr pConstantIndex, IntPtr pConstantValue) => _SpecializeShader_intptr(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SpecializeShaderARB(uint shader, string pEntryPoint, uint numSpecializationConstants, uint[] pConstantIndex, uint[] pConstantValue) => _SpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SpecializeShaderARB(uint shader, void* pEntryPoint, uint numSpecializationConstants, void* pConstantIndex, void* pConstantValue) => _SpecializeShaderARB_ptr(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SpecializeShaderARB(uint shader, IntPtr pEntryPoint, uint numSpecializationConstants, IntPtr pConstantIndex, IntPtr pConstantValue) => _SpecializeShaderARB_intptr(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SpriteParameterfSGIX(SpriteParameterNameSGIX pname, float param) => _SpriteParameterfSGIX(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SpriteParameterfvSGIX(SpriteParameterNameSGIX pname, float[] @params) => _SpriteParameterfvSGIX(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SpriteParameterfvSGIX(SpriteParameterNameSGIX pname, void* @params) => _SpriteParameterfvSGIX_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SpriteParameterfvSGIX(SpriteParameterNameSGIX pname, IntPtr @params) => _SpriteParameterfvSGIX_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SpriteParameteriSGIX(SpriteParameterNameSGIX pname, int param) => _SpriteParameteriSGIX(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SpriteParameterivSGIX(SpriteParameterNameSGIX pname, int[] @params) => _SpriteParameterivSGIX(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SpriteParameterivSGIX(SpriteParameterNameSGIX pname, void* @params) => _SpriteParameterivSGIX_ptr(pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SpriteParameterivSGIX(SpriteParameterNameSGIX pname, IntPtr @params) => _SpriteParameterivSGIX_intptr(pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StartInstrumentsSGIX() => _StartInstrumentsSGIX();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StartTilingQCOM(uint x, uint y, uint width, uint height, int preserveMask) => _StartTilingQCOM(x, y, width, height, preserveMask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StateCaptureNV(uint state, int mode) => _StateCaptureNV(state, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilClearTagEXT(int stencilTagBits, uint stencilClearTag) => _StencilClearTagEXT(stencilTagBits, stencilClearTag);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilFillPathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, float[] transformValues) => _StencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilFillPathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, void* transformValues) => _StencilFillPathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilFillPathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, PathFillMode fillMode, uint mask, PathTransformType transformType, IntPtr transformValues) => _StencilFillPathInstancedNV_intptr(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilFillPathNV(uint path, PathFillMode fillMode, uint mask) => _StencilFillPathNV(path, fillMode, mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilFunc(StencilFunction func, int @ref, uint mask) => _StencilFunc(func, @ref, mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilFuncSeparate(StencilFaceDirection face, StencilFunction func, int @ref, uint mask) => _StencilFuncSeparate(face, func, @ref, mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilFuncSeparateATI(StencilFunction frontfunc, StencilFunction backfunc, int @ref, uint mask) => _StencilFuncSeparateATI(frontfunc, backfunc, @ref, mask);

        // ---

        /// <summary>
        /// glStencilMask controls the writing of individual bits in the stencil planes.            The least significant                        is the number of bits in the stencil buffer,            specify a mask.            Where a 1 appears in the mask,            it's possible to write to the corresponding bit in the stencil buffer.            Where a 0 appears,            the corresponding bit is write-protected.            Initially, all bits are enabled for writing.
        /// There can be two separate mask writemasks; one affects back-facing polygons, and the other            affects front-facing polygons as well as other non-polygon primitives.            glStencilMask sets both front            and back stencil writemasks to the same values. Use glStencilMaskSeparate            to set front and back stencil writemasks to different values.
        /// </summary>
        /// <param name="mask">Specifies a bit mask to enable and disable writing of individual bits                    in the stencil planes.                    Initially, the mask is all 1's.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilMask(uint mask) => _StencilMask(mask);

        // ---

        /// <summary>
        /// glStencilMaskSeparate controls the writing of individual bits in the stencil planes.            The least significant                        is the number of bits in the stencil buffer,            specify a mask.            Where a 1 appears in the mask,            it's possible to write to the corresponding bit in the stencil buffer.            Where a 0 appears,            the corresponding bit is write-protected.            Initially, all bits are enabled for writing.
        /// There can be two separate mask writemasks; one affects back-facing polygons, and the other            affects front-facing polygons as well as other non-polygon primitives.            glStencilMask sets both front            and back stencil writemasks to the same values, as if            glStencilMaskSeparate were called            with face set to GL_FRONT_AND_BACK.
        /// </summary>
        /// <param name="face">Specifies whether the front and/or back stencil writemask is updated.                    Three symbolic constants are valid:                    GL_FRONT,                    GL_BACK, and                    GL_FRONT_AND_BACK.</param>
        /// <param name="mask">Specifies a bit mask to enable and disable writing of individual bits                    in the stencil planes.                    Initially, the mask is all 1's.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilMaskSeparate(StencilFaceDirection face, uint mask) => _StencilMaskSeparate(face, mask);

        // ---

        /// <summary>
        /// Stenciling,            like depth-buffering,            enables and disables drawing on a per-pixel basis.            You draw into the stencil planes using GL drawing primitives,            then render geometry and images,            using the stencil planes to mask out portions of the screen.            Stenciling is typically used in multipass rendering algorithms            to achieve special effects,            such as decals,            outlining,            and constructive solid geometry rendering.
        /// The stencil test conditionally eliminates a pixel based on the outcome            of a comparison between the value in the stencil buffer and a            reference value. To enable and disable the test, call glEnable            and glDisable with argument            GL_STENCIL_TEST; to control it, call            glStencilFunc or            glStencilFuncSeparate.
        /// There can be two separate sets of sfail, dpfail, and            dppass parameters; one affects back-facing polygons, and the other            affects front-facing polygons as well as other non-polygon primitives.            glStencilOp sets both front            and back stencil state to the same values. Use glStencilOpSeparate            to set front and back stencil state to different values.
        /// glStencilOp takes three arguments that indicate what happens            to the stored stencil value while stenciling is enabled.            If the stencil test fails,            no change is made to the pixel's color or depth buffers,            and sfail specifies what happens to the stencil buffer contents.            The following eight actions are possible.
        /// GL_KEEP                        Keeps the current value.                    GL_ZERO                        Sets the stencil buffer value to 0.                    GL_REPLACE                        Sets the stencil buffer value to ref,                        as specified by glStencilFunc.                    GL_INCR                        Increments the current stencil buffer value.                        Clamps to the maximum representable unsigned value.                    GL_INCR_WRAP                        Increments the current stencil buffer value.                        Wraps stencil buffer value to zero when incrementing the maximum                        representable unsigned value.                    GL_DECR                        Decrements the current stencil buffer value.                        Clamps to 0.                    GL_DECR_WRAP                        Decrements the current stencil buffer value.                        Wraps stencil buffer value to the maximum representable unsigned value when                        decrementing a stencil buffer value of zero.                    GL_INVERT                        Bitwise inverts the current stencil buffer value.
        /// Stencil buffer values are treated as unsigned integers.            When incremented and decremented,            values are clamped to 0 and                        is the value returned by querying GL_STENCIL_BITS.
        /// The other two arguments to glStencilOp specify stencil buffer actions            that depend on whether subsequent depth buffer tests succeed (dppass)            or fail (dpfail) (see            glDepthFunc).            The actions are specified using the same eight symbolic constants as sfail.            Note that dpfail is ignored when there is no depth buffer,            or when the depth buffer is not enabled.            In these cases, sfail and dppass specify stencil action when the            stencil test fails and passes,            respectively.
        /// </summary>
        /// <param name="sfail">Specifies the action to take when the stencil test fails.                    Eight symbolic constants are accepted:                    GL_KEEP,                    GL_ZERO,                    GL_REPLACE,                    GL_INCR,                    GL_INCR_WRAP,                    GL_DECR,                    GL_DECR_WRAP, and                    GL_INVERT. The initial value is GL_KEEP.</param>
        /// <param name="dpfail">Specifies the stencil action when the stencil test passes,                    but the depth test fails.                    dpfail accepts the same symbolic constants as sfail. The initial value                    is GL_KEEP.</param>
        /// <param name="dppass">Specifies the stencil action when both the stencil test and the depth                    test pass, or when the stencil test passes and either there is no                    depth buffer or depth testing is not enabled.                    dppass accepts the same symbolic constants as sfail. The initial value                    is GL_KEEP.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilOp(StencilOp fail, StencilOp zfail, StencilOp zpass) => _StencilOp(fail, zfail, zpass);

        // ---

        /// <summary>
        /// Stenciling,            like depth-buffering,            enables and disables drawing on a per-pixel basis.            You draw into the stencil planes using GL drawing primitives,            then render geometry and images,            using the stencil planes to mask out portions of the screen.            Stenciling is typically used in multipass rendering algorithms            to achieve special effects,            such as decals,            outlining,            and constructive solid geometry rendering.
        /// The stencil test conditionally eliminates a pixel based on the outcome            of a comparison between the value in the stencil buffer and a            reference value. To enable and disable the test, call glEnable            and glDisable with argument            GL_STENCIL_TEST; to control it, call            glStencilFunc or            glStencilFuncSeparate.
        /// There can be two separate sets of sfail, dpfail, and            dppass parameters; one affects back-facing polygons, and the other            affects front-facing polygons as well as other non-polygon primitives.            glStencilOp sets both front            and back stencil state to the same values, as if            glStencilOpSeparate were called            with face set to GL_FRONT_AND_BACK.
        /// glStencilOpSeparate takes three arguments that indicate what happens            to the stored stencil value while stenciling is enabled.            If the stencil test fails,            no change is made to the pixel's color or depth buffers,            and sfail specifies what happens to the stencil buffer contents.            The following eight actions are possible.
        /// GL_KEEP                        Keeps the current value.                    GL_ZERO                        Sets the stencil buffer value to 0.                    GL_REPLACE                        Sets the stencil buffer value to ref,                        as specified by glStencilFunc.                    GL_INCR                        Increments the current stencil buffer value.                        Clamps to the maximum representable unsigned value.                    GL_INCR_WRAP                        Increments the current stencil buffer value.                        Wraps stencil buffer value to zero when incrementing the maximum                        representable unsigned value.                    GL_DECR                        Decrements the current stencil buffer value.                        Clamps to 0.                    GL_DECR_WRAP                        Decrements the current stencil buffer value.                        Wraps stencil buffer value to the maximum representable unsigned value when                        decrementing a stencil buffer value of zero.                    GL_INVERT                        Bitwise inverts the current stencil buffer value.
        /// Stencil buffer values are treated as unsigned integers.            When incremented and decremented,            values are clamped to 0 and                        is the value returned by querying GL_STENCIL_BITS.
        /// The other two arguments to glStencilOpSeparate specify stencil buffer actions            that depend on whether subsequent depth buffer tests succeed (dppass)            or fail (dpfail) (see            glDepthFunc).            The actions are specified using the same eight symbolic constants as sfail.            Note that dpfail is ignored when there is no depth buffer,            or when the depth buffer is not enabled.            In these cases, sfail and dppass specify stencil action when the            stencil test fails and passes,            respectively.
        /// </summary>
        /// <param name="face">Specifies whether front and/or back stencil state is updated.                    Three symbolic constants are valid:                    GL_FRONT,                    GL_BACK, and                    GL_FRONT_AND_BACK.</param>
        /// <param name="sfail">Specifies the action to take when the stencil test fails.                    Eight symbolic constants are accepted:                    GL_KEEP,                    GL_ZERO,                    GL_REPLACE,                    GL_INCR,                    GL_INCR_WRAP,                    GL_DECR,                    GL_DECR_WRAP, and                    GL_INVERT. The initial value is GL_KEEP.</param>
        /// <param name="dpfail">Specifies the stencil action when the stencil test passes,                    but the depth test fails.                    dpfail accepts the same symbolic constants as sfail. The initial value                    is GL_KEEP.</param>
        /// <param name="dppass">Specifies the stencil action when both the stencil test and the depth                    test pass, or when the stencil test passes and either there is no                    depth buffer or depth testing is not enabled.                    dppass accepts the same symbolic constants as sfail. The initial value                    is GL_KEEP.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilOpSeparate(StencilFaceDirection face, StencilOp sfail, StencilOp dpfail, StencilOp dppass) => _StencilOpSeparate(face, sfail, dpfail, dppass);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilOpSeparateATI(StencilFaceDirection face, StencilOp sfail, StencilOp dpfail, StencilOp dppass) => _StencilOpSeparateATI(face, sfail, dpfail, dppass);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilOpValueAMD(StencilFaceDirection face, uint value) => _StencilOpValueAMD(face, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilStrokePathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, PathTransformType transformType, float[] transformValues) => _StencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilStrokePathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, PathTransformType transformType, void* transformValues) => _StencilStrokePathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilStrokePathInstancedNV(int numPaths, PathElementType pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, PathTransformType transformType, IntPtr transformValues) => _StencilStrokePathInstancedNV_intptr(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilStrokePathNV(uint path, int reference, uint mask) => _StencilStrokePathNV(path, reference, mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilThenCoverFillPathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int fillMode, uint mask, int coverMode, int transformType, float[] transformValues) => _StencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilThenCoverFillPathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int fillMode, uint mask, int coverMode, int transformType, void* transformValues) => _StencilThenCoverFillPathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilThenCoverFillPathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int fillMode, uint mask, int coverMode, int transformType, IntPtr transformValues) => _StencilThenCoverFillPathInstancedNV_intptr(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilThenCoverFillPathNV(uint path, int fillMode, uint mask, int coverMode) => _StencilThenCoverFillPathNV(path, fillMode, mask, coverMode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilThenCoverStrokePathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, int coverMode, int transformType, float[] transformValues) => _StencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilThenCoverStrokePathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, int coverMode, int transformType, void* transformValues) => _StencilThenCoverStrokePathInstancedNV_ptr(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilThenCoverStrokePathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, int coverMode, int transformType, IntPtr transformValues) => _StencilThenCoverStrokePathInstancedNV_intptr(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StencilThenCoverStrokePathNV(uint path, int reference, uint mask, int coverMode) => _StencilThenCoverStrokePathNV(path, reference, mask, coverMode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StopInstrumentsSGIX(int marker) => _StopInstrumentsSGIX(marker);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void StringMarkerGREMEDY(int len, IntPtr @string) => _StringMarkerGREMEDY(len, @string);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SubpixelPrecisionBiasNV(uint xbits, uint ybits) => _SubpixelPrecisionBiasNV(xbits, ybits);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SwizzleEXT(uint res, uint @in, VertexShaderCoordOutEXT outX, VertexShaderCoordOutEXT outY, VertexShaderCoordOutEXT outZ, VertexShaderCoordOutEXT outW) => _SwizzleEXT(res, @in, outX, outY, outZ, outW);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SyncTextureINTEL(uint texture) => _SyncTextureINTEL(texture);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TagSampleBufferSGIX() => _TagSampleBufferSGIX();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3bEXT(sbyte tx, sbyte ty, sbyte tz) => _Tangent3bEXT(tx, ty, tz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3bvEXT(sbyte[] v) => _Tangent3bvEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3bvEXT(void* v) => _Tangent3bvEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3bvEXT(IntPtr v) => _Tangent3bvEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3dEXT(double tx, double ty, double tz) => _Tangent3dEXT(tx, ty, tz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3dvEXT(double[] v) => _Tangent3dvEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3dvEXT(void* v) => _Tangent3dvEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3dvEXT(IntPtr v) => _Tangent3dvEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3fEXT(float tx, float ty, float tz) => _Tangent3fEXT(tx, ty, tz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3fvEXT(float[] v) => _Tangent3fvEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3fvEXT(void* v) => _Tangent3fvEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3fvEXT(IntPtr v) => _Tangent3fvEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3iEXT(int tx, int ty, int tz) => _Tangent3iEXT(tx, ty, tz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3ivEXT(int[] v) => _Tangent3ivEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3ivEXT(void* v) => _Tangent3ivEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3ivEXT(IntPtr v) => _Tangent3ivEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3sEXT(short tx, short ty, short tz) => _Tangent3sEXT(tx, ty, tz);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3svEXT(short[] v) => _Tangent3svEXT(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3svEXT(void* v) => _Tangent3svEXT_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Tangent3svEXT(IntPtr v) => _Tangent3svEXT_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TangentPointerEXT(TangentPointerTypeEXT type, int stride, IntPtr pointer) => _TangentPointerEXT(type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TbufferMask3DFX(uint mask) => _TbufferMask3DFX(mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TessellationFactorAMD(float factor) => _TessellationFactorAMD(factor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TessellationModeAMD(int mode) => _TessellationModeAMD(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TestFenceAPPLE(uint fence) => _TestFenceAPPLE(fence);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TestFenceNV(uint fence) => _TestFenceNV(fence);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TestObjectAPPLE(ObjectTypeAPPLE @object, uint name) => _TestObjectAPPLE(@object, name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexAttachMemoryNV(TextureTarget target, uint memory, UInt64 offset) => _TexAttachMemoryNV(target, memory, offset);

        // ---

        /// <summary>
        /// glTexBuffer and            glTextureBuffer attaches the data store of            a specified buffer object to a specified texture object, and            specify the storage format for the texture image found in            the buffer object. The texture object must be a buffer texture.
        /// If buffer is zero, any buffer object            attached to the buffer texture is detached and no new buffer            object is attached. If buffer is            non-zero, it must be the name of an existing buffer object.
        /// internalformat specifies the storage            format, and must be one of the following sized internal formats:
        /// internalformat specifies the storage            format, and must be one of the following sized internal formats:
        /// When a buffer object is attached to a buffer texture, the buffer            object's data store is taken as the texture's texel array. The            number of texels in the buffer texture's texel array is given by                $$ \left\lfloor { size \over { components \times sizeof(base\_type) } } \right\rfloor $$            where $size$ is the size of the buffer object in basic machine            units (the value of GL_BUFFER_SIZE for            buffer), and $components$ and            $base\_type$ are the element count and base data type for            elements, as specified in the table above. The number of texels            in the texel array is then clamped to the value of the            implementation-dependent limit            GL_MAX_TEXTURE_BUFFER_SIZE. When a buffer            texture is accessed in a shader, the results of a texel fetch            are undefined if the specified texel coordinate is negative, or            greater than or equal to the clamped number of texels in the            texel array.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture is bound for                    glTexBuffer. Must be                    GL_TEXTURE_BUFFER.</param>
        /// <param name="texture">Specifies the texture object name for                    glTextureBuffer.</param>
        /// <param name="internalformat">Specifies the internal format of the data in the store                    belonging to buffer.</param>
        /// <param name="buffer">Specifies the name of the buffer object whose storage to                    attach to the active buffer texture.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexBuffer(TextureTarget target, InternalFormat internalformat, uint buffer) => _TexBuffer(target, internalformat, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexBufferARB(TextureTarget target, InternalFormat internalformat, uint buffer) => _TexBufferARB(target, internalformat, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexBufferEXT(TextureTarget target, InternalFormat internalformat, uint buffer) => _TexBufferEXT(target, internalformat, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexBufferOES(TextureTarget target, InternalFormat internalformat, uint buffer) => _TexBufferOES(target, internalformat, buffer);

        // ---

        /// <summary>
        /// glTexBufferRange and            glTextureBufferRange attach a range of the            data store of a specified buffer object to a specified texture            object, and specify the storage format for the texture image            found in the buffer object. The texture object must be a            buffer texture.
        /// If buffer is zero, any buffer object            attached to the buffer texture is detached and no new buffer            object is attached. If buffer is            non-zero, it must be the name of an existing buffer object.
        /// The start and size of the range are specified by            offset and size            respectively, both measured in basic machine units.            offset must be greater than or equal to            zero, size must be greater than zero, and            the sum of offset and            size must not exceed the value of            GL_BUFFER_SIZE for            buffer. Furthermore,            offset must be an integer multiple of the            value of            GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT.
        /// internalformat specifies the storage            format, and must be one of the following sized internal formats:
        /// When a range of a buffer object is attached to a buffer texture,            the specified range of the buffer object's data store is taken            as the texture's texel array. The number of texels in the buffer            texture's texel array is given by                $$ \left\lfloor { size \over { components \times sizeof(base\_type) } } \right\rfloor $$            where $components$ and $base\_type$ are the element count and            base data type for elements, as specified in the table above.            The number of texels in the texel array is then clamped to the            value of the implementation-dependent limit            GL_MAX_TEXTURE_BUFFER_SIZE. When a buffer            texture is accessed in a shader, the results of a texel fetch            are undefined if the specified texel coordinate is negative, or            greater than or equal to the clamped number of texels in the            texel array.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture object is                    bound for glTexBufferRange. Must be                    GL_TEXTURE_BUFFER.</param>
        /// <param name="texture">Specifies the texture object name for                    glTextureBufferRange.</param>
        /// <param name="internalformat">Specifies the internal format of the data in the store                    belonging to buffer.</param>
        /// <param name="buffer">Specifies the name of the buffer object whose storage to                    attach to the active buffer texture.</param>
        /// <param name="offset">Specifies the offset of the start of the range of the                    buffer's data store to attach.</param>
        /// <param name="size">Specifies the size of the range of the buffer's data                    store to attach.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexBufferRange(TextureTarget target, InternalFormat internalformat, uint buffer, IntPtr offset, IntPtr size) => _TexBufferRange(target, internalformat, buffer, offset, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexBufferRangeEXT(TextureTarget target, InternalFormat internalformat, uint buffer, IntPtr offset, IntPtr size) => _TexBufferRangeEXT(target, internalformat, buffer, offset, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexBufferRangeOES(TextureTarget target, InternalFormat internalformat, uint buffer, IntPtr offset, IntPtr size) => _TexBufferRangeOES(target, internalformat, buffer, offset, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexBumpParameterfvATI(TexBumpParameterATI pname, float[] param) => _TexBumpParameterfvATI(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexBumpParameterfvATI(TexBumpParameterATI pname, void* param) => _TexBumpParameterfvATI_ptr(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexBumpParameterfvATI(TexBumpParameterATI pname, IntPtr param) => _TexBumpParameterfvATI_intptr(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexBumpParameterivATI(TexBumpParameterATI pname, int[] param) => _TexBumpParameterivATI(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexBumpParameterivATI(TexBumpParameterATI pname, void* param) => _TexBumpParameterivATI_ptr(pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexBumpParameterivATI(TexBumpParameterATI pname, IntPtr param) => _TexBumpParameterivATI_intptr(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1bOES(sbyte s) => _TexCoord1bOES(s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1bvOES(sbyte[] coords) => _TexCoord1bvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1bvOES(void* coords) => _TexCoord1bvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1bvOES(IntPtr coords) => _TexCoord1bvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1d(double s) => _TexCoord1d(s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1dv(double[] v) => _TexCoord1dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1dv(void* v) => _TexCoord1dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1dv(IntPtr v) => _TexCoord1dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1f(float s) => _TexCoord1f(s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1fv(float[] v) => _TexCoord1fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1fv(void* v) => _TexCoord1fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1fv(IntPtr v) => _TexCoord1fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1hNV(float s) => _TexCoord1hNV(s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1hvNV(float[] v) => _TexCoord1hvNV(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1hvNV(void* v) => _TexCoord1hvNV_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1hvNV(IntPtr v) => _TexCoord1hvNV_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1i(int s) => _TexCoord1i(s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1iv(int[] v) => _TexCoord1iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1iv(void* v) => _TexCoord1iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1iv(IntPtr v) => _TexCoord1iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1s(short s) => _TexCoord1s(s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1sv(short[] v) => _TexCoord1sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1sv(void* v) => _TexCoord1sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1sv(IntPtr v) => _TexCoord1sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1xOES(float s) => _TexCoord1xOES(s);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1xvOES(float[] coords) => _TexCoord1xvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1xvOES(void* coords) => _TexCoord1xvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord1xvOES(IntPtr coords) => _TexCoord1xvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2bOES(sbyte s, sbyte t) => _TexCoord2bOES(s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2bvOES(sbyte[] coords) => _TexCoord2bvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2bvOES(void* coords) => _TexCoord2bvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2bvOES(IntPtr coords) => _TexCoord2bvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2d(double s, double t) => _TexCoord2d(s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2dv(double[] v) => _TexCoord2dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2dv(void* v) => _TexCoord2dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2dv(IntPtr v) => _TexCoord2dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2f(float s, float t) => _TexCoord2f(s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fColor3fVertex3fSUN(float s, float t, float r, float g, float b, float x, float y, float z) => _TexCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fColor3fVertex3fvSUN(float[] tc, float[] c, float[] v) => _TexCoord2fColor3fVertex3fvSUN(tc, c, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fColor3fVertex3fvSUN(void* tc, void* c, void* v) => _TexCoord2fColor3fVertex3fvSUN_ptr(tc, c, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fColor3fVertex3fvSUN(IntPtr tc, IntPtr c, IntPtr v) => _TexCoord2fColor3fVertex3fvSUN_intptr(tc, c, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fColor4fNormal3fVertex3fSUN(float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) => _TexCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fColor4fNormal3fVertex3fvSUN(float[] tc, float[] c, float[] n, float[] v) => _TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fColor4fNormal3fVertex3fvSUN(void* tc, void* c, void* n, void* v) => _TexCoord2fColor4fNormal3fVertex3fvSUN_ptr(tc, c, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fColor4fNormal3fVertex3fvSUN(IntPtr tc, IntPtr c, IntPtr n, IntPtr v) => _TexCoord2fColor4fNormal3fVertex3fvSUN_intptr(tc, c, n, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fColor4ubVertex3fSUN(float s, float t, byte r, byte g, byte b, byte a, float x, float y, float z) => _TexCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fColor4ubVertex3fvSUN(float[] tc, byte[] c, float[] v) => _TexCoord2fColor4ubVertex3fvSUN(tc, c, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fColor4ubVertex3fvSUN(void* tc, void* c, void* v) => _TexCoord2fColor4ubVertex3fvSUN_ptr(tc, c, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fColor4ubVertex3fvSUN(IntPtr tc, IntPtr c, IntPtr v) => _TexCoord2fColor4ubVertex3fvSUN_intptr(tc, c, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fNormal3fVertex3fSUN(float s, float t, float nx, float ny, float nz, float x, float y, float z) => _TexCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fNormal3fVertex3fvSUN(float[] tc, float[] n, float[] v) => _TexCoord2fNormal3fVertex3fvSUN(tc, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fNormal3fVertex3fvSUN(void* tc, void* n, void* v) => _TexCoord2fNormal3fVertex3fvSUN_ptr(tc, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fNormal3fVertex3fvSUN(IntPtr tc, IntPtr n, IntPtr v) => _TexCoord2fNormal3fVertex3fvSUN_intptr(tc, n, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fVertex3fSUN(float s, float t, float x, float y, float z) => _TexCoord2fVertex3fSUN(s, t, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fVertex3fvSUN(float[] tc, float[] v) => _TexCoord2fVertex3fvSUN(tc, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fVertex3fvSUN(void* tc, void* v) => _TexCoord2fVertex3fvSUN_ptr(tc, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fVertex3fvSUN(IntPtr tc, IntPtr v) => _TexCoord2fVertex3fvSUN_intptr(tc, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fv(float[] v) => _TexCoord2fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fv(void* v) => _TexCoord2fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2fv(IntPtr v) => _TexCoord2fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2hNV(float s, float t) => _TexCoord2hNV(s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2hvNV(float[] v) => _TexCoord2hvNV(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2hvNV(void* v) => _TexCoord2hvNV_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2hvNV(IntPtr v) => _TexCoord2hvNV_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2i(int s, int t) => _TexCoord2i(s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2iv(int[] v) => _TexCoord2iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2iv(void* v) => _TexCoord2iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2iv(IntPtr v) => _TexCoord2iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2s(short s, short t) => _TexCoord2s(s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2sv(short[] v) => _TexCoord2sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2sv(void* v) => _TexCoord2sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2sv(IntPtr v) => _TexCoord2sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2xOES(float s, float t) => _TexCoord2xOES(s, t);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2xvOES(float[] coords) => _TexCoord2xvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2xvOES(void* coords) => _TexCoord2xvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord2xvOES(IntPtr coords) => _TexCoord2xvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3bOES(sbyte s, sbyte t, sbyte r) => _TexCoord3bOES(s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3bvOES(sbyte[] coords) => _TexCoord3bvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3bvOES(void* coords) => _TexCoord3bvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3bvOES(IntPtr coords) => _TexCoord3bvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3d(double s, double t, double r) => _TexCoord3d(s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3dv(double[] v) => _TexCoord3dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3dv(void* v) => _TexCoord3dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3dv(IntPtr v) => _TexCoord3dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3f(float s, float t, float r) => _TexCoord3f(s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3fv(float[] v) => _TexCoord3fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3fv(void* v) => _TexCoord3fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3fv(IntPtr v) => _TexCoord3fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3hNV(float s, float t, float r) => _TexCoord3hNV(s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3hvNV(float[] v) => _TexCoord3hvNV(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3hvNV(void* v) => _TexCoord3hvNV_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3hvNV(IntPtr v) => _TexCoord3hvNV_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3i(int s, int t, int r) => _TexCoord3i(s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3iv(int[] v) => _TexCoord3iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3iv(void* v) => _TexCoord3iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3iv(IntPtr v) => _TexCoord3iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3s(short s, short t, short r) => _TexCoord3s(s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3sv(short[] v) => _TexCoord3sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3sv(void* v) => _TexCoord3sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3sv(IntPtr v) => _TexCoord3sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3xOES(float s, float t, float r) => _TexCoord3xOES(s, t, r);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3xvOES(float[] coords) => _TexCoord3xvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3xvOES(void* coords) => _TexCoord3xvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord3xvOES(IntPtr coords) => _TexCoord3xvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4bOES(sbyte s, sbyte t, sbyte r, sbyte q) => _TexCoord4bOES(s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4bvOES(sbyte[] coords) => _TexCoord4bvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4bvOES(void* coords) => _TexCoord4bvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4bvOES(IntPtr coords) => _TexCoord4bvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4d(double s, double t, double r, double q) => _TexCoord4d(s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4dv(double[] v) => _TexCoord4dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4dv(void* v) => _TexCoord4dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4dv(IntPtr v) => _TexCoord4dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4f(float s, float t, float r, float q) => _TexCoord4f(s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4fColor4fNormal3fVertex4fSUN(float s, float t, float p, float q, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z, float w) => _TexCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4fColor4fNormal3fVertex4fvSUN(float[] tc, float[] c, float[] n, float[] v) => _TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4fColor4fNormal3fVertex4fvSUN(void* tc, void* c, void* n, void* v) => _TexCoord4fColor4fNormal3fVertex4fvSUN_ptr(tc, c, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4fColor4fNormal3fVertex4fvSUN(IntPtr tc, IntPtr c, IntPtr n, IntPtr v) => _TexCoord4fColor4fNormal3fVertex4fvSUN_intptr(tc, c, n, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4fVertex4fSUN(float s, float t, float p, float q, float x, float y, float z, float w) => _TexCoord4fVertex4fSUN(s, t, p, q, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4fVertex4fvSUN(float[] tc, float[] v) => _TexCoord4fVertex4fvSUN(tc, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4fVertex4fvSUN(void* tc, void* v) => _TexCoord4fVertex4fvSUN_ptr(tc, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4fVertex4fvSUN(IntPtr tc, IntPtr v) => _TexCoord4fVertex4fvSUN_intptr(tc, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4fv(float[] v) => _TexCoord4fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4fv(void* v) => _TexCoord4fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4fv(IntPtr v) => _TexCoord4fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4hNV(float s, float t, float r, float q) => _TexCoord4hNV(s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4hvNV(float[] v) => _TexCoord4hvNV(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4hvNV(void* v) => _TexCoord4hvNV_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4hvNV(IntPtr v) => _TexCoord4hvNV_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4i(int s, int t, int r, int q) => _TexCoord4i(s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4iv(int[] v) => _TexCoord4iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4iv(void* v) => _TexCoord4iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4iv(IntPtr v) => _TexCoord4iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4s(short s, short t, short r, short q) => _TexCoord4s(s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4sv(short[] v) => _TexCoord4sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4sv(void* v) => _TexCoord4sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4sv(IntPtr v) => _TexCoord4sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4xOES(float s, float t, float r, float q) => _TexCoord4xOES(s, t, r, q);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4xvOES(float[] coords) => _TexCoord4xvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4xvOES(void* coords) => _TexCoord4xvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoord4xvOES(IntPtr coords) => _TexCoord4xvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordFormatNV(int size, int type, int stride) => _TexCoordFormatNV(size, type, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP1ui(TexCoordPointerType type, uint coords) => _TexCoordP1ui(type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP1uiv(TexCoordPointerType type, uint[] coords) => _TexCoordP1uiv(type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP1uiv(TexCoordPointerType type, void* coords) => _TexCoordP1uiv_ptr(type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP1uiv(TexCoordPointerType type, IntPtr coords) => _TexCoordP1uiv_intptr(type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP2ui(TexCoordPointerType type, uint coords) => _TexCoordP2ui(type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP2uiv(TexCoordPointerType type, uint[] coords) => _TexCoordP2uiv(type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP2uiv(TexCoordPointerType type, void* coords) => _TexCoordP2uiv_ptr(type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP2uiv(TexCoordPointerType type, IntPtr coords) => _TexCoordP2uiv_intptr(type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP3ui(TexCoordPointerType type, uint coords) => _TexCoordP3ui(type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP3uiv(TexCoordPointerType type, uint[] coords) => _TexCoordP3uiv(type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP3uiv(TexCoordPointerType type, void* coords) => _TexCoordP3uiv_ptr(type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP3uiv(TexCoordPointerType type, IntPtr coords) => _TexCoordP3uiv_intptr(type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP4ui(TexCoordPointerType type, uint coords) => _TexCoordP4ui(type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP4uiv(TexCoordPointerType type, uint[] coords) => _TexCoordP4uiv(type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP4uiv(TexCoordPointerType type, void* coords) => _TexCoordP4uiv_ptr(type, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordP4uiv(TexCoordPointerType type, IntPtr coords) => _TexCoordP4uiv_intptr(type, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordPointer(int size, TexCoordPointerType type, int stride, IntPtr pointer) => _TexCoordPointer(size, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordPointerEXT(int size, TexCoordPointerType type, int stride, int count, IntPtr pointer) => _TexCoordPointerEXT(size, type, stride, count, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordPointerListIBM(int size, TexCoordPointerType type, int stride, IntPtr* pointer, int ptrstride) => _TexCoordPointerListIBM(size, type, stride, pointer, ptrstride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexCoordPointervINTEL(int size, VertexPointerType type, IntPtr* pointer) => _TexCoordPointervINTEL(size, type, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnvf(TextureEnvTarget target, TextureEnvParameter pname, float param) => _TexEnvf(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnvfv(TextureEnvTarget target, TextureEnvParameter pname, float[] @params) => _TexEnvfv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnvfv(TextureEnvTarget target, TextureEnvParameter pname, void* @params) => _TexEnvfv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnvfv(TextureEnvTarget target, TextureEnvParameter pname, IntPtr @params) => _TexEnvfv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnvi(TextureEnvTarget target, TextureEnvParameter pname, int param) => _TexEnvi(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnviv(TextureEnvTarget target, TextureEnvParameter pname, int[] @params) => _TexEnviv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnviv(TextureEnvTarget target, TextureEnvParameter pname, void* @params) => _TexEnviv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnviv(TextureEnvTarget target, TextureEnvParameter pname, IntPtr @params) => _TexEnviv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnvx(TextureEnvTarget target, TextureEnvParameter pname, float param) => _TexEnvx(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnvxOES(TextureEnvTarget target, TextureEnvParameter pname, float param) => _TexEnvxOES(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnvxv(TextureEnvTarget target, TextureEnvParameter pname, float[] @params) => _TexEnvxv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnvxv(TextureEnvTarget target, TextureEnvParameter pname, void* @params) => _TexEnvxv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnvxv(TextureEnvTarget target, TextureEnvParameter pname, IntPtr @params) => _TexEnvxv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, float[] @params) => _TexEnvxvOES(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, void* @params) => _TexEnvxvOES_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEnvxvOES(TextureEnvTarget target, TextureEnvParameter pname, IntPtr @params) => _TexEnvxvOES_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEstimateMotionQCOM(uint @ref, uint target, uint output) => _TexEstimateMotionQCOM(@ref, target, output);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexEstimateMotionRegionsQCOM(uint @ref, uint target, uint output, uint mask) => _TexEstimateMotionRegionsQCOM(@ref, target, output, mask);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, int n, float[] weights) => _TexFilterFuncSGIS(target, filter, n, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, int n, void* weights) => _TexFilterFuncSGIS_ptr(target, filter, n, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexFilterFuncSGIS(TextureTarget target, TextureFilterSGIS filter, int n, IntPtr weights) => _TexFilterFuncSGIS_intptr(target, filter, n, weights);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGend(TextureCoordName coord, TextureGenParameter pname, double param) => _TexGend(coord, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGendv(TextureCoordName coord, TextureGenParameter pname, double[] @params) => _TexGendv(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGendv(TextureCoordName coord, TextureGenParameter pname, void* @params) => _TexGendv_ptr(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGendv(TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _TexGendv_intptr(coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGenf(TextureCoordName coord, TextureGenParameter pname, float param) => _TexGenf(coord, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGenfOES(TextureCoordName coord, TextureGenParameter pname, float param) => _TexGenfOES(coord, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGenfv(TextureCoordName coord, TextureGenParameter pname, float[] @params) => _TexGenfv(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGenfv(TextureCoordName coord, TextureGenParameter pname, void* @params) => _TexGenfv_ptr(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGenfv(TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _TexGenfv_intptr(coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGenfvOES(TextureCoordName coord, TextureGenParameter pname, float[] @params) => _TexGenfvOES(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGenfvOES(TextureCoordName coord, TextureGenParameter pname, void* @params) => _TexGenfvOES_ptr(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGenfvOES(TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _TexGenfvOES_intptr(coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGeni(TextureCoordName coord, TextureGenParameter pname, int param) => _TexGeni(coord, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGeniOES(TextureCoordName coord, TextureGenParameter pname, int param) => _TexGeniOES(coord, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGeniv(TextureCoordName coord, TextureGenParameter pname, int[] @params) => _TexGeniv(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGeniv(TextureCoordName coord, TextureGenParameter pname, void* @params) => _TexGeniv_ptr(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGeniv(TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _TexGeniv_intptr(coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGenivOES(TextureCoordName coord, TextureGenParameter pname, int[] @params) => _TexGenivOES(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGenivOES(TextureCoordName coord, TextureGenParameter pname, void* @params) => _TexGenivOES_ptr(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGenivOES(TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _TexGenivOES_intptr(coord, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGenxOES(TextureCoordName coord, TextureGenParameter pname, float param) => _TexGenxOES(coord, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGenxvOES(TextureCoordName coord, TextureGenParameter pname, float[] @params) => _TexGenxvOES(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGenxvOES(TextureCoordName coord, TextureGenParameter pname, void* @params) => _TexGenxvOES_ptr(coord, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexGenxvOES(TextureCoordName coord, TextureGenParameter pname, IntPtr @params) => _TexGenxvOES_intptr(coord, pname, @params);

        // ---

        /// <summary>
        /// Texturing maps a portion of a specified texture image            onto each graphical primitive for which texturing is enabled.            To enable and disable one-dimensional texturing, call glEnable            and glDisable with argument GL_TEXTURE_1D.
        /// Texture images are defined with glTexImage1D.            The arguments describe the parameters of the texture image,            such as width,            width of the border,            level-of-detail number            (see glTexParameter),            and the internal resolution and format used to store the image.            The last three arguments describe how the image is represented in            memory.
        /// If target is GL_PROXY_TEXTURE_1D, no data is read from data, but            all of the texture image state is recalculated, checked for            consistency, and checked against the implementation's capabilities.            If the implementation cannot handle a texture of the            requested texture size, it sets all of the image state to 0,            but does not generate an error (see glGetError). To query for an            entire mipmap array, use an image array level greater than or equal to            1.
        /// If target is GL_TEXTURE_1D,            data is read from data as a sequence of signed or unsigned bytes,            shorts,            or longs,            or single-precision floating-point values,            depending on type.            These values are grouped into sets of one,            two,            three,            or four values,            depending on format,            to form elements.            Each data byte is treated as eight 1-bit elements,            with bit ordering determined by GL_UNPACK_LSB_FIRST            (see glPixelStore).
        /// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target            (see glBindBuffer) while a texture image is            specified, data is treated as a byte offset into the buffer object's data store.
        /// The first element corresponds to the left end of the texture array.            Subsequent elements progress left-to-right through the remaining texels            in the texture array.            The final element corresponds to the right end of the texture array.
        /// format determines the composition of each element in data.            It can assume one of these symbolic values:
        /// GL_RED                        Each element is a single red component.                        The GL converts it to floating point and assembles it into an RGBA element                        by attaching 0 for green and blue, and 1 for alpha.                        Each component is clamped to the range [0,1].                    GL_RG                        Each element is a single red/green double                        The GL converts it to floating point and assembles it into an RGBA element                        by attaching 0 for blue, and 1 for alpha.                        Each component is clamped to the range [0,1].                    GL_RGBGL_BGR                        Each element is an RGB triple.                        The GL converts it to floating point and assembles it into an RGBA element                        by attaching 1 for alpha.                        Each component is clamped to the range [0,1].                    GL_RGBAGL_BGRA                        Each element contains all four components.                        Each component clamped to the range [0,1].                    GL_DEPTH_COMPONENT                        Each element is a single depth value.                        The GL converts it to floating point and clamps to the range [0,1].
        /// If an application wants to store the texture at a certain            resolution or in a certain format, it can request the resolution            and format with internalformat. The GL will choose an internal            representation that closely approximates that requested by internalformat, but            it may not match exactly.            (The representations specified by GL_RED, GL_RG,            GL_RGB and GL_RGBA must match exactly.)
        /// internalformat may be one of the base internal formats shown in            Table 1, below
        /// internalformat may also be one of the sized internal formats            shown in Table 2, below
        /// Finally, internalformat may also be one of the generic or compressed            texture formats shown in Table 3 below
        /// If the internalformat parameter is one of the generic compressed formats,                GL_COMPRESSED_RED, GL_COMPRESSED_RG,                GL_COMPRESSED_RGB, or                GL_COMPRESSED_RGBA, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage.  If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.
        /// If the internalformat parameter is            GL_SRGB,                        GL_SRGB8,                        GL_SRGB_ALPHAor                        GL_SRGB8_ALPHA8, the texture is treated as if the red, green, or blue components are encoded in the sRGB color space.    Any alpha component is left unchanged.  The conversion from the sRGB encoded component                        ,            where max is the returned value of GL_MAX_TEXTURE_SIZE.
        /// GL_INVALID_VALUE is generated if internalformat is not            one of the accepted resolution and format symbolic constants.
        /// GL_INVALID_VALUE is generated if width is less than 0            or greater than GL_MAX_TEXTURE_SIZE.
        /// GL_INVALID_VALUE is generated if border is not 0.
        /// GL_INVALID_OPERATION is generated if type is one of            GL_UNSIGNED_BYTE_3_3_2,            GL_UNSIGNED_BYTE_2_3_3_REV,            GL_UNSIGNED_SHORT_5_6_5, or            GL_UNSIGNED_SHORT_5_6_5_REV            and format is not GL_RGB.
        /// GL_INVALID_OPERATION is generated if type is one of            GL_UNSIGNED_SHORT_4_4_4_4,            GL_UNSIGNED_SHORT_4_4_4_4_REV,            GL_UNSIGNED_SHORT_5_5_5_1,            GL_UNSIGNED_SHORT_1_5_5_5_REV,            GL_UNSIGNED_INT_8_8_8_8,            GL_UNSIGNED_INT_8_8_8_8_REV,            GL_UNSIGNED_INT_10_10_10_2, or            GL_UNSIGNED_INT_2_10_10_10_REV            and format is neither GL_RGBA nor GL_BGRA.
        /// GL_INVALID_OPERATION is generated if format is            GL_DEPTH_COMPONENT and internalformat is not            GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16,            GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32.
        /// GL_INVALID_OPERATION is generated if internalformat is            GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16,            GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32, and format is            not GL_DEPTH_COMPONENT.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the            GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the            GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer            object such that the memory reads required would exceed the data store size.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the            GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible            into the number of bytes needed to store in memory a datum indicated by type.
        /// </summary>
        /// <param name="target">Specifies the target texture.                    Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.</param>
        /// <param name="level">Specifies the level-of-detail number.                    Level 0 is the base image level.                    Level n is the nth mipmap reduction image.</param>
        /// <param name="internalformat">Specifies the number of color components in the texture.                    Must be one of base internal formats given in Table 1,                    one of the sized internal formats given in Table 2, or one                    of the compressed internal formats given in Table 3, below.</param>
        /// <param name="width">Specifies the width of the texture image.                    All implementations support texture images that are at least 1024 texels                    wide. The height of the 1D texture image is 1.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="format">Specifies the format of the pixel data.                    The following symbolic values are accepted:                    GL_RED,                    GL_RG,                    GL_RGB,                    GL_BGR,                    GL_RGBA,                    GL_BGRA,                    GL_RED_INTEGER,                    GL_RG_INTEGER,                    GL_RGB_INTEGER,                    GL_BGR_INTEGER,                    GL_RGBA_INTEGER,                    GL_BGRA_INTEGER,                    GL_STENCIL_INDEX,                    GL_DEPTH_COMPONENT,                    GL_DEPTH_STENCIL.</param>
        /// <param name="type">Specifies the data type of the pixel data.                    The following symbolic values are accepted:                    GL_UNSIGNED_BYTE,                    GL_BYTE,                    GL_UNSIGNED_SHORT,                    GL_SHORT,                    GL_UNSIGNED_INT,                    GL_INT,                    GL_HALF_FLOAT,                    GL_FLOAT,                    GL_UNSIGNED_BYTE_3_3_2,                    GL_UNSIGNED_BYTE_2_3_3_REV,                    GL_UNSIGNED_SHORT_5_6_5,                    GL_UNSIGNED_SHORT_5_6_5_REV,                    GL_UNSIGNED_SHORT_4_4_4_4,                    GL_UNSIGNED_SHORT_4_4_4_4_REV,                    GL_UNSIGNED_SHORT_5_5_5_1,                    GL_UNSIGNED_SHORT_1_5_5_5_REV,                    GL_UNSIGNED_INT_8_8_8_8,                    GL_UNSIGNED_INT_8_8_8_8_REV,                    GL_UNSIGNED_INT_10_10_10_2, and                    GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Specifies a pointer to the image data in memory.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexImage1D(TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, IntPtr pixels) => _TexImage1D(target, level, internalformat, width, border, format, type, pixels);

        // ---

        /// <summary>
        /// Texturing allows elements of an image array to be read by shaders.
        /// To define texture images, call glTexImage2D.            The arguments describe the parameters of the texture image,            such as height, width, width of the border, level-of-detail number            (see glTexParameter),            and number of color components provided.            The last three arguments describe how the image is represented in memory.
        /// If target is GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY,            GL_PROXY_TEXTURE_CUBE_MAP, or GL_PROXY_TEXTURE_RECTANGLE,            no data is read from data, but            all of the texture image state is recalculated, checked for            consistency, and checked            against the implementation's capabilities. If the implementation cannot            handle a texture of the requested texture size, it sets            all of the image state to 0,            but does not generate an error (see glGetError). To query for an            entire mipmap array, use an image array level greater than or equal to 1.
        /// If target is GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE            or one of the GL_TEXTURE_CUBE_MAP            targets, data is read from data as a sequence of signed or unsigned            bytes, shorts, or longs, or single-precision floating-point values,            depending on type.  These values are grouped into sets of one, two,            three, or four values, depending on format, to form elements.            Each data byte is treated as eight 1-bit elements,            with bit ordering determined by GL_UNPACK_LSB_FIRST            (see glPixelStore).
        /// If target is GL_TEXTURE_1D_ARRAY, data is interpreted            as an array of one-dimensional images.
        /// If a non-zero named buffer object is bound to the GL_PIXEL_UNPACK_BUFFER target            (see glBindBuffer) while a texture image is            specified, data is treated as a byte offset into the buffer object's data store.
        /// The first element corresponds to the lower left corner of the texture image.            Subsequent elements progress left-to-right through the remaining texels            in the lowest row of the texture image, and then in successively higher            rows of the texture image.            The final element corresponds to the upper right corner of the texture            image.
        /// format determines the composition of each element in data.            It can assume one of these symbolic values:
        /// GL_RED                        Each element is a single red component.                        The GL converts it to floating point and assembles it into an RGBA element                        by attaching 0 for green and blue, and 1 for alpha.                        Each component is clamped to the range [0,1].                    GL_RG                        Each element is a red/green double.                        The GL converts it to floating point and assembles it into an RGBA element                        by attaching 0 for blue, and 1 for alpha.                        Each component is clamped to the range [0,1].                    GL_RGBGL_BGR                        Each element is an RGB triple.                        The GL converts it to floating point and assembles it into an RGBA element                        by attaching 1 for alpha.                        Each component is clamped to the range [0,1].                    GL_RGBAGL_BGRA                        Each element contains all four components.                        Each component is clamped to the range [0,1].                    GL_DEPTH_COMPONENT                        Each element is a single depth value.                        The GL converts it to floating point and clamps to the range [0,1].                    GL_DEPTH_STENCIL                        Each element is a pair of depth and stencil values. The depth component of                        the pair is interpreted as in GL_DEPTH_COMPONENT. The stencil                        component is interpreted based on specified the depth + stencil internal format.
        /// If an application wants to store the texture at a certain            resolution or in a certain format, it can request the resolution            and format with internalformat. The GL will choose an internal            representation that closely approximates that requested by internalformat, but            it may not match exactly.            (The representations specified by GL_RED,            GL_RG, GL_RGB,            and GL_RGBA must match exactly.)
        /// internalformat may be one of the base internal formats shown in            Table 1, below
        /// internalformat may also be one of the sized internal formats            shown in Table 2, below
        /// Finally, internalformat may also be one of the generic or compressed            texture formats shown in Table 3 below
        /// If the internalformat parameter is one of the generic compressed formats,            GL_COMPRESSED_RED, GL_COMPRESSED_RG,            GL_COMPRESSED_RGB, or            GL_COMPRESSED_RGBA, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage.  If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.
        /// If the internalformat parameter is            GL_SRGB,            GL_SRGB8,            GL_SRGB_ALPHA, or            GL_SRGB8_ALPHA8, the texture is treated as if the red, green, or blue components are encoded in the sRGB color space.    Any alpha component is left unchanged.  The conversion from the sRGB encoded component            ,            where max is the returned value of GL_MAX_TEXTURE_SIZE.
        /// GL_INVALID_VALUE is generated if internalformat is not one of the            accepted resolution and format symbolic constants.
        /// GL_INVALID_VALUE is generated if width or height is less than 0            or greater than GL_MAX_TEXTURE_SIZE.
        /// GL_INVALID_VALUE is generated if border is not 0.
        /// GL_INVALID_OPERATION is generated if type is one of            GL_UNSIGNED_BYTE_3_3_2,            GL_UNSIGNED_BYTE_2_3_3_REV,            GL_UNSIGNED_SHORT_5_6_5,            GL_UNSIGNED_SHORT_5_6_5_REV, or            GL_UNSIGNED_INT_10F_11F_11F_REV,            and format is not GL_RGB.
        /// GL_INVALID_OPERATION is generated if type is one of            GL_UNSIGNED_SHORT_4_4_4_4,            GL_UNSIGNED_SHORT_4_4_4_4_REV,            GL_UNSIGNED_SHORT_5_5_5_1,            GL_UNSIGNED_SHORT_1_5_5_5_REV,            GL_UNSIGNED_INT_8_8_8_8,            GL_UNSIGNED_INT_8_8_8_8_REV,            GL_UNSIGNED_INT_10_10_10_2,            GL_UNSIGNED_INT_2_10_10_10_REV, or            GL_UNSIGNED_INT_5_9_9_9_REV,            and format is neither GL_RGBA nor GL_BGRA.
        /// GL_INVALID_OPERATION is generated if target is not            GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D,            GL_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_RECTANGLE,            and internalformat is            GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16,            GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32F.
        /// GL_INVALID_OPERATION is generated if format is            GL_DEPTH_COMPONENT and internalformat is not            GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16,            GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32F.
        /// GL_INVALID_OPERATION is generated if internalformat is            GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16,            GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32F, and format is            not GL_DEPTH_COMPONENT.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the            GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the            GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer            object such that the memory reads required would exceed the data store size.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the            GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible            into the number of bytes needed to store in memory a datum indicated by type.
        /// GL_INVALID_VALUE is generated if target is GL_TEXTURE_RECTANGLE            or GL_PROXY_TEXTURE_RECTANGLE and level is not 0.
        /// </summary>
        /// <param name="target">Specifies the target texture.                    Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D,                    GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY,                    GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE,                    GL_TEXTURE_CUBE_MAP_POSITIVE_X,                    GL_TEXTURE_CUBE_MAP_NEGATIVE_X,                    GL_TEXTURE_CUBE_MAP_POSITIVE_Y,                    GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,                    GL_TEXTURE_CUBE_MAP_POSITIVE_Z,                    GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or                    GL_PROXY_TEXTURE_CUBE_MAP.</param>
        /// <param name="level">Specifies the level-of-detail number.                    Level 0 is the base image level.                    Level n is the nth mipmap reduction image.                    If target is GL_TEXTURE_RECTANGLE or                    GL_PROXY_TEXTURE_RECTANGLE, level must be 0.</param>
        /// <param name="internalformat">Specifies the number of color components in the texture.                    Must be one of base internal formats given in Table 1,                    one of the sized internal formats given in Table 2, or one                    of the compressed internal formats given in Table 3, below.</param>
        /// <param name="width">Specifies the width of the texture image.                    All implementations support texture images that are at least 1024 texels                    wide.</param>
        /// <param name="height">Specifies the height of the texture image, or the number of layers in a texture                    array, in the case of the GL_TEXTURE_1D_ARRAY and                    GL_PROXY_TEXTURE_1D_ARRAY targets.                    All implementations support 2D texture images that are at least 1024 texels                    high, and texture arrays that are at least 256 layers deep.</param>
        /// <param name="border">This value must be 0.</param>
        /// <param name="format">Specifies the format of the pixel data.                    The following symbolic values are accepted:                    GL_RED,                    GL_RG,                    GL_RGB,                    GL_BGR,                    GL_RGBA,                    GL_BGRA,                    GL_RED_INTEGER,                    GL_RG_INTEGER,                    GL_RGB_INTEGER,                    GL_BGR_INTEGER,                    GL_RGBA_INTEGER,                    GL_BGRA_INTEGER,                    GL_STENCIL_INDEX,                    GL_DEPTH_COMPONENT,                    GL_DEPTH_STENCIL.</param>
        /// <param name="type">Specifies the data type of the pixel data.                    The following symbolic values are accepted:                    GL_UNSIGNED_BYTE,                    GL_BYTE,                    GL_UNSIGNED_SHORT,                    GL_SHORT,                    GL_UNSIGNED_INT,                    GL_INT,                    GL_HALF_FLOAT,                    GL_FLOAT,                    GL_UNSIGNED_BYTE_3_3_2,                    GL_UNSIGNED_BYTE_2_3_3_REV,                    GL_UNSIGNED_SHORT_5_6_5,                    GL_UNSIGNED_SHORT_5_6_5_REV,                    GL_UNSIGNED_SHORT_4_4_4_4,                    GL_UNSIGNED_SHORT_4_4_4_4_REV,                    GL_UNSIGNED_SHORT_5_5_5_1,                    GL_UNSIGNED_SHORT_1_5_5_5_REV,                    GL_UNSIGNED_INT_8_8_8_8,                    GL_UNSIGNED_INT_8_8_8_8_REV,                    GL_UNSIGNED_INT_10_10_10_2, and                    GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="data">Specifies a pointer to the image data in memory.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexImage2D(TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, IntPtr pixels) => _TexImage2D(target, level, internalformat, width, height, border, format, type, pixels);

        // ---

        /// <summary>
        /// glTexImage2DMultisample establishes the data storage, format, dimensions and number of samples of a multisample texture's image.
        /// target must be            GL_TEXTURE_2D_MULTISAMPLE or            GL_PROXY_TEXTURE_2D_MULTISAMPLE.            width and height            are the dimensions in texels of the texture, and must be in the            range zero to the value of            GL_MAX_TEXTURE_SIZE minus one.            samples specifies the number of samples            in the image and must be in the range zero to the value of            GL_MAX_SAMPLES minus one.
        /// internalformat must be a color-renderable, depth-renderable, or stencil-renderable format.
        /// If fixedsamplelocations is GL_TRUE, the image will use identical sample locations and the same            number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
        /// When a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch and an integer            corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling instructions are allowed on the            multisample texture targets.
        /// </summary>
        /// <param name="target">Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE.</param>
        /// <param name="samples">The number of samples in the multisample texture's image.</param>
        /// <param name="internalformat">The internal format to be used to store the multisample texture's image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format.</param>
        /// <param name="width">The width of the multisample texture's image, in texels.</param>
        /// <param name="height">The height of the multisample texture's image, in texels.</param>
        /// <param name="fixedsamplelocations">Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not                    depend on the internal format or size of the image.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexImage2DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations) => _TexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexImage2DMultisampleCoverageNV(TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, bool fixedSampleLocations) => _TexImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexImage3D(TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, IntPtr pixels) => _TexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexImage3DEXT(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, IntPtr pixels) => _TexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, pixels);

        // ---

        /// <summary>
        /// glTexImage3DMultisample establishes the data storage, format, dimensions and number of samples of a multisample texture's image.
        /// target must be            GL_TEXTURE_2D_MULTISAMPLE_ARRAY or            GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.            width and            heightare the dimensions in texels of the            texture, and must be in the range zero to the value of            GL_MAX_TEXTURE_SIZE minus one.            depth is the number of array slices in            the array texture's image. samples            specifies the number of samples in the image and must be in the            range zero to the value of GL_MAX_SAMPLES            minus one.
        /// internalformat must be a color-renderable, depth-renderable, or stencil-renderable format.
        /// If fixedsamplelocations is GL_TRUE, the image will use identical sample locations and the same            number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
        /// When a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch and an integer            corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling instructions are allowed on the            multisample texture targets.
        /// </summary>
        /// <param name="target">Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.</param>
        /// <param name="samples">The number of samples in the multisample texture's image.</param>
        /// <param name="internalformat">The internal format to be used to store the multisample texture's image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format.</param>
        /// <param name="width">The width of the multisample texture's image, in texels.</param>
        /// <param name="height">The height of the multisample texture's image, in texels.</param>
        /// <param name="fixedsamplelocations">Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not                    depend on the internal format or size of the image.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexImage3DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => _TexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexImage3DMultisampleCoverageNV(TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations) => _TexImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexImage3DOES(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, IntPtr pixels) => _TexImage3DOES(target, level, internalformat, width, height, depth, border, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexImage4DSGIS(TextureTarget target, int level, InternalFormat internalformat, int width, int height, int depth, int size4d, int border, PixelFormat format, PixelType type, IntPtr pixels) => _TexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexPageCommitmentARB(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) => _TexPageCommitmentARB(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexPageCommitmentEXT(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) => _TexPageCommitmentEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIiv(TextureTarget target, TextureParameterName pname, int[] @params) => _TexParameterIiv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIiv(TextureTarget target, TextureParameterName pname, void* @params) => _TexParameterIiv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIiv(TextureTarget target, TextureParameterName pname, IntPtr @params) => _TexParameterIiv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIivEXT(TextureTarget target, TextureParameterName pname, int[] @params) => _TexParameterIivEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIivEXT(TextureTarget target, TextureParameterName pname, void* @params) => _TexParameterIivEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIivEXT(TextureTarget target, TextureParameterName pname, IntPtr @params) => _TexParameterIivEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIivOES(TextureTarget target, TextureParameterName pname, int[] @params) => _TexParameterIivOES(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIivOES(TextureTarget target, TextureParameterName pname, void* @params) => _TexParameterIivOES_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIivOES(TextureTarget target, TextureParameterName pname, IntPtr @params) => _TexParameterIivOES_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIuiv(TextureTarget target, TextureParameterName pname, uint[] @params) => _TexParameterIuiv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIuiv(TextureTarget target, TextureParameterName pname, void* @params) => _TexParameterIuiv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIuiv(TextureTarget target, TextureParameterName pname, IntPtr @params) => _TexParameterIuiv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIuivEXT(TextureTarget target, TextureParameterName pname, uint[] @params) => _TexParameterIuivEXT(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIuivEXT(TextureTarget target, TextureParameterName pname, void* @params) => _TexParameterIuivEXT_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIuivEXT(TextureTarget target, TextureParameterName pname, IntPtr @params) => _TexParameterIuivEXT_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIuivOES(TextureTarget target, TextureParameterName pname, uint[] @params) => _TexParameterIuivOES(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIuivOES(TextureTarget target, TextureParameterName pname, void* @params) => _TexParameterIuivOES_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterIuivOES(TextureTarget target, TextureParameterName pname, IntPtr @params) => _TexParameterIuivOES_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterf(TextureTarget target, TextureParameterName pname, float param) => _TexParameterf(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterfv(TextureTarget target, TextureParameterName pname, float[] @params) => _TexParameterfv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterfv(TextureTarget target, TextureParameterName pname, void* @params) => _TexParameterfv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterfv(TextureTarget target, TextureParameterName pname, IntPtr @params) => _TexParameterfv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameteri(TextureTarget target, TextureParameterName pname, int param) => _TexParameteri(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameteriv(TextureTarget target, TextureParameterName pname, int[] @params) => _TexParameteriv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameteriv(TextureTarget target, TextureParameterName pname, void* @params) => _TexParameteriv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameteriv(TextureTarget target, TextureParameterName pname, IntPtr @params) => _TexParameteriv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterx(TextureTarget target, GetTextureParameter pname, float param) => _TexParameterx(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterxOES(TextureTarget target, GetTextureParameter pname, float param) => _TexParameterxOES(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterxv(TextureTarget target, GetTextureParameter pname, float[] @params) => _TexParameterxv(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterxv(TextureTarget target, GetTextureParameter pname, void* @params) => _TexParameterxv_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterxv(TextureTarget target, GetTextureParameter pname, IntPtr @params) => _TexParameterxv_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterxvOES(TextureTarget target, GetTextureParameter pname, float[] @params) => _TexParameterxvOES(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterxvOES(TextureTarget target, GetTextureParameter pname, void* @params) => _TexParameterxvOES_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexParameterxvOES(TextureTarget target, GetTextureParameter pname, IntPtr @params) => _TexParameterxvOES_intptr(target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexRenderbufferNV(TextureTarget target, uint renderbuffer) => _TexRenderbufferNV(target, renderbuffer);

        // ---

        /// <summary>
        /// glTexStorage1D and            glTextureStorage1D specify the storage            requirements for all levels            of a one-dimensional texture simultaneously. Once a texture is specified with this            command, the format and dimensions of all levels become immutable unless it is a proxy            texture. The contents of the image may still be modified, however, its storage requirements            may not change. Such a texture is referred to as an immutable-format            texture.
        /// Calling glTexStorage1D is equivalent, assuming no errors are generated,            to executing the following pseudo-code:
        /// for (i = 0; i < levels; i++) {        glTexImage1D(target, i, internalformat, width, 0, format, type, NULL);        width = max(1, (width / 2));    }
        /// Calling glTextureStorage1D is equivalent to the            above pseudo-code, where target is the            effective target of texture and it is as            if texture were bound to            target for the purposes of            glTexImage1D.
        /// Since no texture data is actually provided, the values used in the pseudo-code            for format and type are            irrelevant and may be considered to be any values that are legal for the            chosen internalformat enumerant. internalformat            must be one of the sized internal formats given in Table 1 below, one of the sized depth-component            formats GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT24, or            GL_DEPTH_COMPONENT16, one of the combined depth-stencil formats,            GL_DEPTH32F_STENCIL8, or GL_DEPTH24_STENCIL8, or the            stencil-only format, GL_STENCIL_INDEX8. Upon success,            the value of GL_TEXTURE_IMMUTABLE_FORMAT becomes            GL_TRUE. The value of GL_TEXTURE_IMMUTABLE_FORMAT            may be discovered by calling glGetTexParameter            with pname set to GL_TEXTURE_IMMUTABLE_FORMAT.            No further changes to the dimensions or format of the texture object may be            made. Using any command that might alter the dimensions or format of the            texture object (such as glTexImage1D or            another call to glTexStorage1D) will result in the            generation of a GL_INVALID_OPERATION error, even if it            would not, in fact, alter the dimensions or format of the object.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture object is                    bound for glTexStorage1D. Must be                    one of GL_TEXTURE_1D or                    GL_PROXY_TEXTURE_1D.</param>
        /// <param name="texture">Specifies the texture object name for                    glTextureStorage1D. The effective                    target of texture must be one of                    the valid non-proxy target values                    above.</param>
        /// <param name="levels">Specify the number of texture levels.</param>
        /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
        /// <param name="width">Specifies the width of the texture, in texels.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexStorage1D(TextureTarget target, int levels, InternalFormat internalformat, int width) => _TexStorage1D(target, levels, internalformat, width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexStorage1DEXT(TextureTarget target, int levels, InternalFormat internalformat, int width) => _TexStorage1DEXT(target, levels, internalformat, width);

        // ---

        /// <summary>
        /// glTexStorage2D and            glTextureStorage2D specify the storage            requirements for all levels            of a two-dimensional texture or one-dimensional texture array simultaneously. Once a texture is specified with this            command, the format and dimensions of all levels become immutable unless it is a proxy            texture. The contents of the image may still be modified, however, its storage requirements            may not change. Such a texture is referred to as an immutable-format            texture.
        /// The behavior of glTexStorage2D depends on            the target parameter. When            target is            GL_TEXTURE_2D,            GL_PROXY_TEXTURE_2D,            GL_TEXTURE_RECTANGLE,            GL_PROXY_TEXTURE_RECTANGLE or            GL_PROXY_TEXTURE_CUBE_MAP, calling            glTexStorage2D is equivalent, assuming no            errors are generated, to executing the following pseudo-code:
        /// for (i = 0; i < levels; i++) {        glTexImage2D(target, i, internalformat, width, height, 0, format, type, NULL);        width = max(1, (width / 2));        height = max(1, (height / 2));    }
        /// When target is            GL_TEXTURE_CUBE_MAP,            glTexStorage2D is equivalent to:
        /// for (i = 0; i < levels; i++) {        for (face in (+X, -X, +Y, -Y, +Z, -Z)) {            glTexImage2D(face, i, internalformat, width, height, 0, format, type, NULL);        }        width = max(1, (width / 2));        height = max(1, (height / 2));    }
        /// When target is            GL_TEXTURE_1D_ARRAY or            GL_PROXY_TEXTURE_1D_ARRAY,            glTexStorage2D is equivalent to:
        /// for (i = 0; i < levels; i++) {        glTexImage2D(target, i, internalformat, width, height, 0, format, type, NULL);        width = max(1, (width / 2));    }
        /// Calling glTextureStorage2D is equivalent to the            above pseudo-code, where target is the            effective target of texture and it is as            if texture were bound to            target for the purposes of            glTexImage2D.
        /// Since no texture data is actually provided, the values used in the pseudo-code            for format and type are            irrelevant and may be considered to be any values that are legal for the            chosen internalformat enumerant. internalformat            must be one of the sized internal formats given in Table 1 below, one of the sized depth-component            formats GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT24, or            GL_DEPTH_COMPONENT16, one of the combined depth-stencil formats,            GL_DEPTH32F_STENCIL8, or GL_DEPTH24_STENCIL8, or the            stencil-only format, GL_STENCIL_INDEX8. Upon success,            the value of GL_TEXTURE_IMMUTABLE_FORMAT becomes            GL_TRUE. The value of GL_TEXTURE_IMMUTABLE_FORMAT            may be discovered by calling glGetTexParameter            with pname set to GL_TEXTURE_IMMUTABLE_FORMAT.            No further changes to the dimensions or format of the texture object may be            made. Using any command that might alter the dimensions or format of the            texture object (such as glTexImage2D or            another call to glTexStorage2D) will result in the            generation of a GL_INVALID_OPERATION error, even if it            would not, in fact, alter the dimensions or format of the object.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture object is                    bound for glTexStorage2D. Must be                    one of GL_TEXTURE_2D,                    GL_TEXTURE_1D_ARRAY,                    GL_TEXTURE_RECTANGLE,                    GL_TEXTURE_CUBE_MAP,                    GL_PROXY_TEXTURE_2D,                    GL_PROXY_TEXTURE_1D_ARRAY,                    GL_PROXY_TEXTURE_RECTANGLE, or                    GL_PROXY_TEXTURE_CUBE_MAP.</param>
        /// <param name="texture">Specifies the texture object name for                    glTextureStorage2D. The effective                    target of texture must be one of                    the valid non-proxy target values                    above.</param>
        /// <param name="levels">Specify the number of texture levels.</param>
        /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
        /// <param name="width">Specifies the width of the texture, in texels.</param>
        /// <param name="height">Specifies the height of the texture, in texels.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexStorage2D(TextureTarget target, int levels, InternalFormat internalformat, int width, int height) => _TexStorage2D(target, levels, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexStorage2DEXT(TextureTarget target, int levels, InternalFormat internalformat, int width, int height) => _TexStorage2DEXT(target, levels, internalformat, width, height);

        // ---

        /// <summary>
        /// glTexStorage2DMultisample and            glTextureStorage2DMultisample specify the            storage requirements for            a two-dimensional multisample texture. Once a texture is specified with this            command, its format and dimensions become immutable unless it is a proxy            texture. The contents of the image may still be modified, however, its storage requirements            may not change. Such a texture is referred to as an immutable-format            texture.
        /// samples specifies the number of samples to be used for the texture            and must be greater than zero and less than or equal to the value of GL_MAX_SAMPLES.            internalformat must be a color-renderable, depth-renderable, or stencil-renderable format.            width and height specify the width and height,            respectively, of the texture. If fixedsamplelocations is GL_TRUE,            the image will use identical sample locations and the same number of samples for all texels in the image,            and the sample locations will not depend on the internal format or size of the image.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture object is                    bound for                    glTexStorage2DMultisample. Must be                    one of GL_TEXTURE_2D_MULTISAMPLE or                    GL_PROXY_TEXTURE_2D_MULTISAMPLE.</param>
        /// <param name="texture">Specifies the texture object name for                    glTextureStorage2DMultisample. The                    effective target of texture must                    be one of the valid non-proxy                    target values above.</param>
        /// <param name="samples">Specify the number of samples in the texture.</param>
        /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
        /// <param name="width">Specifies the width of the texture, in texels.</param>
        /// <param name="height">Specifies the height of the texture, in texels.</param>
        /// <param name="fixedsamplelocations">Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not                    depend on the internal format or size of the image.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexStorage2DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations) => _TexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);

        // ---

        /// <summary>
        /// glTexStorage3D and            glTextureStorage3D specify the            storage requirements for all levels            of a three-dimensional, two-dimensional array or cube-map array texture simultaneously. Once a texture is specified with this            command, the format and dimensions of all levels become immutable unless it is a proxy            texture. The contents of the image may still be modified, however, its storage requirements            may not change. Such a texture is referred to as an immutable-format            texture.
        /// The behavior of glTexStorage3D depends on the target parameter.            When target is GL_TEXTURE_3D, or GL_PROXY_TEXTURE_3D,            calling glTexStorage3D is equivalent, assuming no errors are generated,            to executing the following pseudo-code:
        /// for (i = 0; i < levels; i++) {        glTexImage3D(target, i, internalformat, width, height, depth, 0, format, type, NULL);        width = max(1, (width / 2));        height = max(1, (height / 2));        depth = max(1, (depth / 2));    }
        /// When target is GL_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY,            GL_TEXTURE_CUBE_MAP_ARRAY, or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY, glTexStorage3D            is equivalent to:
        /// for (i = 0; i < levels; i++) {        glTexImage3D(target, i, internalformat, width, height, depth, 0, format, type, NULL);        width = max(1, (width / 2));        height = max(1, (height / 2));    }
        /// Calling glTextureStorage3D is equivalent to the            above pseudo-code, where target is the            effective target of texture and it is as            if texture were bound to            target for the purposes of            glTexImage3D.
        /// Since no texture data is actually provided, the values used in the pseudo-code            for format and type are            irrelevant and may be considered to be any values that are legal for the            chosen internalformat enumerant. internalformat            must be one of the sized internal formats given in Table 1 below, one of the sized depth-component            formats GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT24, or            GL_DEPTH_COMPONENT16, one of the combined depth-stencil formats,            GL_DEPTH32F_STENCIL8, or GL_DEPTH24_STENCIL8, or the            stencil-only format, GL_STENCIL_INDEX8. Upon success,            the value of GL_TEXTURE_IMMUTABLE_FORMAT becomes            GL_TRUE. The value of GL_TEXTURE_IMMUTABLE_FORMAT            may be discovered by calling glGetTexParameter            with pname set to GL_TEXTURE_IMMUTABLE_FORMAT.            No further changes to the dimensions or format of the texture object may be            made. Using any command that might alter the dimensions or format of the            texture object (such as glTexImage3D or            another call to glTexStorage3D) will result in the            generation of a GL_INVALID_OPERATION error, even if it            would not, in fact, alter the dimensions or format of the object.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture object is                    bound for glTexStorage3D. Must be                    one of GL_TEXTURE_3D,                    GL_TEXTURE_2D_ARRAY,                    GL_TEXTURE_CUBE_MAP_ARRAY,                    GL_PROXY_TEXTURE_3D,                    GL_PROXY_TEXTURE_2D_ARRAY or                    GL_PROXY_TEXTURE_CUBE_MAP_ARRAY.</param>
        /// <param name="texture">Specifies the texture object name for                    glTextureStorage3D. The effective                    target of texture must be one of                    the valid non-proxy target values                    above.</param>
        /// <param name="levels">Specify the number of texture levels.</param>
        /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
        /// <param name="width">Specifies the width of the texture, in texels.</param>
        /// <param name="height">Specifies the height of the texture, in texels.</param>
        /// <param name="depth">Specifies the depth of the texture, in texels.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexStorage3D(TextureTarget target, int levels, InternalFormat internalformat, int width, int height, int depth) => _TexStorage3D(target, levels, internalformat, width, height, depth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexStorage3DEXT(TextureTarget target, int levels, InternalFormat internalformat, int width, int height, int depth) => _TexStorage3DEXT(target, levels, internalformat, width, height, depth);

        // ---

        /// <summary>
        /// glTexStorage3DMultisample and            glTextureStorage3DMultisample specify the            storage requirements for            a two-dimensional multisample array texture. Once a texture is specified with this            command, its format and dimensions become immutable unless it is a proxy            texture. The contents of the image may still be modified, however, its storage requirements            may not change. Such a texture is referred to as an immutable-format            texture.
        /// samples specifies the number of samples to be used for the texture            and must be greater than zero and less than or equal to the value of GL_MAX_SAMPLES.            internalformat must be a color-renderable, depth-renderable, or stencil-renderable format.            width and height specify the width and height,            respectively, of the texture and depth specifies the depth (or the number of layers)            of the texture. If fixedsamplelocations is GL_TRUE,            the image will use identical sample locations and the same number of samples for all texels in the image,            and the sample locations will not depend on the internal format or size of the image.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture object is                    bound for                    glTexStorage3DMultisample. Must be                    one of                    GL_TEXTURE_2D_MULTISAMPLE_ARRAY or                    GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.</param>
        /// <param name="texture">Specifies the texture object name for                    glTextureStorage3DMultisample. The                    effective target of texture must                    be one of the valid non-proxy                    target values above.</param>
        /// <param name="samples">Specify the number of samples in the texture.</param>
        /// <param name="internalformat">Specifies the sized internal format to be used to store texture image data.</param>
        /// <param name="width">Specifies the width of the texture, in texels.</param>
        /// <param name="height">Specifies the height of the texture, in texels.</param>
        /// <param name="depth">Specifies the depth of the texture, in layers.</param>
        /// <param name="fixedsamplelocations">Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not                    depend on the internal format or size of the image.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexStorage3DMultisample(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => _TexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexStorage3DMultisampleOES(TextureTarget target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => _TexStorage3DMultisampleOES(target, samples, internalformat, width, height, depth, fixedsamplelocations);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexStorageMem1DEXT(TextureTarget target, int levels, int internalFormat, int width, uint memory, UInt64 offset) => _TexStorageMem1DEXT(target, levels, internalFormat, width, memory, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexStorageMem2DEXT(TextureTarget target, int levels, int internalFormat, int width, int height, uint memory, UInt64 offset) => _TexStorageMem2DEXT(target, levels, internalFormat, width, height, memory, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexStorageMem2DMultisampleEXT(TextureTarget target, int samples, int internalFormat, int width, int height, bool fixedSampleLocations, uint memory, UInt64 offset) => _TexStorageMem2DMultisampleEXT(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexStorageMem3DEXT(TextureTarget target, int levels, int internalFormat, int width, int height, int depth, uint memory, UInt64 offset) => _TexStorageMem3DEXT(target, levels, internalFormat, width, height, depth, memory, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexStorageMem3DMultisampleEXT(TextureTarget target, int samples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, UInt64 offset) => _TexStorageMem3DMultisampleEXT(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexStorageSparseAMD(TextureTarget target, InternalFormat internalFormat, int width, int height, int depth, int layers, int flags) => _TexStorageSparseAMD(target, internalFormat, width, height, depth, layers, flags);

        // ---

        /// <summary>
        /// Texturing maps a portion of a specified texture image            onto each graphical primitive for which texturing is enabled.            To enable or disable one-dimensional texturing, call glEnable            and glDisable with argument GL_TEXTURE_1D.
        /// glTexSubImage1D and            glTextureSubImage1D redefine a contiguous            subregion of an existing one-dimensional texture image.            The texels referenced by pixels replace the portion of the            existing texture array with x indices xoffset and                        includes twice the border width.
        /// GL_INVALID_VALUE is generated if width is less than 0.
        /// GL_INVALID_OPERATION is generated if the texture array has not            been defined by a previous glTexImage1D operation.
        /// GL_INVALID_OPERATION is generated if type is one of            GL_UNSIGNED_BYTE_3_3_2,            GL_UNSIGNED_BYTE_2_3_3_REV,            GL_UNSIGNED_SHORT_5_6_5, or            GL_UNSIGNED_SHORT_5_6_5_REV            and format is not GL_RGB.
        /// GL_INVALID_OPERATION is generated if type is one of            GL_UNSIGNED_SHORT_4_4_4_4,            GL_UNSIGNED_SHORT_4_4_4_4_REV,            GL_UNSIGNED_SHORT_5_5_5_1,            GL_UNSIGNED_SHORT_1_5_5_5_REV,            GL_UNSIGNED_INT_8_8_8_8,            GL_UNSIGNED_INT_8_8_8_8_REV,            GL_UNSIGNED_INT_10_10_10_2, or            GL_UNSIGNED_INT_2_10_10_10_REV            and format is neither GL_RGBA nor GL_BGRA.
        /// GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX            and the base internal format is not GL_STENCIL_INDEX.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the            GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the            GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer            object such that the memory reads required would exceed the data store size.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the            GL_PIXEL_UNPACK_BUFFER target and pixels is not evenly divisible            into the number of bytes needed to store in memory a datum indicated by type.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture is bound for                    glTexSubImage1D.                    Must be GL_TEXTURE_1D.</param>
        /// <param name="texture">Specifies the texture object name for                    glTextureSubImage1D. The effective                    target of texture must be one of                    the valid target values above.</param>
        /// <param name="level">Specifies the level-of-detail number.                    Level 0 is the base image level.                    Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="format">Specifies the format of the pixel data.                    The following symbolic values are accepted:                    GL_RED,                    GL_RG,                    GL_RGB,                    GL_BGR,                    GL_RGBA,                    GL_DEPTH_COMPONENT, and                    GL_STENCIL_INDEX.</param>
        /// <param name="type">Specifies the data type of the pixel data.                    The following symbolic values are accepted:                    GL_UNSIGNED_BYTE,                    GL_BYTE,                    GL_UNSIGNED_SHORT,                    GL_SHORT,                    GL_UNSIGNED_INT,                    GL_INT,                    GL_FLOAT,                    GL_UNSIGNED_BYTE_3_3_2,                    GL_UNSIGNED_BYTE_2_3_3_REV,                    GL_UNSIGNED_SHORT_5_6_5,                    GL_UNSIGNED_SHORT_5_6_5_REV,                    GL_UNSIGNED_SHORT_4_4_4_4,                    GL_UNSIGNED_SHORT_4_4_4_4_REV,                    GL_UNSIGNED_SHORT_5_5_5_1,                    GL_UNSIGNED_SHORT_1_5_5_5_REV,                    GL_UNSIGNED_INT_8_8_8_8,                    GL_UNSIGNED_INT_8_8_8_8_REV,                    GL_UNSIGNED_INT_10_10_10_2, and                    GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="pixels">Specifies a pointer to the image data in memory.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexSubImage1D(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, IntPtr pixels) => _TexSubImage1D(target, level, xoffset, width, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexSubImage1DEXT(TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, IntPtr pixels) => _TexSubImage1DEXT(target, level, xoffset, width, format, type, pixels);

        // ---

        /// <summary>
        /// Texturing maps a portion of a specified texture image            onto each graphical primitive for which texturing is enabled.
        /// glTexSubImage2D and            glTextureSubImage2D redefine a contiguous            subregion of an existing two-dimensional or one-dimensional            array texture image.            The texels referenced by pixels replace the portion of the            existing texture array with x indices xoffset and                        include twice the border width.
        /// GL_INVALID_VALUE is generated if width or height is less than 0.
        /// GL_INVALID_OPERATION is generated if the texture array has not            been defined by a previous glTexImage2D operation.
        /// GL_INVALID_OPERATION is generated if type is one of            GL_UNSIGNED_BYTE_3_3_2,            GL_UNSIGNED_BYTE_2_3_3_REV,            GL_UNSIGNED_SHORT_5_6_5, or            GL_UNSIGNED_SHORT_5_6_5_REV            and format is not GL_RGB.
        /// GL_INVALID_OPERATION is generated if type is one of            GL_UNSIGNED_SHORT_4_4_4_4,            GL_UNSIGNED_SHORT_4_4_4_4_REV,            GL_UNSIGNED_SHORT_5_5_5_1,            GL_UNSIGNED_SHORT_1_5_5_5_REV,            GL_UNSIGNED_INT_8_8_8_8,            GL_UNSIGNED_INT_8_8_8_8_REV,            GL_UNSIGNED_INT_10_10_10_2, or            GL_UNSIGNED_INT_2_10_10_10_REV            and format is neither GL_RGBA nor GL_BGRA.
        /// GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX            and the base internal format is not GL_STENCIL_INDEX.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the            GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the            GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer            object such that the memory reads required would exceed the data store size.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the            GL_PIXEL_UNPACK_BUFFER target and pixels is not evenly divisible            into the number of bytes needed to store in memory a datum indicated by type.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture is bound                    for glTexSubImage2D.                    Must be GL_TEXTURE_2D,                    GL_TEXTURE_CUBE_MAP_POSITIVE_X,                    GL_TEXTURE_CUBE_MAP_NEGATIVE_X,                    GL_TEXTURE_CUBE_MAP_POSITIVE_Y,                    GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,                    GL_TEXTURE_CUBE_MAP_POSITIVE_Z,                    GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,                    or GL_TEXTURE_1D_ARRAY.</param>
        /// <param name="texture">Specifies the texture object name for                    glTextureSubImage2D. The effective                    target of texture must be one of                    the valid target values above.</param>
        /// <param name="level">Specifies the level-of-detail number.                    Level 0 is the base image level.                    Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="format">Specifies the format of the pixel data.                    The following symbolic values are accepted:                    GL_RED,                    GL_RG,                    GL_RGB,                    GL_BGR,                    GL_RGBA,                    GL_BGRA,                    GL_DEPTH_COMPONENT, and                    GL_STENCIL_INDEX.</param>
        /// <param name="type">Specifies the data type of the pixel data.                    The following symbolic values are accepted:                    GL_UNSIGNED_BYTE,                    GL_BYTE,                    GL_UNSIGNED_SHORT,                    GL_SHORT,                    GL_UNSIGNED_INT,                    GL_INT,                    GL_FLOAT,                    GL_UNSIGNED_BYTE_3_3_2,                    GL_UNSIGNED_BYTE_2_3_3_REV,                    GL_UNSIGNED_SHORT_5_6_5,                    GL_UNSIGNED_SHORT_5_6_5_REV,                    GL_UNSIGNED_SHORT_4_4_4_4,                    GL_UNSIGNED_SHORT_4_4_4_4_REV,                    GL_UNSIGNED_SHORT_5_5_5_1,                    GL_UNSIGNED_SHORT_1_5_5_5_REV,                    GL_UNSIGNED_INT_8_8_8_8,                    GL_UNSIGNED_INT_8_8_8_8_REV,                    GL_UNSIGNED_INT_10_10_10_2, and                    GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="pixels">Specifies a pointer to the image data in memory.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexSubImage2D(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, IntPtr pixels) => _TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexSubImage2DEXT(TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, IntPtr pixels) => _TexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels);

        // ---

        /// <summary>
        /// Texturing maps a portion of a specified texture image            onto each graphical primitive for which texturing is enabled.
        /// glTexSubImage3D and            glTextureSubImage3D redefine a contiguous            subregion of an existing three-dimensional or two-dimensioanl            array texture image.            The texels referenced by pixels replace the portion of the            existing texture array with x indices xoffset and                        include twice the border width.
        /// GL_INVALID_VALUE is generated if width, height, or depth            is less than 0.
        /// GL_INVALID_OPERATION is generated if the texture array has not            been defined by a previous glTexImage3D            or glTexStorage3D operation.
        /// GL_INVALID_OPERATION is generated if type is one of            GL_UNSIGNED_BYTE_3_3_2,            GL_UNSIGNED_BYTE_2_3_3_REV,            GL_UNSIGNED_SHORT_5_6_5, or            GL_UNSIGNED_SHORT_5_6_5_REV            and format is not GL_RGB.
        /// GL_INVALID_OPERATION is generated if type is one of            GL_UNSIGNED_SHORT_4_4_4_4,            GL_UNSIGNED_SHORT_4_4_4_4_REV,            GL_UNSIGNED_SHORT_5_5_5_1,            GL_UNSIGNED_SHORT_1_5_5_5_REV,            GL_UNSIGNED_INT_8_8_8_8,            GL_UNSIGNED_INT_8_8_8_8_REV,            GL_UNSIGNED_INT_10_10_10_2, or            GL_UNSIGNED_INT_2_10_10_10_REV            and format is neither GL_RGBA nor GL_BGRA.
        /// GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX            and the base internal format is not GL_STENCIL_INDEX.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the            GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the            GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer            object such that the memory reads required would exceed the data store size.
        /// GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the            GL_PIXEL_UNPACK_BUFFER target and pixels is not evenly divisible            into the number of bytes needed to store in memory a datum indicated by type.
        /// </summary>
        /// <param name="target">Specifies the target to which the texture is bound                    for glTexSubImage3D.                    Must be GL_TEXTURE_3D or                    GL_TEXTURE_2D_ARRAY.</param>
        /// <param name="texture">Specifies the texture object name for                    glTextureSubImage3D. The effective                    target of texture must be one of                    the valid target values above.</param>
        /// <param name="level">Specifies the level-of-detail number.                    Level 0 is the base image level.                    Level n is the nth mipmap reduction image.</param>
        /// <param name="xoffset">Specifies a texel offset in the x direction within the texture array.</param>
        /// <param name="yoffset">Specifies a texel offset in the y direction within the texture array.</param>
        /// <param name="zoffset">Specifies a texel offset in the z direction within the texture array.</param>
        /// <param name="width">Specifies the width of the texture subimage.</param>
        /// <param name="height">Specifies the height of the texture subimage.</param>
        /// <param name="depth">Specifies the depth of the texture subimage.</param>
        /// <param name="format">Specifies the format of the pixel data.                    The following symbolic values are accepted:                    GL_RED,                    GL_RG,                    GL_RGB,                    GL_BGR,                    GL_RGBA,                    GL_DEPTH_COMPONENT, and                    GL_STENCIL_INDEX.</param>
        /// <param name="type">Specifies the data type of the pixel data.                    The following symbolic values are accepted:                    GL_UNSIGNED_BYTE,                    GL_BYTE,                    GL_UNSIGNED_SHORT,                    GL_SHORT,                    GL_UNSIGNED_INT,                    GL_INT,                    GL_FLOAT,                    GL_UNSIGNED_BYTE_3_3_2,                    GL_UNSIGNED_BYTE_2_3_3_REV,                    GL_UNSIGNED_SHORT_5_6_5,                    GL_UNSIGNED_SHORT_5_6_5_REV,                    GL_UNSIGNED_SHORT_4_4_4_4,                    GL_UNSIGNED_SHORT_4_4_4_4_REV,                    GL_UNSIGNED_SHORT_5_5_5_1,                    GL_UNSIGNED_SHORT_1_5_5_5_REV,                    GL_UNSIGNED_INT_8_8_8_8,                    GL_UNSIGNED_INT_8_8_8_8_REV,                    GL_UNSIGNED_INT_10_10_10_2, and                    GL_UNSIGNED_INT_2_10_10_10_REV.</param>
        /// <param name="pixels">Specifies a pointer to the image data in memory.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexSubImage3D(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels) => _TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexSubImage3DEXT(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels) => _TexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexSubImage3DOES(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels) => _TexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexSubImage4DSGIS(TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, PixelFormat format, PixelType type, IntPtr pixels) => _TexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureAttachMemoryNV(uint texture, uint memory, UInt64 offset) => _TextureAttachMemoryNV(texture, memory, offset);

        // ---

        /// <summary>
        /// The values of rendered fragments are undefined when a shader            stage fetches texels and the same texels are written via            fragment shader outputs, even if the reads and writes are not in            the same drawing command. To safely read the result of a written            texel via a texel fetch in a subsequent drawing command, call            glTextureBarrier between the two drawing            commands to guarantee that writes have completed and caches have            been invalidated before subsequent drawing commands are            executed.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureBarrier() => _TextureBarrier();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureBarrierNV() => _TextureBarrierNV();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureBuffer(uint texture, InternalFormat internalformat, uint buffer) => _TextureBuffer(texture, internalformat, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureBufferEXT(uint texture, TextureTarget target, InternalFormat internalformat, uint buffer) => _TextureBufferEXT(texture, target, internalformat, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureBufferRange(uint texture, InternalFormat internalformat, uint buffer, IntPtr offset, IntPtr size) => _TextureBufferRange(texture, internalformat, buffer, offset, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureBufferRangeEXT(uint texture, TextureTarget target, InternalFormat internalformat, uint buffer, IntPtr offset, IntPtr size) => _TextureBufferRangeEXT(texture, target, internalformat, buffer, offset, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureColorMaskSGIS(bool red, bool green, bool blue, bool alpha) => _TextureColorMaskSGIS(red, green, blue, alpha);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureFoveationParametersQCOM(uint texture, uint layer, uint focalPoint, float focalX, float focalY, float gainX, float gainY, float foveaArea) => _TextureFoveationParametersQCOM(texture, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureImage1DEXT(uint texture, TextureTarget target, int level, int internalformat, int width, int border, PixelFormat format, PixelType type, IntPtr pixels) => _TextureImage1DEXT(texture, target, level, internalformat, width, border, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureImage2DEXT(uint texture, TextureTarget target, int level, int internalformat, int width, int height, int border, PixelFormat format, PixelType type, IntPtr pixels) => _TextureImage2DEXT(texture, target, level, internalformat, width, height, border, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureImage2DMultisampleCoverageNV(uint texture, TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, bool fixedSampleLocations) => _TextureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureImage2DMultisampleNV(uint texture, TextureTarget target, int samples, int internalFormat, int width, int height, bool fixedSampleLocations) => _TextureImage2DMultisampleNV(texture, target, samples, internalFormat, width, height, fixedSampleLocations);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureImage3DEXT(uint texture, TextureTarget target, int level, int internalformat, int width, int height, int depth, int border, PixelFormat format, PixelType type, IntPtr pixels) => _TextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureImage3DMultisampleCoverageNV(uint texture, TextureTarget target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations) => _TextureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureImage3DMultisampleNV(uint texture, TextureTarget target, int samples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations) => _TextureImage3DMultisampleNV(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureLightEXT(LightTexturePNameEXT pname) => _TextureLightEXT(pname);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureMaterialEXT(MaterialFace face, MaterialParameter mode) => _TextureMaterialEXT(face, mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureNormalEXT(TextureNormalModeEXT mode) => _TextureNormalEXT(mode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TexturePageCommitmentEXT(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) => _TexturePageCommitmentEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterIiv(uint texture, TextureParameterName pname, int[] @params) => _TextureParameterIiv(texture, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterIiv(uint texture, TextureParameterName pname, void* @params) => _TextureParameterIiv_ptr(texture, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterIiv(uint texture, TextureParameterName pname, IntPtr @params) => _TextureParameterIiv_intptr(texture, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterIivEXT(uint texture, TextureTarget target, TextureParameterName pname, int[] @params) => _TextureParameterIivEXT(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterIivEXT(uint texture, TextureTarget target, TextureParameterName pname, void* @params) => _TextureParameterIivEXT_ptr(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterIivEXT(uint texture, TextureTarget target, TextureParameterName pname, IntPtr @params) => _TextureParameterIivEXT_intptr(texture, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterIuiv(uint texture, TextureParameterName pname, uint[] @params) => _TextureParameterIuiv(texture, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterIuiv(uint texture, TextureParameterName pname, void* @params) => _TextureParameterIuiv_ptr(texture, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterIuiv(uint texture, TextureParameterName pname, IntPtr @params) => _TextureParameterIuiv_intptr(texture, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterIuivEXT(uint texture, TextureTarget target, TextureParameterName pname, uint[] @params) => _TextureParameterIuivEXT(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterIuivEXT(uint texture, TextureTarget target, TextureParameterName pname, void* @params) => _TextureParameterIuivEXT_ptr(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterIuivEXT(uint texture, TextureTarget target, TextureParameterName pname, IntPtr @params) => _TextureParameterIuivEXT_intptr(texture, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterf(uint texture, TextureParameterName pname, float param) => _TextureParameterf(texture, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterfEXT(uint texture, TextureTarget target, TextureParameterName pname, float param) => _TextureParameterfEXT(texture, target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterfv(uint texture, TextureParameterName pname, float[] param) => _TextureParameterfv(texture, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterfv(uint texture, TextureParameterName pname, void* param) => _TextureParameterfv_ptr(texture, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterfv(uint texture, TextureParameterName pname, IntPtr param) => _TextureParameterfv_intptr(texture, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterfvEXT(uint texture, TextureTarget target, TextureParameterName pname, float[] @params) => _TextureParameterfvEXT(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterfvEXT(uint texture, TextureTarget target, TextureParameterName pname, void* @params) => _TextureParameterfvEXT_ptr(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterfvEXT(uint texture, TextureTarget target, TextureParameterName pname, IntPtr @params) => _TextureParameterfvEXT_intptr(texture, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameteri(uint texture, TextureParameterName pname, int param) => _TextureParameteri(texture, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameteriEXT(uint texture, TextureTarget target, TextureParameterName pname, int param) => _TextureParameteriEXT(texture, target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameteriv(uint texture, TextureParameterName pname, int[] param) => _TextureParameteriv(texture, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameteriv(uint texture, TextureParameterName pname, void* param) => _TextureParameteriv_ptr(texture, pname, param);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameteriv(uint texture, TextureParameterName pname, IntPtr param) => _TextureParameteriv_intptr(texture, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterivEXT(uint texture, TextureTarget target, TextureParameterName pname, int[] @params) => _TextureParameterivEXT(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterivEXT(uint texture, TextureTarget target, TextureParameterName pname, void* @params) => _TextureParameterivEXT_ptr(texture, target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureParameterivEXT(uint texture, TextureTarget target, TextureParameterName pname, IntPtr @params) => _TextureParameterivEXT_intptr(texture, target, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureRangeAPPLE(int target, int length, IntPtr pointer) => _TextureRangeAPPLE(target, length, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureRenderbufferEXT(uint texture, TextureTarget target, uint renderbuffer) => _TextureRenderbufferEXT(texture, target, renderbuffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorage1D(uint texture, int levels, InternalFormat internalformat, int width) => _TextureStorage1D(texture, levels, internalformat, width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorage1DEXT(uint texture, int target, int levels, InternalFormat internalformat, int width) => _TextureStorage1DEXT(texture, target, levels, internalformat, width);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorage2D(uint texture, int levels, InternalFormat internalformat, int width, int height) => _TextureStorage2D(texture, levels, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorage2DEXT(uint texture, int target, int levels, InternalFormat internalformat, int width, int height) => _TextureStorage2DEXT(texture, target, levels, internalformat, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorage2DMultisample(uint texture, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations) => _TextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorage2DMultisampleEXT(uint texture, TextureTarget target, int samples, InternalFormat internalformat, int width, int height, bool fixedsamplelocations) => _TextureStorage2DMultisampleEXT(texture, target, samples, internalformat, width, height, fixedsamplelocations);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorage3D(uint texture, int levels, InternalFormat internalformat, int width, int height, int depth) => _TextureStorage3D(texture, levels, internalformat, width, height, depth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorage3DEXT(uint texture, int target, int levels, InternalFormat internalformat, int width, int height, int depth) => _TextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorage3DMultisample(uint texture, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => _TextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorage3DMultisampleEXT(uint texture, int target, int samples, InternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations) => _TextureStorage3DMultisampleEXT(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorageMem1DEXT(uint texture, int levels, int internalFormat, int width, uint memory, UInt64 offset) => _TextureStorageMem1DEXT(texture, levels, internalFormat, width, memory, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorageMem2DEXT(uint texture, int levels, int internalFormat, int width, int height, uint memory, UInt64 offset) => _TextureStorageMem2DEXT(texture, levels, internalFormat, width, height, memory, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorageMem2DMultisampleEXT(uint texture, int samples, int internalFormat, int width, int height, bool fixedSampleLocations, uint memory, UInt64 offset) => _TextureStorageMem2DMultisampleEXT(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorageMem3DEXT(uint texture, int levels, int internalFormat, int width, int height, int depth, uint memory, UInt64 offset) => _TextureStorageMem3DEXT(texture, levels, internalFormat, width, height, depth, memory, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorageMem3DMultisampleEXT(uint texture, int samples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, UInt64 offset) => _TextureStorageMem3DMultisampleEXT(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureStorageSparseAMD(uint texture, int target, InternalFormat internalFormat, int width, int height, int depth, int layers, int flags) => _TextureStorageSparseAMD(texture, target, internalFormat, width, height, depth, layers, flags);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureSubImage1D(uint texture, int level, int xoffset, int width, PixelFormat format, PixelType type, IntPtr pixels) => _TextureSubImage1D(texture, level, xoffset, width, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureSubImage1DEXT(uint texture, TextureTarget target, int level, int xoffset, int width, PixelFormat format, PixelType type, IntPtr pixels) => _TextureSubImage1DEXT(texture, target, level, xoffset, width, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, IntPtr pixels) => _TextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureSubImage2DEXT(uint texture, TextureTarget target, int level, int xoffset, int yoffset, int width, int height, PixelFormat format, PixelType type, IntPtr pixels) => _TextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels) => _TextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureSubImage3DEXT(uint texture, TextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, PixelFormat format, PixelType type, IntPtr pixels) => _TextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);

        // ---

        /// <summary>
        /// glTextureView initializes a texture object as an            alias, or view of another texture object, sharing some or all of the            parent texture's data store with the initialized texture. texture            specifies a name previously reserved by a successful call to glGenTextures            but that has not yet been bound or given a target. target            specifies the target for the newly initialized texture and must be compatible            with the target of the parent texture, given in origtexture            as specified in the following table:
        /// Original TargetCompatible New TargetsGL_TEXTURE_1DGL_TEXTURE_1D, GL_TEXTURE_1D_ARRAYGL_TEXTURE_2DGL_TEXTURE_2D, GL_TEXTURE_2D_ARRAYGL_TEXTURE_3DGL_TEXTURE_3DGL_TEXTURE_CUBE_MAPGL_TEXTURE_CUBE_MAP, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAYGL_TEXTURE_RECTANGLEGL_TEXTURE_RECTANGLEGL_TEXTURE_BUFFERnoneGL_TEXTURE_1D_ARRAYGL_TEXTURE_1D, GL_TEXTURE_1D_ARRAYGL_TEXTURE_2D_ARRAYGL_TEXTURE_2D, GL_TEXTURE_2D_ARRAYGL_TEXTURE_CUBE_MAP_ARRAYGL_TEXTURE_CUBE_MAP, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAYGL_TEXTURE_2D_MULTISAMPLEGL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_MULTISAMPLE_ARRAYGL_TEXTURE_2D_MULTISAMPLE_ARRAYGL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_MULTISAMPLE_ARRAY
        /// The value of GL_TEXTURE_IMMUTABLE_FORMAT for origtexture            must be GL_TRUE.            After initialization, texture inherits the data store of            the parent texture, origtexture and is usable as a normal            texture object with target target. Data in the shared store            is reinterpreted with the new internal format specified by internalformat.            internalformat must be compatible with the internal format            of the parent texture as specified in the following table:
        /// ClassInternal Formats128-bitGL_RGBA32F, GL_RGBA32UI, GL_RGBA32I96-bitGL_RGB32F, GL_RGB32UI, GL_RGB32I64-bitGL_RGBA16F, GL_RG32F, GL_RGBA16UI,                        GL_RG32UI, GL_RGBA16I, GL_RG32I, GL_RGBA16, GL_RGBA16_SNORM48-bitGL_RGB16, GL_RGB16_SNORM, GL_RGB16F, GL_RGB16UI, GL_RGB16I32-bitGL_RG16F, GL_R11F_G11F_B10F, GL_R32F, GL_RGB10_A2UI,                                            GL_RGBA8UI, GL_RG16UI, GL_R32UI, GL_RGBA8I,                                            GL_RG16I, GL_R32I, GL_RGB10_A2, GL_RGBA8,                                            GL_RG16, GL_RGBA8_SNORM, GL_RG16_SNORM, GL_SRGB8_ALPHA8,                                            GL_RGB9_E524-bitGL_RGB8, GL_RGB8_SNORM, GL_SRGB8,                                            GL_RGB8UI, GL_RGB8I16-bitGL_R16F, GL_RG8UI, GL_R16UI, GL_RG8I,                                            GL_R16I, GL_RG8, GL_R16, GL_RG8_SNORM, GL_R16_SNORM8-bitGL_R8UI, GL_R8I, GL_R8, GL_R8_SNORMGL_RGTC1_REDGL_COMPRESSED_RED_RGTC1, GL_COMPRESSED_SIGNED_RED_RGTC1GL_RGTC2_RGGL_COMPRESSED_RG_RGTC2, GL_COMPRESSED_SIGNED_RG_RGTC2GL_BPTC_UNORMGL_COMPRESSED_RGBA_BPTC_UNORM, GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORMGL_BPTC_FLOATGL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT, GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT
        /// If the original texture is an array or has multiple mipmap levels,            the parameters minlayer, numlayers, minlevel, and numlevels            control which of those slices and levels are considered part of the texture.            The minlevel and minlayer parameters are relative to the view of the            original texture. If numlayers or numlevels extend beyond the original            texture, they are clamped to the max extent of the original texture.
        /// If the new texture's target is GL_TEXTURE_CUBE_MAP, the clamped numlayers            must be equal to 6. If the new texture's target is GL_TEXTURE_CUBE_MAP_ARRAY,            then numlayers counts layer-faces rather than layers, and the clamped            numlayers must be a multiple of 6. If the new texture's target is GL_TEXTURE_CUBE_MAP or            GL_TEXTURE_CUBE_MAP_ARRAY, the width and height of the original texture's            levels must be equal.
        /// When the original texture's target is GL_TEXTURE_CUBE_MAP, the layer            parameters are interpreted in the same order as if it were a            GL_TEXTURE_CUBE_MAP_ARRAY with 6 layer-faces.
        /// If target is GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, or            GL_TEXTURE_2D_MULTISAMPLE, numlayers must equal 1.
        /// The dimensions of the original texture must be less than or equal to the maximum            supported dimensions of the new target. For example, if the original texture has a GL_TEXTURE_2D_ARRAY            target and its width is greater than GL_MAX_CUBE_MAP_TEXTURE_SIZE, an error            will be generated if glTextureView is called to create a GL_TEXTURE_CUBE_MAP            view.
        /// Texture commands that take a level or layer parameter, such as            glTexSubImage2D, interpret that parameter to be relative to the view of the            texture. i.e. the mipmap level of the data store that would be updated via            glTexSubImage2D would be the sum of level and the value of            GL_TEXTURE_VIEW_MIN_LEVEL.
        /// </summary>
        /// <param name="texture">Specifies the texture object to be initialized as a view.</param>
        /// <param name="target">Specifies the target to be used for the newly initialized texture.</param>
        /// <param name="origtexture">Specifies the name of a texture object of which to make a view.</param>
        /// <param name="internalformat">Specifies the internal format for the newly created view.</param>
        /// <param name="minlevel">Specifies lowest level of detail of the view.</param>
        /// <param name="numlevels">Specifies the number of levels of detail to include in the view.</param>
        /// <param name="minlayer">Specifies the index of the first layer to include in the view.</param>
        /// <param name="numlayers">Specifies the number of layers to include in the view.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureView(uint texture, TextureTarget target, uint origtexture, InternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) => _TextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureViewEXT(uint texture, TextureTarget target, uint origtexture, InternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) => _TextureViewEXT(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TextureViewOES(uint texture, TextureTarget target, uint origtexture, InternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) => _TextureViewOES(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TrackMatrixNV(VertexAttribEnumNV target, uint address, VertexAttribEnumNV matrix, VertexAttribEnumNV transform) => _TrackMatrixNV(target, address, matrix, transform);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackAttribsNV(int count, int[] attribs, int bufferMode) => _TransformFeedbackAttribsNV(count, attribs, bufferMode);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackAttribsNV(int count, void* attribs, int bufferMode) => _TransformFeedbackAttribsNV_ptr(count, attribs, bufferMode);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackAttribsNV(int count, IntPtr attribs, int bufferMode) => _TransformFeedbackAttribsNV_intptr(count, attribs, bufferMode);

        // ---

        /// <summary>
        /// glTransformFeedbackBufferBase binds the            buffer object buffer to the binding point            at index index of the transform feedback            object xfb.
        /// </summary>
        /// <param name="xfb">Name of the transform feedback buffer object.</param>
        /// <param name="index">Index of the binding point within                        xfb.</param>
        /// <param name="buffer">Name of the buffer object to bind to the specified                        binding point.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackBufferBase(uint xfb, uint index, uint buffer) => _TransformFeedbackBufferBase(xfb, index, buffer);

        // ---

        /// <summary>
        /// glTransformFeedbackBufferRange             binds a range of the buffer object buffer            represented by offset and            size to the binding point at index            index of the transform feedback object            xfb.
        /// offset specifies the offset in basic            machine units into the buffer object            buffer and size            specifies the amount of data that can be read from the buffer            object while used as an indexed target.
        /// </summary>
        /// <param name="xfb">Name of the transform feedback buffer object.</param>
        /// <param name="index">Index of the binding point within                        xfb.</param>
        /// <param name="buffer">Name of the buffer object to bind to the specified                        binding point.</param>
        /// <param name="offset">The starting offset in basic machine units into the                        buffer object.</param>
        /// <param name="size">The amount of data in basic machine units that can                        be read from or written to the buffer object while                        used as an indexed target.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackBufferRange(uint xfb, uint index, uint buffer, IntPtr offset, IntPtr size) => _TransformFeedbackBufferRange(xfb, index, buffer, offset, size);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackStreamAttribsNV(int count, int[] attribs, int nbuffers, int[] bufstreams, int bufferMode) => _TransformFeedbackStreamAttribsNV(count, attribs, nbuffers, bufstreams, bufferMode);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackStreamAttribsNV(int count, void* attribs, int nbuffers, void* bufstreams, int bufferMode) => _TransformFeedbackStreamAttribsNV_ptr(count, attribs, nbuffers, bufstreams, bufferMode);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackStreamAttribsNV(int count, IntPtr attribs, int nbuffers, IntPtr bufstreams, int bufferMode) => _TransformFeedbackStreamAttribsNV_intptr(count, attribs, nbuffers, bufstreams, bufferMode);

        // ---

        /// <summary>
        /// The names of the vertex or geometry shader outputs to be recorded in transform feedback mode            are specified using glTransformFeedbackVaryings. When a geometry shader            is active, transform feedback records the values of selected geometry shader output variables            from the emitted vertices. Otherwise, the values of the selected vertex shader outputs are            recorded.
        /// The state set by glTranformFeedbackVaryings is stored and takes effect            next time glLinkProgram is called            on program. When glLinkProgram            is called, program is linked so that the values of the specified varying variables            for the vertices of each primitive generated by the GL are written to a single buffer            object if bufferMode is GL_INTERLEAVED_ATTRIBS or multiple            buffer objects if bufferMode is GL_SEPARATE_ATTRIBS.
        /// glTransformFeedbackVaryings can also special identifiers if                bufferMode is            GL_INTERLEAVED_ATTRIBS:
        /// gl_NextBufferSubsequent variables in varyings will be assigned                        to the next buffer binding point.gl_SkipComponents#Where # may be 1, 2, 3, or 4. The variable is treated as having this                        number of components, but the contents of the memory are preserved under                        feedback operations.
        /// In addition to the errors generated by glTransformFeedbackVaryings, the            program program will fail to link if:                                    The count specified by glTransformFeedbackVaryings is non-zero, but the                        program object has no vertex or geometry shader.                                            Any variable name specified in the varyings array is not declared as an output                        in the vertex shader (or the geometry shader, if active), or is not                        one of the special identifiers listed above.                                            Special identifiers appear in a varyings array where                        bufferMode is not GL_INTERLEAVED_ATTRIBS.                                            Any two entries in the varyings array, which are not one of the special varyings above,                        specify the same varying variable.                                            Discounting any special identifiers, the total number of components to capture in any                        varying variable in varyings is greater than the constant GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS                        and the buffer mode is GL_SEPARATE_ATTRIBS.                                             The total number of components to capture is greater than the constant                        GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS and the buffer                        mode is GL_INTERLEAVED_ATTRIBS.
        /// </summary>
        /// <param name="program">The name of the target program object.</param>
        /// <param name="count">The number of varying variables used for transform feedback.</param>
        /// <param name="varyings">An array of count zero-terminated strings specifying the                    names of the varying variables to use for transform feedback.</param>
        /// <param name="bufferMode">Identifies the mode used to capture the varying variables when transform feedback is active.                    bufferMode must be GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackVaryings(uint program, int count, string[] varyings, TransformFeedbackBufferMode bufferMode) => _TransformFeedbackVaryings(program, count, varyings, bufferMode);

        /// <summary>
        /// The names of the vertex or geometry shader outputs to be recorded in transform feedback mode            are specified using glTransformFeedbackVaryings. When a geometry shader            is active, transform feedback records the values of selected geometry shader output variables            from the emitted vertices. Otherwise, the values of the selected vertex shader outputs are            recorded.
        /// The state set by glTranformFeedbackVaryings is stored and takes effect            next time glLinkProgram is called            on program. When glLinkProgram            is called, program is linked so that the values of the specified varying variables            for the vertices of each primitive generated by the GL are written to a single buffer            object if bufferMode is GL_INTERLEAVED_ATTRIBS or multiple            buffer objects if bufferMode is GL_SEPARATE_ATTRIBS.
        /// glTransformFeedbackVaryings can also special identifiers if                bufferMode is            GL_INTERLEAVED_ATTRIBS:
        /// gl_NextBufferSubsequent variables in varyings will be assigned                        to the next buffer binding point.gl_SkipComponents#Where # may be 1, 2, 3, or 4. The variable is treated as having this                        number of components, but the contents of the memory are preserved under                        feedback operations.
        /// In addition to the errors generated by glTransformFeedbackVaryings, the            program program will fail to link if:                                    The count specified by glTransformFeedbackVaryings is non-zero, but the                        program object has no vertex or geometry shader.                                            Any variable name specified in the varyings array is not declared as an output                        in the vertex shader (or the geometry shader, if active), or is not                        one of the special identifiers listed above.                                            Special identifiers appear in a varyings array where                        bufferMode is not GL_INTERLEAVED_ATTRIBS.                                            Any two entries in the varyings array, which are not one of the special varyings above,                        specify the same varying variable.                                            Discounting any special identifiers, the total number of components to capture in any                        varying variable in varyings is greater than the constant GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS                        and the buffer mode is GL_SEPARATE_ATTRIBS.                                             The total number of components to capture is greater than the constant                        GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS and the buffer                        mode is GL_INTERLEAVED_ATTRIBS.
        /// </summary>
        /// <param name="program">The name of the target program object.</param>
        /// <param name="count">The number of varying variables used for transform feedback.</param>
        /// <param name="varyings">An array of count zero-terminated strings specifying the                    names of the varying variables to use for transform feedback.</param>
        /// <param name="bufferMode">Identifies the mode used to capture the varying variables when transform feedback is active.                    bufferMode must be GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackVaryings(uint program, int count, void* varyings, TransformFeedbackBufferMode bufferMode) => _TransformFeedbackVaryings_ptr(program, count, varyings, bufferMode);

        /// <summary>
        /// The names of the vertex or geometry shader outputs to be recorded in transform feedback mode            are specified using glTransformFeedbackVaryings. When a geometry shader            is active, transform feedback records the values of selected geometry shader output variables            from the emitted vertices. Otherwise, the values of the selected vertex shader outputs are            recorded.
        /// The state set by glTranformFeedbackVaryings is stored and takes effect            next time glLinkProgram is called            on program. When glLinkProgram            is called, program is linked so that the values of the specified varying variables            for the vertices of each primitive generated by the GL are written to a single buffer            object if bufferMode is GL_INTERLEAVED_ATTRIBS or multiple            buffer objects if bufferMode is GL_SEPARATE_ATTRIBS.
        /// glTransformFeedbackVaryings can also special identifiers if                bufferMode is            GL_INTERLEAVED_ATTRIBS:
        /// gl_NextBufferSubsequent variables in varyings will be assigned                        to the next buffer binding point.gl_SkipComponents#Where # may be 1, 2, 3, or 4. The variable is treated as having this                        number of components, but the contents of the memory are preserved under                        feedback operations.
        /// In addition to the errors generated by glTransformFeedbackVaryings, the            program program will fail to link if:                                    The count specified by glTransformFeedbackVaryings is non-zero, but the                        program object has no vertex or geometry shader.                                            Any variable name specified in the varyings array is not declared as an output                        in the vertex shader (or the geometry shader, if active), or is not                        one of the special identifiers listed above.                                            Special identifiers appear in a varyings array where                        bufferMode is not GL_INTERLEAVED_ATTRIBS.                                            Any two entries in the varyings array, which are not one of the special varyings above,                        specify the same varying variable.                                            Discounting any special identifiers, the total number of components to capture in any                        varying variable in varyings is greater than the constant GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS                        and the buffer mode is GL_SEPARATE_ATTRIBS.                                             The total number of components to capture is greater than the constant                        GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS and the buffer                        mode is GL_INTERLEAVED_ATTRIBS.
        /// </summary>
        /// <param name="program">The name of the target program object.</param>
        /// <param name="count">The number of varying variables used for transform feedback.</param>
        /// <param name="varyings">An array of count zero-terminated strings specifying the                    names of the varying variables to use for transform feedback.</param>
        /// <param name="bufferMode">Identifies the mode used to capture the varying variables when transform feedback is active.                    bufferMode must be GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackVaryings(uint program, int count, IntPtr varyings, TransformFeedbackBufferMode bufferMode) => _TransformFeedbackVaryings_intptr(program, count, varyings, bufferMode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackVaryingsEXT(uint program, int count, string[] varyings, int bufferMode) => _TransformFeedbackVaryingsEXT(program, count, varyings, bufferMode);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackVaryingsEXT(uint program, int count, void* varyings, int bufferMode) => _TransformFeedbackVaryingsEXT_ptr(program, count, varyings, bufferMode);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackVaryingsEXT(uint program, int count, IntPtr varyings, int bufferMode) => _TransformFeedbackVaryingsEXT_intptr(program, count, varyings, bufferMode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackVaryingsNV(uint program, int count, int[] locations, int bufferMode) => _TransformFeedbackVaryingsNV(program, count, locations, bufferMode);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackVaryingsNV(uint program, int count, void* locations, int bufferMode) => _TransformFeedbackVaryingsNV_ptr(program, count, locations, bufferMode);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformFeedbackVaryingsNV(uint program, int count, IntPtr locations, int bufferMode) => _TransformFeedbackVaryingsNV_intptr(program, count, locations, bufferMode);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformPathNV(uint resultPath, uint srcPath, PathTransformType transformType, float[] transformValues) => _TransformPathNV(resultPath, srcPath, transformType, transformValues);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformPathNV(uint resultPath, uint srcPath, PathTransformType transformType, void* transformValues) => _TransformPathNV_ptr(resultPath, srcPath, transformType, transformValues);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TransformPathNV(uint resultPath, uint srcPath, PathTransformType transformType, IntPtr transformValues) => _TransformPathNV_intptr(resultPath, srcPath, transformType, transformValues);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Translated(double x, double y, double z) => _Translated(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Translatef(float x, float y, float z) => _Translatef(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Translatex(float x, float y, float z) => _Translatex(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void TranslatexOES(float x, float y, float z) => _TranslatexOES(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1d(int location, double x) => _Uniform1d(location, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1dv(int location, int count, double[] value) => _Uniform1dv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1dv(int location, int count, void* value) => _Uniform1dv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1dv(int location, int count, IntPtr value) => _Uniform1dv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1f(int location, float v0) => _Uniform1f(location, v0);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1fARB(int location, float v0) => _Uniform1fARB(location, v0);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1fv(int location, int count, float[] value) => _Uniform1fv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1fv(int location, int count, void* value) => _Uniform1fv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1fv(int location, int count, IntPtr value) => _Uniform1fv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1fvARB(int location, int count, float[] value) => _Uniform1fvARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1fvARB(int location, int count, void* value) => _Uniform1fvARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1fvARB(int location, int count, IntPtr value) => _Uniform1fvARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1i(int location, int v0) => _Uniform1i(location, v0);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1i64ARB(int location, Int64 x) => _Uniform1i64ARB(location, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1i64NV(int location, Int64 x) => _Uniform1i64NV(location, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1i64vARB(int location, int count, Int64[] value) => _Uniform1i64vARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1i64vARB(int location, int count, void* value) => _Uniform1i64vARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1i64vARB(int location, int count, IntPtr value) => _Uniform1i64vARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1i64vNV(int location, int count, Int64[] value) => _Uniform1i64vNV(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1i64vNV(int location, int count, void* value) => _Uniform1i64vNV_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1i64vNV(int location, int count, IntPtr value) => _Uniform1i64vNV_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1iARB(int location, int v0) => _Uniform1iARB(location, v0);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1iv(int location, int count, int[] value) => _Uniform1iv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1iv(int location, int count, void* value) => _Uniform1iv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1iv(int location, int count, IntPtr value) => _Uniform1iv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1ivARB(int location, int count, int[] value) => _Uniform1ivARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1ivARB(int location, int count, void* value) => _Uniform1ivARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1ivARB(int location, int count, IntPtr value) => _Uniform1ivARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1ui(int location, uint v0) => _Uniform1ui(location, v0);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1ui64ARB(int location, UInt64 x) => _Uniform1ui64ARB(location, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1ui64NV(int location, UInt64 x) => _Uniform1ui64NV(location, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1ui64vARB(int location, int count, UInt64[] value) => _Uniform1ui64vARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1ui64vARB(int location, int count, void* value) => _Uniform1ui64vARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1ui64vARB(int location, int count, IntPtr value) => _Uniform1ui64vARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1ui64vNV(int location, int count, UInt64[] value) => _Uniform1ui64vNV(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1ui64vNV(int location, int count, void* value) => _Uniform1ui64vNV_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1ui64vNV(int location, int count, IntPtr value) => _Uniform1ui64vNV_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1uiEXT(int location, uint v0) => _Uniform1uiEXT(location, v0);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1uiv(int location, int count, uint[] value) => _Uniform1uiv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1uiv(int location, int count, void* value) => _Uniform1uiv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1uiv(int location, int count, IntPtr value) => _Uniform1uiv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1uivEXT(int location, int count, uint[] value) => _Uniform1uivEXT(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1uivEXT(int location, int count, void* value) => _Uniform1uivEXT_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform1uivEXT(int location, int count, IntPtr value) => _Uniform1uivEXT_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2d(int location, double x, double y) => _Uniform2d(location, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2dv(int location, int count, double[] value) => _Uniform2dv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2dv(int location, int count, void* value) => _Uniform2dv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2dv(int location, int count, IntPtr value) => _Uniform2dv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2f(int location, float v0, float v1) => _Uniform2f(location, v0, v1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2fARB(int location, float v0, float v1) => _Uniform2fARB(location, v0, v1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2fv(int location, int count, float[] value) => _Uniform2fv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2fv(int location, int count, void* value) => _Uniform2fv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2fv(int location, int count, IntPtr value) => _Uniform2fv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2fvARB(int location, int count, float[] value) => _Uniform2fvARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2fvARB(int location, int count, void* value) => _Uniform2fvARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2fvARB(int location, int count, IntPtr value) => _Uniform2fvARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2i(int location, int v0, int v1) => _Uniform2i(location, v0, v1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2i64ARB(int location, Int64 x, Int64 y) => _Uniform2i64ARB(location, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2i64NV(int location, Int64 x, Int64 y) => _Uniform2i64NV(location, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2i64vARB(int location, int count, Int64[] value) => _Uniform2i64vARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2i64vARB(int location, int count, void* value) => _Uniform2i64vARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2i64vARB(int location, int count, IntPtr value) => _Uniform2i64vARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2i64vNV(int location, int count, Int64[] value) => _Uniform2i64vNV(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2i64vNV(int location, int count, void* value) => _Uniform2i64vNV_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2i64vNV(int location, int count, IntPtr value) => _Uniform2i64vNV_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2iARB(int location, int v0, int v1) => _Uniform2iARB(location, v0, v1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2iv(int location, int count, int[] value) => _Uniform2iv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2iv(int location, int count, void* value) => _Uniform2iv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2iv(int location, int count, IntPtr value) => _Uniform2iv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2ivARB(int location, int count, int[] value) => _Uniform2ivARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2ivARB(int location, int count, void* value) => _Uniform2ivARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2ivARB(int location, int count, IntPtr value) => _Uniform2ivARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2ui(int location, uint v0, uint v1) => _Uniform2ui(location, v0, v1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2ui64ARB(int location, UInt64 x, UInt64 y) => _Uniform2ui64ARB(location, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2ui64NV(int location, UInt64 x, UInt64 y) => _Uniform2ui64NV(location, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2ui64vARB(int location, int count, UInt64[] value) => _Uniform2ui64vARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2ui64vARB(int location, int count, void* value) => _Uniform2ui64vARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2ui64vARB(int location, int count, IntPtr value) => _Uniform2ui64vARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2ui64vNV(int location, int count, UInt64[] value) => _Uniform2ui64vNV(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2ui64vNV(int location, int count, void* value) => _Uniform2ui64vNV_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2ui64vNV(int location, int count, IntPtr value) => _Uniform2ui64vNV_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2uiEXT(int location, uint v0, uint v1) => _Uniform2uiEXT(location, v0, v1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2uiv(int location, int count, uint[] value) => _Uniform2uiv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2uiv(int location, int count, void* value) => _Uniform2uiv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2uiv(int location, int count, IntPtr value) => _Uniform2uiv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2uivEXT(int location, int count, uint[] value) => _Uniform2uivEXT(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2uivEXT(int location, int count, void* value) => _Uniform2uivEXT_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform2uivEXT(int location, int count, IntPtr value) => _Uniform2uivEXT_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3d(int location, double x, double y, double z) => _Uniform3d(location, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3dv(int location, int count, double[] value) => _Uniform3dv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3dv(int location, int count, void* value) => _Uniform3dv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3dv(int location, int count, IntPtr value) => _Uniform3dv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3f(int location, float v0, float v1, float v2) => _Uniform3f(location, v0, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3fARB(int location, float v0, float v1, float v2) => _Uniform3fARB(location, v0, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3fv(int location, int count, float[] value) => _Uniform3fv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3fv(int location, int count, void* value) => _Uniform3fv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3fv(int location, int count, IntPtr value) => _Uniform3fv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3fvARB(int location, int count, float[] value) => _Uniform3fvARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3fvARB(int location, int count, void* value) => _Uniform3fvARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3fvARB(int location, int count, IntPtr value) => _Uniform3fvARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3i(int location, int v0, int v1, int v2) => _Uniform3i(location, v0, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3i64ARB(int location, Int64 x, Int64 y, Int64 z) => _Uniform3i64ARB(location, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3i64NV(int location, Int64 x, Int64 y, Int64 z) => _Uniform3i64NV(location, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3i64vARB(int location, int count, Int64[] value) => _Uniform3i64vARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3i64vARB(int location, int count, void* value) => _Uniform3i64vARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3i64vARB(int location, int count, IntPtr value) => _Uniform3i64vARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3i64vNV(int location, int count, Int64[] value) => _Uniform3i64vNV(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3i64vNV(int location, int count, void* value) => _Uniform3i64vNV_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3i64vNV(int location, int count, IntPtr value) => _Uniform3i64vNV_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3iARB(int location, int v0, int v1, int v2) => _Uniform3iARB(location, v0, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3iv(int location, int count, int[] value) => _Uniform3iv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3iv(int location, int count, void* value) => _Uniform3iv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3iv(int location, int count, IntPtr value) => _Uniform3iv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3ivARB(int location, int count, int[] value) => _Uniform3ivARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3ivARB(int location, int count, void* value) => _Uniform3ivARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3ivARB(int location, int count, IntPtr value) => _Uniform3ivARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3ui(int location, uint v0, uint v1, uint v2) => _Uniform3ui(location, v0, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3ui64ARB(int location, UInt64 x, UInt64 y, UInt64 z) => _Uniform3ui64ARB(location, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3ui64NV(int location, UInt64 x, UInt64 y, UInt64 z) => _Uniform3ui64NV(location, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3ui64vARB(int location, int count, UInt64[] value) => _Uniform3ui64vARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3ui64vARB(int location, int count, void* value) => _Uniform3ui64vARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3ui64vARB(int location, int count, IntPtr value) => _Uniform3ui64vARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3ui64vNV(int location, int count, UInt64[] value) => _Uniform3ui64vNV(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3ui64vNV(int location, int count, void* value) => _Uniform3ui64vNV_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3ui64vNV(int location, int count, IntPtr value) => _Uniform3ui64vNV_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3uiEXT(int location, uint v0, uint v1, uint v2) => _Uniform3uiEXT(location, v0, v1, v2);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3uiv(int location, int count, uint[] value) => _Uniform3uiv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3uiv(int location, int count, void* value) => _Uniform3uiv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3uiv(int location, int count, IntPtr value) => _Uniform3uiv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3uivEXT(int location, int count, uint[] value) => _Uniform3uivEXT(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3uivEXT(int location, int count, void* value) => _Uniform3uivEXT_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform3uivEXT(int location, int count, IntPtr value) => _Uniform3uivEXT_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4d(int location, double x, double y, double z, double w) => _Uniform4d(location, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4dv(int location, int count, double[] value) => _Uniform4dv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4dv(int location, int count, void* value) => _Uniform4dv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4dv(int location, int count, IntPtr value) => _Uniform4dv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4f(int location, float v0, float v1, float v2, float v3) => _Uniform4f(location, v0, v1, v2, v3);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4fARB(int location, float v0, float v1, float v2, float v3) => _Uniform4fARB(location, v0, v1, v2, v3);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4fv(int location, int count, float[] value) => _Uniform4fv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4fv(int location, int count, void* value) => _Uniform4fv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4fv(int location, int count, IntPtr value) => _Uniform4fv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4fvARB(int location, int count, float[] value) => _Uniform4fvARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4fvARB(int location, int count, void* value) => _Uniform4fvARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4fvARB(int location, int count, IntPtr value) => _Uniform4fvARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4i(int location, int v0, int v1, int v2, int v3) => _Uniform4i(location, v0, v1, v2, v3);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4i64ARB(int location, Int64 x, Int64 y, Int64 z, Int64 w) => _Uniform4i64ARB(location, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4i64NV(int location, Int64 x, Int64 y, Int64 z, Int64 w) => _Uniform4i64NV(location, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4i64vARB(int location, int count, Int64[] value) => _Uniform4i64vARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4i64vARB(int location, int count, void* value) => _Uniform4i64vARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4i64vARB(int location, int count, IntPtr value) => _Uniform4i64vARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4i64vNV(int location, int count, Int64[] value) => _Uniform4i64vNV(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4i64vNV(int location, int count, void* value) => _Uniform4i64vNV_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4i64vNV(int location, int count, IntPtr value) => _Uniform4i64vNV_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4iARB(int location, int v0, int v1, int v2, int v3) => _Uniform4iARB(location, v0, v1, v2, v3);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4iv(int location, int count, int[] value) => _Uniform4iv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4iv(int location, int count, void* value) => _Uniform4iv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4iv(int location, int count, IntPtr value) => _Uniform4iv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4ivARB(int location, int count, int[] value) => _Uniform4ivARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4ivARB(int location, int count, void* value) => _Uniform4ivARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4ivARB(int location, int count, IntPtr value) => _Uniform4ivARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4ui(int location, uint v0, uint v1, uint v2, uint v3) => _Uniform4ui(location, v0, v1, v2, v3);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4ui64ARB(int location, UInt64 x, UInt64 y, UInt64 z, UInt64 w) => _Uniform4ui64ARB(location, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4ui64NV(int location, UInt64 x, UInt64 y, UInt64 z, UInt64 w) => _Uniform4ui64NV(location, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4ui64vARB(int location, int count, UInt64[] value) => _Uniform4ui64vARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4ui64vARB(int location, int count, void* value) => _Uniform4ui64vARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4ui64vARB(int location, int count, IntPtr value) => _Uniform4ui64vARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4ui64vNV(int location, int count, UInt64[] value) => _Uniform4ui64vNV(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4ui64vNV(int location, int count, void* value) => _Uniform4ui64vNV_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4ui64vNV(int location, int count, IntPtr value) => _Uniform4ui64vNV_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4uiEXT(int location, uint v0, uint v1, uint v2, uint v3) => _Uniform4uiEXT(location, v0, v1, v2, v3);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4uiv(int location, int count, uint[] value) => _Uniform4uiv(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4uiv(int location, int count, void* value) => _Uniform4uiv_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4uiv(int location, int count, IntPtr value) => _Uniform4uiv_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4uivEXT(int location, int count, uint[] value) => _Uniform4uivEXT(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4uivEXT(int location, int count, void* value) => _Uniform4uivEXT_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniform4uivEXT(int location, int count, IntPtr value) => _Uniform4uivEXT_intptr(location, count, value);

        // ---

        /// <summary>
        /// Binding points for active uniform blocks are assigned using glUniformBlockBinding. Each of a program's active uniform            blocks has a corresponding uniform buffer binding point. program is the name of a program object for which the command            glLinkProgram has been issued in the past.
        /// If successful, glUniformBlockBinding specifies that program will use the data store of the            buffer object bound to the binding point uniformBlockBinding to extract the values of the uniforms in the            uniform block identified by uniformBlockIndex.
        /// When a program object is linked or re-linked, the uniform buffer object binding point assigned to each of its active uniform blocks is reset to zero.
        /// </summary>
        /// <param name="program">The name of a program object containing the active uniform block whose binding to assign.</param>
        /// <param name="uniformBlockIndex">The index of the active uniform block within program whose binding to assign.</param>
        /// <param name="uniformBlockBinding">Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformBlockBinding(uint program, uint uniformBlockIndex, uint uniformBlockBinding) => _UniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformBufferEXT(uint program, int location, uint buffer) => _UniformBufferEXT(program, location, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformHandleui64ARB(int location, UInt64 value) => _UniformHandleui64ARB(location, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformHandleui64IMG(int location, UInt64 value) => _UniformHandleui64IMG(location, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformHandleui64NV(int location, UInt64 value) => _UniformHandleui64NV(location, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformHandleui64vARB(int location, int count, UInt64[] value) => _UniformHandleui64vARB(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformHandleui64vARB(int location, int count, void* value) => _UniformHandleui64vARB_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformHandleui64vARB(int location, int count, IntPtr value) => _UniformHandleui64vARB_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformHandleui64vIMG(int location, int count, UInt64[] value) => _UniformHandleui64vIMG(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformHandleui64vIMG(int location, int count, void* value) => _UniformHandleui64vIMG_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformHandleui64vIMG(int location, int count, IntPtr value) => _UniformHandleui64vIMG_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformHandleui64vNV(int location, int count, UInt64[] value) => _UniformHandleui64vNV(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformHandleui64vNV(int location, int count, void* value) => _UniformHandleui64vNV_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformHandleui64vNV(int location, int count, IntPtr value) => _UniformHandleui64vNV_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2dv(int location, int count, bool transpose, double[] value) => _UniformMatrix2dv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2dv(int location, int count, bool transpose, void* value) => _UniformMatrix2dv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2dv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix2dv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2fv(int location, int count, bool transpose, float[] value) => _UniformMatrix2fv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2fv(int location, int count, bool transpose, void* value) => _UniformMatrix2fv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2fv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix2fv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2fvARB(int location, int count, bool transpose, float[] value) => _UniformMatrix2fvARB(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2fvARB(int location, int count, bool transpose, void* value) => _UniformMatrix2fvARB_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2fvARB(int location, int count, bool transpose, IntPtr value) => _UniformMatrix2fvARB_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x3dv(int location, int count, bool transpose, double[] value) => _UniformMatrix2x3dv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x3dv(int location, int count, bool transpose, void* value) => _UniformMatrix2x3dv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x3dv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix2x3dv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x3fv(int location, int count, bool transpose, float[] value) => _UniformMatrix2x3fv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x3fv(int location, int count, bool transpose, void* value) => _UniformMatrix2x3fv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x3fv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix2x3fv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x3fvNV(int location, int count, bool transpose, float[] value) => _UniformMatrix2x3fvNV(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x3fvNV(int location, int count, bool transpose, void* value) => _UniformMatrix2x3fvNV_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x3fvNV(int location, int count, bool transpose, IntPtr value) => _UniformMatrix2x3fvNV_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x4dv(int location, int count, bool transpose, double[] value) => _UniformMatrix2x4dv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x4dv(int location, int count, bool transpose, void* value) => _UniformMatrix2x4dv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x4dv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix2x4dv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x4fv(int location, int count, bool transpose, float[] value) => _UniformMatrix2x4fv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x4fv(int location, int count, bool transpose, void* value) => _UniformMatrix2x4fv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x4fv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix2x4fv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x4fvNV(int location, int count, bool transpose, float[] value) => _UniformMatrix2x4fvNV(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x4fvNV(int location, int count, bool transpose, void* value) => _UniformMatrix2x4fvNV_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix2x4fvNV(int location, int count, bool transpose, IntPtr value) => _UniformMatrix2x4fvNV_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3dv(int location, int count, bool transpose, double[] value) => _UniformMatrix3dv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3dv(int location, int count, bool transpose, void* value) => _UniformMatrix3dv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3dv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix3dv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3fv(int location, int count, bool transpose, float[] value) => _UniformMatrix3fv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3fv(int location, int count, bool transpose, void* value) => _UniformMatrix3fv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3fv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix3fv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3fvARB(int location, int count, bool transpose, float[] value) => _UniformMatrix3fvARB(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3fvARB(int location, int count, bool transpose, void* value) => _UniformMatrix3fvARB_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3fvARB(int location, int count, bool transpose, IntPtr value) => _UniformMatrix3fvARB_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x2dv(int location, int count, bool transpose, double[] value) => _UniformMatrix3x2dv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x2dv(int location, int count, bool transpose, void* value) => _UniformMatrix3x2dv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x2dv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix3x2dv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x2fv(int location, int count, bool transpose, float[] value) => _UniformMatrix3x2fv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x2fv(int location, int count, bool transpose, void* value) => _UniformMatrix3x2fv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x2fv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix3x2fv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x2fvNV(int location, int count, bool transpose, float[] value) => _UniformMatrix3x2fvNV(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x2fvNV(int location, int count, bool transpose, void* value) => _UniformMatrix3x2fvNV_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x2fvNV(int location, int count, bool transpose, IntPtr value) => _UniformMatrix3x2fvNV_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x4dv(int location, int count, bool transpose, double[] value) => _UniformMatrix3x4dv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x4dv(int location, int count, bool transpose, void* value) => _UniformMatrix3x4dv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x4dv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix3x4dv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x4fv(int location, int count, bool transpose, float[] value) => _UniformMatrix3x4fv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x4fv(int location, int count, bool transpose, void* value) => _UniformMatrix3x4fv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x4fv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix3x4fv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x4fvNV(int location, int count, bool transpose, float[] value) => _UniformMatrix3x4fvNV(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x4fvNV(int location, int count, bool transpose, void* value) => _UniformMatrix3x4fvNV_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix3x4fvNV(int location, int count, bool transpose, IntPtr value) => _UniformMatrix3x4fvNV_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4dv(int location, int count, bool transpose, double[] value) => _UniformMatrix4dv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4dv(int location, int count, bool transpose, void* value) => _UniformMatrix4dv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4dv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix4dv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4fv(int location, int count, bool transpose, float[] value) => _UniformMatrix4fv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4fv(int location, int count, bool transpose, void* value) => _UniformMatrix4fv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4fv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix4fv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4fvARB(int location, int count, bool transpose, float[] value) => _UniformMatrix4fvARB(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4fvARB(int location, int count, bool transpose, void* value) => _UniformMatrix4fvARB_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4fvARB(int location, int count, bool transpose, IntPtr value) => _UniformMatrix4fvARB_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x2dv(int location, int count, bool transpose, double[] value) => _UniformMatrix4x2dv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x2dv(int location, int count, bool transpose, void* value) => _UniformMatrix4x2dv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x2dv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix4x2dv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x2fv(int location, int count, bool transpose, float[] value) => _UniformMatrix4x2fv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x2fv(int location, int count, bool transpose, void* value) => _UniformMatrix4x2fv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x2fv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix4x2fv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x2fvNV(int location, int count, bool transpose, float[] value) => _UniformMatrix4x2fvNV(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x2fvNV(int location, int count, bool transpose, void* value) => _UniformMatrix4x2fvNV_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x2fvNV(int location, int count, bool transpose, IntPtr value) => _UniformMatrix4x2fvNV_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x3dv(int location, int count, bool transpose, double[] value) => _UniformMatrix4x3dv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x3dv(int location, int count, bool transpose, void* value) => _UniformMatrix4x3dv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x3dv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix4x3dv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x3fv(int location, int count, bool transpose, float[] value) => _UniformMatrix4x3fv(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x3fv(int location, int count, bool transpose, void* value) => _UniformMatrix4x3fv_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x3fv(int location, int count, bool transpose, IntPtr value) => _UniformMatrix4x3fv_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x3fvNV(int location, int count, bool transpose, float[] value) => _UniformMatrix4x3fvNV(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x3fvNV(int location, int count, bool transpose, void* value) => _UniformMatrix4x3fvNV_ptr(location, count, transpose, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformMatrix4x3fvNV(int location, int count, bool transpose, IntPtr value) => _UniformMatrix4x3fvNV_intptr(location, count, transpose, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformSubroutinesuiv(ShaderType shadertype, int count, uint[] indices) => _UniformSubroutinesuiv(shadertype, count, indices);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformSubroutinesuiv(ShaderType shadertype, int count, void* indices) => _UniformSubroutinesuiv_ptr(shadertype, count, indices);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UniformSubroutinesuiv(ShaderType shadertype, int count, IntPtr indices) => _UniformSubroutinesuiv_intptr(shadertype, count, indices);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniformui64NV(int location, UInt64 value) => _Uniformui64NV(location, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniformui64vNV(int location, int count, UInt64[] value) => _Uniformui64vNV(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniformui64vNV(int location, int count, void* value) => _Uniformui64vNV_ptr(location, count, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Uniformui64vNV(int location, int count, IntPtr value) => _Uniformui64vNV_intptr(location, count, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnlockArraysEXT() => _UnlockArraysEXT();

        // ---

        /// <summary>
        /// glUnmapBuffer and            glUnmapNamedBuffer unmap (release) any            mapping of a specified buffer object into the client's address            space (see            glMapBufferRange            and            glMapBuffer).
        /// If a mapping is not unmapped before the corresponding buffer            object's data store is used by the GL, an error will be            generated by any GL command that attempts to dereference the            buffer object's data store, unless the buffer was successfully            mapped with GL_MAP_PERSISTENT_BIT (see            glMapBufferRange).            When a data store is unmapped, the mapped pointer becomes            invalid.
        /// glUnmapBuffer returns            GL_TRUE unless the data store contents have            become corrupt during the time the data store was mapped. This            can occur for system-specific reasons that affect the            availability of graphics memory, such as screen mode changes. In            such situations, GL_FALSE is returned and            the data store contents are undefined. An application must            detect this rare condition and reinitialize the data store.
        /// A buffer object's mapped data store is automatically unmapped            when the buffer object is deleted or its data store is recreated            with            glBufferData).
        /// </summary>
        /// <param name="target">Specifies the target to which the buffer object is bound                    for glUnmapBuffer, which must be                    one of the buffer binding targets in the following                    table:</param>
        /// <param name="buffer">Specifies the name of the buffer object for                    glUnmapNamedBuffer.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool UnmapBuffer(BufferTargetARB target) => _UnmapBuffer(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool UnmapBufferARB(BufferTargetARB target) => _UnmapBufferARB(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool UnmapBufferOES(int target) => _UnmapBufferOES(target);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool UnmapNamedBuffer(uint buffer) => _UnmapNamedBuffer(buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool UnmapNamedBufferEXT(uint buffer) => _UnmapNamedBufferEXT(buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnmapObjectBufferATI(uint buffer) => _UnmapObjectBufferATI(buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UnmapTexture2DINTEL(uint texture, int level) => _UnmapTexture2DINTEL(texture, level);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UpdateObjectBufferATI(uint buffer, uint offset, int size, IntPtr pointer, PreserveModeATI preserve) => _UpdateObjectBufferATI(buffer, offset, size, pointer, preserve);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UploadGpuMaskNVX(int mask) => _UploadGpuMaskNVX(mask);

        // ---

        /// <summary>
        /// glUseProgram installs the program        object specified by program as part of        current rendering state. One or more executables are created in        a program object by successfully attaching shader objects to it        with        glAttachShader,        successfully compiling the shader objects with        glCompileShader,        and successfully linking the program object with        glLinkProgram.
        /// A program object will contain an executable that will run        on the vertex processor if it contains one or more shader        objects of type GL_VERTEX_SHADER that have        been successfully compiled and linked. A program object will contain an        executable that will run on the geometry processor if it contains one or        more shader objects of type GL_GEOMETRY_SHADER that        have been successfully compiled and linked.        Similarly, a program object will contain an executable that will run on the        fragment processor if it contains one or more shader objects of type        GL_FRAGMENT_SHADER that have been        successfully compiled and linked.
        /// While a program object is in use, applications are free to        modify attached shader objects, compile attached shader objects,        attach additional shader objects, and detach or delete shader        objects. None of these operations will affect the executables        that are part of the current state. However, relinking the        program object that is currently in use will install the program        object as part of the current rendering state if the link        operation was successful (see        glLinkProgram        ). If the program object currently in use is relinked        unsuccessfully, its link status will be set to        GL_FALSE, but the executables and        associated state will remain part of the current state until a        subsequent call to glUseProgram removes it        from use. After it is removed from use, it cannot be made part        of current state until it has been successfully relinked.
        /// If program is zero, then the current rendering        state refers to an invalid program object and the        results of shader execution are undefined. However, this is not an error.
        /// If program does not        contain shader objects of type GL_FRAGMENT_SHADER, an        executable will be installed on the vertex, and possibly geometry processors,        but the results of fragment shader execution will be undefined.
        /// </summary>
        /// <param name="program">Specifies the handle of the program object                    whose executables are to be used as part of current                    rendering state.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UseProgram(uint program) => _UseProgram(program);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UseProgramObjectARB(int programObj) => _UseProgramObjectARB(programObj);

        // ---

        /// <summary>
        /// glUseProgramStages binds executables from a program object            associated with a specified set of shader stages to the program pipeline object given            by pipeline.            pipeline specifies the program pipeline object to which to bind            the executables. stages contains a logical combination of bits            indicating the shader stages to use within program with the program            pipeline object pipeline. stages must be            a logical combination of GL_VERTEX_SHADER_BIT,            GL_TESS_CONTROL_SHADER_BIT, GL_TESS_EVALUATION_SHADER_BIT,            GL_GEOMETRY_SHADER_BIT, GL_FRAGMENT_SHADER_BIT and GL_COMPUTE_SHADER_BIT.            Additionally, the special value GL_ALL_SHADER_BITS may be specified to            indicate that all executables contained in program should be            installed in pipeline.
        /// If program refers to a program object with a valid shader attached for            an indicated shader stage, glUseProgramStages installs the executable            code for that stage in the indicated program pipeline object pipeline.            If program is zero, or refers to a program object with no valid shader            executable for a given stage, it is as if the pipeline object has no programmable stage configured            for the indicated shader stages. If stages contains bits other than those            listed above, and is not equal to GL_ALL_SHADER_BITS, an error is generated.
        /// </summary>
        /// <param name="pipeline">Specifies the program pipeline object to which to bind stages from program.</param>
        /// <param name="stages">Specifies a set of program stages to bind to the program pipeline object.</param>
        /// <param name="program">Specifies the program object containing the shader executables to use in pipeline.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UseProgramStages(uint pipeline, int stages, uint program) => _UseProgramStages(pipeline, stages, program);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UseProgramStagesEXT(uint pipeline, int stages, uint program) => _UseProgramStagesEXT(pipeline, stages, program);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void UseShaderProgramEXT(int type, uint program) => _UseShaderProgramEXT(type, program);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VDPAUFiniNV() => _VDPAUFiniNV();

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VDPAUGetSurfaceivNV(IntPtr surface, int pname, int count, int[] length, int[] values) => _VDPAUGetSurfaceivNV(surface, pname, count, length, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VDPAUGetSurfaceivNV(IntPtr surface, int pname, int count, void* length, void* values) => _VDPAUGetSurfaceivNV_ptr(surface, pname, count, length, values);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VDPAUGetSurfaceivNV(IntPtr surface, int pname, int count, IntPtr length, IntPtr values) => _VDPAUGetSurfaceivNV_intptr(surface, pname, count, length, values);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VDPAUInitNV(IntPtr vdpDevice, IntPtr getProcAddress) => _VDPAUInitNV(vdpDevice, getProcAddress);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool VDPAUIsSurfaceNV(IntPtr surface) => _VDPAUIsSurfaceNV(surface);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VDPAUMapSurfacesNV(int numSurfaces, IntPtr[] surfaces) => _VDPAUMapSurfacesNV(numSurfaces, surfaces);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VDPAUMapSurfacesNV(int numSurfaces, void* surfaces) => _VDPAUMapSurfacesNV_ptr(numSurfaces, surfaces);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VDPAUMapSurfacesNV(int numSurfaces, IntPtr surfaces) => _VDPAUMapSurfacesNV_intptr(numSurfaces, surfaces);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IntPtr VDPAURegisterOutputSurfaceNV(IntPtr vdpSurface, int target, int numTextureNames, uint[] textureNames) => _VDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IntPtr VDPAURegisterOutputSurfaceNV(IntPtr vdpSurface, int target, int numTextureNames, void* textureNames) => _VDPAURegisterOutputSurfaceNV_ptr(vdpSurface, target, numTextureNames, textureNames);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IntPtr VDPAURegisterOutputSurfaceNV(IntPtr vdpSurface, int target, int numTextureNames, IntPtr textureNames) => _VDPAURegisterOutputSurfaceNV_intptr(vdpSurface, target, numTextureNames, textureNames);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IntPtr VDPAURegisterVideoSurfaceNV(IntPtr vdpSurface, int target, int numTextureNames, uint[] textureNames) => _VDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IntPtr VDPAURegisterVideoSurfaceNV(IntPtr vdpSurface, int target, int numTextureNames, void* textureNames) => _VDPAURegisterVideoSurfaceNV_ptr(vdpSurface, target, numTextureNames, textureNames);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IntPtr VDPAURegisterVideoSurfaceNV(IntPtr vdpSurface, int target, int numTextureNames, IntPtr textureNames) => _VDPAURegisterVideoSurfaceNV_intptr(vdpSurface, target, numTextureNames, textureNames);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IntPtr VDPAURegisterVideoSurfaceWithPictureStructureNV(IntPtr vdpSurface, int target, int numTextureNames, uint[] textureNames, bool isFrameStructure) => _VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IntPtr VDPAURegisterVideoSurfaceWithPictureStructureNV(IntPtr vdpSurface, int target, int numTextureNames, void* textureNames, bool isFrameStructure) => _VDPAURegisterVideoSurfaceWithPictureStructureNV_ptr(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IntPtr VDPAURegisterVideoSurfaceWithPictureStructureNV(IntPtr vdpSurface, int target, int numTextureNames, IntPtr textureNames, bool isFrameStructure) => _VDPAURegisterVideoSurfaceWithPictureStructureNV_intptr(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VDPAUSurfaceAccessNV(IntPtr surface, int access) => _VDPAUSurfaceAccessNV(surface, access);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VDPAUUnmapSurfacesNV(int numSurface, IntPtr[] surfaces) => _VDPAUUnmapSurfacesNV(numSurface, surfaces);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VDPAUUnmapSurfacesNV(int numSurface, void* surfaces) => _VDPAUUnmapSurfacesNV_ptr(numSurface, surfaces);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VDPAUUnmapSurfacesNV(int numSurface, IntPtr surfaces) => _VDPAUUnmapSurfacesNV_intptr(numSurface, surfaces);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VDPAUUnregisterSurfaceNV(IntPtr surface) => _VDPAUUnregisterSurfaceNV(surface);

        // ---

        /// <summary>
        /// glValidateProgram checks to see        whether the executables contained in        program can execute given the current        OpenGL state. The information generated by the validation        process will be stored in program's        information log. The validation information may consist of an        empty string, or it may be a string containing information about        how the current program object interacts with the rest of        current OpenGL state. This provides a way for OpenGL        implementers to convey more information about why the current        program is inefficient, suboptimal, failing to execute, and so        on.
        /// The status of the validation operation will be stored as        part of the program object's state. This value will be set to        GL_TRUE if the validation succeeded, and        GL_FALSE otherwise. It can be queried by        calling        glGetProgram        with arguments program and        GL_VALIDATE_STATUS. If validation is        successful, program is guaranteed to        execute given the current state. Otherwise,        program is guaranteed to not execute.
        /// This function is typically useful only during application        development. The informational string stored in the information        log is completely implementation dependent; therefore, an        application should not expect different OpenGL implementations        to produce identical information strings.
        /// </summary>
        /// <param name="program">Specifies the handle of the program object to                    be validated.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ValidateProgram(uint program) => _ValidateProgram(program);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ValidateProgramARB(int programObj) => _ValidateProgramARB(programObj);

        // ---

        /// <summary>
        /// glValidateProgramPipeline instructs the implementation to validate the            shader executables contained in pipeline against the current GL state.            The implementation may use this as an opportunity to perform any internal shader modifications            that may be required to ensure correct operation of the installed shaders given the            current GL state.
        /// After a program pipeline has been validated, its validation status is set to GL_TRUE.            The validation status of a program pipeline object may be queried by calling            glGetProgramPipeline with            parameter GL_VALIDATE_STATUS.
        /// If pipeline is a name previously returned from a call to            glGenProgramPipelines but            that has not yet been bound by a call to glBindProgramPipeline,            a new program pipeline object is created with name pipeline and            the default state vector.
        /// </summary>
        /// <param name="pipeline">Specifies the name of a program pipeline object to validate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ValidateProgramPipeline(uint pipeline) => _ValidateProgramPipeline(pipeline);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ValidateProgramPipelineEXT(uint pipeline) => _ValidateProgramPipelineEXT(pipeline);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantArrayObjectATI(uint id, ScalarType type, int stride, uint buffer, uint offset) => _VariantArrayObjectATI(id, type, stride, buffer, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantPointerEXT(uint id, ScalarType type, uint stride, IntPtr addr) => _VariantPointerEXT(id, type, stride, addr);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantbvEXT(uint id, sbyte[] addr) => _VariantbvEXT(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantbvEXT(uint id, void* addr) => _VariantbvEXT_ptr(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantbvEXT(uint id, IntPtr addr) => _VariantbvEXT_intptr(id, addr);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantdvEXT(uint id, double[] addr) => _VariantdvEXT(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantdvEXT(uint id, void* addr) => _VariantdvEXT_ptr(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantdvEXT(uint id, IntPtr addr) => _VariantdvEXT_intptr(id, addr);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantfvEXT(uint id, float[] addr) => _VariantfvEXT(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantfvEXT(uint id, void* addr) => _VariantfvEXT_ptr(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantfvEXT(uint id, IntPtr addr) => _VariantfvEXT_intptr(id, addr);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantivEXT(uint id, int[] addr) => _VariantivEXT(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantivEXT(uint id, void* addr) => _VariantivEXT_ptr(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantivEXT(uint id, IntPtr addr) => _VariantivEXT_intptr(id, addr);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantsvEXT(uint id, short[] addr) => _VariantsvEXT(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantsvEXT(uint id, void* addr) => _VariantsvEXT_ptr(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantsvEXT(uint id, IntPtr addr) => _VariantsvEXT_intptr(id, addr);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantubvEXT(uint id, byte[] addr) => _VariantubvEXT(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantubvEXT(uint id, void* addr) => _VariantubvEXT_ptr(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantubvEXT(uint id, IntPtr addr) => _VariantubvEXT_intptr(id, addr);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantuivEXT(uint id, uint[] addr) => _VariantuivEXT(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantuivEXT(uint id, void* addr) => _VariantuivEXT_ptr(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantuivEXT(uint id, IntPtr addr) => _VariantuivEXT_intptr(id, addr);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantusvEXT(uint id, ushort[] addr) => _VariantusvEXT(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantusvEXT(uint id, void* addr) => _VariantusvEXT_ptr(id, addr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VariantusvEXT(uint id, IntPtr addr) => _VariantusvEXT_intptr(id, addr);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2bOES(sbyte x, sbyte y) => _Vertex2bOES(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2bvOES(sbyte[] coords) => _Vertex2bvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2bvOES(void* coords) => _Vertex2bvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2bvOES(IntPtr coords) => _Vertex2bvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2d(double x, double y) => _Vertex2d(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2dv(double[] v) => _Vertex2dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2dv(void* v) => _Vertex2dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2dv(IntPtr v) => _Vertex2dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2f(float x, float y) => _Vertex2f(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2fv(float[] v) => _Vertex2fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2fv(void* v) => _Vertex2fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2fv(IntPtr v) => _Vertex2fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2hNV(float x, float y) => _Vertex2hNV(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2hvNV(float[] v) => _Vertex2hvNV(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2hvNV(void* v) => _Vertex2hvNV_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2hvNV(IntPtr v) => _Vertex2hvNV_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2i(int x, int y) => _Vertex2i(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2iv(int[] v) => _Vertex2iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2iv(void* v) => _Vertex2iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2iv(IntPtr v) => _Vertex2iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2s(short x, short y) => _Vertex2s(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2sv(short[] v) => _Vertex2sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2sv(void* v) => _Vertex2sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2sv(IntPtr v) => _Vertex2sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2xOES(float x) => _Vertex2xOES(x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2xvOES(float[] coords) => _Vertex2xvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2xvOES(void* coords) => _Vertex2xvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex2xvOES(IntPtr coords) => _Vertex2xvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3bOES(sbyte x, sbyte y, sbyte z) => _Vertex3bOES(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3bvOES(sbyte[] coords) => _Vertex3bvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3bvOES(void* coords) => _Vertex3bvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3bvOES(IntPtr coords) => _Vertex3bvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3d(double x, double y, double z) => _Vertex3d(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3dv(double[] v) => _Vertex3dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3dv(void* v) => _Vertex3dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3dv(IntPtr v) => _Vertex3dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3f(float x, float y, float z) => _Vertex3f(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3fv(float[] v) => _Vertex3fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3fv(void* v) => _Vertex3fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3fv(IntPtr v) => _Vertex3fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3hNV(float x, float y, float z) => _Vertex3hNV(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3hvNV(float[] v) => _Vertex3hvNV(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3hvNV(void* v) => _Vertex3hvNV_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3hvNV(IntPtr v) => _Vertex3hvNV_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3i(int x, int y, int z) => _Vertex3i(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3iv(int[] v) => _Vertex3iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3iv(void* v) => _Vertex3iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3iv(IntPtr v) => _Vertex3iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3s(short x, short y, short z) => _Vertex3s(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3sv(short[] v) => _Vertex3sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3sv(void* v) => _Vertex3sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3sv(IntPtr v) => _Vertex3sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3xOES(float x, float y) => _Vertex3xOES(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3xvOES(float[] coords) => _Vertex3xvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3xvOES(void* coords) => _Vertex3xvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex3xvOES(IntPtr coords) => _Vertex3xvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4bOES(sbyte x, sbyte y, sbyte z, sbyte w) => _Vertex4bOES(x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4bvOES(sbyte[] coords) => _Vertex4bvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4bvOES(void* coords) => _Vertex4bvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4bvOES(IntPtr coords) => _Vertex4bvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4d(double x, double y, double z, double w) => _Vertex4d(x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4dv(double[] v) => _Vertex4dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4dv(void* v) => _Vertex4dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4dv(IntPtr v) => _Vertex4dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4f(float x, float y, float z, float w) => _Vertex4f(x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4fv(float[] v) => _Vertex4fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4fv(void* v) => _Vertex4fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4fv(IntPtr v) => _Vertex4fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4hNV(float x, float y, float z, float w) => _Vertex4hNV(x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4hvNV(float[] v) => _Vertex4hvNV(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4hvNV(void* v) => _Vertex4hvNV_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4hvNV(IntPtr v) => _Vertex4hvNV_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4i(int x, int y, int z, int w) => _Vertex4i(x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4iv(int[] v) => _Vertex4iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4iv(void* v) => _Vertex4iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4iv(IntPtr v) => _Vertex4iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4s(short x, short y, short z, short w) => _Vertex4s(x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4sv(short[] v) => _Vertex4sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4sv(void* v) => _Vertex4sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4sv(IntPtr v) => _Vertex4sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4xOES(float x, float y, float z) => _Vertex4xOES(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4xvOES(float[] coords) => _Vertex4xvOES(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4xvOES(void* coords) => _Vertex4xvOES_ptr(coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Vertex4xvOES(IntPtr coords) => _Vertex4xvOES_intptr(coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayAttribBinding(uint vaobj, uint attribindex, uint bindingindex) => _VertexArrayAttribBinding(vaobj, attribindex, bindingindex);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayAttribFormat(uint vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => _VertexArrayAttribFormat(vaobj, attribindex, size, type, normalized, relativeoffset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayAttribIFormat(uint vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => _VertexArrayAttribIFormat(vaobj, attribindex, size, type, relativeoffset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayAttribLFormat(uint vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => _VertexArrayAttribLFormat(vaobj, attribindex, size, type, relativeoffset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayBindVertexBufferEXT(uint vaobj, uint bindingindex, uint buffer, IntPtr offset, int stride) => _VertexArrayBindVertexBufferEXT(vaobj, bindingindex, buffer, offset, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayBindingDivisor(uint vaobj, uint bindingindex, uint divisor) => _VertexArrayBindingDivisor(vaobj, bindingindex, divisor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayColorOffsetEXT(uint vaobj, uint buffer, int size, ColorPointerType type, int stride, IntPtr offset) => _VertexArrayColorOffsetEXT(vaobj, buffer, size, type, stride, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayEdgeFlagOffsetEXT(uint vaobj, uint buffer, int stride, IntPtr offset) => _VertexArrayEdgeFlagOffsetEXT(vaobj, buffer, stride, offset);

        // ---

        /// <summary>
        /// glVertexArrayElementBuffer binds a buffer object with id buffer            to the element array buffer bind point of a vertex array object with id vaobj.            If buffer is zero, any existing element array buffer binding to vaobj            is removed.
        /// </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object.</param>
        /// <param name="buffer">Specifies the name of the buffer object to use for the element array buffer binding.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayElementBuffer(uint vaobj, uint buffer) => _VertexArrayElementBuffer(vaobj, buffer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayFogCoordOffsetEXT(uint vaobj, uint buffer, FogCoordinatePointerType type, int stride, IntPtr offset) => _VertexArrayFogCoordOffsetEXT(vaobj, buffer, type, stride, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayIndexOffsetEXT(uint vaobj, uint buffer, IndexPointerType type, int stride, IntPtr offset) => _VertexArrayIndexOffsetEXT(vaobj, buffer, type, stride, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayMultiTexCoordOffsetEXT(uint vaobj, uint buffer, int texunit, int size, TexCoordPointerType type, int stride, IntPtr offset) => _VertexArrayMultiTexCoordOffsetEXT(vaobj, buffer, texunit, size, type, stride, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayNormalOffsetEXT(uint vaobj, uint buffer, NormalPointerType type, int stride, IntPtr offset) => _VertexArrayNormalOffsetEXT(vaobj, buffer, type, stride, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayParameteriAPPLE(VertexArrayPNameAPPLE pname, int param) => _VertexArrayParameteriAPPLE(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayRangeAPPLE(int length, IntPtr pointer) => _VertexArrayRangeAPPLE(length, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayRangeNV(int length, IntPtr pointer) => _VertexArrayRangeNV(length, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArraySecondaryColorOffsetEXT(uint vaobj, uint buffer, int size, ColorPointerType type, int stride, IntPtr offset) => _VertexArraySecondaryColorOffsetEXT(vaobj, buffer, size, type, stride, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayTexCoordOffsetEXT(uint vaobj, uint buffer, int size, TexCoordPointerType type, int stride, IntPtr offset) => _VertexArrayTexCoordOffsetEXT(vaobj, buffer, size, type, stride, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayVertexAttribBindingEXT(uint vaobj, uint attribindex, uint bindingindex) => _VertexArrayVertexAttribBindingEXT(vaobj, attribindex, bindingindex);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayVertexAttribDivisorEXT(uint vaobj, uint index, uint divisor) => _VertexArrayVertexAttribDivisorEXT(vaobj, index, divisor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayVertexAttribFormatEXT(uint vaobj, uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => _VertexArrayVertexAttribFormatEXT(vaobj, attribindex, size, type, normalized, relativeoffset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayVertexAttribIFormatEXT(uint vaobj, uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => _VertexArrayVertexAttribIFormatEXT(vaobj, attribindex, size, type, relativeoffset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayVertexAttribIOffsetEXT(uint vaobj, uint buffer, uint index, int size, VertexAttribType type, int stride, IntPtr offset) => _VertexArrayVertexAttribIOffsetEXT(vaobj, buffer, index, size, type, stride, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayVertexAttribLFormatEXT(uint vaobj, uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => _VertexArrayVertexAttribLFormatEXT(vaobj, attribindex, size, type, relativeoffset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayVertexAttribLOffsetEXT(uint vaobj, uint buffer, uint index, int size, VertexAttribLType type, int stride, IntPtr offset) => _VertexArrayVertexAttribLOffsetEXT(vaobj, buffer, index, size, type, stride, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayVertexAttribOffsetEXT(uint vaobj, uint buffer, uint index, int size, VertexAttribPointerType type, bool normalized, int stride, IntPtr offset) => _VertexArrayVertexAttribOffsetEXT(vaobj, buffer, index, size, type, normalized, stride, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayVertexBindingDivisorEXT(uint vaobj, uint bindingindex, uint divisor) => _VertexArrayVertexBindingDivisorEXT(vaobj, bindingindex, divisor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayVertexBuffer(uint vaobj, uint bindingindex, uint buffer, IntPtr offset, int stride) => _VertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, uint[] buffers, IntPtr[] offsets, int[] strides) => _VertexArrayVertexBuffers(vaobj, first, count, buffers, offsets, strides);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, void* buffers, void* offsets, void* strides) => _VertexArrayVertexBuffers_ptr(vaobj, first, count, buffers, offsets, strides);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, IntPtr buffers, IntPtr offsets, IntPtr strides) => _VertexArrayVertexBuffers_intptr(vaobj, first, count, buffers, offsets, strides);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexArrayVertexOffsetEXT(uint vaobj, uint buffer, int size, VertexPointerType type, int stride, IntPtr offset) => _VertexArrayVertexOffsetEXT(vaobj, buffer, size, type, stride, offset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1d(uint index, double x) => _VertexAttrib1d(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1dARB(uint index, double x) => _VertexAttrib1dARB(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1dNV(uint index, double x) => _VertexAttrib1dNV(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1dv(uint index, double[] v) => _VertexAttrib1dv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1dv(uint index, void* v) => _VertexAttrib1dv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1dv(uint index, IntPtr v) => _VertexAttrib1dv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1dvARB(uint index, double[] v) => _VertexAttrib1dvARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1dvARB(uint index, void* v) => _VertexAttrib1dvARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1dvARB(uint index, IntPtr v) => _VertexAttrib1dvARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1dvNV(uint index, double[] v) => _VertexAttrib1dvNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1dvNV(uint index, void* v) => _VertexAttrib1dvNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1dvNV(uint index, IntPtr v) => _VertexAttrib1dvNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1f(uint index, float x) => _VertexAttrib1f(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1fARB(uint index, float x) => _VertexAttrib1fARB(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1fNV(uint index, float x) => _VertexAttrib1fNV(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1fv(uint index, float[] v) => _VertexAttrib1fv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1fv(uint index, void* v) => _VertexAttrib1fv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1fv(uint index, IntPtr v) => _VertexAttrib1fv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1fvARB(uint index, float[] v) => _VertexAttrib1fvARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1fvARB(uint index, void* v) => _VertexAttrib1fvARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1fvARB(uint index, IntPtr v) => _VertexAttrib1fvARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1fvNV(uint index, float[] v) => _VertexAttrib1fvNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1fvNV(uint index, void* v) => _VertexAttrib1fvNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1fvNV(uint index, IntPtr v) => _VertexAttrib1fvNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1hNV(uint index, float x) => _VertexAttrib1hNV(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1hvNV(uint index, float[] v) => _VertexAttrib1hvNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1hvNV(uint index, void* v) => _VertexAttrib1hvNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1hvNV(uint index, IntPtr v) => _VertexAttrib1hvNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1s(uint index, short x) => _VertexAttrib1s(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1sARB(uint index, short x) => _VertexAttrib1sARB(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1sNV(uint index, short x) => _VertexAttrib1sNV(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1sv(uint index, short[] v) => _VertexAttrib1sv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1sv(uint index, void* v) => _VertexAttrib1sv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1sv(uint index, IntPtr v) => _VertexAttrib1sv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1svARB(uint index, short[] v) => _VertexAttrib1svARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1svARB(uint index, void* v) => _VertexAttrib1svARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1svARB(uint index, IntPtr v) => _VertexAttrib1svARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1svNV(uint index, short[] v) => _VertexAttrib1svNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1svNV(uint index, void* v) => _VertexAttrib1svNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib1svNV(uint index, IntPtr v) => _VertexAttrib1svNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2d(uint index, double x, double y) => _VertexAttrib2d(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2dARB(uint index, double x, double y) => _VertexAttrib2dARB(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2dNV(uint index, double x, double y) => _VertexAttrib2dNV(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2dv(uint index, double[] v) => _VertexAttrib2dv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2dv(uint index, void* v) => _VertexAttrib2dv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2dv(uint index, IntPtr v) => _VertexAttrib2dv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2dvARB(uint index, double[] v) => _VertexAttrib2dvARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2dvARB(uint index, void* v) => _VertexAttrib2dvARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2dvARB(uint index, IntPtr v) => _VertexAttrib2dvARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2dvNV(uint index, double[] v) => _VertexAttrib2dvNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2dvNV(uint index, void* v) => _VertexAttrib2dvNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2dvNV(uint index, IntPtr v) => _VertexAttrib2dvNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2f(uint index, float x, float y) => _VertexAttrib2f(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2fARB(uint index, float x, float y) => _VertexAttrib2fARB(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2fNV(uint index, float x, float y) => _VertexAttrib2fNV(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2fv(uint index, float[] v) => _VertexAttrib2fv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2fv(uint index, void* v) => _VertexAttrib2fv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2fv(uint index, IntPtr v) => _VertexAttrib2fv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2fvARB(uint index, float[] v) => _VertexAttrib2fvARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2fvARB(uint index, void* v) => _VertexAttrib2fvARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2fvARB(uint index, IntPtr v) => _VertexAttrib2fvARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2fvNV(uint index, float[] v) => _VertexAttrib2fvNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2fvNV(uint index, void* v) => _VertexAttrib2fvNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2fvNV(uint index, IntPtr v) => _VertexAttrib2fvNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2hNV(uint index, float x, float y) => _VertexAttrib2hNV(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2hvNV(uint index, float[] v) => _VertexAttrib2hvNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2hvNV(uint index, void* v) => _VertexAttrib2hvNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2hvNV(uint index, IntPtr v) => _VertexAttrib2hvNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2s(uint index, short x, short y) => _VertexAttrib2s(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2sARB(uint index, short x, short y) => _VertexAttrib2sARB(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2sNV(uint index, short x, short y) => _VertexAttrib2sNV(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2sv(uint index, short[] v) => _VertexAttrib2sv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2sv(uint index, void* v) => _VertexAttrib2sv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2sv(uint index, IntPtr v) => _VertexAttrib2sv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2svARB(uint index, short[] v) => _VertexAttrib2svARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2svARB(uint index, void* v) => _VertexAttrib2svARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2svARB(uint index, IntPtr v) => _VertexAttrib2svARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2svNV(uint index, short[] v) => _VertexAttrib2svNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2svNV(uint index, void* v) => _VertexAttrib2svNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib2svNV(uint index, IntPtr v) => _VertexAttrib2svNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3d(uint index, double x, double y, double z) => _VertexAttrib3d(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3dARB(uint index, double x, double y, double z) => _VertexAttrib3dARB(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3dNV(uint index, double x, double y, double z) => _VertexAttrib3dNV(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3dv(uint index, double[] v) => _VertexAttrib3dv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3dv(uint index, void* v) => _VertexAttrib3dv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3dv(uint index, IntPtr v) => _VertexAttrib3dv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3dvARB(uint index, double[] v) => _VertexAttrib3dvARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3dvARB(uint index, void* v) => _VertexAttrib3dvARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3dvARB(uint index, IntPtr v) => _VertexAttrib3dvARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3dvNV(uint index, double[] v) => _VertexAttrib3dvNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3dvNV(uint index, void* v) => _VertexAttrib3dvNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3dvNV(uint index, IntPtr v) => _VertexAttrib3dvNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3f(uint index, float x, float y, float z) => _VertexAttrib3f(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3fARB(uint index, float x, float y, float z) => _VertexAttrib3fARB(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3fNV(uint index, float x, float y, float z) => _VertexAttrib3fNV(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3fv(uint index, float[] v) => _VertexAttrib3fv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3fv(uint index, void* v) => _VertexAttrib3fv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3fv(uint index, IntPtr v) => _VertexAttrib3fv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3fvARB(uint index, float[] v) => _VertexAttrib3fvARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3fvARB(uint index, void* v) => _VertexAttrib3fvARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3fvARB(uint index, IntPtr v) => _VertexAttrib3fvARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3fvNV(uint index, float[] v) => _VertexAttrib3fvNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3fvNV(uint index, void* v) => _VertexAttrib3fvNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3fvNV(uint index, IntPtr v) => _VertexAttrib3fvNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3hNV(uint index, float x, float y, float z) => _VertexAttrib3hNV(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3hvNV(uint index, float[] v) => _VertexAttrib3hvNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3hvNV(uint index, void* v) => _VertexAttrib3hvNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3hvNV(uint index, IntPtr v) => _VertexAttrib3hvNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3s(uint index, short x, short y, short z) => _VertexAttrib3s(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3sARB(uint index, short x, short y, short z) => _VertexAttrib3sARB(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3sNV(uint index, short x, short y, short z) => _VertexAttrib3sNV(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3sv(uint index, short[] v) => _VertexAttrib3sv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3sv(uint index, void* v) => _VertexAttrib3sv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3sv(uint index, IntPtr v) => _VertexAttrib3sv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3svARB(uint index, short[] v) => _VertexAttrib3svARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3svARB(uint index, void* v) => _VertexAttrib3svARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3svARB(uint index, IntPtr v) => _VertexAttrib3svARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3svNV(uint index, short[] v) => _VertexAttrib3svNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3svNV(uint index, void* v) => _VertexAttrib3svNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib3svNV(uint index, IntPtr v) => _VertexAttrib3svNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nbv(uint index, sbyte[] v) => _VertexAttrib4Nbv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nbv(uint index, void* v) => _VertexAttrib4Nbv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nbv(uint index, IntPtr v) => _VertexAttrib4Nbv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NbvARB(uint index, sbyte[] v) => _VertexAttrib4NbvARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NbvARB(uint index, void* v) => _VertexAttrib4NbvARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NbvARB(uint index, IntPtr v) => _VertexAttrib4NbvARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Niv(uint index, int[] v) => _VertexAttrib4Niv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Niv(uint index, void* v) => _VertexAttrib4Niv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Niv(uint index, IntPtr v) => _VertexAttrib4Niv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NivARB(uint index, int[] v) => _VertexAttrib4NivARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NivARB(uint index, void* v) => _VertexAttrib4NivARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NivARB(uint index, IntPtr v) => _VertexAttrib4NivARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nsv(uint index, short[] v) => _VertexAttrib4Nsv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nsv(uint index, void* v) => _VertexAttrib4Nsv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nsv(uint index, IntPtr v) => _VertexAttrib4Nsv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NsvARB(uint index, short[] v) => _VertexAttrib4NsvARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NsvARB(uint index, void* v) => _VertexAttrib4NsvARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NsvARB(uint index, IntPtr v) => _VertexAttrib4NsvARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nub(uint index, byte x, byte y, byte z, byte w) => _VertexAttrib4Nub(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NubARB(uint index, byte x, byte y, byte z, byte w) => _VertexAttrib4NubARB(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nubv(uint index, byte[] v) => _VertexAttrib4Nubv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nubv(uint index, void* v) => _VertexAttrib4Nubv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nubv(uint index, IntPtr v) => _VertexAttrib4Nubv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NubvARB(uint index, byte[] v) => _VertexAttrib4NubvARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NubvARB(uint index, void* v) => _VertexAttrib4NubvARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NubvARB(uint index, IntPtr v) => _VertexAttrib4NubvARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nuiv(uint index, uint[] v) => _VertexAttrib4Nuiv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nuiv(uint index, void* v) => _VertexAttrib4Nuiv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nuiv(uint index, IntPtr v) => _VertexAttrib4Nuiv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NuivARB(uint index, uint[] v) => _VertexAttrib4NuivARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NuivARB(uint index, void* v) => _VertexAttrib4NuivARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NuivARB(uint index, IntPtr v) => _VertexAttrib4NuivARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nusv(uint index, ushort[] v) => _VertexAttrib4Nusv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nusv(uint index, void* v) => _VertexAttrib4Nusv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4Nusv(uint index, IntPtr v) => _VertexAttrib4Nusv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NusvARB(uint index, ushort[] v) => _VertexAttrib4NusvARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NusvARB(uint index, void* v) => _VertexAttrib4NusvARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4NusvARB(uint index, IntPtr v) => _VertexAttrib4NusvARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4bv(uint index, sbyte[] v) => _VertexAttrib4bv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4bv(uint index, void* v) => _VertexAttrib4bv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4bv(uint index, IntPtr v) => _VertexAttrib4bv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4bvARB(uint index, sbyte[] v) => _VertexAttrib4bvARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4bvARB(uint index, void* v) => _VertexAttrib4bvARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4bvARB(uint index, IntPtr v) => _VertexAttrib4bvARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4d(uint index, double x, double y, double z, double w) => _VertexAttrib4d(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4dARB(uint index, double x, double y, double z, double w) => _VertexAttrib4dARB(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4dNV(uint index, double x, double y, double z, double w) => _VertexAttrib4dNV(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4dv(uint index, double[] v) => _VertexAttrib4dv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4dv(uint index, void* v) => _VertexAttrib4dv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4dv(uint index, IntPtr v) => _VertexAttrib4dv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4dvARB(uint index, double[] v) => _VertexAttrib4dvARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4dvARB(uint index, void* v) => _VertexAttrib4dvARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4dvARB(uint index, IntPtr v) => _VertexAttrib4dvARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4dvNV(uint index, double[] v) => _VertexAttrib4dvNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4dvNV(uint index, void* v) => _VertexAttrib4dvNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4dvNV(uint index, IntPtr v) => _VertexAttrib4dvNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4f(uint index, float x, float y, float z, float w) => _VertexAttrib4f(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4fARB(uint index, float x, float y, float z, float w) => _VertexAttrib4fARB(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4fNV(uint index, float x, float y, float z, float w) => _VertexAttrib4fNV(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4fv(uint index, float[] v) => _VertexAttrib4fv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4fv(uint index, void* v) => _VertexAttrib4fv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4fv(uint index, IntPtr v) => _VertexAttrib4fv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4fvARB(uint index, float[] v) => _VertexAttrib4fvARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4fvARB(uint index, void* v) => _VertexAttrib4fvARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4fvARB(uint index, IntPtr v) => _VertexAttrib4fvARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4fvNV(uint index, float[] v) => _VertexAttrib4fvNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4fvNV(uint index, void* v) => _VertexAttrib4fvNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4fvNV(uint index, IntPtr v) => _VertexAttrib4fvNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4hNV(uint index, float x, float y, float z, float w) => _VertexAttrib4hNV(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4hvNV(uint index, float[] v) => _VertexAttrib4hvNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4hvNV(uint index, void* v) => _VertexAttrib4hvNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4hvNV(uint index, IntPtr v) => _VertexAttrib4hvNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4iv(uint index, int[] v) => _VertexAttrib4iv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4iv(uint index, void* v) => _VertexAttrib4iv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4iv(uint index, IntPtr v) => _VertexAttrib4iv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4ivARB(uint index, int[] v) => _VertexAttrib4ivARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4ivARB(uint index, void* v) => _VertexAttrib4ivARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4ivARB(uint index, IntPtr v) => _VertexAttrib4ivARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4s(uint index, short x, short y, short z, short w) => _VertexAttrib4s(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4sARB(uint index, short x, short y, short z, short w) => _VertexAttrib4sARB(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4sNV(uint index, short x, short y, short z, short w) => _VertexAttrib4sNV(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4sv(uint index, short[] v) => _VertexAttrib4sv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4sv(uint index, void* v) => _VertexAttrib4sv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4sv(uint index, IntPtr v) => _VertexAttrib4sv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4svARB(uint index, short[] v) => _VertexAttrib4svARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4svARB(uint index, void* v) => _VertexAttrib4svARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4svARB(uint index, IntPtr v) => _VertexAttrib4svARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4svNV(uint index, short[] v) => _VertexAttrib4svNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4svNV(uint index, void* v) => _VertexAttrib4svNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4svNV(uint index, IntPtr v) => _VertexAttrib4svNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4ubNV(uint index, byte x, byte y, byte z, byte w) => _VertexAttrib4ubNV(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4ubv(uint index, byte[] v) => _VertexAttrib4ubv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4ubv(uint index, void* v) => _VertexAttrib4ubv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4ubv(uint index, IntPtr v) => _VertexAttrib4ubv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4ubvARB(uint index, byte[] v) => _VertexAttrib4ubvARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4ubvARB(uint index, void* v) => _VertexAttrib4ubvARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4ubvARB(uint index, IntPtr v) => _VertexAttrib4ubvARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4ubvNV(uint index, byte[] v) => _VertexAttrib4ubvNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4ubvNV(uint index, void* v) => _VertexAttrib4ubvNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4ubvNV(uint index, IntPtr v) => _VertexAttrib4ubvNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4uiv(uint index, uint[] v) => _VertexAttrib4uiv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4uiv(uint index, void* v) => _VertexAttrib4uiv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4uiv(uint index, IntPtr v) => _VertexAttrib4uiv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4uivARB(uint index, uint[] v) => _VertexAttrib4uivARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4uivARB(uint index, void* v) => _VertexAttrib4uivARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4uivARB(uint index, IntPtr v) => _VertexAttrib4uivARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4usv(uint index, ushort[] v) => _VertexAttrib4usv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4usv(uint index, void* v) => _VertexAttrib4usv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4usv(uint index, IntPtr v) => _VertexAttrib4usv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4usvARB(uint index, ushort[] v) => _VertexAttrib4usvARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4usvARB(uint index, void* v) => _VertexAttrib4usvARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttrib4usvARB(uint index, IntPtr v) => _VertexAttrib4usvARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribArrayObjectATI(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, uint buffer, uint offset) => _VertexAttribArrayObjectATI(index, size, type, normalized, stride, buffer, offset);

        // ---

        /// <summary>
        /// glVertexAttribBinding and            glVertexArrayAttribBinding establishes an            association between the generic vertex attribute of a vertex            array object whose index is given by            attribindex, and a vertex buffer binding            whose index is given by bindingindex. For            glVertexAttribBinding, the vertex array            object affected is that currently bound. For            glVertexArrayAttribBinding,            vaobj is the name of the vertex array            object.
        /// attribindex must be less than the value            of GL_MAX_VERTEX_ATTRIBS and            bindingindex must be less than the value            of GL_MAX_VERTEX_ATTRIB_BINDINGS.
        /// </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for                    glVertexArrayAttribBinding.</param>
        /// <param name="attribindex">The index of the attribute to associate with a vertex                    buffer binding.</param>
        /// <param name="bindingindex">The index of the vertex buffer binding with which to                    associate the generic vertex attribute.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribBinding(uint attribindex, uint bindingindex) => _VertexAttribBinding(attribindex, bindingindex);

        // ---

        /// <summary>
        /// glVertexAttribDivisor modifies the rate at which generic vertex attributes advance when rendering            multiple instances of primitives in a single draw call. If divisor is zero, the attribute at slot            index advances once per vertex. If divisor is non-zero, the attribute advances            once per divisor instances of the set(s) of vertices being rendered.  An attribute            is referred to as instanced if its GL_VERTEX_ATTRIB_ARRAY_DIVISOR value is non-zero.
        /// index must be less than the value of GL_MAX_VERTEX_ATTRIBS.
        /// </summary>
        /// <param name="index">Specify the index of the generic vertex attribute.</param>
        /// <param name="divisor">Specify the number of instances that will pass between updates of the generic attribute at slot index.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribDivisor(uint index, uint divisor) => _VertexAttribDivisor(index, divisor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribDivisorANGLE(uint index, uint divisor) => _VertexAttribDivisorANGLE(index, divisor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribDivisorARB(uint index, uint divisor) => _VertexAttribDivisorARB(index, divisor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribDivisorEXT(uint index, uint divisor) => _VertexAttribDivisorEXT(index, divisor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribDivisorNV(uint index, uint divisor) => _VertexAttribDivisorNV(index, divisor);

        // ---

        /// <summary>
        /// glVertexAttribFormat,    glVertexAttribIFormat and    glVertexAttribLFormat, as well as    glVertexArrayAttribFormat,    glVertexArrayAttribIFormat and    glVertexArrayAttribLFormat specify the organization    of data in vertex arrays. The first three calls operate on the bound    vertex array object, whereas the last three ones modify the state of a    vertex array object with ID vaobj.    attribindex specifies the index of the generic    vertex attribute array whose data layout is being described, and must be    less than the value of GL_MAX_VERTEX_ATTRIBS.
        /// size determines the number of components per    vertex are allocated to the specified attribute and must be 1, 2, 3 or 4.    type indicates the type of the data. If    type is one of GL_BYTE,    GL_SHORT, GL_INT,    GL_FIXED, GL_FLOAT,    GL_HALF_FLOAT, and GL_DOUBLE    indicate types GLbyte, GLshort,    GLint, GLfixed, GLfloat,    GLhalf, and GLdouble, respectively; the values    GL_UNSIGNED_BYTE,    GL_UNSIGNED_SHORT, and    GL_UNSIGNED_INT indicate types GLubyte,    GLushort, and GLuint, respectively; the values    GL_INT_2_10_10_10_REV and    GL_UNSIGNED_INT_2_10_10_10_REV indicating    respectively four signed or unsigned elements packed into a single    GLuint; and the value    GL_UNSIGNED_INT_10F_11F_11F_REV indicating three    floating point values packed into a single GLuint.
        /// glVertexAttribLFormat and    glVertexArrayAttribLFormat is used to specify layout    for data associated with a generic attribute variable declared as 64-bit    double precision components. For    glVertexAttribLFormat and    glVertexArrayAttribLFormat,    type must be GL_DOUBLE. In    contrast to glVertexAttribFormat or    glVertexArrayAttribFormat, which will cause data    declared as GL_DOUBLE to be converted to 32-bit    representation, glVertexAttribLFormat and    glVertexArrayAttribLFormat cause such data to be left    in its natural, 64-bit representation.
        /// For glVertexAttribFormat and    glVertexArrayAttribFormat, if    normalized is GL_TRUE, then    integer data is normalized to the range [-1, 1] or [0, 1] if it is signed    or unsigned, respectively. If normalized is    GL_FALSE then integer data is directly converted to    floating point.
        /// relativeoffset is the offset, measured in    basic machine units of the first element relative to the start of the    vertex buffer binding this attribute fetches from.
        /// glVertexAttribFormat and    glVertexArrayAttribFormat should be used to describe    vertex attribute layout for floating-point vertex attributes,    glVertexAttribIFormat and    glVertexArrayAttribIFormat should be used to describe    vertex attribute layout for integer vertex attribute, and    glVertexAttribLFormat and    glVertexArrayAttribLFormat should be used to describe    the layout for 64-bit vertex attributes. Data for an array specified by    glVertexAttribIFormat and    glVertexArrayAttribIFormat will always be left as    integer values; such data are referred to as pure integers.
        /// </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for          glVertexArrayAttrib{I, L}Format          functions.</param>
        /// <param name="attribindex">The generic vertex attribute array being described.</param>
        /// <param name="size">The number of values per vertex that are stored in the          array.</param>
        /// <param name="type">The type of the data stored in the array.</param>
        /// <param name="normalized">Specifies whether fixed-point data values should be normalized (GL_TRUE) or 		    converted directly as fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED.</param>
        /// <param name="relativeoffset">The distance between elements within the buffer.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribFormat(uint attribindex, int size, VertexAttribType type, bool normalized, uint relativeoffset) => _VertexAttribFormat(attribindex, size, type, normalized, relativeoffset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribFormatNV(uint index, int size, VertexAttribType type, bool normalized, int stride) => _VertexAttribFormatNV(index, size, type, normalized, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1i(uint index, int x) => _VertexAttribI1i(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1iEXT(uint index, int x) => _VertexAttribI1iEXT(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1iv(uint index, int[] v) => _VertexAttribI1iv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1iv(uint index, void* v) => _VertexAttribI1iv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1iv(uint index, IntPtr v) => _VertexAttribI1iv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1ivEXT(uint index, int[] v) => _VertexAttribI1ivEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1ivEXT(uint index, void* v) => _VertexAttribI1ivEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1ivEXT(uint index, IntPtr v) => _VertexAttribI1ivEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1ui(uint index, uint x) => _VertexAttribI1ui(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1uiEXT(uint index, uint x) => _VertexAttribI1uiEXT(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1uiv(uint index, uint[] v) => _VertexAttribI1uiv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1uiv(uint index, void* v) => _VertexAttribI1uiv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1uiv(uint index, IntPtr v) => _VertexAttribI1uiv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1uivEXT(uint index, uint[] v) => _VertexAttribI1uivEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1uivEXT(uint index, void* v) => _VertexAttribI1uivEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI1uivEXT(uint index, IntPtr v) => _VertexAttribI1uivEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2i(uint index, int x, int y) => _VertexAttribI2i(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2iEXT(uint index, int x, int y) => _VertexAttribI2iEXT(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2iv(uint index, int[] v) => _VertexAttribI2iv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2iv(uint index, void* v) => _VertexAttribI2iv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2iv(uint index, IntPtr v) => _VertexAttribI2iv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2ivEXT(uint index, int[] v) => _VertexAttribI2ivEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2ivEXT(uint index, void* v) => _VertexAttribI2ivEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2ivEXT(uint index, IntPtr v) => _VertexAttribI2ivEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2ui(uint index, uint x, uint y) => _VertexAttribI2ui(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2uiEXT(uint index, uint x, uint y) => _VertexAttribI2uiEXT(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2uiv(uint index, uint[] v) => _VertexAttribI2uiv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2uiv(uint index, void* v) => _VertexAttribI2uiv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2uiv(uint index, IntPtr v) => _VertexAttribI2uiv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2uivEXT(uint index, uint[] v) => _VertexAttribI2uivEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2uivEXT(uint index, void* v) => _VertexAttribI2uivEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI2uivEXT(uint index, IntPtr v) => _VertexAttribI2uivEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3i(uint index, int x, int y, int z) => _VertexAttribI3i(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3iEXT(uint index, int x, int y, int z) => _VertexAttribI3iEXT(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3iv(uint index, int[] v) => _VertexAttribI3iv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3iv(uint index, void* v) => _VertexAttribI3iv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3iv(uint index, IntPtr v) => _VertexAttribI3iv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3ivEXT(uint index, int[] v) => _VertexAttribI3ivEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3ivEXT(uint index, void* v) => _VertexAttribI3ivEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3ivEXT(uint index, IntPtr v) => _VertexAttribI3ivEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3ui(uint index, uint x, uint y, uint z) => _VertexAttribI3ui(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3uiEXT(uint index, uint x, uint y, uint z) => _VertexAttribI3uiEXT(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3uiv(uint index, uint[] v) => _VertexAttribI3uiv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3uiv(uint index, void* v) => _VertexAttribI3uiv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3uiv(uint index, IntPtr v) => _VertexAttribI3uiv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3uivEXT(uint index, uint[] v) => _VertexAttribI3uivEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3uivEXT(uint index, void* v) => _VertexAttribI3uivEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI3uivEXT(uint index, IntPtr v) => _VertexAttribI3uivEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4bv(uint index, sbyte[] v) => _VertexAttribI4bv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4bv(uint index, void* v) => _VertexAttribI4bv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4bv(uint index, IntPtr v) => _VertexAttribI4bv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4bvEXT(uint index, sbyte[] v) => _VertexAttribI4bvEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4bvEXT(uint index, void* v) => _VertexAttribI4bvEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4bvEXT(uint index, IntPtr v) => _VertexAttribI4bvEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4i(uint index, int x, int y, int z, int w) => _VertexAttribI4i(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4iEXT(uint index, int x, int y, int z, int w) => _VertexAttribI4iEXT(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4iv(uint index, int[] v) => _VertexAttribI4iv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4iv(uint index, void* v) => _VertexAttribI4iv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4iv(uint index, IntPtr v) => _VertexAttribI4iv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4ivEXT(uint index, int[] v) => _VertexAttribI4ivEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4ivEXT(uint index, void* v) => _VertexAttribI4ivEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4ivEXT(uint index, IntPtr v) => _VertexAttribI4ivEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4sv(uint index, short[] v) => _VertexAttribI4sv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4sv(uint index, void* v) => _VertexAttribI4sv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4sv(uint index, IntPtr v) => _VertexAttribI4sv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4svEXT(uint index, short[] v) => _VertexAttribI4svEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4svEXT(uint index, void* v) => _VertexAttribI4svEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4svEXT(uint index, IntPtr v) => _VertexAttribI4svEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4ubv(uint index, byte[] v) => _VertexAttribI4ubv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4ubv(uint index, void* v) => _VertexAttribI4ubv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4ubv(uint index, IntPtr v) => _VertexAttribI4ubv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4ubvEXT(uint index, byte[] v) => _VertexAttribI4ubvEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4ubvEXT(uint index, void* v) => _VertexAttribI4ubvEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4ubvEXT(uint index, IntPtr v) => _VertexAttribI4ubvEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4ui(uint index, uint x, uint y, uint z, uint w) => _VertexAttribI4ui(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4uiEXT(uint index, uint x, uint y, uint z, uint w) => _VertexAttribI4uiEXT(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4uiv(uint index, uint[] v) => _VertexAttribI4uiv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4uiv(uint index, void* v) => _VertexAttribI4uiv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4uiv(uint index, IntPtr v) => _VertexAttribI4uiv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4uivEXT(uint index, uint[] v) => _VertexAttribI4uivEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4uivEXT(uint index, void* v) => _VertexAttribI4uivEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4uivEXT(uint index, IntPtr v) => _VertexAttribI4uivEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4usv(uint index, ushort[] v) => _VertexAttribI4usv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4usv(uint index, void* v) => _VertexAttribI4usv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4usv(uint index, IntPtr v) => _VertexAttribI4usv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4usvEXT(uint index, ushort[] v) => _VertexAttribI4usvEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4usvEXT(uint index, void* v) => _VertexAttribI4usvEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribI4usvEXT(uint index, IntPtr v) => _VertexAttribI4usvEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribIFormat(uint attribindex, int size, VertexAttribIType type, uint relativeoffset) => _VertexAttribIFormat(attribindex, size, type, relativeoffset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribIFormatNV(uint index, int size, VertexAttribIType type, int stride) => _VertexAttribIFormatNV(index, size, type, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribIPointer(uint index, int size, VertexAttribIType type, int stride, IntPtr pointer) => _VertexAttribIPointer(index, size, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribIPointerEXT(uint index, int size, VertexAttribIType type, int stride, IntPtr pointer) => _VertexAttribIPointerEXT(index, size, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1d(uint index, double x) => _VertexAttribL1d(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1dEXT(uint index, double x) => _VertexAttribL1dEXT(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1dv(uint index, double[] v) => _VertexAttribL1dv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1dv(uint index, void* v) => _VertexAttribL1dv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1dv(uint index, IntPtr v) => _VertexAttribL1dv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1dvEXT(uint index, double[] v) => _VertexAttribL1dvEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1dvEXT(uint index, void* v) => _VertexAttribL1dvEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1dvEXT(uint index, IntPtr v) => _VertexAttribL1dvEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1i64NV(uint index, Int64 x) => _VertexAttribL1i64NV(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1i64vNV(uint index, Int64[] v) => _VertexAttribL1i64vNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1i64vNV(uint index, void* v) => _VertexAttribL1i64vNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1i64vNV(uint index, IntPtr v) => _VertexAttribL1i64vNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1ui64ARB(uint index, UInt64 x) => _VertexAttribL1ui64ARB(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1ui64NV(uint index, UInt64 x) => _VertexAttribL1ui64NV(index, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1ui64vARB(uint index, UInt64[] v) => _VertexAttribL1ui64vARB(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1ui64vARB(uint index, void* v) => _VertexAttribL1ui64vARB_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1ui64vARB(uint index, IntPtr v) => _VertexAttribL1ui64vARB_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1ui64vNV(uint index, UInt64[] v) => _VertexAttribL1ui64vNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1ui64vNV(uint index, void* v) => _VertexAttribL1ui64vNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL1ui64vNV(uint index, IntPtr v) => _VertexAttribL1ui64vNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2d(uint index, double x, double y) => _VertexAttribL2d(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2dEXT(uint index, double x, double y) => _VertexAttribL2dEXT(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2dv(uint index, double[] v) => _VertexAttribL2dv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2dv(uint index, void* v) => _VertexAttribL2dv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2dv(uint index, IntPtr v) => _VertexAttribL2dv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2dvEXT(uint index, double[] v) => _VertexAttribL2dvEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2dvEXT(uint index, void* v) => _VertexAttribL2dvEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2dvEXT(uint index, IntPtr v) => _VertexAttribL2dvEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2i64NV(uint index, Int64 x, Int64 y) => _VertexAttribL2i64NV(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2i64vNV(uint index, Int64[] v) => _VertexAttribL2i64vNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2i64vNV(uint index, void* v) => _VertexAttribL2i64vNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2i64vNV(uint index, IntPtr v) => _VertexAttribL2i64vNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2ui64NV(uint index, UInt64 x, UInt64 y) => _VertexAttribL2ui64NV(index, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2ui64vNV(uint index, UInt64[] v) => _VertexAttribL2ui64vNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2ui64vNV(uint index, void* v) => _VertexAttribL2ui64vNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL2ui64vNV(uint index, IntPtr v) => _VertexAttribL2ui64vNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3d(uint index, double x, double y, double z) => _VertexAttribL3d(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3dEXT(uint index, double x, double y, double z) => _VertexAttribL3dEXT(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3dv(uint index, double[] v) => _VertexAttribL3dv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3dv(uint index, void* v) => _VertexAttribL3dv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3dv(uint index, IntPtr v) => _VertexAttribL3dv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3dvEXT(uint index, double[] v) => _VertexAttribL3dvEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3dvEXT(uint index, void* v) => _VertexAttribL3dvEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3dvEXT(uint index, IntPtr v) => _VertexAttribL3dvEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3i64NV(uint index, Int64 x, Int64 y, Int64 z) => _VertexAttribL3i64NV(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3i64vNV(uint index, Int64[] v) => _VertexAttribL3i64vNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3i64vNV(uint index, void* v) => _VertexAttribL3i64vNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3i64vNV(uint index, IntPtr v) => _VertexAttribL3i64vNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3ui64NV(uint index, UInt64 x, UInt64 y, UInt64 z) => _VertexAttribL3ui64NV(index, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3ui64vNV(uint index, UInt64[] v) => _VertexAttribL3ui64vNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3ui64vNV(uint index, void* v) => _VertexAttribL3ui64vNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL3ui64vNV(uint index, IntPtr v) => _VertexAttribL3ui64vNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4d(uint index, double x, double y, double z, double w) => _VertexAttribL4d(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4dEXT(uint index, double x, double y, double z, double w) => _VertexAttribL4dEXT(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4dv(uint index, double[] v) => _VertexAttribL4dv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4dv(uint index, void* v) => _VertexAttribL4dv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4dv(uint index, IntPtr v) => _VertexAttribL4dv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4dvEXT(uint index, double[] v) => _VertexAttribL4dvEXT(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4dvEXT(uint index, void* v) => _VertexAttribL4dvEXT_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4dvEXT(uint index, IntPtr v) => _VertexAttribL4dvEXT_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4i64NV(uint index, Int64 x, Int64 y, Int64 z, Int64 w) => _VertexAttribL4i64NV(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4i64vNV(uint index, Int64[] v) => _VertexAttribL4i64vNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4i64vNV(uint index, void* v) => _VertexAttribL4i64vNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4i64vNV(uint index, IntPtr v) => _VertexAttribL4i64vNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4ui64NV(uint index, UInt64 x, UInt64 y, UInt64 z, UInt64 w) => _VertexAttribL4ui64NV(index, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4ui64vNV(uint index, UInt64[] v) => _VertexAttribL4ui64vNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4ui64vNV(uint index, void* v) => _VertexAttribL4ui64vNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribL4ui64vNV(uint index, IntPtr v) => _VertexAttribL4ui64vNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribLFormat(uint attribindex, int size, VertexAttribLType type, uint relativeoffset) => _VertexAttribLFormat(attribindex, size, type, relativeoffset);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribLFormatNV(uint index, int size, VertexAttribLType type, int stride) => _VertexAttribLFormatNV(index, size, type, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribLPointer(uint index, int size, VertexAttribLType type, int stride, IntPtr pointer) => _VertexAttribLPointer(index, size, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribLPointerEXT(uint index, int size, VertexAttribLType type, int stride, IntPtr pointer) => _VertexAttribLPointerEXT(index, size, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP1ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => _VertexAttribP1ui(index, type, normalized, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP1uiv(uint index, VertexAttribPointerType type, bool normalized, uint[] value) => _VertexAttribP1uiv(index, type, normalized, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP1uiv(uint index, VertexAttribPointerType type, bool normalized, void* value) => _VertexAttribP1uiv_ptr(index, type, normalized, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP1uiv(uint index, VertexAttribPointerType type, bool normalized, IntPtr value) => _VertexAttribP1uiv_intptr(index, type, normalized, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP2ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => _VertexAttribP2ui(index, type, normalized, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP2uiv(uint index, VertexAttribPointerType type, bool normalized, uint[] value) => _VertexAttribP2uiv(index, type, normalized, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP2uiv(uint index, VertexAttribPointerType type, bool normalized, void* value) => _VertexAttribP2uiv_ptr(index, type, normalized, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP2uiv(uint index, VertexAttribPointerType type, bool normalized, IntPtr value) => _VertexAttribP2uiv_intptr(index, type, normalized, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP3ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => _VertexAttribP3ui(index, type, normalized, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP3uiv(uint index, VertexAttribPointerType type, bool normalized, uint[] value) => _VertexAttribP3uiv(index, type, normalized, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP3uiv(uint index, VertexAttribPointerType type, bool normalized, void* value) => _VertexAttribP3uiv_ptr(index, type, normalized, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP3uiv(uint index, VertexAttribPointerType type, bool normalized, IntPtr value) => _VertexAttribP3uiv_intptr(index, type, normalized, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP4ui(uint index, VertexAttribPointerType type, bool normalized, uint value) => _VertexAttribP4ui(index, type, normalized, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP4uiv(uint index, VertexAttribPointerType type, bool normalized, uint[] value) => _VertexAttribP4uiv(index, type, normalized, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP4uiv(uint index, VertexAttribPointerType type, bool normalized, void* value) => _VertexAttribP4uiv_ptr(index, type, normalized, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribP4uiv(uint index, VertexAttribPointerType type, bool normalized, IntPtr value) => _VertexAttribP4uiv_intptr(index, type, normalized, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribParameteriAMD(uint index, int pname, int param) => _VertexAttribParameteriAMD(index, pname, param);

        // ---

        /// <summary>
        /// glVertexAttribPointer, glVertexAttribIPointer and glVertexAttribLPointer            specify the            location and data format of the array of generic vertex attributes at index index            to use when rendering. size specifies the number of components per attribute and            must be 1, 2, 3, 4, or GL_BGRA. type specifies the data type            of each component, and stride specifies the byte stride from one attribute to the next,            allowing vertices and attributes to be packed into a single array or stored in separate arrays.
        /// For glVertexAttribPointer, if normalized is set to GL_TRUE,            it indicates that values stored in an integer format are to be mapped to the range [-1,1] (for signed values) or [0,1] (for            unsigned values) when they are accessed and converted to floating point. Otherwise, values will            be converted to floats directly without normalization.
        /// For glVertexAttribIPointer, only the integer types GL_BYTE,            GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT,            GL_INT, GL_UNSIGNED_INT are accepted. Values are always left as integer values.
        /// glVertexAttribLPointer specifies state for a generic vertex attribute array associated            with a shader attribute variable declared with 64-bit double precision components. type            must be GL_DOUBLE. index, size, and            stride behave as described for glVertexAttribPointer and            glVertexAttribIPointer.
        /// If pointer is not NULL, a non-zero named buffer object must be bound to the            GL_ARRAY_BUFFER target (see glBindBuffer),            otherwise an error is generated. pointer is treated as a byte offset into the buffer object's data store.            The buffer object binding (GL_ARRAY_BUFFER_BINDING) is saved as generic vertex attribute array            state (GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING) for index index.
        /// When a generic vertex attribute array is specified,            size, type,            normalized,            stride, and            pointer are saved as vertex array            state, in addition to the current vertex array buffer object binding.
        /// To enable and disable a generic vertex attribute array, call            glEnableVertexAttribArray and            glDisableVertexAttribArray with index.            If enabled, the generic vertex attribute array is used when glDrawArrays,            glMultiDrawArrays, glDrawElements,            glMultiDrawElements, or  glDrawRangeElements            is called.
        /// </summary>
        /// <param name="index">Specifies the index of the generic vertex            attribute to be modified.</param>
        /// <param name="size">Specifies the number of components per            generic vertex attribute. Must            be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA            is accepted by glVertexAttribPointer. The initial value is 4.</param>
        /// <param name="type">Specifies the data type of each component in            the array. The symbolic constants            GL_BYTE,            GL_UNSIGNED_BYTE,            GL_SHORT,            GL_UNSIGNED_SHORT,            GL_INT, and            GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally            GL_HALF_FLOAT,            GL_FLOAT,            GL_DOUBLE,            GL_FIXED,            GL_INT_2_10_10_10_REV,            GL_UNSIGNED_INT_2_10_10_10_REV and            GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer.            GL_DOUBLE is also accepted by glVertexAttribLPointer and is            the only token accepted by the type parameter for that function.            The initial value is GL_FLOAT.</param>
        /// <param name="normalized">For glVertexAttribPointer, specifies whether fixed-point data values            should be normalized (GL_TRUE)            or converted directly as fixed-point values            (GL_FALSE) when they are            accessed.</param>
        /// <param name="stride">Specifies the byte offset between consecutive            generic vertex attributes. If stride            is 0, the generic vertex attributes are            understood to be tightly packed in the            array. The initial value is 0.</param>
        /// <param name="pointer">Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the            buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribPointer(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, IntPtr pointer) => _VertexAttribPointer(index, size, type, normalized, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribPointerARB(uint index, int size, VertexAttribPointerType type, bool normalized, int stride, IntPtr pointer) => _VertexAttribPointerARB(index, size, type, normalized, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribPointerNV(uint index, int fsize, VertexAttribEnumNV type, int stride, IntPtr pointer) => _VertexAttribPointerNV(index, fsize, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs1dvNV(uint index, int count, double[] v) => _VertexAttribs1dvNV(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs1dvNV(uint index, int count, void* v) => _VertexAttribs1dvNV_ptr(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs1dvNV(uint index, int count, IntPtr v) => _VertexAttribs1dvNV_intptr(index, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs1fvNV(uint index, int count, float[] v) => _VertexAttribs1fvNV(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs1fvNV(uint index, int count, void* v) => _VertexAttribs1fvNV_ptr(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs1fvNV(uint index, int count, IntPtr v) => _VertexAttribs1fvNV_intptr(index, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs1hvNV(uint index, int n, float[] v) => _VertexAttribs1hvNV(index, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs1hvNV(uint index, int n, void* v) => _VertexAttribs1hvNV_ptr(index, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs1hvNV(uint index, int n, IntPtr v) => _VertexAttribs1hvNV_intptr(index, n, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs1svNV(uint index, int count, short[] v) => _VertexAttribs1svNV(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs1svNV(uint index, int count, void* v) => _VertexAttribs1svNV_ptr(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs1svNV(uint index, int count, IntPtr v) => _VertexAttribs1svNV_intptr(index, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs2dvNV(uint index, int count, double[] v) => _VertexAttribs2dvNV(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs2dvNV(uint index, int count, void* v) => _VertexAttribs2dvNV_ptr(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs2dvNV(uint index, int count, IntPtr v) => _VertexAttribs2dvNV_intptr(index, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs2fvNV(uint index, int count, float[] v) => _VertexAttribs2fvNV(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs2fvNV(uint index, int count, void* v) => _VertexAttribs2fvNV_ptr(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs2fvNV(uint index, int count, IntPtr v) => _VertexAttribs2fvNV_intptr(index, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs2hvNV(uint index, int n, float[] v) => _VertexAttribs2hvNV(index, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs2hvNV(uint index, int n, void* v) => _VertexAttribs2hvNV_ptr(index, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs2hvNV(uint index, int n, IntPtr v) => _VertexAttribs2hvNV_intptr(index, n, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs2svNV(uint index, int count, short[] v) => _VertexAttribs2svNV(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs2svNV(uint index, int count, void* v) => _VertexAttribs2svNV_ptr(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs2svNV(uint index, int count, IntPtr v) => _VertexAttribs2svNV_intptr(index, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs3dvNV(uint index, int count, double[] v) => _VertexAttribs3dvNV(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs3dvNV(uint index, int count, void* v) => _VertexAttribs3dvNV_ptr(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs3dvNV(uint index, int count, IntPtr v) => _VertexAttribs3dvNV_intptr(index, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs3fvNV(uint index, int count, float[] v) => _VertexAttribs3fvNV(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs3fvNV(uint index, int count, void* v) => _VertexAttribs3fvNV_ptr(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs3fvNV(uint index, int count, IntPtr v) => _VertexAttribs3fvNV_intptr(index, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs3hvNV(uint index, int n, float[] v) => _VertexAttribs3hvNV(index, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs3hvNV(uint index, int n, void* v) => _VertexAttribs3hvNV_ptr(index, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs3hvNV(uint index, int n, IntPtr v) => _VertexAttribs3hvNV_intptr(index, n, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs3svNV(uint index, int count, short[] v) => _VertexAttribs3svNV(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs3svNV(uint index, int count, void* v) => _VertexAttribs3svNV_ptr(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs3svNV(uint index, int count, IntPtr v) => _VertexAttribs3svNV_intptr(index, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs4dvNV(uint index, int count, double[] v) => _VertexAttribs4dvNV(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs4dvNV(uint index, int count, void* v) => _VertexAttribs4dvNV_ptr(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs4dvNV(uint index, int count, IntPtr v) => _VertexAttribs4dvNV_intptr(index, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs4fvNV(uint index, int count, float[] v) => _VertexAttribs4fvNV(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs4fvNV(uint index, int count, void* v) => _VertexAttribs4fvNV_ptr(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs4fvNV(uint index, int count, IntPtr v) => _VertexAttribs4fvNV_intptr(index, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs4hvNV(uint index, int n, float[] v) => _VertexAttribs4hvNV(index, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs4hvNV(uint index, int n, void* v) => _VertexAttribs4hvNV_ptr(index, n, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs4hvNV(uint index, int n, IntPtr v) => _VertexAttribs4hvNV_intptr(index, n, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs4svNV(uint index, int count, short[] v) => _VertexAttribs4svNV(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs4svNV(uint index, int count, void* v) => _VertexAttribs4svNV_ptr(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs4svNV(uint index, int count, IntPtr v) => _VertexAttribs4svNV_intptr(index, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs4ubvNV(uint index, int count, byte[] v) => _VertexAttribs4ubvNV(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs4ubvNV(uint index, int count, void* v) => _VertexAttribs4ubvNV_ptr(index, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexAttribs4ubvNV(uint index, int count, IntPtr v) => _VertexAttribs4ubvNV_intptr(index, count, v);

        // ---

        /// <summary>
        /// glVertexBindingDivisor and    glVertexArrayBindingDivisor modify the rate at which    generic vertex attributes advance when rendering multiple instances of    primitives in a single draw command. If divisor is    zero, the attributes using the buffer bound to    bindingindex advance once per vertex. If    divisor is non-zero, the attributes advance once    per divisor instances of the set(s) of vertices    being rendered. An attribute is referred to as    instanced if the corresponding    divisor value is non-zero.
        /// glVertexBindingDivisor uses currently bound    vertex array object , whereas    glVertexArrayBindingDivisor updates state of the    vertex array object with ID vaobj.
        /// </summary>
        /// <param name="vaobj">Specifies the name of the vertex array object for          glVertexArrayBindingDivisor function.</param>
        /// <param name="bindingindex">The index of the binding whose divisor to modify.</param>
        /// <param name="divisor">The new value for the instance step rate to apply.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexBindingDivisor(uint bindingindex, uint divisor) => _VertexBindingDivisor(bindingindex, divisor);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexBlendARB(int count) => _VertexBlendARB(count);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexBlendEnvfATI(VertexStreamATI pname, float param) => _VertexBlendEnvfATI(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexBlendEnviATI(VertexStreamATI pname, int param) => _VertexBlendEnviATI(pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexFormatNV(int size, VertexPointerType type, int stride) => _VertexFormatNV(size, type, stride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexP2ui(VertexPointerType type, uint value) => _VertexP2ui(type, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexP2uiv(VertexPointerType type, uint[] value) => _VertexP2uiv(type, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexP2uiv(VertexPointerType type, void* value) => _VertexP2uiv_ptr(type, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexP2uiv(VertexPointerType type, IntPtr value) => _VertexP2uiv_intptr(type, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexP3ui(VertexPointerType type, uint value) => _VertexP3ui(type, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexP3uiv(VertexPointerType type, uint[] value) => _VertexP3uiv(type, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexP3uiv(VertexPointerType type, void* value) => _VertexP3uiv_ptr(type, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexP3uiv(VertexPointerType type, IntPtr value) => _VertexP3uiv_intptr(type, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexP4ui(VertexPointerType type, uint value) => _VertexP4ui(type, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexP4uiv(VertexPointerType type, uint[] value) => _VertexP4uiv(type, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexP4uiv(VertexPointerType type, void* value) => _VertexP4uiv_ptr(type, value);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexP4uiv(VertexPointerType type, IntPtr value) => _VertexP4uiv_intptr(type, value);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexPointer(int size, VertexPointerType type, int stride, IntPtr pointer) => _VertexPointer(size, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexPointerEXT(int size, VertexPointerType type, int stride, int count, IntPtr pointer) => _VertexPointerEXT(size, type, stride, count, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexPointerListIBM(int size, VertexPointerType type, int stride, IntPtr* pointer, int ptrstride) => _VertexPointerListIBM(size, type, stride, pointer, ptrstride);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexPointervINTEL(int size, VertexPointerType type, IntPtr* pointer) => _VertexPointervINTEL(size, type, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1dATI(VertexStreamATI stream, double x) => _VertexStream1dATI(stream, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1dvATI(VertexStreamATI stream, double[] coords) => _VertexStream1dvATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1dvATI(VertexStreamATI stream, void* coords) => _VertexStream1dvATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1dvATI(VertexStreamATI stream, IntPtr coords) => _VertexStream1dvATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1fATI(VertexStreamATI stream, float x) => _VertexStream1fATI(stream, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1fvATI(VertexStreamATI stream, float[] coords) => _VertexStream1fvATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1fvATI(VertexStreamATI stream, void* coords) => _VertexStream1fvATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1fvATI(VertexStreamATI stream, IntPtr coords) => _VertexStream1fvATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1iATI(VertexStreamATI stream, int x) => _VertexStream1iATI(stream, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1ivATI(VertexStreamATI stream, int[] coords) => _VertexStream1ivATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1ivATI(VertexStreamATI stream, void* coords) => _VertexStream1ivATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1ivATI(VertexStreamATI stream, IntPtr coords) => _VertexStream1ivATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1sATI(VertexStreamATI stream, short x) => _VertexStream1sATI(stream, x);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1svATI(VertexStreamATI stream, short[] coords) => _VertexStream1svATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1svATI(VertexStreamATI stream, void* coords) => _VertexStream1svATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream1svATI(VertexStreamATI stream, IntPtr coords) => _VertexStream1svATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2dATI(VertexStreamATI stream, double x, double y) => _VertexStream2dATI(stream, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2dvATI(VertexStreamATI stream, double[] coords) => _VertexStream2dvATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2dvATI(VertexStreamATI stream, void* coords) => _VertexStream2dvATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2dvATI(VertexStreamATI stream, IntPtr coords) => _VertexStream2dvATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2fATI(VertexStreamATI stream, float x, float y) => _VertexStream2fATI(stream, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2fvATI(VertexStreamATI stream, float[] coords) => _VertexStream2fvATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2fvATI(VertexStreamATI stream, void* coords) => _VertexStream2fvATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2fvATI(VertexStreamATI stream, IntPtr coords) => _VertexStream2fvATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2iATI(VertexStreamATI stream, int x, int y) => _VertexStream2iATI(stream, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2ivATI(VertexStreamATI stream, int[] coords) => _VertexStream2ivATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2ivATI(VertexStreamATI stream, void* coords) => _VertexStream2ivATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2ivATI(VertexStreamATI stream, IntPtr coords) => _VertexStream2ivATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2sATI(VertexStreamATI stream, short x, short y) => _VertexStream2sATI(stream, x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2svATI(VertexStreamATI stream, short[] coords) => _VertexStream2svATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2svATI(VertexStreamATI stream, void* coords) => _VertexStream2svATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream2svATI(VertexStreamATI stream, IntPtr coords) => _VertexStream2svATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3dATI(VertexStreamATI stream, double x, double y, double z) => _VertexStream3dATI(stream, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3dvATI(VertexStreamATI stream, double[] coords) => _VertexStream3dvATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3dvATI(VertexStreamATI stream, void* coords) => _VertexStream3dvATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3dvATI(VertexStreamATI stream, IntPtr coords) => _VertexStream3dvATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3fATI(VertexStreamATI stream, float x, float y, float z) => _VertexStream3fATI(stream, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3fvATI(VertexStreamATI stream, float[] coords) => _VertexStream3fvATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3fvATI(VertexStreamATI stream, void* coords) => _VertexStream3fvATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3fvATI(VertexStreamATI stream, IntPtr coords) => _VertexStream3fvATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3iATI(VertexStreamATI stream, int x, int y, int z) => _VertexStream3iATI(stream, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3ivATI(VertexStreamATI stream, int[] coords) => _VertexStream3ivATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3ivATI(VertexStreamATI stream, void* coords) => _VertexStream3ivATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3ivATI(VertexStreamATI stream, IntPtr coords) => _VertexStream3ivATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3sATI(VertexStreamATI stream, short x, short y, short z) => _VertexStream3sATI(stream, x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3svATI(VertexStreamATI stream, short[] coords) => _VertexStream3svATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3svATI(VertexStreamATI stream, void* coords) => _VertexStream3svATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream3svATI(VertexStreamATI stream, IntPtr coords) => _VertexStream3svATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4dATI(VertexStreamATI stream, double x, double y, double z, double w) => _VertexStream4dATI(stream, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4dvATI(VertexStreamATI stream, double[] coords) => _VertexStream4dvATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4dvATI(VertexStreamATI stream, void* coords) => _VertexStream4dvATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4dvATI(VertexStreamATI stream, IntPtr coords) => _VertexStream4dvATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4fATI(VertexStreamATI stream, float x, float y, float z, float w) => _VertexStream4fATI(stream, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4fvATI(VertexStreamATI stream, float[] coords) => _VertexStream4fvATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4fvATI(VertexStreamATI stream, void* coords) => _VertexStream4fvATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4fvATI(VertexStreamATI stream, IntPtr coords) => _VertexStream4fvATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4iATI(VertexStreamATI stream, int x, int y, int z, int w) => _VertexStream4iATI(stream, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4ivATI(VertexStreamATI stream, int[] coords) => _VertexStream4ivATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4ivATI(VertexStreamATI stream, void* coords) => _VertexStream4ivATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4ivATI(VertexStreamATI stream, IntPtr coords) => _VertexStream4ivATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4sATI(VertexStreamATI stream, short x, short y, short z, short w) => _VertexStream4sATI(stream, x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4svATI(VertexStreamATI stream, short[] coords) => _VertexStream4svATI(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4svATI(VertexStreamATI stream, void* coords) => _VertexStream4svATI_ptr(stream, coords);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexStream4svATI(VertexStreamATI stream, IntPtr coords) => _VertexStream4svATI_intptr(stream, coords);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexWeightPointerEXT(int size, VertexWeightPointerTypeEXT type, int stride, IntPtr pointer) => _VertexWeightPointerEXT(size, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexWeightfEXT(float weight) => _VertexWeightfEXT(weight);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexWeightfvEXT(float[] weight) => _VertexWeightfvEXT(weight);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexWeightfvEXT(void* weight) => _VertexWeightfvEXT_ptr(weight);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexWeightfvEXT(IntPtr weight) => _VertexWeightfvEXT_intptr(weight);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexWeighthNV(float weight) => _VertexWeighthNV(weight);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexWeighthvNV(float[] weight) => _VertexWeighthvNV(weight);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexWeighthvNV(void* weight) => _VertexWeighthvNV_ptr(weight);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VertexWeighthvNV(IntPtr weight) => _VertexWeighthvNV_intptr(weight);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int VideoCaptureNV(uint video_capture_slot, uint[] sequence_num, UInt64[] capture_time) => _VideoCaptureNV(video_capture_slot, sequence_num, capture_time);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int VideoCaptureNV(uint video_capture_slot, void* sequence_num, void* capture_time) => _VideoCaptureNV_ptr(video_capture_slot, sequence_num, capture_time);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int VideoCaptureNV(uint video_capture_slot, IntPtr sequence_num, IntPtr capture_time) => _VideoCaptureNV_intptr(video_capture_slot, sequence_num, capture_time);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VideoCaptureStreamParameterdvNV(uint video_capture_slot, uint stream, int pname, double[] @params) => _VideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VideoCaptureStreamParameterdvNV(uint video_capture_slot, uint stream, int pname, void* @params) => _VideoCaptureStreamParameterdvNV_ptr(video_capture_slot, stream, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VideoCaptureStreamParameterdvNV(uint video_capture_slot, uint stream, int pname, IntPtr @params) => _VideoCaptureStreamParameterdvNV_intptr(video_capture_slot, stream, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VideoCaptureStreamParameterfvNV(uint video_capture_slot, uint stream, int pname, float[] @params) => _VideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VideoCaptureStreamParameterfvNV(uint video_capture_slot, uint stream, int pname, void* @params) => _VideoCaptureStreamParameterfvNV_ptr(video_capture_slot, stream, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VideoCaptureStreamParameterfvNV(uint video_capture_slot, uint stream, int pname, IntPtr @params) => _VideoCaptureStreamParameterfvNV_intptr(video_capture_slot, stream, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VideoCaptureStreamParameterivNV(uint video_capture_slot, uint stream, int pname, int[] @params) => _VideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VideoCaptureStreamParameterivNV(uint video_capture_slot, uint stream, int pname, void* @params) => _VideoCaptureStreamParameterivNV_ptr(video_capture_slot, stream, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void VideoCaptureStreamParameterivNV(uint video_capture_slot, uint stream, int pname, IntPtr @params) => _VideoCaptureStreamParameterivNV_intptr(video_capture_slot, stream, pname, @params);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Viewport(int x, int y, int width, int height) => _Viewport(x, y, width, height);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportArrayv(uint first, int count, float[] v) => _ViewportArrayv(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportArrayv(uint first, int count, void* v) => _ViewportArrayv_ptr(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportArrayv(uint first, int count, IntPtr v) => _ViewportArrayv_intptr(first, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportArrayvNV(uint first, int count, float[] v) => _ViewportArrayvNV(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportArrayvNV(uint first, int count, void* v) => _ViewportArrayvNV_ptr(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportArrayvNV(uint first, int count, IntPtr v) => _ViewportArrayvNV_intptr(first, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportArrayvOES(uint first, int count, float[] v) => _ViewportArrayvOES(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportArrayvOES(uint first, int count, void* v) => _ViewportArrayvOES_ptr(first, count, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportArrayvOES(uint first, int count, IntPtr v) => _ViewportArrayvOES_intptr(first, count, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportIndexedf(uint index, float x, float y, float w, float h) => _ViewportIndexedf(index, x, y, w, h);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportIndexedfOES(uint index, float x, float y, float w, float h) => _ViewportIndexedfOES(index, x, y, w, h);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportIndexedfNV(uint index, float x, float y, float w, float h) => _ViewportIndexedfNV(index, x, y, w, h);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportIndexedfv(uint index, float[] v) => _ViewportIndexedfv(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportIndexedfv(uint index, void* v) => _ViewportIndexedfv_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportIndexedfv(uint index, IntPtr v) => _ViewportIndexedfv_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportIndexedfvOES(uint index, float[] v) => _ViewportIndexedfvOES(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportIndexedfvOES(uint index, void* v) => _ViewportIndexedfvOES_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportIndexedfvOES(uint index, IntPtr v) => _ViewportIndexedfvOES_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportIndexedfvNV(uint index, float[] v) => _ViewportIndexedfvNV(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportIndexedfvNV(uint index, void* v) => _ViewportIndexedfvNV_ptr(index, v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportIndexedfvNV(uint index, IntPtr v) => _ViewportIndexedfvNV_intptr(index, v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportPositionWScaleNV(uint index, float xcoeff, float ycoeff) => _ViewportPositionWScaleNV(index, xcoeff, ycoeff);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ViewportSwizzleNV(uint index, int swizzlex, int swizzley, int swizzlez, int swizzlew) => _ViewportSwizzleNV(index, swizzlex, swizzley, swizzlez, swizzlew);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint[] buffers, uint numTextureBarriers, uint[] textures, TextureLayout[] srcLayouts) => _WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, void* buffers, uint numTextureBarriers, void* textures, void* srcLayouts) => _WaitSemaphoreEXT_ptr(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, IntPtr buffers, uint numTextureBarriers, IntPtr textures, IntPtr srcLayouts) => _WaitSemaphoreEXT_intptr(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WaitSemaphoreui64NVX(uint waitGpu, int fenceObjectCount, uint[] semaphoreArray, UInt64[] fenceValueArray) => _WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WaitSemaphoreui64NVX(uint waitGpu, int fenceObjectCount, void* semaphoreArray, void* fenceValueArray) => _WaitSemaphoreui64NVX_ptr(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WaitSemaphoreui64NVX(uint waitGpu, int fenceObjectCount, IntPtr semaphoreArray, IntPtr fenceValueArray) => _WaitSemaphoreui64NVX_intptr(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);

        // ---

        /// <summary>
        /// glWaitSync causes the GL server to block and wait until sync becomes signaled. sync            is the name of an existing sync object upon which to wait. flags and timeout are currently not used and            must be set to zero and the special value GL_TIMEOUT_IGNORED, respectivelyflags and            timeout are placeholders for anticipated future extensions of sync object capabilities. They must have these reserved values in            order that existing code calling glWaitSync operate properly in the presence of such extensions.. glWaitSync will always wait no longer than an implementation-dependent timeout. The            duration of this timeout in nanoseconds may be queried by calling glGet with the            parameter GL_MAX_SERVER_WAIT_TIMEOUT. There is currently no way to determine whether glWaitSync unblocked            because the timeout expired or because the sync object being waited on was signaled.
        /// If an error occurs, glWaitSync does not cause the GL server to block.
        /// </summary>
        /// <param name="sync">Specifies the sync object whose status to wait on.</param>
        /// <param name="flags">A bitfield controlling the command flushing behavior. flags may be zero.</param>
        /// <param name="timeout">Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WaitSync(int sync, int flags, UInt64 timeout) => _WaitSync(sync, flags, timeout);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WaitSyncAPPLE(int sync, int flags, UInt64 timeout) => _WaitSyncAPPLE(sync, flags, timeout);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightPathsNV(uint resultPath, int numPaths, uint[] paths, float[] weights) => _WeightPathsNV(resultPath, numPaths, paths, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightPathsNV(uint resultPath, int numPaths, void* paths, void* weights) => _WeightPathsNV_ptr(resultPath, numPaths, paths, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightPathsNV(uint resultPath, int numPaths, IntPtr paths, IntPtr weights) => _WeightPathsNV_intptr(resultPath, numPaths, paths, weights);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightPointerARB(int size, WeightPointerTypeARB type, int stride, IntPtr pointer) => _WeightPointerARB(size, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightPointerOES(int size, int type, int stride, IntPtr pointer) => _WeightPointerOES(size, type, stride, pointer);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightbvARB(int size, sbyte[] weights) => _WeightbvARB(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightbvARB(int size, void* weights) => _WeightbvARB_ptr(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightbvARB(int size, IntPtr weights) => _WeightbvARB_intptr(size, weights);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightdvARB(int size, double[] weights) => _WeightdvARB(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightdvARB(int size, void* weights) => _WeightdvARB_ptr(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightdvARB(int size, IntPtr weights) => _WeightdvARB_intptr(size, weights);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightfvARB(int size, float[] weights) => _WeightfvARB(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightfvARB(int size, void* weights) => _WeightfvARB_ptr(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightfvARB(int size, IntPtr weights) => _WeightfvARB_intptr(size, weights);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightivARB(int size, int[] weights) => _WeightivARB(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightivARB(int size, void* weights) => _WeightivARB_ptr(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightivARB(int size, IntPtr weights) => _WeightivARB_intptr(size, weights);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightsvARB(int size, short[] weights) => _WeightsvARB(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightsvARB(int size, void* weights) => _WeightsvARB_ptr(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightsvARB(int size, IntPtr weights) => _WeightsvARB_intptr(size, weights);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightubvARB(int size, byte[] weights) => _WeightubvARB(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightubvARB(int size, void* weights) => _WeightubvARB_ptr(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightubvARB(int size, IntPtr weights) => _WeightubvARB_intptr(size, weights);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightuivARB(int size, uint[] weights) => _WeightuivARB(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightuivARB(int size, void* weights) => _WeightuivARB_ptr(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightuivARB(int size, IntPtr weights) => _WeightuivARB_intptr(size, weights);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightusvARB(int size, ushort[] weights) => _WeightusvARB(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightusvARB(int size, void* weights) => _WeightusvARB_ptr(size, weights);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WeightusvARB(int size, IntPtr weights) => _WeightusvARB_intptr(size, weights);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2d(double x, double y) => _WindowPos2d(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2dARB(double x, double y) => _WindowPos2dARB(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2dMESA(double x, double y) => _WindowPos2dMESA(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2dv(double[] v) => _WindowPos2dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2dv(void* v) => _WindowPos2dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2dv(IntPtr v) => _WindowPos2dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2dvARB(double[] v) => _WindowPos2dvARB(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2dvARB(void* v) => _WindowPos2dvARB_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2dvARB(IntPtr v) => _WindowPos2dvARB_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2dvMESA(double[] v) => _WindowPos2dvMESA(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2dvMESA(void* v) => _WindowPos2dvMESA_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2dvMESA(IntPtr v) => _WindowPos2dvMESA_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2f(float x, float y) => _WindowPos2f(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2fARB(float x, float y) => _WindowPos2fARB(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2fMESA(float x, float y) => _WindowPos2fMESA(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2fv(float[] v) => _WindowPos2fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2fv(void* v) => _WindowPos2fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2fv(IntPtr v) => _WindowPos2fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2fvARB(float[] v) => _WindowPos2fvARB(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2fvARB(void* v) => _WindowPos2fvARB_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2fvARB(IntPtr v) => _WindowPos2fvARB_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2fvMESA(float[] v) => _WindowPos2fvMESA(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2fvMESA(void* v) => _WindowPos2fvMESA_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2fvMESA(IntPtr v) => _WindowPos2fvMESA_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2i(int x, int y) => _WindowPos2i(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2iARB(int x, int y) => _WindowPos2iARB(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2iMESA(int x, int y) => _WindowPos2iMESA(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2iv(int[] v) => _WindowPos2iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2iv(void* v) => _WindowPos2iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2iv(IntPtr v) => _WindowPos2iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2ivARB(int[] v) => _WindowPos2ivARB(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2ivARB(void* v) => _WindowPos2ivARB_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2ivARB(IntPtr v) => _WindowPos2ivARB_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2ivMESA(int[] v) => _WindowPos2ivMESA(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2ivMESA(void* v) => _WindowPos2ivMESA_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2ivMESA(IntPtr v) => _WindowPos2ivMESA_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2s(short x, short y) => _WindowPos2s(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2sARB(short x, short y) => _WindowPos2sARB(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2sMESA(short x, short y) => _WindowPos2sMESA(x, y);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2sv(short[] v) => _WindowPos2sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2sv(void* v) => _WindowPos2sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2sv(IntPtr v) => _WindowPos2sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2svARB(short[] v) => _WindowPos2svARB(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2svARB(void* v) => _WindowPos2svARB_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2svARB(IntPtr v) => _WindowPos2svARB_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2svMESA(short[] v) => _WindowPos2svMESA(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2svMESA(void* v) => _WindowPos2svMESA_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos2svMESA(IntPtr v) => _WindowPos2svMESA_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3d(double x, double y, double z) => _WindowPos3d(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3dARB(double x, double y, double z) => _WindowPos3dARB(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3dMESA(double x, double y, double z) => _WindowPos3dMESA(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3dv(double[] v) => _WindowPos3dv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3dv(void* v) => _WindowPos3dv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3dv(IntPtr v) => _WindowPos3dv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3dvARB(double[] v) => _WindowPos3dvARB(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3dvARB(void* v) => _WindowPos3dvARB_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3dvARB(IntPtr v) => _WindowPos3dvARB_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3dvMESA(double[] v) => _WindowPos3dvMESA(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3dvMESA(void* v) => _WindowPos3dvMESA_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3dvMESA(IntPtr v) => _WindowPos3dvMESA_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3f(float x, float y, float z) => _WindowPos3f(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3fARB(float x, float y, float z) => _WindowPos3fARB(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3fMESA(float x, float y, float z) => _WindowPos3fMESA(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3fv(float[] v) => _WindowPos3fv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3fv(void* v) => _WindowPos3fv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3fv(IntPtr v) => _WindowPos3fv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3fvARB(float[] v) => _WindowPos3fvARB(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3fvARB(void* v) => _WindowPos3fvARB_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3fvARB(IntPtr v) => _WindowPos3fvARB_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3fvMESA(float[] v) => _WindowPos3fvMESA(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3fvMESA(void* v) => _WindowPos3fvMESA_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3fvMESA(IntPtr v) => _WindowPos3fvMESA_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3i(int x, int y, int z) => _WindowPos3i(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3iARB(int x, int y, int z) => _WindowPos3iARB(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3iMESA(int x, int y, int z) => _WindowPos3iMESA(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3iv(int[] v) => _WindowPos3iv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3iv(void* v) => _WindowPos3iv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3iv(IntPtr v) => _WindowPos3iv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3ivARB(int[] v) => _WindowPos3ivARB(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3ivARB(void* v) => _WindowPos3ivARB_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3ivARB(IntPtr v) => _WindowPos3ivARB_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3ivMESA(int[] v) => _WindowPos3ivMESA(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3ivMESA(void* v) => _WindowPos3ivMESA_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3ivMESA(IntPtr v) => _WindowPos3ivMESA_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3s(short x, short y, short z) => _WindowPos3s(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3sARB(short x, short y, short z) => _WindowPos3sARB(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3sMESA(short x, short y, short z) => _WindowPos3sMESA(x, y, z);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3sv(short[] v) => _WindowPos3sv(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3sv(void* v) => _WindowPos3sv_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3sv(IntPtr v) => _WindowPos3sv_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3svARB(short[] v) => _WindowPos3svARB(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3svARB(void* v) => _WindowPos3svARB_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3svARB(IntPtr v) => _WindowPos3svARB_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3svMESA(short[] v) => _WindowPos3svMESA(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3svMESA(void* v) => _WindowPos3svMESA_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos3svMESA(IntPtr v) => _WindowPos3svMESA_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4dMESA(double x, double y, double z, double w) => _WindowPos4dMESA(x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4dvMESA(double[] v) => _WindowPos4dvMESA(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4dvMESA(void* v) => _WindowPos4dvMESA_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4dvMESA(IntPtr v) => _WindowPos4dvMESA_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4fMESA(float x, float y, float z, float w) => _WindowPos4fMESA(x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4fvMESA(float[] v) => _WindowPos4fvMESA(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4fvMESA(void* v) => _WindowPos4fvMESA_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4fvMESA(IntPtr v) => _WindowPos4fvMESA_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4iMESA(int x, int y, int z, int w) => _WindowPos4iMESA(x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4ivMESA(int[] v) => _WindowPos4ivMESA(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4ivMESA(void* v) => _WindowPos4ivMESA_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4ivMESA(IntPtr v) => _WindowPos4ivMESA_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4sMESA(short x, short y, short z, short w) => _WindowPos4sMESA(x, y, z, w);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4svMESA(short[] v) => _WindowPos4svMESA(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4svMESA(void* v) => _WindowPos4svMESA_ptr(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowPos4svMESA(IntPtr v) => _WindowPos4svMESA_intptr(v);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowRectanglesEXT(int mode, int count, int[] box) => _WindowRectanglesEXT(mode, count, box);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowRectanglesEXT(int mode, int count, void* box) => _WindowRectanglesEXT_ptr(mode, count, box);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WindowRectanglesEXT(int mode, int count, IntPtr box) => _WindowRectanglesEXT_intptr(mode, count, box);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WriteMaskEXT(uint res, uint @in, VertexShaderWriteMaskEXT outX, VertexShaderWriteMaskEXT outY, VertexShaderWriteMaskEXT outZ, VertexShaderWriteMaskEXT outW) => _WriteMaskEXT(res, @in, outX, outY, outZ, outW);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void DrawVkImageNV(UInt64 vkImage, uint sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) => _DrawVkImageNV(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public VulkanProc GetVkProcAddrNV(string name) => _GetVkProcAddrNV(name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public VulkanProc GetVkProcAddrNV(void* name) => _GetVkProcAddrNV_ptr(name);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public VulkanProc GetVkProcAddrNV(IntPtr name) => _GetVkProcAddrNV_intptr(name);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WaitVkSemaphoreNV(UInt64 vkSemaphore) => _WaitVkSemaphoreNV(vkSemaphore);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SignalVkSemaphoreNV(UInt64 vkSemaphore) => _SignalVkSemaphoreNV(vkSemaphore);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void SignalVkFenceNV(UInt64 vkFence) => _SignalVkFenceNV(vkFence);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FramebufferParameteriMESA(FramebufferTarget target, FramebufferParameterName pname, int param) => _FramebufferParameteriMESA(target, pname, param);

        // ---

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferParameterivMESA(FramebufferTarget target, FramebufferAttachmentParameterName pname, int[] @params) => _GetFramebufferParameterivMESA(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferParameterivMESA(FramebufferTarget target, FramebufferAttachmentParameterName pname, void* @params) => _GetFramebufferParameterivMESA_ptr(target, pname, @params);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetFramebufferParameterivMESA(FramebufferTarget target, FramebufferAttachmentParameterName pname, IntPtr @params) => _GetFramebufferParameterivMESA_intptr(target, pname, @params);

    }

}
