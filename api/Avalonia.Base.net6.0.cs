//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     GenAPI Version: 7.0.8.6004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace Avalonia
{
    public partial class AttachedProperty<TValue> : Avalonia.StyledProperty<TValue>
    {
        internal AttachedProperty() { }
        public new Avalonia.AttachedProperty<TValue> AddOwner<TOwner>(Avalonia.StyledPropertyMetadata<TValue>? metadata = null) where TOwner : Avalonia.AvaloniaObject { throw null; }
    }
    public partial class AvaloniaInternalException : System.Exception
    {
        public AvaloniaInternalException(string message) { }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class AvaloniaLocator : Avalonia.IAvaloniaDependencyResolver
    {
        public AvaloniaLocator() { }
        public AvaloniaLocator(Avalonia.IAvaloniaDependencyResolver parentScope) { }
        public static Avalonia.IAvaloniaDependencyResolver Current { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public static Avalonia.AvaloniaLocator CurrentMutable { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.AvaloniaLocator BindToSelfSingleton<T>() where T : class, new() { throw null; }
        public Avalonia.AvaloniaLocator BindToSelf<T>(T constant) { throw null; }
        public Avalonia.AvaloniaLocator.RegistrationHelper<T> Bind<T>() { throw null; }
        public static System.IDisposable EnterScope() { throw null; }
        public object? GetService(System.Type t) { throw null; }
        public partial class RegistrationHelper<TService>
        {
            public RegistrationHelper(Avalonia.AvaloniaLocator locator) { }
            public Avalonia.AvaloniaLocator ToConstant<TImpl>(TImpl constant) where TImpl : TService { throw null; }
            public Avalonia.AvaloniaLocator ToFunc<TImlp>(System.Func<TImlp> func) where TImlp : TService { throw null; }
            public Avalonia.AvaloniaLocator ToLazy<TImlp>(System.Func<TImlp> func) where TImlp : TService { throw null; }
            public Avalonia.AvaloniaLocator ToSingleton<TImpl>() where TImpl : class, TService, new() { throw null; }
            public Avalonia.AvaloniaLocator ToTransient<TImpl>() where TImpl : class, TService, new() { throw null; }
        }
    }
    public partial class AvaloniaObject : System.ComponentModel.INotifyPropertyChanged
    {
        public AvaloniaObject() { }
        protected internal Avalonia.AvaloniaObject? InheritanceParent { get { throw null; } set { } }
        public object? this[Avalonia.AvaloniaProperty property] { get { throw null; } set { } }
        public Avalonia.Data.IBinding this[Avalonia.Data.IndexerDescriptor binding] { get { throw null; } set { } }
        public event System.EventHandler<Avalonia.AvaloniaPropertyChangedEventArgs>? PropertyChanged { add { } remove { } }
        event System.ComponentModel.PropertyChangedEventHandler? System.ComponentModel.INotifyPropertyChanged.PropertyChanged { add { } remove { } }
        public System.IDisposable Bind(Avalonia.AvaloniaProperty property, System.IObservable<object?> source, Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) { throw null; }
        public System.IDisposable Bind<T>(Avalonia.DirectPropertyBase<T> property, System.IObservable<Avalonia.Data.BindingValue<T>> source) { throw null; }
        public System.IDisposable Bind<T>(Avalonia.DirectPropertyBase<T> property, System.IObservable<object?> source) { throw null; }
        public System.IDisposable Bind<T>(Avalonia.DirectPropertyBase<T> property, System.IObservable<T> source) { throw null; }
        public System.IDisposable Bind<T>(Avalonia.StyledProperty<T> property, System.IObservable<Avalonia.Data.BindingValue<T>> source, Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) { throw null; }
        public System.IDisposable Bind<T>(Avalonia.StyledProperty<T> property, System.IObservable<object?> source, Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) { throw null; }
        public System.IDisposable Bind<T>(Avalonia.StyledProperty<T> property, System.IObservable<T> source, Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) { throw null; }
        public bool CheckAccess() { throw null; }
        public void ClearValue(Avalonia.AvaloniaProperty property) { }
        public void ClearValue<T>(Avalonia.AvaloniaProperty<T> property) { }
        public void ClearValue<T>(Avalonia.DirectPropertyBase<T> property) { }
        public void ClearValue<T>(Avalonia.StyledProperty<T> property) { }
        public void CoerceValue(Avalonia.AvaloniaProperty property) { }
        public sealed override bool Equals(object? obj) { throw null; }
        public Avalonia.Data.Optional<T> GetBaseValue<T>(Avalonia.StyledProperty<T> property) { throw null; }
        public sealed override int GetHashCode() { throw null; }
        public object? GetValue(Avalonia.AvaloniaProperty property) { throw null; }
        public T GetValue<T>(Avalonia.DirectPropertyBase<T> property) { throw null; }
        public T GetValue<T>(Avalonia.StyledProperty<T> property) { throw null; }
        public bool IsAnimating(Avalonia.AvaloniaProperty property) { throw null; }
        public bool IsSet(Avalonia.AvaloniaProperty property) { throw null; }
        protected virtual void OnPropertyChanged(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
        protected virtual void OnPropertyChangedCore(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
        protected void RaisePropertyChanged<T>(Avalonia.DirectPropertyBase<T> property, T oldValue, T newValue) { }
        protected bool SetAndRaise<T>(Avalonia.DirectPropertyBase<T> property, ref T field, T value) { throw null; }
        public void SetCurrentValue(Avalonia.AvaloniaProperty property, object? value) { }
        public void SetCurrentValue<T>(Avalonia.StyledProperty<T> property, T value) { }
        public System.IDisposable? SetValue(Avalonia.AvaloniaProperty property, object? value, Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) { throw null; }
        public void SetValue<T>(Avalonia.DirectPropertyBase<T> property, T value) { }
        public System.IDisposable? SetValue<T>(Avalonia.StyledProperty<T> property, T value, Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) { throw null; }
        protected virtual void UpdateDataValidation(Avalonia.AvaloniaProperty property, Avalonia.Data.BindingValueType state, System.Exception? error) { }
        public void VerifyAccess() { }
    }
    public static partial class AvaloniaObjectExtensions
    {
        public static System.IDisposable AddClassHandler<TTarget>(this System.IObservable<Avalonia.AvaloniaPropertyChangedEventArgs> observable, System.Action<TTarget, Avalonia.AvaloniaPropertyChangedEventArgs> action) where TTarget : Avalonia.AvaloniaObject { throw null; }
        public static System.IDisposable AddClassHandler<TTarget, TValue>(this System.IObservable<Avalonia.AvaloniaPropertyChangedEventArgs<TValue>> observable, System.Action<TTarget, Avalonia.AvaloniaPropertyChangedEventArgs<TValue>> action) where TTarget : Avalonia.AvaloniaObject { throw null; }
        public static System.IDisposable Bind(this Avalonia.AvaloniaObject target, Avalonia.AvaloniaProperty property, Avalonia.Data.IBinding binding, object? anchor = null) { throw null; }
        public static System.IDisposable Bind<T>(this Avalonia.AvaloniaObject target, Avalonia.AvaloniaProperty<T> property, System.IObservable<Avalonia.Data.BindingValue<T>> source, Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) { throw null; }
        public static System.IDisposable Bind<T>(this Avalonia.AvaloniaObject target, Avalonia.AvaloniaProperty<T> property, System.IObservable<T> source, Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) { throw null; }
        public static object? GetBaseValue(this Avalonia.AvaloniaObject target, Avalonia.AvaloniaProperty property) { throw null; }
        public static Avalonia.Data.Optional<T> GetBaseValue<T>(this Avalonia.AvaloniaObject target, Avalonia.AvaloniaProperty<T> property) { throw null; }
        public static System.IObservable<Avalonia.Data.BindingValue<object?>> GetBindingObservable(this Avalonia.AvaloniaObject o, Avalonia.AvaloniaProperty property) { throw null; }
        public static System.IObservable<Avalonia.Data.BindingValue<T>> GetBindingObservable<T>(this Avalonia.AvaloniaObject o, Avalonia.AvaloniaProperty<T> property) { throw null; }
        public static System.IObservable<Avalonia.Data.BindingValue<TResult>> GetBindingObservable<TSource, TResult>(this Avalonia.AvaloniaObject o, Avalonia.AvaloniaProperty<TSource> property, System.Func<TSource, TResult> converter) { throw null; }
        public static System.IObservable<object?> GetObservable(this Avalonia.AvaloniaObject o, Avalonia.AvaloniaProperty property) { throw null; }
        public static System.IObservable<T> GetObservable<T>(this Avalonia.AvaloniaObject o, Avalonia.AvaloniaProperty<T> property) { throw null; }
        public static System.IObservable<TResult> GetObservable<TSource, TResult>(this Avalonia.AvaloniaObject o, Avalonia.AvaloniaProperty<TSource> property, System.Func<TSource, TResult> converter) { throw null; }
        public static System.IObservable<Avalonia.AvaloniaPropertyChangedEventArgs> GetPropertyChangedObservable(this Avalonia.AvaloniaObject o, Avalonia.AvaloniaProperty property) { throw null; }
        public static T GetValue<T>(this Avalonia.AvaloniaObject target, Avalonia.AvaloniaProperty<T> property) { throw null; }
        public static Avalonia.Data.IBinding ToBinding<T>(this System.IObservable<T> source) { throw null; }
    }
    public abstract partial class AvaloniaProperty : Avalonia.Data.Core.IPropertyInfo, System.IEquatable<Avalonia.AvaloniaProperty>
    {
        internal AvaloniaProperty() { }
        public static readonly object UnsetValue;
        bool Avalonia.Data.Core.IPropertyInfo.CanGet { get { throw null; } }
        bool Avalonia.Data.Core.IPropertyInfo.CanSet { get { throw null; } }
        public System.IObservable<Avalonia.AvaloniaPropertyChangedEventArgs> Changed { get { throw null; } }
        public bool Inherits { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsAttached { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsDirect { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsReadOnly { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public string Name { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.Type OwnerType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.Type PropertyType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        object? Avalonia.Data.Core.IPropertyInfo.Get(object target) { throw null; }
        void Avalonia.Data.Core.IPropertyInfo.Set(object target, object? value) { }
        public Avalonia.Data.IndexerDescriptor Bind() { throw null; }
        public bool Equals(Avalonia.AvaloniaProperty? other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public Avalonia.AvaloniaPropertyMetadata GetMetadata(System.Type type) { throw null; }
        public Avalonia.AvaloniaPropertyMetadata GetMetadata<T>() where T : Avalonia.AvaloniaObject { throw null; }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("Implicit conversion methods are required for type conversion.")]
        public bool IsValidValue(object? value) { throw null; }
        public static bool operator ==(Avalonia.AvaloniaProperty? a, Avalonia.AvaloniaProperty? b) { throw null; }
        public static bool operator !=(Avalonia.AvaloniaProperty? a, Avalonia.AvaloniaProperty? b) { throw null; }
        public static Avalonia.Data.IndexerDescriptor operator !(Avalonia.AvaloniaProperty property) { throw null; }
        public static Avalonia.Data.IndexerDescriptor operator ~(Avalonia.AvaloniaProperty property) { throw null; }
        public static Avalonia.AttachedProperty<TValue> RegisterAttached<THost, TValue>(string name, System.Type ownerType, TValue defaultValue = null, bool inherits = false, Avalonia.Data.BindingMode defaultBindingMode = Avalonia.Data.BindingMode.OneWay, System.Func<TValue, bool>? validate = null, System.Func<Avalonia.AvaloniaObject, TValue, TValue>? coerce = null) where THost : Avalonia.AvaloniaObject { throw null; }
        public static Avalonia.AttachedProperty<TValue> RegisterAttached<TOwner, THost, TValue>(string name, TValue defaultValue = null, bool inherits = false, Avalonia.Data.BindingMode defaultBindingMode = Avalonia.Data.BindingMode.OneWay, System.Func<TValue, bool>? validate = null, System.Func<Avalonia.AvaloniaObject, TValue, TValue>? coerce = null) where THost : Avalonia.AvaloniaObject { throw null; }
        public static Avalonia.DirectProperty<TOwner, TValue> RegisterDirect<TOwner, TValue>(string name, System.Func<TOwner, TValue> getter, System.Action<TOwner, TValue>? setter = null, TValue unsetValue = null, Avalonia.Data.BindingMode defaultBindingMode = Avalonia.Data.BindingMode.OneWay, bool enableDataValidation = false) where TOwner : Avalonia.AvaloniaObject { throw null; }
        public static Avalonia.StyledProperty<TValue> Register<TOwner, TValue>(string name, TValue defaultValue = null, bool inherits = false, Avalonia.Data.BindingMode defaultBindingMode = Avalonia.Data.BindingMode.OneWay, System.Func<TValue, bool>? validate = null, System.Func<Avalonia.AvaloniaObject, TValue, TValue>? coerce = null, bool enableDataValidation = false) where TOwner : Avalonia.AvaloniaObject { throw null; }
        public override string ToString() { throw null; }
    }
    public abstract partial class AvaloniaPropertyChangedEventArgs : System.EventArgs
    {
        public AvaloniaPropertyChangedEventArgs(Avalonia.AvaloniaObject sender, Avalonia.Data.BindingPriority priority) { }
        public object? NewValue { get { throw null; } }
        public object? OldValue { get { throw null; } }
        public Avalonia.Data.BindingPriority Priority { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.AvaloniaProperty Property { get { throw null; } }
        public Avalonia.AvaloniaObject Sender { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        protected abstract object? GetNewValue();
        protected abstract object? GetOldValue();
        protected abstract Avalonia.AvaloniaProperty GetProperty();
    }
    public partial class AvaloniaPropertyChangedEventArgs<T> : Avalonia.AvaloniaPropertyChangedEventArgs
    {
        public AvaloniaPropertyChangedEventArgs(Avalonia.AvaloniaObject sender, Avalonia.AvaloniaProperty<T> property, Avalonia.Data.Optional<T> oldValue, Avalonia.Data.BindingValue<T> newValue, Avalonia.Data.BindingPriority priority) : base (default(Avalonia.AvaloniaObject), default(Avalonia.Data.BindingPriority)) { }
        public new Avalonia.Data.BindingValue<T> NewValue { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public new Avalonia.Data.Optional<T> OldValue { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public new Avalonia.AvaloniaProperty<T> Property { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        protected override object? GetNewValue() { throw null; }
        protected override object? GetOldValue() { throw null; }
        protected override Avalonia.AvaloniaProperty GetProperty() { throw null; }
    }
    public static partial class AvaloniaPropertyChangedExtensions
    {
        public static T GetNewValue<T>(this Avalonia.AvaloniaPropertyChangedEventArgs e) { throw null; }
        public static (T oldValue, T newValue) GetOldAndNewValue<T>(this Avalonia.AvaloniaPropertyChangedEventArgs e) { throw null; }
        public static T GetOldValue<T>(this Avalonia.AvaloniaPropertyChangedEventArgs e) { throw null; }
    }
    public abstract partial class AvaloniaPropertyMetadata
    {
        public AvaloniaPropertyMetadata(Avalonia.Data.BindingMode defaultBindingMode = Avalonia.Data.BindingMode.Default, bool? enableDataValidation = default(bool?)) { }
        public Avalonia.Data.BindingMode DefaultBindingMode { get { throw null; } }
        public bool? EnableDataValidation { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public abstract Avalonia.AvaloniaPropertyMetadata GenerateTypeSafeMetadata();
        public virtual void Merge(Avalonia.AvaloniaPropertyMetadata baseMetadata, Avalonia.AvaloniaProperty property) { }
    }
    public partial class AvaloniaPropertyRegistry
    {
        public AvaloniaPropertyRegistry() { }
        public static Avalonia.AvaloniaPropertyRegistry Instance { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.AvaloniaProperty? FindRegistered(Avalonia.AvaloniaObject o, string name) { throw null; }
        public Avalonia.AvaloniaProperty? FindRegistered(System.Type type, string name) { throw null; }
        public Avalonia.DirectPropertyBase<T>? FindRegisteredDirect<T>(Avalonia.AvaloniaObject o, Avalonia.DirectPropertyBase<T> property) { throw null; }
        public System.Collections.Generic.IReadOnlyList<Avalonia.AvaloniaProperty> GetRegistered(Avalonia.AvaloniaObject o) { throw null; }
        [System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute("Trimming", "IL2059", Justification="If type was trimmed out, no properties were referenced")]
        public System.Collections.Generic.IReadOnlyList<Avalonia.AvaloniaProperty> GetRegistered(System.Type type) { throw null; }
        public System.Collections.Generic.IReadOnlyList<Avalonia.AvaloniaProperty> GetRegisteredAttached(System.Type type) { throw null; }
        public System.Collections.Generic.IReadOnlyList<Avalonia.AvaloniaProperty> GetRegisteredDirect(System.Type type) { throw null; }
        public Avalonia.DirectPropertyBase<T> GetRegisteredDirect<T>(Avalonia.AvaloniaObject o, Avalonia.DirectPropertyBase<T> property) { throw null; }
        public System.Collections.Generic.IReadOnlyList<Avalonia.AvaloniaProperty> GetRegisteredInherited(System.Type type) { throw null; }
        public bool IsRegistered(object o, Avalonia.AvaloniaProperty property) { throw null; }
        public bool IsRegistered(System.Type type, Avalonia.AvaloniaProperty property) { throw null; }
        public void Register(System.Type type, Avalonia.AvaloniaProperty property) { }
        public void RegisterAttached(System.Type type, Avalonia.AvaloniaProperty property) { }
    }
    public abstract partial class AvaloniaProperty<TValue> : Avalonia.AvaloniaProperty
    {
        internal AvaloniaProperty() { }
        public new System.IObservable<Avalonia.AvaloniaPropertyChangedEventArgs<TValue>> Changed { get { throw null; } }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct CornerRadius : System.IEquatable<Avalonia.CornerRadius>
    {
        private readonly int _dummyPrimitive;
        public CornerRadius(double uniformRadius) { throw null; }
        public CornerRadius(double top, double bottom) { throw null; }
        public CornerRadius(double topLeft, double topRight, double bottomRight, double bottomLeft) { throw null; }
        public double BottomLeft { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double BottomRight { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsUniform { get { throw null; } }
        public double TopLeft { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double TopRight { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.CornerRadius other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.CornerRadius left, Avalonia.CornerRadius right) { throw null; }
        public static bool operator !=(Avalonia.CornerRadius left, Avalonia.CornerRadius right) { throw null; }
        public static Avalonia.CornerRadius Parse(string s) { throw null; }
        public override string ToString() { throw null; }
    }
    public abstract partial class DirectPropertyBase<TValue> : Avalonia.AvaloniaProperty<TValue>
    {
        internal DirectPropertyBase() { }
        public System.Type Owner { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public new Avalonia.DirectPropertyMetadata<TValue> GetMetadata(System.Type type) { throw null; }
        public TValue GetUnsetValue(System.Type type) { throw null; }
        public void OverrideMetadata(System.Type type, Avalonia.DirectPropertyMetadata<TValue> metadata) { }
        public void OverrideMetadata<T>(Avalonia.DirectPropertyMetadata<TValue> metadata) where T : Avalonia.AvaloniaObject { }
    }
    public partial class DirectPropertyMetadata<TValue> : Avalonia.AvaloniaPropertyMetadata, Avalonia.IDirectPropertyMetadata
    {
        public DirectPropertyMetadata(TValue unsetValue = null, Avalonia.Data.BindingMode defaultBindingMode = Avalonia.Data.BindingMode.Default, bool? enableDataValidation = default(bool?)) : base (default(Avalonia.Data.BindingMode), default(bool?)) { }
        object? Avalonia.IDirectPropertyMetadata.UnsetValue { get { throw null; } }
        public TValue UnsetValue { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override Avalonia.AvaloniaPropertyMetadata GenerateTypeSafeMetadata() { throw null; }
        public override void Merge(Avalonia.AvaloniaPropertyMetadata baseMetadata, Avalonia.AvaloniaProperty property) { }
    }
    public partial class DirectProperty<TOwner, TValue> : Avalonia.DirectPropertyBase<TValue> where TOwner : Avalonia.AvaloniaObject
    {
        internal DirectProperty() { }
        public System.Func<TOwner, TValue> Getter { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.Action<TOwner, TValue>? Setter { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.DirectProperty<TNewOwner, TValue> AddOwner<TNewOwner>(System.Func<TNewOwner, TValue> getter, System.Action<TNewOwner, TValue>? setter = null, TValue unsetValue = null, Avalonia.Data.BindingMode defaultBindingMode = Avalonia.Data.BindingMode.Default, bool enableDataValidation = false) where TNewOwner : Avalonia.AvaloniaObject { throw null; }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial interface IAvaloniaDependencyResolver
    {
        object? GetService(System.Type t);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IDataContextProvider
    {
        object? DataContext { get; set; }
    }
    public partial interface IDescription
    {
        string? Description { get; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IDirectPropertyMetadata
    {
        bool? EnableDataValidation { get; }
        object? UnsetValue { get; }
    }
    public partial interface INamed
    {
        string? Name { get; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IStyledPropertyMetadata
    {
        object? DefaultValue { get; }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public static partial class LocatorExtensions
    {
        public static object GetRequiredService(this Avalonia.IAvaloniaDependencyResolver resolver, System.Type t) { throw null; }
        public static T GetRequiredService<T>(this Avalonia.IAvaloniaDependencyResolver resolver) { throw null; }
        public static T? GetService<T>(this Avalonia.IAvaloniaDependencyResolver resolver) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct Matrix : System.IEquatable<Avalonia.Matrix>
    {
        private readonly int _dummyPrimitive;
        public Matrix(double scaleX, double skewY, double skewX, double scaleY, double offsetX, double offsetY) { throw null; }
        public Matrix(double scaleX, double skewY, double perspX, double skewX, double scaleY, double perspY, double offsetX, double offsetY, double perspZ) { throw null; }
        public bool HasInverse { get { throw null; } }
        public static Avalonia.Matrix Identity { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsIdentity { get { throw null; } }
        public double M11 { get { throw null; } }
        public double M12 { get { throw null; } }
        public double M13 { get { throw null; } }
        public double M21 { get { throw null; } }
        public double M22 { get { throw null; } }
        public double M23 { get { throw null; } }
        public double M31 { get { throw null; } }
        public double M32 { get { throw null; } }
        public double M33 { get { throw null; } }
        public Avalonia.Matrix Append(Avalonia.Matrix value) { throw null; }
        public bool ContainsPerspective() { throw null; }
        public static Avalonia.Matrix CreateRotation(double radians) { throw null; }
        public static Avalonia.Matrix CreateScale(Avalonia.Vector scales) { throw null; }
        public static Avalonia.Matrix CreateScale(double xScale, double yScale) { throw null; }
        public static Avalonia.Matrix CreateSkew(double xAngle, double yAngle) { throw null; }
        public static Avalonia.Matrix CreateTranslation(Avalonia.Vector position) { throw null; }
        public static Avalonia.Matrix CreateTranslation(double xPosition, double yPosition) { throw null; }
        public bool Equals(Avalonia.Matrix other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public double GetDeterminant() { throw null; }
        public override int GetHashCode() { throw null; }
        public Avalonia.Matrix Invert() { throw null; }
        public static bool operator ==(Avalonia.Matrix value1, Avalonia.Matrix value2) { throw null; }
        public static bool operator !=(Avalonia.Matrix value1, Avalonia.Matrix value2) { throw null; }
        public static Avalonia.Matrix operator *(Avalonia.Matrix value1, Avalonia.Matrix value2) { throw null; }
        public static Avalonia.Matrix operator -(Avalonia.Matrix value) { throw null; }
        public static Avalonia.Matrix Parse(string s) { throw null; }
        public Avalonia.Matrix Prepend(Avalonia.Matrix value) { throw null; }
        public static double ToRadians(double angle) { throw null; }
        public override string ToString() { throw null; }
        public Avalonia.Point Transform(Avalonia.Point p) { throw null; }
        public static bool TryDecomposeTransform(Avalonia.Matrix matrix, out Avalonia.Matrix.Decomposed decomposed) { throw null; }
        public bool TryInvert(out Avalonia.Matrix inverted) { throw null; }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public partial struct Decomposed : System.IEquatable<Avalonia.Matrix.Decomposed>
        {
            public double Angle;
            public Avalonia.Vector Scale;
            public Avalonia.Vector Skew;
            public Avalonia.Vector Translate;
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public bool Equals(Avalonia.Matrix.Decomposed other) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override bool Equals(object obj) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override int GetHashCode() { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public static bool operator ==(Avalonia.Matrix.Decomposed left, Avalonia.Matrix.Decomposed right) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public static bool operator !=(Avalonia.Matrix.Decomposed left, Avalonia.Matrix.Decomposed right) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override string ToString() { throw null; }
        }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct PixelPoint : System.IEquatable<Avalonia.PixelPoint>
    {
        private readonly int _dummyPrimitive;
        public static readonly Avalonia.PixelPoint Origin;
        public PixelPoint(int x, int y) { throw null; }
        public int X { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int Y { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.PixelPoint other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public static Avalonia.PixelPoint FromPoint(Avalonia.Point point, Avalonia.Vector scale) { throw null; }
        public static Avalonia.PixelPoint FromPoint(Avalonia.Point point, double scale) { throw null; }
        public static Avalonia.PixelPoint FromPointWithDpi(Avalonia.Point point, Avalonia.Vector dpi) { throw null; }
        public static Avalonia.PixelPoint FromPointWithDpi(Avalonia.Point point, double dpi) { throw null; }
        public override int GetHashCode() { throw null; }
        public static Avalonia.PixelPoint operator +(Avalonia.PixelPoint a, Avalonia.PixelPoint b) { throw null; }
        public static Avalonia.PixelPoint operator +(Avalonia.PixelPoint a, Avalonia.PixelVector b) { throw null; }
        public static bool operator ==(Avalonia.PixelPoint left, Avalonia.PixelPoint right) { throw null; }
        public static implicit operator Avalonia.PixelVector (Avalonia.PixelPoint p) { throw null; }
        public static bool operator !=(Avalonia.PixelPoint left, Avalonia.PixelPoint right) { throw null; }
        public static Avalonia.PixelPoint operator -(Avalonia.PixelPoint a, Avalonia.PixelPoint b) { throw null; }
        public static Avalonia.PixelPoint operator -(Avalonia.PixelPoint a, Avalonia.PixelVector b) { throw null; }
        public static Avalonia.PixelPoint Parse(string s) { throw null; }
        public Avalonia.Point ToPoint(Avalonia.Vector scale) { throw null; }
        public Avalonia.Point ToPoint(double scale) { throw null; }
        public Avalonia.Point ToPointWithDpi(Avalonia.Vector dpi) { throw null; }
        public Avalonia.Point ToPointWithDpi(double dpi) { throw null; }
        public override string ToString() { throw null; }
        public Avalonia.PixelPoint WithX(int x) { throw null; }
        public Avalonia.PixelPoint WithY(int y) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct PixelRect : System.IEquatable<Avalonia.PixelRect>
    {
        private readonly int _dummyPrimitive;
        public PixelRect(Avalonia.PixelPoint topLeft, Avalonia.PixelPoint bottomRight) { throw null; }
        public PixelRect(Avalonia.PixelPoint position, Avalonia.PixelSize size) { throw null; }
        public PixelRect(Avalonia.PixelSize size) { throw null; }
        public PixelRect(int x, int y, int width, int height) { throw null; }
        public int Bottom { get { throw null; } }
        public Avalonia.PixelPoint BottomLeft { get { throw null; } }
        public Avalonia.PixelPoint BottomRight { get { throw null; } }
        public Avalonia.PixelPoint Center { get { throw null; } }
        public int Height { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.PixelPoint Position { get { throw null; } }
        public int Right { get { throw null; } }
        public Avalonia.PixelSize Size { get { throw null; } }
        public Avalonia.PixelPoint TopLeft { get { throw null; } }
        public Avalonia.PixelPoint TopRight { get { throw null; } }
        public int Width { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int X { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int Y { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.PixelRect CenterRect(Avalonia.PixelRect rect) { throw null; }
        public bool Contains(Avalonia.PixelPoint p) { throw null; }
        public bool Contains(Avalonia.PixelRect r) { throw null; }
        public bool ContainsExclusive(Avalonia.PixelPoint p) { throw null; }
        public bool Equals(Avalonia.PixelRect other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public static Avalonia.PixelRect FromRect(Avalonia.Rect rect, Avalonia.Vector scale) { throw null; }
        public static Avalonia.PixelRect FromRect(Avalonia.Rect rect, double scale) { throw null; }
        public static Avalonia.PixelRect FromRectWithDpi(Avalonia.Rect rect, Avalonia.Vector dpi) { throw null; }
        public static Avalonia.PixelRect FromRectWithDpi(Avalonia.Rect rect, double dpi) { throw null; }
        public override int GetHashCode() { throw null; }
        public Avalonia.PixelRect Intersect(Avalonia.PixelRect rect) { throw null; }
        public bool Intersects(Avalonia.PixelRect rect) { throw null; }
        public static bool operator ==(Avalonia.PixelRect left, Avalonia.PixelRect right) { throw null; }
        public static bool operator !=(Avalonia.PixelRect left, Avalonia.PixelRect right) { throw null; }
        public static Avalonia.PixelRect Parse(string s) { throw null; }
        public Avalonia.Rect ToRect(Avalonia.Vector scale) { throw null; }
        public Avalonia.Rect ToRect(double scale) { throw null; }
        public Avalonia.Rect ToRectWithDpi(Avalonia.Vector dpi) { throw null; }
        public Avalonia.Rect ToRectWithDpi(double dpi) { throw null; }
        public override string ToString() { throw null; }
        public Avalonia.PixelRect Translate(Avalonia.PixelVector offset) { throw null; }
        public Avalonia.PixelRect Union(Avalonia.PixelRect rect) { throw null; }
        public Avalonia.PixelRect WithHeight(int height) { throw null; }
        public Avalonia.PixelRect WithWidth(int width) { throw null; }
        public Avalonia.PixelRect WithX(int x) { throw null; }
        public Avalonia.PixelRect WithY(int y) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct PixelSize : System.IEquatable<Avalonia.PixelSize>
    {
        private readonly int _dummyPrimitive;
        public static readonly Avalonia.PixelSize Empty;
        public PixelSize(int width, int height) { throw null; }
        public double AspectRatio { get { throw null; } }
        public int Height { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int Width { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.PixelSize other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public static Avalonia.PixelSize FromSize(Avalonia.Size size, Avalonia.Vector scale) { throw null; }
        public static Avalonia.PixelSize FromSize(Avalonia.Size size, double scale) { throw null; }
        public static Avalonia.PixelSize FromSizeWithDpi(Avalonia.Size size, Avalonia.Vector dpi) { throw null; }
        public static Avalonia.PixelSize FromSizeWithDpi(Avalonia.Size size, double dpi) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.PixelSize left, Avalonia.PixelSize right) { throw null; }
        public static bool operator !=(Avalonia.PixelSize left, Avalonia.PixelSize right) { throw null; }
        public static Avalonia.PixelSize Parse(string s) { throw null; }
        public Avalonia.Size ToSize(Avalonia.Vector scale) { throw null; }
        public Avalonia.Size ToSize(double scale) { throw null; }
        public Avalonia.Size ToSizeWithDpi(Avalonia.Vector dpi) { throw null; }
        public Avalonia.Size ToSizeWithDpi(double dpi) { throw null; }
        public override string ToString() { throw null; }
        public Avalonia.PixelSize WithHeight(int height) { throw null; }
        public Avalonia.PixelSize WithWidth(int width) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct PixelVector
    {
        private readonly int _dummyPrimitive;
        public PixelVector(int x, int y) { throw null; }
        public double Length { get { throw null; } }
        public int X { get { throw null; } }
        public int Y { get { throw null; } }
        public bool Equals(Avalonia.PixelVector other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public bool NearlyEquals(Avalonia.PixelVector other) { throw null; }
        public static Avalonia.PixelVector operator +(Avalonia.PixelVector a, Avalonia.PixelVector b) { throw null; }
        public static Avalonia.PixelVector operator /(Avalonia.PixelVector vector, int scale) { throw null; }
        public static bool operator ==(Avalonia.PixelVector left, Avalonia.PixelVector right) { throw null; }
        public static explicit operator Avalonia.PixelPoint (Avalonia.PixelVector a) { throw null; }
        public static bool operator !=(Avalonia.PixelVector left, Avalonia.PixelVector right) { throw null; }
        public static int operator *(Avalonia.PixelVector a, Avalonia.PixelVector b) { throw null; }
        public static Avalonia.PixelVector operator *(Avalonia.PixelVector vector, int scale) { throw null; }
        public static Avalonia.PixelVector operator -(Avalonia.PixelVector a, Avalonia.PixelVector b) { throw null; }
        public static Avalonia.PixelVector operator -(Avalonia.PixelVector a) { throw null; }
        public override string ToString() { throw null; }
        public Avalonia.PixelVector WithX(int x) { throw null; }
        public Avalonia.PixelVector WithY(int y) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct Point : System.IEquatable<Avalonia.Point>
    {
        private readonly int _dummyPrimitive;
        public Point(double x, double y) { throw null; }
        public double X { get { throw null; } }
        public double Y { get { throw null; } }
        public void Deconstruct(out double x, out double y) { throw null; }
        public bool Equals(Avalonia.Point other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public bool NearlyEquals(Avalonia.Point other) { throw null; }
        public static Avalonia.Point operator +(Avalonia.Point a, Avalonia.Point b) { throw null; }
        public static Avalonia.Point operator +(Avalonia.Point a, Avalonia.Vector b) { throw null; }
        public static Avalonia.Point operator /(Avalonia.Point p, double k) { throw null; }
        public static bool operator ==(Avalonia.Point left, Avalonia.Point right) { throw null; }
        public static implicit operator Avalonia.Vector (Avalonia.Point p) { throw null; }
        public static bool operator !=(Avalonia.Point left, Avalonia.Point right) { throw null; }
        public static Avalonia.Point operator *(Avalonia.Point point, Avalonia.Matrix matrix) { throw null; }
        public static Avalonia.Point operator *(Avalonia.Point p, double k) { throw null; }
        public static Avalonia.Point operator *(double k, Avalonia.Point p) { throw null; }
        public static Avalonia.Point operator -(Avalonia.Point a, Avalonia.Point b) { throw null; }
        public static Avalonia.Point operator -(Avalonia.Point a, Avalonia.Vector b) { throw null; }
        public static Avalonia.Point operator -(Avalonia.Point a) { throw null; }
        public static Avalonia.Point Parse(string s) { throw null; }
        public override string ToString() { throw null; }
        public Avalonia.Point Transform(Avalonia.Matrix transform) { throw null; }
        public Avalonia.Point WithX(double x) { throw null; }
        public Avalonia.Point WithY(double y) { throw null; }
    }
    public sealed partial class Points : Avalonia.Collections.AvaloniaList<Avalonia.Point>
    {
        public Points() { }
        public Points(System.Collections.Generic.IEnumerable<Avalonia.Point> points) { }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct Rect : System.IEquatable<Avalonia.Rect>
    {
        private readonly int _dummyPrimitive;
        public Rect(Avalonia.Point topLeft, Avalonia.Point bottomRight) { throw null; }
        public Rect(Avalonia.Point position, Avalonia.Size size) { throw null; }
        public Rect(Avalonia.Size size) { throw null; }
        public Rect(double x, double y, double width, double height) { throw null; }
        public double Bottom { get { throw null; } }
        public Avalonia.Point BottomLeft { get { throw null; } }
        public Avalonia.Point BottomRight { get { throw null; } }
        public Avalonia.Point Center { get { throw null; } }
        public double Height { get { throw null; } }
        public double Left { get { throw null; } }
        public Avalonia.Point Position { get { throw null; } }
        public double Right { get { throw null; } }
        public Avalonia.Size Size { get { throw null; } }
        public double Top { get { throw null; } }
        public Avalonia.Point TopLeft { get { throw null; } }
        public Avalonia.Point TopRight { get { throw null; } }
        public double Width { get { throw null; } }
        public double X { get { throw null; } }
        public double Y { get { throw null; } }
        public Avalonia.Rect CenterRect(Avalonia.Rect rect) { throw null; }
        public bool Contains(Avalonia.Point p) { throw null; }
        public bool Contains(Avalonia.Rect r) { throw null; }
        public bool ContainsExclusive(Avalonia.Point p) { throw null; }
        public Avalonia.Rect Deflate(Avalonia.Thickness thickness) { throw null; }
        public Avalonia.Rect Deflate(double thickness) { throw null; }
        public bool Equals(Avalonia.Rect other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public Avalonia.Rect Inflate(Avalonia.Thickness thickness) { throw null; }
        public Avalonia.Rect Inflate(double thickness) { throw null; }
        public Avalonia.Rect Intersect(Avalonia.Rect rect) { throw null; }
        public bool Intersects(Avalonia.Rect rect) { throw null; }
        public Avalonia.Rect Normalize() { throw null; }
        public static Avalonia.Rect operator /(Avalonia.Rect rect, Avalonia.Vector scale) { throw null; }
        public static bool operator ==(Avalonia.Rect left, Avalonia.Rect right) { throw null; }
        public static bool operator !=(Avalonia.Rect left, Avalonia.Rect right) { throw null; }
        public static Avalonia.Rect operator *(Avalonia.Rect rect, Avalonia.Vector scale) { throw null; }
        public static Avalonia.Rect operator *(Avalonia.Rect rect, double scale) { throw null; }
        public static Avalonia.Rect Parse(string s) { throw null; }
        public override string ToString() { throw null; }
        public Avalonia.Rect TransformToAABB(Avalonia.Matrix matrix) { throw null; }
        public Avalonia.Rect Translate(Avalonia.Vector offset) { throw null; }
        public Avalonia.Rect Union(Avalonia.Rect rect) { throw null; }
        public Avalonia.Rect WithHeight(double height) { throw null; }
        public Avalonia.Rect WithWidth(double width) { throw null; }
        public Avalonia.Rect WithX(double x) { throw null; }
        public Avalonia.Rect WithY(double y) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct RelativePoint : System.IEquatable<Avalonia.RelativePoint>
    {
        private readonly int _dummyPrimitive;
        public static readonly Avalonia.RelativePoint BottomRight;
        public static readonly Avalonia.RelativePoint Center;
        public static readonly Avalonia.RelativePoint TopLeft;
        public RelativePoint(Avalonia.Point point, Avalonia.RelativeUnit unit) { throw null; }
        public RelativePoint(double x, double y, Avalonia.RelativeUnit unit) { throw null; }
        public Avalonia.Point Point { get { throw null; } }
        public Avalonia.RelativeUnit Unit { get { throw null; } }
        public bool Equals(Avalonia.RelativePoint p) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.RelativePoint left, Avalonia.RelativePoint right) { throw null; }
        public static bool operator !=(Avalonia.RelativePoint left, Avalonia.RelativePoint right) { throw null; }
        public static Avalonia.RelativePoint Parse(string s) { throw null; }
        public Avalonia.Point ToPixels(Avalonia.Size size) { throw null; }
        public override string ToString() { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct RelativeRect : System.IEquatable<Avalonia.RelativeRect>
    {
        private readonly int _dummyPrimitive;
        public static readonly Avalonia.RelativeRect Fill;
        public RelativeRect(Avalonia.Point topLeft, Avalonia.Point bottomRight, Avalonia.RelativeUnit unit) { throw null; }
        public RelativeRect(Avalonia.Point position, Avalonia.Size size, Avalonia.RelativeUnit unit) { throw null; }
        public RelativeRect(Avalonia.Rect rect, Avalonia.RelativeUnit unit) { throw null; }
        public RelativeRect(Avalonia.Size size, Avalonia.RelativeUnit unit) { throw null; }
        public RelativeRect(double x, double y, double width, double height, Avalonia.RelativeUnit unit) { throw null; }
        public Avalonia.Rect Rect { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.RelativeUnit Unit { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.RelativeRect p) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.RelativeRect left, Avalonia.RelativeRect right) { throw null; }
        public static bool operator !=(Avalonia.RelativeRect left, Avalonia.RelativeRect right) { throw null; }
        public static Avalonia.RelativeRect Parse(string s) { throw null; }
        public Avalonia.Rect ToPixels(Avalonia.Size size) { throw null; }
    }
    public enum RelativeUnit
    {
        Relative = 0,
        Absolute = 1,
    }
    public partial class RenderTargetCorruptedException : System.Exception
    {
        public RenderTargetCorruptedException() { }
        public RenderTargetCorruptedException(System.Exception innerException) { }
        public RenderTargetCorruptedException(string message) { }
        public RenderTargetCorruptedException(string message, System.Exception innerException) { }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct RoundedRect
    {
        private int _dummyPrimitive;
        public RoundedRect(Avalonia.Rect rect) { throw null; }
        public RoundedRect(Avalonia.Rect rect, Avalonia.Vector radii) { throw null; }
        public RoundedRect(Avalonia.Rect rect, Avalonia.Vector radiiTopLeft, Avalonia.Vector radiiTopRight, Avalonia.Vector radiiBottomRight, Avalonia.Vector radiiBottomLeft) { throw null; }
        public RoundedRect(Avalonia.Rect rect, double radius) { throw null; }
        public RoundedRect(Avalonia.Rect rect, double radiusX, double radiusY) { throw null; }
        public RoundedRect(Avalonia.Rect rect, double radiusTopLeft, double radiusTopRight, double radiusBottomRight, double radiusBottomLeft) { throw null; }
        public RoundedRect(in Avalonia.Rect bounds, in Avalonia.CornerRadius radius) { throw null; }
        public bool IsRounded { get { throw null; } }
        public bool IsUniform { get { throw null; } }
        public Avalonia.Vector RadiiBottomLeft { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Vector RadiiBottomRight { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Vector RadiiTopLeft { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Vector RadiiTopRight { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Rect Rect { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.RoundedRect Deflate(double dx, double dy) { throw null; }
        public bool Equals(Avalonia.RoundedRect other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public Avalonia.RoundedRect Inflate(double dx, double dy) { throw null; }
        public static bool operator ==(Avalonia.RoundedRect left, Avalonia.RoundedRect right) { throw null; }
        public static implicit operator Avalonia.RoundedRect (Avalonia.Rect r) { throw null; }
        public static bool operator !=(Avalonia.RoundedRect left, Avalonia.RoundedRect right) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct Size : System.IEquatable<Avalonia.Size>
    {
        private readonly int _dummyPrimitive;
        public static readonly Avalonia.Size Infinity;
        public Size(double width, double height) { throw null; }
        public Size(System.Numerics.Vector2 vector2) { throw null; }
        public double AspectRatio { get { throw null; } }
        public double Height { get { throw null; } }
        public double Width { get { throw null; } }
        public Avalonia.Size Constrain(Avalonia.Size constraint) { throw null; }
        public void Deconstruct(out double width, out double height) { throw null; }
        public Avalonia.Size Deflate(Avalonia.Thickness thickness) { throw null; }
        public bool Equals(Avalonia.Size other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public Avalonia.Size Inflate(Avalonia.Thickness thickness) { throw null; }
        public bool NearlyEquals(Avalonia.Size other) { throw null; }
        public static Avalonia.Size operator +(Avalonia.Size size, Avalonia.Size toAdd) { throw null; }
        public static Avalonia.Vector operator /(Avalonia.Size left, Avalonia.Size right) { throw null; }
        public static Avalonia.Size operator /(Avalonia.Size size, Avalonia.Vector scale) { throw null; }
        public static Avalonia.Size operator /(Avalonia.Size size, double scale) { throw null; }
        public static bool operator ==(Avalonia.Size left, Avalonia.Size right) { throw null; }
        public static bool operator !=(Avalonia.Size left, Avalonia.Size right) { throw null; }
        public static Avalonia.Size operator *(Avalonia.Size size, Avalonia.Vector scale) { throw null; }
        public static Avalonia.Size operator *(Avalonia.Size size, double scale) { throw null; }
        public static Avalonia.Size operator -(Avalonia.Size size, Avalonia.Size toSubtract) { throw null; }
        public static Avalonia.Size Parse(string s) { throw null; }
        public override string ToString() { throw null; }
        public Avalonia.Size WithHeight(double height) { throw null; }
        public Avalonia.Size WithWidth(double width) { throw null; }
    }
    public static partial class StreamBindingExtensions
    {
        public static object StreamBinding(this System.Threading.Tasks.Task @this) { throw null; }
        public static T StreamBinding<T>(this System.IObservable<T> @this) { throw null; }
        public static T StreamBinding<T>(this System.Threading.Tasks.Task<T> @this) { throw null; }
    }
    public partial class StyledElement : Avalonia.Animation.Animatable, Avalonia.Controls.IResourceHost, Avalonia.Controls.IResourceNode, Avalonia.Controls.ISetInheritanceParent, Avalonia.Controls.ISetLogicalParent, Avalonia.IDataContextProvider, Avalonia.INamed, Avalonia.LogicalTree.ILogical, Avalonia.Styling.IStyleable, Avalonia.Styling.IStyleHost, Avalonia.Styling.IThemeVariantHost, System.ComponentModel.ISupportInitialize
    {
        public static readonly Avalonia.StyledProperty<object?> DataContextProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.StyledElement, string?> NameProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.StyledElement, Avalonia.StyledElement?> ParentProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.StyledElement, Avalonia.AvaloniaObject?> TemplatedParentProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Styling.ControlTheme?> ThemeProperty;
        public StyledElement() { }
        public Avalonia.Styling.ThemeVariant ActualThemeVariant { get { throw null; } }
        bool Avalonia.Controls.IResourceNode.HasResources { get { throw null; } }
        bool Avalonia.LogicalTree.ILogical.IsAttachedToLogicalTree { get { throw null; } }
        Avalonia.Collections.IAvaloniaReadOnlyList<Avalonia.LogicalTree.ILogical> Avalonia.LogicalTree.ILogical.LogicalChildren { get { throw null; } }
        Avalonia.LogicalTree.ILogical? Avalonia.LogicalTree.ILogical.LogicalParent { get { throw null; } }
        Avalonia.Collections.IAvaloniaReadOnlyList<string> Avalonia.Styling.IStyleable.Classes { get { throw null; } }
        bool Avalonia.Styling.IStyleHost.IsStylesInitialized { get { throw null; } }
        Avalonia.Styling.IStyleHost? Avalonia.Styling.IStyleHost.StylingParent { get { throw null; } }
        public Avalonia.Controls.Classes Classes { get { throw null; } }
        public object? DataContext { get { throw null; } set { } }
        public bool IsInitialized { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        protected internal Avalonia.Collections.IAvaloniaList<Avalonia.LogicalTree.ILogical> LogicalChildren { get { throw null; } }
        public string? Name { get { throw null; } set { } }
        public Avalonia.StyledElement? Parent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        protected Avalonia.Controls.IPseudoClasses PseudoClasses { get { throw null; } }
        public Avalonia.Controls.IResourceDictionary Resources { get { throw null; } set { } }
        public System.Type StyleKey { get { throw null; } }
        protected virtual System.Type StyleKeyOverride { get { throw null; } }
        public Avalonia.Styling.Styles Styles { get { throw null; } }
        public Avalonia.AvaloniaObject? TemplatedParent { get { throw null; } }
        public Avalonia.Styling.ControlTheme? Theme { get { throw null; } set { } }
        public event System.EventHandler? ActualThemeVariantChanged { add { } remove { } }
        public event System.EventHandler<Avalonia.LogicalTree.LogicalTreeAttachmentEventArgs>? AttachedToLogicalTree { add { } remove { } }
        public event System.EventHandler? DataContextChanged { add { } remove { } }
        public event System.EventHandler<Avalonia.LogicalTree.LogicalTreeAttachmentEventArgs>? DetachedFromLogicalTree { add { } remove { } }
        public event System.EventHandler? Initialized { add { } remove { } }
        public event System.EventHandler<Avalonia.Controls.ResourcesChangedEventArgs>? ResourcesChanged { add { } remove { } }
        public bool ApplyStyling() { throw null; }
        void Avalonia.Controls.IResourceHost.NotifyHostedResourcesChanged(Avalonia.Controls.ResourcesChangedEventArgs e) { }
        void Avalonia.Controls.ISetInheritanceParent.SetParent(Avalonia.AvaloniaObject? parent) { }
        void Avalonia.Controls.ISetLogicalParent.SetParent(Avalonia.LogicalTree.ILogical? parent) { }
        void Avalonia.LogicalTree.ILogical.NotifyAttachedToLogicalTree(Avalonia.LogicalTree.LogicalTreeAttachmentEventArgs e) { }
        void Avalonia.LogicalTree.ILogical.NotifyDetachedFromLogicalTree(Avalonia.LogicalTree.LogicalTreeAttachmentEventArgs e) { }
        void Avalonia.LogicalTree.ILogical.NotifyResourcesChanged(Avalonia.Controls.ResourcesChangedEventArgs e) { }
        void Avalonia.Styling.IStyleHost.StylesAdded(System.Collections.Generic.IReadOnlyList<Avalonia.Styling.IStyle> styles) { }
        void Avalonia.Styling.IStyleHost.StylesRemoved(System.Collections.Generic.IReadOnlyList<Avalonia.Styling.IStyle> styles) { }
        public virtual void BeginInit() { }
        public virtual void EndInit() { }
        protected void InitializeIfNeeded() { }
        protected virtual void LogicalChildrenCollectionChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e) { }
        protected virtual void OnAttachedToLogicalTree(Avalonia.LogicalTree.LogicalTreeAttachmentEventArgs e) { }
        protected virtual void OnDataContextBeginUpdate() { }
        protected virtual void OnDataContextChanged(System.EventArgs e) { }
        protected virtual void OnDataContextEndUpdate() { }
        protected virtual void OnDetachedFromLogicalTree(Avalonia.LogicalTree.LogicalTreeAttachmentEventArgs e) { }
        protected virtual void OnInitialized() { }
        protected override void OnPropertyChanged(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
        public bool TryGetResource(object key, Avalonia.Styling.ThemeVariant? theme, out object? value) { throw null; }
    }
    public static partial class StyledElementExtensions
    {
        public static System.IDisposable BindClass(this Avalonia.StyledElement target, string className, Avalonia.Data.IBinding source, object anchor) { throw null; }
    }
    public partial class StyledPropertyMetadata<TValue> : Avalonia.AvaloniaPropertyMetadata, Avalonia.IStyledPropertyMetadata
    {
        public StyledPropertyMetadata(Avalonia.Data.Optional<TValue> defaultValue = default(Avalonia.Data.Optional<TValue>), Avalonia.Data.BindingMode defaultBindingMode = Avalonia.Data.BindingMode.Default, System.Func<Avalonia.AvaloniaObject, TValue, TValue>? coerce = null, bool enableDataValidation = false) : base (default(Avalonia.Data.BindingMode), default(bool?)) { }
        object? Avalonia.IStyledPropertyMetadata.DefaultValue { get { throw null; } }
        public System.Func<Avalonia.AvaloniaObject, TValue, TValue>? CoerceValue { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public TValue DefaultValue { get { throw null; } }
        public override Avalonia.AvaloniaPropertyMetadata GenerateTypeSafeMetadata() { throw null; }
        public override void Merge(Avalonia.AvaloniaPropertyMetadata baseMetadata, Avalonia.AvaloniaProperty property) { }
    }
    public partial class StyledProperty<TValue> : Avalonia.AvaloniaProperty<TValue>
    {
        internal StyledProperty() { }
        public System.Func<TValue, bool>? ValidateValue { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.StyledProperty<TValue> AddOwner<TOwner>(Avalonia.StyledPropertyMetadata<TValue>? metadata = null) where TOwner : Avalonia.AvaloniaObject { throw null; }
        public TValue CoerceValue(Avalonia.AvaloniaObject instance, TValue baseValue) { throw null; }
        public TValue GetDefaultValue(System.Type type) { throw null; }
        public new Avalonia.StyledPropertyMetadata<TValue> GetMetadata(System.Type type) { throw null; }
        public void OverrideDefaultValue(System.Type type, TValue defaultValue) { }
        public void OverrideDefaultValue<T>(TValue defaultValue) where T : Avalonia.AvaloniaObject { }
        public void OverrideMetadata(System.Type type, Avalonia.StyledPropertyMetadata<TValue> metadata) { }
        public void OverrideMetadata<T>(Avalonia.StyledPropertyMetadata<TValue> metadata) where T : Avalonia.AvaloniaObject { }
        public override string ToString() { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct Thickness : System.IEquatable<Avalonia.Thickness>
    {
        private readonly int _dummyPrimitive;
        public Thickness(double uniformLength) { throw null; }
        public Thickness(double horizontal, double vertical) { throw null; }
        public Thickness(double left, double top, double right, double bottom) { throw null; }
        public double Bottom { get { throw null; } }
        public bool IsUniform { get { throw null; } }
        public double Left { get { throw null; } }
        public double Right { get { throw null; } }
        public double Top { get { throw null; } }
        public void Deconstruct(out double left, out double top, out double right, out double bottom) { throw null; }
        public bool Equals(Avalonia.Thickness other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static Avalonia.Size operator +(Avalonia.Size size, Avalonia.Thickness thickness) { throw null; }
        public static Avalonia.Thickness operator +(Avalonia.Thickness a, Avalonia.Thickness b) { throw null; }
        public static bool operator ==(Avalonia.Thickness a, Avalonia.Thickness b) { throw null; }
        public static bool operator !=(Avalonia.Thickness a, Avalonia.Thickness b) { throw null; }
        public static Avalonia.Thickness operator *(Avalonia.Thickness a, double b) { throw null; }
        public static Avalonia.Size operator -(Avalonia.Size size, Avalonia.Thickness thickness) { throw null; }
        public static Avalonia.Thickness operator -(Avalonia.Thickness a, Avalonia.Thickness b) { throw null; }
        public static Avalonia.Thickness Parse(string s) { throw null; }
        public override string ToString() { throw null; }
    }
    public sealed partial class UnsetValueType
    {
        internal UnsetValueType() { }
        public override string ToString() { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct Vector : System.IEquatable<Avalonia.Vector>
    {
        private readonly int _dummyPrimitive;
        public Vector(double x, double y) { throw null; }
        public double Length { get { throw null; } }
        public static Avalonia.Vector One { get { throw null; } }
        public double SquaredLength { get { throw null; } }
        public static Avalonia.Vector UnitX { get { throw null; } }
        public static Avalonia.Vector UnitY { get { throw null; } }
        public double X { get { throw null; } }
        public double Y { get { throw null; } }
        public static Avalonia.Vector Zero { get { throw null; } }
        public static Avalonia.Vector Add(Avalonia.Vector a, Avalonia.Vector b) { throw null; }
        public static double Cross(Avalonia.Vector a, Avalonia.Vector b) { throw null; }
        public void Deconstruct(out double x, out double y) { throw null; }
        public static Avalonia.Vector Divide(Avalonia.Vector a, Avalonia.Vector b) { throw null; }
        public static Avalonia.Vector Divide(Avalonia.Vector vector, double scalar) { throw null; }
        public static double Dot(Avalonia.Vector a, Avalonia.Vector b) { throw null; }
        public bool Equals(Avalonia.Vector other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static Avalonia.Vector Multiply(Avalonia.Vector a, Avalonia.Vector b) { throw null; }
        public static Avalonia.Vector Multiply(Avalonia.Vector vector, double scalar) { throw null; }
        public bool NearlyEquals(Avalonia.Vector other) { throw null; }
        public Avalonia.Vector Negate() { throw null; }
        public static Avalonia.Vector Negate(Avalonia.Vector vector) { throw null; }
        public Avalonia.Vector Normalize() { throw null; }
        public static Avalonia.Vector Normalize(Avalonia.Vector vector) { throw null; }
        public static Avalonia.Vector operator +(Avalonia.Vector a, Avalonia.Vector b) { throw null; }
        public static Avalonia.Vector operator /(Avalonia.Vector vector, double scale) { throw null; }
        public static bool operator ==(Avalonia.Vector left, Avalonia.Vector right) { throw null; }
        public static explicit operator Avalonia.Point (Avalonia.Vector a) { throw null; }
        public static bool operator !=(Avalonia.Vector left, Avalonia.Vector right) { throw null; }
        public static double operator *(Avalonia.Vector a, Avalonia.Vector b) { throw null; }
        public static Avalonia.Vector operator *(Avalonia.Vector vector, double scale) { throw null; }
        public static Avalonia.Vector operator *(double scale, Avalonia.Vector vector) { throw null; }
        public static Avalonia.Vector operator -(Avalonia.Vector a, Avalonia.Vector b) { throw null; }
        public static Avalonia.Vector operator -(Avalonia.Vector a) { throw null; }
        public static Avalonia.Vector Parse(string s) { throw null; }
        public static Avalonia.Vector Subtract(Avalonia.Vector a, Avalonia.Vector b) { throw null; }
        public override string ToString() { throw null; }
        public Avalonia.Vector WithX(double x) { throw null; }
        public Avalonia.Vector WithY(double y) { throw null; }
    }
    [Avalonia.Metadata.UsableDuringInitializationAttribute]
    public partial class Visual : Avalonia.StyledElement
    {
        public static readonly Avalonia.DirectProperty<Avalonia.Visual, Avalonia.Rect> BoundsProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Geometry?> ClipProperty;
        public static readonly Avalonia.StyledProperty<bool> ClipToBoundsProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.IEffect?> EffectProperty;
        public static readonly Avalonia.AttachedProperty<Avalonia.Media.FlowDirection> FlowDirectionProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Visual, bool> HasMirrorTransformProperty;
        public static readonly Avalonia.StyledProperty<bool> IsVisibleProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.IBrush?> OpacityMaskProperty;
        public static readonly Avalonia.StyledProperty<double> OpacityProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.RelativePoint> RenderTransformOriginProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.ITransform?> RenderTransformProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Visual, Avalonia.Visual?> VisualParentProperty;
        public static readonly Avalonia.StyledProperty<int> ZIndexProperty;
        public Visual() { }
        public Avalonia.Rect Bounds { get { throw null; } protected set { } }
        protected virtual bool BypassFlowDirectionPolicies { get { throw null; } }
        public Avalonia.Media.Geometry? Clip { get { throw null; } set { } }
        public bool ClipToBounds { get { throw null; } set { } }
        public Avalonia.Media.IEffect? Effect { get { throw null; } set { } }
        public Avalonia.Media.FlowDirection FlowDirection { get { throw null; } set { } }
        public bool HasMirrorTransform { get { throw null; } protected set { } }
        public bool IsEffectivelyVisible { get { throw null; } }
        public bool IsVisible { get { throw null; } set { } }
        public double Opacity { get { throw null; } set { } }
        public Avalonia.Media.IBrush? OpacityMask { get { throw null; } set { } }
        public Avalonia.Media.ITransform? RenderTransform { get { throw null; } set { } }
        public Avalonia.RelativePoint RenderTransformOrigin { get { throw null; } set { } }
        protected internal Avalonia.Collections.IAvaloniaList<Avalonia.Visual> VisualChildren { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        protected internal Avalonia.Rendering.IRenderRoot? VisualRoot { get { throw null; } }
        public int ZIndex { get { throw null; } set { } }
        public event System.EventHandler<Avalonia.VisualTreeAttachmentEventArgs>? AttachedToVisualTree { add { } remove { } }
        public event System.EventHandler<Avalonia.VisualTreeAttachmentEventArgs>? DetachedFromVisualTree { add { } remove { } }
        protected static void AffectsRender<T>(params Avalonia.AvaloniaProperty[] properties) where T : Avalonia.Visual { }
        public static Avalonia.Media.FlowDirection GetFlowDirection(Avalonia.Visual visual) { throw null; }
        protected internal virtual void InvalidateMirrorTransform() { }
        public void InvalidateVisual() { }
        protected override void LogicalChildrenCollectionChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e) { }
        protected virtual void OnAttachedToVisualTree(Avalonia.VisualTreeAttachmentEventArgs e) { }
        protected virtual void OnAttachedToVisualTreeCore(Avalonia.VisualTreeAttachmentEventArgs e) { }
        protected virtual void OnDetachedFromVisualTree(Avalonia.VisualTreeAttachmentEventArgs e) { }
        protected virtual void OnDetachedFromVisualTreeCore(Avalonia.VisualTreeAttachmentEventArgs e) { }
        protected override void OnPropertyChanged(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
        protected virtual void OnVisualParentChanged(Avalonia.Visual? oldParent, Avalonia.Visual? newParent) { }
        public virtual void Render(Avalonia.Media.DrawingContext context) { }
        public static void SetFlowDirection(Avalonia.Visual visual, Avalonia.Media.FlowDirection value) { }
    }
    public static partial class VisualExtensions
    {
        public static Avalonia.Point PointToClient(this Avalonia.Visual visual, Avalonia.PixelPoint point) { throw null; }
        public static Avalonia.PixelPoint PointToScreen(this Avalonia.Visual visual, Avalonia.Point point) { throw null; }
        public static Avalonia.Matrix? TransformToVisual(this Avalonia.Visual from, Avalonia.Visual to) { throw null; }
        public static Avalonia.Point? TranslatePoint(this Avalonia.Visual visual, Avalonia.Point point, Avalonia.Visual relativeTo) { throw null; }
    }
    public partial class VisualTreeAttachmentEventArgs : System.EventArgs
    {
        public VisualTreeAttachmentEventArgs(Avalonia.Visual parent, Avalonia.Rendering.IRenderRoot root) { }
        public Avalonia.Visual Parent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Rendering.IRenderRoot Root { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
}
namespace Avalonia.Animation
{
    public partial class Animatable : Avalonia.AvaloniaObject
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Animation.Transitions?> TransitionsProperty;
        public Animatable() { }
        public Avalonia.Animation.Transitions? Transitions { get { throw null; } set { } }
        protected sealed override void OnPropertyChangedCore(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
    }
    public sealed partial class Animation : Avalonia.AvaloniaObject, Avalonia.Animation.IAnimation
    {
        public static readonly Avalonia.DirectProperty<Avalonia.Animation.Animation, System.TimeSpan> DelayBetweenIterationsProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Animation.Animation, System.TimeSpan> DelayProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Animation.Animation, System.TimeSpan> DurationProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Animation.Animation, Avalonia.Animation.Easings.Easing> EasingProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Animation.Animation, Avalonia.Animation.FillMode> FillModeProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Animation.Animation, Avalonia.Animation.IterationCount> IterationCountProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Animation.Animation, Avalonia.Animation.PlaybackDirection> PlaybackDirectionProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Animation.Animation, double> SpeedRatioProperty;
        public Animation() { }
        [Avalonia.Metadata.ContentAttribute]
        public Avalonia.Animation.KeyFrames Children { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.TimeSpan Delay { get { throw null; } set { } }
        public System.TimeSpan DelayBetweenIterations { get { throw null; } set { } }
        public System.TimeSpan Duration { get { throw null; } set { } }
        public Avalonia.Animation.Easings.Easing Easing { get { throw null; } set { } }
        public Avalonia.Animation.FillMode FillMode { get { throw null; } set { } }
        public Avalonia.Animation.IterationCount IterationCount { get { throw null; } set { } }
        public Avalonia.Animation.PlaybackDirection PlaybackDirection { get { throw null; } set { } }
        public double SpeedRatio { get { throw null; } set { } }
        public System.Threading.Tasks.Task RunAsync(Avalonia.Animation.Animatable control, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static void SetAnimator(Avalonia.Animation.IAnimationSetter setter, Avalonia.Animation.CustomAnimatorBase value) { }
    }
    public partial class BoxShadowsTransition : Avalonia.Animation.Transition<Avalonia.Media.BoxShadows>
    {
        public BoxShadowsTransition() { }
    }
    public partial class BrushTransition : Avalonia.Animation.Transition<Avalonia.Media.IBrush?>
    {
        public BrushTransition() { }
    }
    public partial class ColorTransition : Avalonia.Animation.Transition<Avalonia.Media.Color>
    {
        public ColorTransition() { }
    }
    public partial class CompositePageTransition : Avalonia.Animation.IPageTransition
    {
        public CompositePageTransition() { }
        [Avalonia.Metadata.ContentAttribute]
        public System.Collections.Generic.List<Avalonia.Animation.IPageTransition> PageTransitions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Threading.Tasks.Task Start(Avalonia.Visual? from, Avalonia.Visual? to, bool forward, System.Threading.CancellationToken cancellationToken) { throw null; }
    }
    public partial class CornerRadiusTransition : Avalonia.Animation.Transition<Avalonia.CornerRadius>
    {
        public CornerRadiusTransition() { }
    }
    public partial class CrossFade : Avalonia.Animation.IPageTransition
    {
        public CrossFade() { }
        public CrossFade(System.TimeSpan duration) { }
        public System.TimeSpan Duration { get { throw null; } set { } }
        public Avalonia.Animation.Easings.Easing FadeInEasing { get { throw null; } set { } }
        public Avalonia.Animation.Easings.Easing FadeOutEasing { get { throw null; } set { } }
        System.Threading.Tasks.Task Avalonia.Animation.IPageTransition.Start(Avalonia.Visual? from, Avalonia.Visual? to, bool forward, System.Threading.CancellationToken cancellationToken) { throw null; }
        public System.Threading.Tasks.Task Start(Avalonia.Visual? from, Avalonia.Visual? to, System.Threading.CancellationToken cancellationToken) { throw null; }
    }
    [System.ComponentModel.TypeConverterAttribute(typeof(Avalonia.Animation.CueTypeConverter))]
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct Cue : System.IEquatable<Avalonia.Animation.Cue>, System.IEquatable<double>
    {
        private readonly int _dummyPrimitive;
        public Cue(double value) { throw null; }
        public double CueValue { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Animation.Cue other) { throw null; }
        public bool Equals(double other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Animation.Cue left, Avalonia.Animation.Cue right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Animation.Cue left, Avalonia.Animation.Cue right) { throw null; }
        public static Avalonia.Animation.Cue Parse(string value, System.Globalization.CultureInfo? culture) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public partial class CueTypeConverter : System.ComponentModel.TypeConverter
    {
        public CueTypeConverter() { }
        public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Type sourceType) { throw null; }
        public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object value) { throw null; }
    }
    public abstract partial class CustomAnimatorBase
    {
        protected CustomAnimatorBase() { }
        internal abstract System.Type WrapperType { get; }
        internal abstract Avalonia.Animation.IAnimator CreateWrapper();
    }
    public abstract partial class CustomAnimatorBase<T> : Avalonia.Animation.CustomAnimatorBase
    {
        protected CustomAnimatorBase() { }
        public abstract T Interpolate(double progress, T oldValue, T newValue);
    }
    public partial class DoubleTransition : Avalonia.Animation.Transition<double>
    {
        public DoubleTransition() { }
    }
    public partial class EffectTransition : Avalonia.Animation.Transition<Avalonia.Media.IEffect?>
    {
        public EffectTransition() { }
    }
    public enum FillMode
    {
        None = 0,
        Forward = 1,
        Backward = 2,
        Both = 3,
    }
    public partial class FloatTransition : Avalonia.Animation.Transition<float>
    {
        public FloatTransition() { }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IAnimation
    {
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial interface IAnimationSetter
    {
        Avalonia.AvaloniaProperty? Property { get; set; }
        object? Value { get; set; }
    }
    public partial class IntegerTransition : Avalonia.Animation.Transition<int>
    {
        public IntegerTransition() { }
    }
    public partial interface IPageTransition
    {
        System.Threading.Tasks.Task Start(Avalonia.Visual? from, Avalonia.Visual? to, bool forward, System.Threading.CancellationToken cancellationToken);
    }
    [System.ComponentModel.TypeConverterAttribute(typeof(Avalonia.Animation.IterationCountTypeConverter))]
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct IterationCount : System.IEquatable<Avalonia.Animation.IterationCount>
    {
        private int _dummyPrimitive;
        public IterationCount(ulong value) { throw null; }
        public IterationCount(ulong value, Avalonia.Animation.IterationType type) { throw null; }
        public static Avalonia.Animation.IterationCount Infinite { get { throw null; } }
        public bool IsInfinite { get { throw null; } }
        public Avalonia.Animation.IterationType RepeatType { get { throw null; } }
        public ulong Value { get { throw null; } }
        public bool Equals(Avalonia.Animation.IterationCount IterationCount) { throw null; }
        public override bool Equals(object? o) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Animation.IterationCount a, Avalonia.Animation.IterationCount b) { throw null; }
        public static bool operator !=(Avalonia.Animation.IterationCount rc1, Avalonia.Animation.IterationCount rc2) { throw null; }
        public static Avalonia.Animation.IterationCount Parse(string s) { throw null; }
        public override string ToString() { throw null; }
    }
    public partial class IterationCountTypeConverter : System.ComponentModel.TypeConverter
    {
        public IterationCountTypeConverter() { }
        public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Type sourceType) { throw null; }
        public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object value) { throw null; }
    }
    public enum IterationType
    {
        Many = 0,
        Infinite = 1,
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial interface ITransition
    {
        Avalonia.AvaloniaProperty Property { get; set; }
    }
    public sealed partial class KeyFrame : Avalonia.AvaloniaObject
    {
        public KeyFrame() { }
        public Avalonia.Animation.Cue Cue { get { throw null; } set { } }
        public Avalonia.Animation.KeySpline? KeySpline { get { throw null; } set { } }
        public System.TimeSpan KeyTime { get { throw null; } set { } }
        [Avalonia.Metadata.ContentAttribute]
        public Avalonia.Collections.AvaloniaList<Avalonia.Animation.IAnimationSetter> Setters { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public sealed partial class KeyFrames : Avalonia.Collections.AvaloniaList<Avalonia.Animation.KeyFrame>
    {
        public KeyFrames() { }
        public KeyFrames(System.Collections.Generic.IEnumerable<Avalonia.Animation.KeyFrame> items) { }
    }
    [System.ComponentModel.TypeConverterAttribute(typeof(Avalonia.Animation.KeySplineTypeConverter))]
    public sealed partial class KeySpline : Avalonia.AvaloniaObject
    {
        public KeySpline() { }
        public KeySpline(double x1, double y1, double x2, double y2) { }
        public double ControlPointX1 { get { throw null; } set { } }
        public double ControlPointX2 { get { throw null; } set { } }
        public double ControlPointY1 { get { throw null; } set { } }
        public double ControlPointY2 { get { throw null; } set { } }
        public double GetSplineProgress(double linearProgress) { throw null; }
        public bool IsValid() { throw null; }
        public static Avalonia.Animation.KeySpline Parse(string value, System.Globalization.CultureInfo? culture) { throw null; }
    }
    public partial class KeySplineTypeConverter : System.ComponentModel.TypeConverter
    {
        public KeySplineTypeConverter() { }
        public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Type sourceType) { throw null; }
        public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object value) { throw null; }
    }
    public partial class PageSlide : Avalonia.Animation.IPageTransition
    {
        public PageSlide() { }
        public PageSlide(System.TimeSpan duration, Avalonia.Animation.PageSlide.SlideAxis orientation = Avalonia.Animation.PageSlide.SlideAxis.Horizontal) { }
        public System.TimeSpan Duration { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Animation.PageSlide.SlideAxis Orientation { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Animation.Easings.Easing SlideInEasing { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Animation.Easings.Easing SlideOutEasing { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        protected static Avalonia.Visual GetVisualParent(Avalonia.Visual? from, Avalonia.Visual? to) { throw null; }
        public virtual System.Threading.Tasks.Task Start(Avalonia.Visual? from, Avalonia.Visual? to, bool forward, System.Threading.CancellationToken cancellationToken) { throw null; }
        public enum SlideAxis
        {
            Horizontal = 0,
            Vertical = 1,
        }
    }
    public enum PlaybackDirection
    {
        Normal = 0,
        Reverse = 1,
        Alternate = 2,
        AlternateReverse = 3,
    }
    public enum PlayState
    {
        Run = 0,
        Pause = 1,
        Stop = 2,
    }
    public partial class PointTransition : Avalonia.Animation.Transition<Avalonia.Point>
    {
        public PointTransition() { }
    }
    public partial class RelativePointTransition : Avalonia.Animation.Transition<Avalonia.RelativePoint>
    {
        public RelativePointTransition() { }
    }
    public partial class Rotate3DTransition : Avalonia.Animation.PageSlide
    {
        public Rotate3DTransition() { }
        public Rotate3DTransition(System.TimeSpan duration, Avalonia.Animation.PageSlide.SlideAxis orientation = Avalonia.Animation.PageSlide.SlideAxis.Horizontal, double? depth = default(double?)) { }
        public double? Depth { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public override System.Threading.Tasks.Task Start(Avalonia.Visual? from, Avalonia.Visual? to, bool forward, System.Threading.CancellationToken cancellationToken) { throw null; }
    }
    public partial class SizeTransition : Avalonia.Animation.Transition<Avalonia.Size>
    {
        public SizeTransition() { }
    }
    public partial class ThicknessTransition : Avalonia.Animation.Transition<Avalonia.Thickness>
    {
        public ThicknessTransition() { }
    }
    public partial class TransformOperationsTransition : Avalonia.Animation.Transition<Avalonia.Media.ITransform>
    {
        public TransformOperationsTransition() { }
    }
    public sealed partial class Transitions : Avalonia.Collections.AvaloniaList<Avalonia.Animation.ITransition>
    {
        public Transitions() { }
    }
    public abstract partial class Transition<T> : Avalonia.AvaloniaObject, Avalonia.Animation.ITransition
    {
        protected Transition() { }
        Avalonia.AvaloniaProperty Avalonia.Animation.ITransition.Property { get { throw null; } set { } }
        public System.TimeSpan Delay { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.TimeSpan Duration { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Animation.Easings.Easing Easing { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        [System.Diagnostics.CodeAnalysis.DisallowNullAttribute]
        public Avalonia.AvaloniaProperty? Property { get { throw null; } set { } }
        internal abstract System.IObservable<T> DoTransition(System.IObservable<double> progress, T oldValue, T newValue);
    }
    public partial class VectorTransition : Avalonia.Animation.Transition<Avalonia.Vector>
    {
        public VectorTransition() { }
    }
}
namespace Avalonia.Animation.Easings
{
    public partial class BackEaseIn : Avalonia.Animation.Easings.Easing
    {
        public BackEaseIn() { }
        public override double Ease(double p) { throw null; }
    }
    public partial class BackEaseInOut : Avalonia.Animation.Easings.Easing
    {
        public BackEaseInOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class BackEaseOut : Avalonia.Animation.Easings.Easing
    {
        public BackEaseOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class BounceEaseIn : Avalonia.Animation.Easings.Easing
    {
        public BounceEaseIn() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class BounceEaseInOut : Avalonia.Animation.Easings.Easing
    {
        public BounceEaseInOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class BounceEaseOut : Avalonia.Animation.Easings.Easing
    {
        public BounceEaseOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class CircularEaseIn : Avalonia.Animation.Easings.Easing
    {
        public CircularEaseIn() { }
        public override double Ease(double p) { throw null; }
    }
    public partial class CircularEaseInOut : Avalonia.Animation.Easings.Easing
    {
        public CircularEaseInOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class CircularEaseOut : Avalonia.Animation.Easings.Easing
    {
        public CircularEaseOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class CubicBezierEasing : Avalonia.Animation.Easings.IEasing
    {
        internal CubicBezierEasing() { }
        public Avalonia.Point ControlPoint1 { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Point ControlPoint2 { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        double Avalonia.Animation.Easings.IEasing.Ease(double progress) { throw null; }
    }
    public partial class CubicEaseIn : Avalonia.Animation.Easings.Easing
    {
        public CubicEaseIn() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class CubicEaseInOut : Avalonia.Animation.Easings.Easing
    {
        public CubicEaseInOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class CubicEaseOut : Avalonia.Animation.Easings.Easing
    {
        public CubicEaseOut() { }
        public override double Ease(double progress) { throw null; }
    }
    [System.ComponentModel.TypeConverterAttribute(typeof(Avalonia.Animation.Easings.EasingTypeConverter))]
    public abstract partial class Easing : Avalonia.Animation.Easings.IEasing
    {
        protected Easing() { }
        public abstract double Ease(double progress);
        public static Avalonia.Animation.Easings.Easing Parse(string e) { throw null; }
    }
    public partial class EasingTypeConverter : System.ComponentModel.TypeConverter
    {
        public EasingTypeConverter() { }
        public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Type sourceType) { throw null; }
        public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object value) { throw null; }
    }
    public partial class ElasticEaseIn : Avalonia.Animation.Easings.Easing
    {
        public ElasticEaseIn() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class ElasticEaseInOut : Avalonia.Animation.Easings.Easing
    {
        public ElasticEaseInOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class ElasticEaseOut : Avalonia.Animation.Easings.Easing
    {
        public ElasticEaseOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class ExponentialEaseIn : Avalonia.Animation.Easings.Easing
    {
        public ExponentialEaseIn() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class ExponentialEaseInOut : Avalonia.Animation.Easings.Easing
    {
        public ExponentialEaseInOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class ExponentialEaseOut : Avalonia.Animation.Easings.Easing
    {
        public ExponentialEaseOut() { }
        public override double Ease(double progress) { throw null; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IEasing
    {
        double Ease(double progress);
    }
    public partial class LinearEasing : Avalonia.Animation.Easings.Easing
    {
        public LinearEasing() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class QuadraticEaseIn : Avalonia.Animation.Easings.Easing
    {
        public QuadraticEaseIn() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class QuadraticEaseInOut : Avalonia.Animation.Easings.Easing
    {
        public QuadraticEaseInOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class QuadraticEaseOut : Avalonia.Animation.Easings.Easing
    {
        public QuadraticEaseOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class QuarticEaseIn : Avalonia.Animation.Easings.Easing
    {
        public QuarticEaseIn() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class QuarticEaseInOut : Avalonia.Animation.Easings.Easing
    {
        public QuarticEaseInOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class QuarticEaseOut : Avalonia.Animation.Easings.Easing
    {
        public QuarticEaseOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class QuinticEaseIn : Avalonia.Animation.Easings.Easing
    {
        public QuinticEaseIn() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class QuinticEaseInOut : Avalonia.Animation.Easings.Easing
    {
        public QuinticEaseInOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class QuinticEaseOut : Avalonia.Animation.Easings.Easing
    {
        public QuinticEaseOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class SineEaseIn : Avalonia.Animation.Easings.Easing
    {
        public SineEaseIn() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class SineEaseInOut : Avalonia.Animation.Easings.Easing
    {
        public SineEaseInOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class SineEaseOut : Avalonia.Animation.Easings.Easing
    {
        public SineEaseOut() { }
        public override double Ease(double progress) { throw null; }
    }
    public partial class SplineEasing : Avalonia.Animation.Easings.Easing
    {
        public SplineEasing() { }
        public SplineEasing(Avalonia.Animation.KeySpline keySpline) { }
        public SplineEasing(double x1 = 0, double y1 = 0, double x2 = 1, double y2 = 1) { }
        public double X1 { get { throw null; } set { } }
        public double X2 { get { throw null; } set { } }
        public double Y1 { get { throw null; } set { } }
        public double Y2 { get { throw null; } set { } }
        public override double Ease(double progress) { throw null; }
    }
    public partial class SpringEasing : Avalonia.Animation.Easings.Easing
    {
        public SpringEasing() { }
        public SpringEasing(double mass = 0, double stiffness = 0, double damping = 0, double initialVelocity = 0) { }
        public double Damping { get { throw null; } set { } }
        public double InitialVelocity { get { throw null; } set { } }
        public double Mass { get { throw null; } set { } }
        public double Stiffness { get { throw null; } set { } }
        public override double Ease(double progress) { throw null; }
    }
}
namespace Avalonia.Collections
{
    public static partial class AvaloniaDictionaryExtensions
    {
        public static System.IDisposable ForEachItem<TKey, TValue>(this Avalonia.Collections.IAvaloniaReadOnlyDictionary<TKey, TValue> collection, System.Action<TKey, TValue> added, System.Action<TKey, TValue> removed, System.Action reset, bool weakSubscription = false) where TKey : notnull { throw null; }
    }
    public partial class AvaloniaDictionary<TKey, TValue> : Avalonia.Collections.IAvaloniaDictionary<TKey, TValue>, Avalonia.Collections.IAvaloniaReadOnlyDictionary<TKey, TValue>, System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IDictionary<TKey, TValue>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>, System.Collections.ICollection, System.Collections.IDictionary, System.Collections.IEnumerable, System.Collections.Specialized.INotifyCollectionChanged, System.ComponentModel.INotifyPropertyChanged where TKey : notnull
    {
        public AvaloniaDictionary() { }
        public AvaloniaDictionary(int capacity) { }
        public int Count { get { throw null; } }
        public bool IsReadOnly { get { throw null; } }
        public TValue this[TKey key] { get { throw null; } set { } }
        public System.Collections.Generic.ICollection<TKey> Keys { get { throw null; } }
        System.Collections.Generic.IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>.Keys { get { throw null; } }
        System.Collections.Generic.IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>.Values { get { throw null; } }
        bool System.Collections.ICollection.IsSynchronized { get { throw null; } }
        object System.Collections.ICollection.SyncRoot { get { throw null; } }
        bool System.Collections.IDictionary.IsFixedSize { get { throw null; } }
        object? System.Collections.IDictionary.this[object key] { get { throw null; } set { } }
        System.Collections.ICollection System.Collections.IDictionary.Keys { get { throw null; } }
        System.Collections.ICollection System.Collections.IDictionary.Values { get { throw null; } }
        public System.Collections.Generic.ICollection<TValue> Values { get { throw null; } }
        public event System.Collections.Specialized.NotifyCollectionChangedEventHandler? CollectionChanged { add { } remove { } }
        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged { add { } remove { } }
        public void Add(TKey key, TValue value) { }
        public void Clear() { }
        public bool ContainsKey(TKey key) { throw null; }
        public void CopyTo(System.Collections.Generic.KeyValuePair<TKey, TValue>[] array, int arrayIndex) { }
        public System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> GetEnumerator() { throw null; }
        public bool Remove(TKey key) { throw null; }
        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Add(System.Collections.Generic.KeyValuePair<TKey, TValue> item) { }
        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Contains(System.Collections.Generic.KeyValuePair<TKey, TValue> item) { throw null; }
        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Remove(System.Collections.Generic.KeyValuePair<TKey, TValue> item) { throw null; }
        void System.Collections.ICollection.CopyTo(System.Array array, int index) { }
        void System.Collections.IDictionary.Add(object key, object? value) { }
        bool System.Collections.IDictionary.Contains(object key) { throw null; }
        System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() { throw null; }
        void System.Collections.IDictionary.Remove(object key) { }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
        public bool TryGetValue(TKey key, [System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute(false)] out TValue value) { throw null; }
    }
    [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("Conversion methods are required for type conversion, including op_Implicit, op_Explicit, Parse and TypeConverter.")]
    public partial class AvaloniaListConverter<T> : System.ComponentModel.TypeConverter
    {
        public AvaloniaListConverter() { }
        public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Type sourceType) { throw null; }
        public override object? ConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object? value) { throw null; }
    }
    public static partial class AvaloniaListExtensions
    {
        public static System.IDisposable ForEachItem<T>(this Avalonia.Collections.IAvaloniaReadOnlyList<T> collection, System.Action<int, T> added, System.Action<int, T> removed, System.Action reset, bool weakSubscription = false) { throw null; }
        public static System.IDisposable ForEachItem<T>(this Avalonia.Collections.IAvaloniaReadOnlyList<T> collection, System.Action<T> added, System.Action<T> removed, System.Action reset, bool weakSubscription = false) { throw null; }
        public static System.IDisposable TrackItemPropertyChanged<T>(this Avalonia.Collections.IAvaloniaReadOnlyList<T> collection, System.Action<System.Tuple<object?, System.ComponentModel.PropertyChangedEventArgs>> callback) { throw null; }
    }
    public partial class AvaloniaList<T> : Avalonia.Collections.IAvaloniaList<T>, Avalonia.Collections.IAvaloniaReadOnlyList<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IList<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlyList<T>, System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList, System.Collections.Specialized.INotifyCollectionChanged, System.ComponentModel.INotifyPropertyChanged
    {
        public AvaloniaList() { }
        public AvaloniaList(System.Collections.Generic.IEnumerable<T> items) { }
        public AvaloniaList(int capacity) { }
        public AvaloniaList(params T[] items) { }
        public int Capacity { get { throw null; } set { } }
        public int Count { get { throw null; } }
        public T this[int index] { get { throw null; } set { } }
        public Avalonia.Collections.ResetBehavior ResetBehavior { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get { throw null; } }
        int System.Collections.ICollection.Count { get { throw null; } }
        bool System.Collections.ICollection.IsSynchronized { get { throw null; } }
        object System.Collections.ICollection.SyncRoot { get { throw null; } }
        bool System.Collections.IList.IsFixedSize { get { throw null; } }
        bool System.Collections.IList.IsReadOnly { get { throw null; } }
        object? System.Collections.IList.this[int index] { get { throw null; } set { } }
        public System.Action<T>? Validate { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public event System.Collections.Specialized.NotifyCollectionChangedEventHandler? CollectionChanged { add { } remove { } }
        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged { add { } remove { } }
        public virtual void Add(T item) { }
        public virtual void AddRange(System.Collections.Generic.IEnumerable<T> items) { }
        public virtual void Clear() { }
        public bool Contains(T item) { throw null; }
        public void CopyTo(T[] array, int arrayIndex) { }
        public void EnsureCapacity(int capacity) { }
        public Avalonia.Collections.AvaloniaList<T>.Enumerator GetEnumerator() { throw null; }
        public System.Collections.Generic.IEnumerable<T> GetRange(int index, int count) { throw null; }
        public int IndexOf(T item) { throw null; }
        public virtual void Insert(int index, T item) { }
        public virtual void InsertRange(int index, System.Collections.Generic.IEnumerable<T> items) { }
        public void Move(int oldIndex, int newIndex) { }
        public void MoveRange(int oldIndex, int count, int newIndex) { }
        public virtual bool Remove(T item) { throw null; }
        public virtual void RemoveAll(System.Collections.Generic.IEnumerable<T> items) { }
        public virtual void RemoveAt(int index) { }
        public virtual void RemoveRange(int index, int count) { }
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator() { throw null; }
        void System.Collections.ICollection.CopyTo(System.Array array, int index) { }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
        int System.Collections.IList.Add(object? value) { throw null; }
        void System.Collections.IList.Clear() { }
        bool System.Collections.IList.Contains(object? value) { throw null; }
        int System.Collections.IList.IndexOf(object? value) { throw null; }
        void System.Collections.IList.Insert(int index, object? value) { }
        void System.Collections.IList.Remove(object? value) { }
        void System.Collections.IList.RemoveAt(int index) { }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public partial struct Enumerator : System.Collections.Generic.IEnumerator<T>, System.Collections.IEnumerator, System.IDisposable
        {
            private object _dummy;
            private int _dummyPrimitive;
            public Enumerator(System.Collections.Generic.List<T> inner) { throw null; }
            public T Current { get { throw null; } }
            object? System.Collections.IEnumerator.Current { get { throw null; } }
            public void Dispose() { }
            public bool MoveNext() { throw null; }
            void System.Collections.IEnumerator.Reset() { }
        }
    }
    public partial interface IAvaloniaDictionary<TKey, TValue> : Avalonia.Collections.IAvaloniaReadOnlyDictionary<TKey, TValue>, System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IDictionary<TKey, TValue>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>, System.Collections.ICollection, System.Collections.IDictionary, System.Collections.IEnumerable, System.Collections.Specialized.INotifyCollectionChanged, System.ComponentModel.INotifyPropertyChanged where TKey : notnull
    {
    }
    public partial interface IAvaloniaList<T> : Avalonia.Collections.IAvaloniaReadOnlyList<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IList<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlyList<T>, System.Collections.IEnumerable, System.Collections.Specialized.INotifyCollectionChanged, System.ComponentModel.INotifyPropertyChanged
    {
        new int Count { get; }
        new T this[int index] { get; set; }
        void AddRange(System.Collections.Generic.IEnumerable<T> items);
        void InsertRange(int index, System.Collections.Generic.IEnumerable<T> items);
        void Move(int oldIndex, int newIndex);
        void MoveRange(int oldIndex, int count, int newIndex);
        void RemoveAll(System.Collections.Generic.IEnumerable<T> items);
        void RemoveRange(int index, int count);
    }
    public partial interface IAvaloniaReadOnlyDictionary<TKey, TValue> : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>, System.Collections.IEnumerable, System.Collections.Specialized.INotifyCollectionChanged, System.ComponentModel.INotifyPropertyChanged where TKey : notnull
    {
    }
    public partial interface IAvaloniaReadOnlyList<out T> : System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlyList<T>, System.Collections.IEnumerable, System.Collections.Specialized.INotifyCollectionChanged, System.ComponentModel.INotifyPropertyChanged
    {
    }
    public static partial class NotifyCollectionChangedExtensions
    {
        public static System.IObservable<System.Collections.Specialized.NotifyCollectionChangedEventArgs> GetWeakCollectionChangedObservable(this System.Collections.Specialized.INotifyCollectionChanged collection) { throw null; }
        public static System.IDisposable WeakSubscribe(this System.Collections.Specialized.INotifyCollectionChanged collection, System.Action<System.Collections.Specialized.NotifyCollectionChangedEventArgs> handler) { throw null; }
        public static System.IDisposable WeakSubscribe(this System.Collections.Specialized.INotifyCollectionChanged collection, System.Collections.Specialized.NotifyCollectionChangedEventHandler handler) { throw null; }
    }
    public enum ResetBehavior
    {
        Reset = 0,
        Remove = 1,
    }
}
namespace Avalonia.Controls
{
    public partial class Classes : Avalonia.Collections.AvaloniaList<string>, Avalonia.Controls.IPseudoClasses
    {
        public Classes() { }
        public Classes(System.Collections.Generic.IEnumerable<string> items) { }
        public Classes(params string[] items) { }
        public override void Add(string name) { }
        public override void AddRange(System.Collections.Generic.IEnumerable<string> names) { }
        void Avalonia.Controls.IPseudoClasses.Add(string name) { }
        bool Avalonia.Controls.IPseudoClasses.Remove(string name) { throw null; }
        public override void Clear() { }
        public override void Insert(int index, string name) { }
        public override void InsertRange(int index, System.Collections.Generic.IEnumerable<string> names) { }
        public static Avalonia.Controls.Classes Parse(string s) { throw null; }
        public override bool Remove(string name) { throw null; }
        public override void RemoveAll(System.Collections.Generic.IEnumerable<string> names) { }
        public override void RemoveAt(int index) { }
        public override void RemoveRange(int index, int count) { }
        public void Replace(System.Collections.Generic.IList<string> source) { }
        public void Set(string name, bool value) { }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface INameScope
    {
        bool IsCompleted { get; }
        void Complete();
        object? Find(string name);
        Avalonia.Utilities.SynchronousCompletionAsyncResult<object?> FindAsync(string name);
        void Register(string name, object element);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IPseudoClasses
    {
        void Add(string name);
        bool Contains(string name);
        bool Remove(string name);
    }
    public partial interface IResourceDictionary : Avalonia.Controls.IResourceNode, Avalonia.Controls.IResourceProvider, System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<object, object?>>, System.Collections.Generic.IDictionary<object, object?>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<object, object?>>, System.Collections.IEnumerable
    {
        System.Collections.Generic.IList<Avalonia.Controls.IResourceProvider> MergedDictionaries { get; }
        System.Collections.Generic.IDictionary<Avalonia.Styling.ThemeVariant, Avalonia.Controls.IThemeVariantProvider> ThemeDictionaries { get; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IResourceHost : Avalonia.Controls.IResourceNode
    {
        event System.EventHandler<Avalonia.Controls.ResourcesChangedEventArgs>? ResourcesChanged;
        void NotifyHostedResourcesChanged(Avalonia.Controls.ResourcesChangedEventArgs e);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IResourceNode
    {
        bool HasResources { get; }
        bool TryGetResource(object key, Avalonia.Styling.ThemeVariant? theme, out object? value);
    }
    public partial interface IResourceProvider : Avalonia.Controls.IResourceNode
    {
        Avalonia.Controls.IResourceHost? Owner { get; }
        event System.EventHandler? OwnerChanged;
        void AddOwner(Avalonia.Controls.IResourceHost owner);
        void RemoveOwner(Avalonia.Controls.IResourceHost owner);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ISetInheritanceParent
    {
        void SetParent(Avalonia.AvaloniaObject? parent);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ISetLogicalParent
    {
        void SetParent(Avalonia.LogicalTree.ILogical? parent);
    }
    [Avalonia.Metadata.UnstableAttribute("This XAML-only API might be removed in the future minor updates.")]
    public partial interface IThemeVariantProvider : Avalonia.Controls.IResourceNode, Avalonia.Controls.IResourceProvider
    {
        Avalonia.Styling.ThemeVariant? Key { get; set; }
    }
    public partial class NameScope : Avalonia.Controls.INameScope
    {
        public static readonly Avalonia.AttachedProperty<Avalonia.Controls.INameScope> NameScopeProperty;
        public NameScope() { }
        public bool IsCompleted { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public void Complete() { }
        public object? Find(string name) { throw null; }
        public Avalonia.Utilities.SynchronousCompletionAsyncResult<object?> FindAsync(string name) { throw null; }
        public static Avalonia.Controls.INameScope GetNameScope(Avalonia.StyledElement styled) { throw null; }
        public void Register(string name, object element) { }
        public static void SetNameScope(Avalonia.StyledElement styled, Avalonia.Controls.INameScope value) { }
    }
    public static partial class NameScopeExtensions
    {
        public static Avalonia.Controls.INameScope? FindNameScope(this Avalonia.LogicalTree.ILogical control) { throw null; }
        public static T? Find<T>(this Avalonia.Controls.INameScope nameScope, string name) where T : class { throw null; }
        public static T? Find<T>(this Avalonia.LogicalTree.ILogical anchor, string name) where T : class { throw null; }
        public static T Get<T>(this Avalonia.Controls.INameScope nameScope, string name) where T : class { throw null; }
        public static T Get<T>(this Avalonia.LogicalTree.ILogical anchor, string name) where T : class { throw null; }
    }
    public partial class NameScopeLocator
    {
        public NameScopeLocator() { }
        public static System.IObservable<object?> Track(Avalonia.Controls.INameScope scope, string name) { throw null; }
    }
    public static partial class PseudolassesExtensions
    {
        public static void Set(this Avalonia.Controls.IPseudoClasses classes, string name, bool value) { }
    }
    public partial class ResourceDictionary : Avalonia.Controls.IResourceDictionary, Avalonia.Controls.IResourceNode, Avalonia.Controls.IResourceProvider, Avalonia.Controls.IThemeVariantProvider, System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<object, object?>>, System.Collections.Generic.IDictionary<object, object?>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<object, object?>>, System.Collections.IEnumerable
    {
        public ResourceDictionary() { }
        public ResourceDictionary(Avalonia.Controls.IResourceHost owner) { }
        bool Avalonia.Controls.IResourceNode.HasResources { get { throw null; } }
        Avalonia.Styling.ThemeVariant? Avalonia.Controls.IThemeVariantProvider.Key { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int Count { get { throw null; } }
        public object? this[object key] { get { throw null; } set { } }
        public System.Collections.Generic.ICollection<object> Keys { get { throw null; } }
        public System.Collections.Generic.IList<Avalonia.Controls.IResourceProvider> MergedDictionaries { get { throw null; } }
        public Avalonia.Controls.IResourceHost? Owner { get { throw null; } }
        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<object, object?>>.IsReadOnly { get { throw null; } }
        public System.Collections.Generic.IDictionary<Avalonia.Styling.ThemeVariant, Avalonia.Controls.IThemeVariantProvider> ThemeDictionaries { get { throw null; } }
        public System.Collections.Generic.ICollection<object?> Values { get { throw null; } }
        public event System.EventHandler? OwnerChanged { add { } remove { } }
        public void Add(object key, object? value) { }
        public void AddDeferred(object key, System.Func<System.IServiceProvider?, object?> factory) { }
        void Avalonia.Controls.IResourceProvider.AddOwner(Avalonia.Controls.IResourceHost owner) { }
        void Avalonia.Controls.IResourceProvider.RemoveOwner(Avalonia.Controls.IResourceHost owner) { }
        public void Clear() { }
        public bool ContainsKey(object key) { throw null; }
        public System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<object, object?>> GetEnumerator() { throw null; }
        public bool Remove(object key) { throw null; }
        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<object, object?>>.Add(System.Collections.Generic.KeyValuePair<object, object?> item) { }
        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<object, object?>>.Contains(System.Collections.Generic.KeyValuePair<object, object?> item) { throw null; }
        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<object, object?>>.CopyTo(System.Collections.Generic.KeyValuePair<object, object>[] array, int arrayIndex) { }
        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<object, object?>>.Remove(System.Collections.Generic.KeyValuePair<object, object?> item) { throw null; }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
        public bool TryGetResource(object key, Avalonia.Styling.ThemeVariant? theme, out object? value) { throw null; }
        public bool TryGetValue(object key, out object? value) { throw null; }
    }
    public static partial class ResourceNodeExtensions
    {
        public static object? FindResource(this Avalonia.Controls.IResourceHost control, Avalonia.Styling.ThemeVariant? theme, object key) { throw null; }
        public static object? FindResource(this Avalonia.Controls.IResourceHost control, object key) { throw null; }
        public static System.IObservable<object?> GetResourceObservable(this Avalonia.Controls.IResourceHost control, object key, System.Func<object?, object?>? converter = null) { throw null; }
        public static System.IObservable<object?> GetResourceObservable(this Avalonia.Controls.IResourceProvider resourceProvider, object key, Avalonia.Styling.ThemeVariant? defaultThemeVariant, System.Func<object?, object?>? converter = null) { throw null; }
        public static System.IObservable<object?> GetResourceObservable(this Avalonia.Controls.IResourceProvider resourceProvider, object key, System.Func<object?, object?>? converter = null) { throw null; }
        public static bool TryFindResource(this Avalonia.Controls.IResourceHost control, object key, Avalonia.Styling.ThemeVariant? theme, out object? value) { throw null; }
        public static bool TryFindResource(this Avalonia.Controls.IResourceHost control, object key, out object? value) { throw null; }
        public static bool TryGetResource(this Avalonia.Controls.IResourceHost control, object key, out object? value) { throw null; }
    }
    public partial class ResourcesChangedEventArgs : System.EventArgs
    {
        public static readonly new Avalonia.Controls.ResourcesChangedEventArgs Empty;
        public ResourcesChangedEventArgs() { }
    }
}
namespace Avalonia.Controls.Metadata
{
    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=true)]
    public sealed partial class PseudoClassesAttribute : System.Attribute
    {
        public PseudoClassesAttribute(params string[] pseudoClasses) { }
        public System.Collections.Generic.IReadOnlyList<string> PseudoClasses { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=true)]
    public sealed partial class TemplatePartAttribute : System.Attribute
    {
        public TemplatePartAttribute() { }
        public TemplatePartAttribute(string name, System.Type type) { }
        public string Name { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Type Type { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
}
namespace Avalonia.Controls.Templates
{
    public partial interface ITemplateResult
    {
        Avalonia.Controls.INameScope NameScope { get; }
        object? Result { get; }
    }
    public partial class TemplateResult<T> : Avalonia.Controls.Templates.ITemplateResult
    {
        public TemplateResult(T result, Avalonia.Controls.INameScope nameScope) { }
        object? Avalonia.Controls.Templates.ITemplateResult.Result { get { throw null; } }
        public Avalonia.Controls.INameScope NameScope { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public T Result { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public void Deconstruct(out T result, out Avalonia.Controls.INameScope scope) { throw null; }
    }
}
namespace Avalonia.Data
{
    [System.AttributeUsageAttribute(System.AttributeTargets.Property)]
    public sealed partial class AssignBindingAttribute : System.Attribute
    {
        public AssignBindingAttribute() { }
    }
    public partial class BindingChainException : System.Exception
    {
        public BindingChainException() { }
        public BindingChainException(string message) { }
        public BindingChainException(string message, string expression, string errorPoint) { }
        public string? Expression { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] protected set { } }
        public string? ExpressionErrorPoint { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] protected set { } }
        public override string Message { get { throw null; } }
    }
    public enum BindingErrorType
    {
        None = 0,
        Error = 1,
        DataValidationError = 2,
    }
    public enum BindingMode
    {
        Default = 0,
        OneWay = 1,
        TwoWay = 2,
        OneTime = 3,
        OneWayToSource = 4,
    }
    public partial class BindingNotification
    {
        public static readonly Avalonia.Data.BindingNotification Null;
        public static readonly Avalonia.Data.BindingNotification UnsetValue;
        public BindingNotification(System.Exception error, Avalonia.Data.BindingErrorType errorType) { }
        public BindingNotification(System.Exception error, Avalonia.Data.BindingErrorType errorType, object? fallbackValue) { }
        public BindingNotification(object? value) { }
        public System.Exception? Error { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Data.BindingErrorType ErrorType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public bool HasValue { get { throw null; } }
        public object? Value { get { throw null; } }
        public void AddError(System.Exception e, Avalonia.Data.BindingErrorType type) { }
        public void ClearValue() { }
        public bool Equals(Avalonia.Data.BindingNotification? other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public static object? ExtractError(object? o) { throw null; }
        public static object? ExtractValue(object? o) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Data.BindingNotification? a, Avalonia.Data.BindingNotification? b) { throw null; }
        public static bool operator !=(Avalonia.Data.BindingNotification? a, Avalonia.Data.BindingNotification? b) { throw null; }
        public void SetValue(object? value) { }
        public override string ToString() { throw null; }
    }
    public static partial class BindingOperations
    {
        public static readonly object DoNothing;
        public static System.IDisposable Apply(Avalonia.AvaloniaObject target, Avalonia.AvaloniaProperty property, Avalonia.Data.InstancedBinding binding, object? anchor) { throw null; }
    }
    public enum BindingPriority
    {
        Animation = -1,
        LocalValue = 0,
        StyleTrigger = 1,
        Template = 2,
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.ObsoleteAttribute("Use Template priority")]
        TemplatedParent = 2,
        Style = 3,
        Inherited = 4,
        Unset = 2147483647,
    }
    [System.FlagsAttribute]
    public enum BindingValueType
    {
        UnsetValue = 0,
        DoNothing = 1,
        TypeMask = 255,
        HasValue = 256,
        Value = 258,
        HasError = 512,
        BindingError = 515,
        DataValidationError = 516,
        BindingErrorWithFallback = 771,
        DataValidationErrorWithFallback = 772,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct BindingValue<T> : System.IEquatable<Avalonia.Data.BindingValue<T>>
    {
        private readonly T _value;
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public BindingValue(T value) { throw null; }
        public static Avalonia.Data.BindingValue<T> DoNothing { get { throw null; } }
        public System.Exception? Error { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool HasError { get { throw null; } }
        public bool HasValue { get { throw null; } }
        public Avalonia.Data.BindingValueType Type { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Data.BindingValue<T> Unset { get { throw null; } }
        public T Value { get { throw null; } }
        public static Avalonia.Data.BindingValue<T> BindingError(System.Exception e) { throw null; }
        public static Avalonia.Data.BindingValue<T> BindingError(System.Exception e, Avalonia.Data.Optional<T> fallbackValue) { throw null; }
        public static Avalonia.Data.BindingValue<T> BindingError(System.Exception e, T fallbackValue) { throw null; }
        public static Avalonia.Data.BindingValue<T> DataValidationError(System.Exception e) { throw null; }
        public static Avalonia.Data.BindingValue<T> DataValidationError(System.Exception e, Avalonia.Data.Optional<T> fallbackValue) { throw null; }
        public static Avalonia.Data.BindingValue<T> DataValidationError(System.Exception e, T fallbackValue) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Data.BindingValue<T> other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("Implicit conversion methods are required for type conversion.")]
        public static Avalonia.Data.BindingValue<T> FromUntyped(object? value) { throw null; }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("Implicit conversion methods are required for type conversion.")]
        public static Avalonia.Data.BindingValue<T> FromUntyped(object? value, System.Type targetType) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        public T? GetValueOrDefault() { throw null; }
        public T? GetValueOrDefault(T defaultValue) { throw null; }
        public TResult? GetValueOrDefault<TResult>() { throw null; }
        public TResult? GetValueOrDefault<TResult>(TResult defaultValue) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Data.BindingValue<T> left, Avalonia.Data.BindingValue<T> right) { throw null; }
        public static implicit operator Avalonia.Data.BindingValue<T> (Avalonia.Data.Optional<T> optional) { throw null; }
        public static implicit operator Avalonia.Data.BindingValue<T> (T value) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Data.BindingValue<T> left, Avalonia.Data.BindingValue<T> right) { throw null; }
        public Avalonia.Data.Optional<T> ToOptional() { throw null; }
        public override string ToString() { throw null; }
        public object? ToUntyped() { throw null; }
        public Avalonia.Data.BindingValue<T> WithValue(T value) { throw null; }
    }
    public partial class DataValidationException : System.Exception
    {
        public DataValidationException(object? errorData) { }
        public object? ErrorData { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public sealed partial class DoNothingType
    {
        internal DoNothingType() { }
        public override string ToString() { throw null; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IBinding
    {
        Avalonia.Data.InstancedBinding? Initiate(Avalonia.AvaloniaObject target, Avalonia.AvaloniaProperty? targetProperty, object? anchor = null, bool enableDataValidation = false);
    }
    public partial class IndexerDescriptor : Avalonia.IDescription, System.IObservable<object?>
    {
        public IndexerDescriptor() { }
        public string Description { get { throw null; } }
        public Avalonia.Data.BindingMode Mode { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Data.BindingPriority Priority { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.AvaloniaProperty? Property { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.AvaloniaObject? Source { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.IObservable<object>? SourceObservable { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public static Avalonia.Data.IndexerDescriptor operator !(Avalonia.Data.IndexerDescriptor binding) { throw null; }
        public static Avalonia.Data.IndexerDescriptor operator ~(Avalonia.Data.IndexerDescriptor binding) { throw null; }
        public System.IDisposable Subscribe(System.IObserver<object?> observer) { throw null; }
        public Avalonia.Data.IndexerDescriptor WithMode(Avalonia.Data.BindingMode mode) { throw null; }
        public Avalonia.Data.IndexerDescriptor WithPriority(Avalonia.Data.BindingPriority priority) { throw null; }
    }
    public partial class InstancedBinding
    {
        internal InstancedBinding() { }
        public Avalonia.Data.BindingMode Mode { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.ObsoleteAttribute("Use Source property")]
        public System.IObservable<object?> Observable { get { throw null; } }
        public Avalonia.Data.BindingPriority Priority { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.IObservable<object?> Source { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Data.InstancedBinding OneTime(System.IObservable<object?> observable, Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) { throw null; }
        public static Avalonia.Data.InstancedBinding OneTime(object value, Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) { throw null; }
        public static Avalonia.Data.InstancedBinding OneWay(System.IObservable<object?> observable, Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) { throw null; }
        public static Avalonia.Data.InstancedBinding OneWayToSource(System.IObserver<object?> observer, Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) { throw null; }
        public static Avalonia.Data.InstancedBinding TwoWay(System.IObservable<object?> observable, System.IObserver<object?> observer, Avalonia.Data.BindingPriority priority = Avalonia.Data.BindingPriority.LocalValue) { throw null; }
        public Avalonia.Data.InstancedBinding WithPriority(Avalonia.Data.BindingPriority priority) { throw null; }
    }
    public static partial class OptionalExtensions
    {
        public static Avalonia.Data.Optional<T> Cast<T>(this Avalonia.Data.Optional<object?> value) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct Optional<T> : System.IEquatable<Avalonia.Data.Optional<T>>
    {
        private readonly T _value;
        private readonly int _dummyPrimitive;
        public Optional(T value) { throw null; }
        public static Avalonia.Data.Optional<T> Empty { get { throw null; } }
        public bool HasValue { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public T Value { get { throw null; } }
        public bool Equals(Avalonia.Data.Optional<T> other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public T? GetValueOrDefault() { throw null; }
        public T? GetValueOrDefault(T defaultValue) { throw null; }
        public TResult? GetValueOrDefault<TResult>() { throw null; }
        public TResult? GetValueOrDefault<TResult>(TResult defaultValue) { throw null; }
        public static bool operator ==(Avalonia.Data.Optional<T> x, Avalonia.Data.Optional<T> y) { throw null; }
        public static implicit operator Avalonia.Data.Optional<T> (T value) { throw null; }
        public static bool operator !=(Avalonia.Data.Optional<T> x, Avalonia.Data.Optional<T> y) { throw null; }
        public Avalonia.Data.Optional<object?> ToObject() { throw null; }
        public override string ToString() { throw null; }
    }
    public partial class TemplateBinding : Avalonia.Data.IBinding, Avalonia.IDescription, Avalonia.Styling.ISetterValue, System.IDisposable, System.IObservable<object?>, System.IObserver<object?>
    {
        public TemplateBinding() { }
        public TemplateBinding(Avalonia.AvaloniaProperty property) { }
        public Avalonia.Data.Converters.IValueConverter? Converter { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public object? ConverterParameter { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public string Description { get { throw null; } }
        public Avalonia.Data.BindingMode Mode { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.AvaloniaProperty? Property { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        void Avalonia.Styling.ISetterValue.Initialize(Avalonia.Styling.SetterBase setter) { }
        public virtual void Dispose() { }
        public Avalonia.Data.InstancedBinding? Initiate(Avalonia.AvaloniaObject target, Avalonia.AvaloniaProperty? targetProperty, object? anchor = null, bool enableDataValidation = false) { throw null; }
        public Avalonia.Data.IBinding ProvideValue() { throw null; }
        public System.IDisposable Subscribe(System.IObserver<object?> observer) { throw null; }
        void System.IObserver<object?>.OnCompleted() { }
        void System.IObserver<object?>.OnError(System.Exception error) { }
        void System.IObserver<object?>.OnNext(object? value) { }
    }
}
namespace Avalonia.Data.Converters
{
    public static partial class BoolConverters
    {
        public static readonly Avalonia.Data.Converters.IMultiValueConverter And;
        public static readonly Avalonia.Data.Converters.IValueConverter Not;
        public static readonly Avalonia.Data.Converters.IMultiValueConverter Or;
    }
    [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("Conversion methods are required for type conversion, including op_Implicit, op_Explicit, Parse and TypeConverter.")]
    public partial class DefaultValueConverter : Avalonia.Data.Converters.IValueConverter
    {
        public static readonly Avalonia.Data.Converters.DefaultValueConverter Instance;
        public DefaultValueConverter() { }
        public object? Convert(object? value, System.Type targetType, object? parameter, System.Globalization.CultureInfo culture) { throw null; }
        public object? ConvertBack(object? value, System.Type targetType, object? parameter, System.Globalization.CultureInfo culture) { throw null; }
    }
    public partial class FuncMultiValueConverter<TIn, TOut> : Avalonia.Data.Converters.IMultiValueConverter
    {
        public FuncMultiValueConverter(System.Func<System.Collections.Generic.IEnumerable<TIn?>, TOut> convert) { }
        public object? Convert(System.Collections.Generic.IList<object?> values, System.Type targetType, object? parameter, System.Globalization.CultureInfo culture) { throw null; }
    }
    public partial class FuncValueConverter<TIn, TOut> : Avalonia.Data.Converters.IValueConverter
    {
        public FuncValueConverter(System.Func<TIn?, TOut> convert) { }
        public object? Convert(object? value, System.Type targetType, object? parameter, System.Globalization.CultureInfo culture) { throw null; }
        public object? ConvertBack(object? value, System.Type targetType, object? parameter, System.Globalization.CultureInfo culture) { throw null; }
    }
    public partial interface IMultiValueConverter
    {
        object? Convert(System.Collections.Generic.IList<object?> values, System.Type targetType, object? parameter, System.Globalization.CultureInfo culture);
    }
    public partial interface IValueConverter
    {
        object? Convert(object? value, System.Type targetType, object? parameter, System.Globalization.CultureInfo culture);
        object? ConvertBack(object? value, System.Type targetType, object? parameter, System.Globalization.CultureInfo culture);
    }
    public static partial class ObjectConverters
    {
        public static readonly Avalonia.Data.Converters.IValueConverter IsNotNull;
        public static readonly Avalonia.Data.Converters.IValueConverter IsNull;
    }
    public static partial class StringConverters
    {
        public static readonly Avalonia.Data.Converters.IValueConverter IsNotNullOrEmpty;
        public static readonly Avalonia.Data.Converters.IValueConverter IsNullOrEmpty;
    }
    public partial class StringFormatMultiValueConverter : Avalonia.Data.Converters.IMultiValueConverter
    {
        public StringFormatMultiValueConverter(string format, Avalonia.Data.Converters.IMultiValueConverter? inner) { }
        public string Format { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Data.Converters.IMultiValueConverter? Inner { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public object? Convert(System.Collections.Generic.IList<object?> values, System.Type targetType, object? parameter, System.Globalization.CultureInfo culture) { throw null; }
    }
    public partial class StringFormatValueConverter : Avalonia.Data.Converters.IValueConverter
    {
        public StringFormatValueConverter(string format, Avalonia.Data.Converters.IValueConverter? inner) { }
        public string Format { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Data.Converters.IValueConverter? Inner { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public object? Convert(object? value, System.Type targetType, object? parameter, System.Globalization.CultureInfo culture) { throw null; }
        public object? ConvertBack(object? value, System.Type targetType, object? parameter, System.Globalization.CultureInfo culture) { throw null; }
    }
}
namespace Avalonia.Data.Core
{
    public partial class CastTypePropertyPathElement : Avalonia.Data.Core.IPropertyPathElement
    {
        public CastTypePropertyPathElement(System.Type type) { }
        public System.Type Type { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class ChildTraversalPropertyPathElement : Avalonia.Data.Core.IPropertyPathElement
    {
        public ChildTraversalPropertyPathElement() { }
    }
    public partial class ClrPropertyInfo : Avalonia.Data.Core.IPropertyInfo
    {
        public ClrPropertyInfo(string name, System.Func<object, object?>? getter, System.Action<object, object?>? setter, System.Type propertyType) { }
        public bool CanGet { get { throw null; } }
        public bool CanSet { get { throw null; } }
        public string Name { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.Type PropertyType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public object? Get(object target) { throw null; }
        public void Set(object target, object? value) { }
    }
    public partial class EnsureTypePropertyPathElement : Avalonia.Data.Core.IPropertyPathElement
    {
        public EnsureTypePropertyPathElement(System.Type type) { }
        public System.Type Type { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class ExpressionParseException : System.Exception
    {
        public ExpressionParseException(int column, string message, System.Exception? innerException = null) { }
        public int Column { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IPropertyInfo
    {
        bool CanGet { get; }
        bool CanSet { get; }
        string Name { get; }
        System.Type PropertyType { get; }
        object? Get(object target);
        void Set(object target, object? value);
    }
    public partial interface IPropertyPathElement
    {
    }
    public partial class PropertyPath
    {
        public PropertyPath(System.Collections.Generic.IEnumerable<Avalonia.Data.Core.IPropertyPathElement> elements) { }
        public System.Collections.Generic.IReadOnlyList<Avalonia.Data.Core.IPropertyPathElement> Elements { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class PropertyPathBuilder
    {
        public PropertyPathBuilder() { }
        public Avalonia.Data.Core.PropertyPath Build() { throw null; }
        public Avalonia.Data.Core.PropertyPathBuilder Cast(System.Type type) { throw null; }
        public Avalonia.Data.Core.PropertyPathBuilder ChildTraversal() { throw null; }
        public Avalonia.Data.Core.PropertyPathBuilder EnsureType(System.Type type) { throw null; }
        public Avalonia.Data.Core.PropertyPathBuilder Property(Avalonia.Data.Core.IPropertyInfo property) { throw null; }
    }
    public partial class PropertyPropertyPathElement : Avalonia.Data.Core.IPropertyPathElement
    {
        public PropertyPropertyPathElement(Avalonia.Data.Core.IPropertyInfo property) { }
        public Avalonia.Data.Core.IPropertyInfo Property { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class ReflectionClrPropertyInfo : Avalonia.Data.Core.ClrPropertyInfo
    {
        public ReflectionClrPropertyInfo(System.Reflection.PropertyInfo info) : base (default(string), default(System.Func<object, object>), default(System.Action<object, object>), default(System.Type)) { }
    }
}
namespace Avalonia.Data.Core.Plugins
{
    public static partial class BindingPlugins
    {
        public static System.Collections.Generic.IList<Avalonia.Data.Core.Plugins.IDataValidationPlugin> DataValidators { get { throw null; } }
        public static System.Collections.Generic.IList<Avalonia.Data.Core.Plugins.IPropertyAccessorPlugin> PropertyAccessors { get { throw null; } }
        public static System.Collections.Generic.IList<Avalonia.Data.Core.Plugins.IStreamPlugin> StreamHandlers { get { throw null; } }
    }
    public partial class DataAnnotationsValidationPlugin : Avalonia.Data.Core.Plugins.IDataValidationPlugin
    {
        public DataAnnotationsValidationPlugin() { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("DataValidationPlugin might require unreferenced code.")]
        public bool Match(System.WeakReference<object?> reference, string memberName) { throw null; }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("DataValidationPlugin might require unreferenced code.")]
        public Avalonia.Data.Core.Plugins.IPropertyAccessor Start(System.WeakReference<object?> reference, string name, Avalonia.Data.Core.Plugins.IPropertyAccessor inner) { throw null; }
    }
    public abstract partial class DataValidationBase : Avalonia.Data.Core.Plugins.PropertyAccessorBase, System.IObserver<object?>
    {
        protected DataValidationBase(Avalonia.Data.Core.Plugins.IPropertyAccessor inner) { }
        public override System.Type? PropertyType { get { throw null; } }
        public override object? Value { get { throw null; } }
        protected virtual void InnerValueChanged(object? value) { }
        public override bool SetValue(object? value, Avalonia.Data.BindingPriority priority) { throw null; }
        protected override void SubscribeCore() { }
        void System.IObserver<object?>.OnCompleted() { }
        void System.IObserver<object?>.OnError(System.Exception error) { }
        void System.IObserver<object?>.OnNext(object? value) { }
        protected override void UnsubscribeCore() { }
    }
    public partial class ExceptionValidationPlugin : Avalonia.Data.Core.Plugins.IDataValidationPlugin
    {
        public ExceptionValidationPlugin() { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("DataValidationPlugin might require unreferenced code.")]
        public bool Match(System.WeakReference<object?> reference, string memberName) { throw null; }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("DataValidationPlugin might require unreferenced code.")]
        public Avalonia.Data.Core.Plugins.IPropertyAccessor Start(System.WeakReference<object?> reference, string name, Avalonia.Data.Core.Plugins.IPropertyAccessor inner) { throw null; }
    }
    public partial interface IDataValidationPlugin
    {
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("DataValidationPlugin might require unreferenced code.")]
        bool Match(System.WeakReference<object?> reference, string memberName);
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("DataValidationPlugin might require unreferenced code.")]
        Avalonia.Data.Core.Plugins.IPropertyAccessor Start(System.WeakReference<object?> reference, string propertyName, Avalonia.Data.Core.Plugins.IPropertyAccessor inner);
    }
    public partial class IndeiValidationPlugin : Avalonia.Data.Core.Plugins.IDataValidationPlugin
    {
        public IndeiValidationPlugin() { }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("DataValidationPlugin might require unreferenced code.")]
        public bool Match(System.WeakReference<object?> reference, string memberName) { throw null; }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("DataValidationPlugin might require unreferenced code.")]
        public Avalonia.Data.Core.Plugins.IPropertyAccessor Start(System.WeakReference<object?> reference, string name, Avalonia.Data.Core.Plugins.IPropertyAccessor accessor) { throw null; }
    }
    public partial interface IPropertyAccessor : System.IDisposable
    {
        System.Type? PropertyType { get; }
        object? Value { get; }
        bool SetValue(object? value, Avalonia.Data.BindingPriority priority);
        void Subscribe(System.Action<object?> listener);
        void Unsubscribe();
    }
    public partial interface IPropertyAccessorPlugin
    {
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("PropertyAccessors might require unreferenced code.")]
        bool Match(object obj, string propertyName);
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("PropertyAccessors might require unreferenced code.")]
        Avalonia.Data.Core.Plugins.IPropertyAccessor? Start(System.WeakReference<object?> reference, string propertyName);
    }
    public partial interface IStreamPlugin
    {
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("StreamPlugin might require unreferenced code.")]
        bool Match(System.WeakReference<object?> reference);
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("StreamPlugin might require unreferenced code.")]
        System.IObservable<object?> Start(System.WeakReference<object?> reference);
    }
    public abstract partial class PropertyAccessorBase : Avalonia.Data.Core.Plugins.IPropertyAccessor, System.IDisposable
    {
        protected PropertyAccessorBase() { }
        public abstract System.Type? PropertyType { get; }
        public abstract object? Value { get; }
        public void Dispose() { }
        protected void PublishValue(object? value) { }
        public abstract bool SetValue(object? value, Avalonia.Data.BindingPriority priority);
        public void Subscribe(System.Action<object?> listener) { }
        protected abstract void SubscribeCore();
        public void Unsubscribe() { }
        protected abstract void UnsubscribeCore();
    }
    public partial class PropertyError : Avalonia.Data.Core.Plugins.IPropertyAccessor, System.IDisposable
    {
        public PropertyError(Avalonia.Data.BindingNotification error) { }
        public System.Type? PropertyType { get { throw null; } }
        public object? Value { get { throw null; } }
        public void Dispose() { }
        public bool SetValue(object? value, Avalonia.Data.BindingPriority priority) { throw null; }
        public void Subscribe(System.Action<object> listener) { }
        public void Unsubscribe() { }
    }
}
namespace Avalonia.Diagnostics
{
    public partial class AppliedStyle
    {
        internal AppliedStyle() { }
        public bool HasActivator { get { throw null; } }
        public bool IsActive { get { throw null; } }
        public Avalonia.Styling.StyleBase Style { get { throw null; } }
    }
    public static partial class AvaloniaObjectExtensions
    {
        public static Avalonia.Diagnostics.AvaloniaPropertyValue GetDiagnostic(this Avalonia.AvaloniaObject o, Avalonia.AvaloniaProperty property) { throw null; }
    }
    public partial class AvaloniaPropertyValue
    {
        internal AvaloniaPropertyValue() { }
        public string? Diagnostic { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsOverriddenCurrentValue { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Data.BindingPriority Priority { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.AvaloniaProperty Property { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public object? Value { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public static partial class StyledElementExtensions
    {
        public static Avalonia.Diagnostics.StyleDiagnostics GetStyleDiagnostics(this Avalonia.StyledElement styledElement) { throw null; }
    }
    public partial class StyleDiagnostics
    {
        public StyleDiagnostics(System.Collections.Generic.IReadOnlyList<Avalonia.Diagnostics.AppliedStyle> appliedStyles) { }
        public System.Collections.Generic.IReadOnlyList<Avalonia.Diagnostics.AppliedStyle> AppliedStyles { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
}
namespace Avalonia.Input
{
    public partial class Cursor : System.IDisposable
    {
        public static readonly Avalonia.Input.Cursor Default;
        public Cursor(Avalonia.Input.StandardCursorType cursorType) { }
        public Cursor(Avalonia.Media.Imaging.Bitmap cursor, Avalonia.PixelPoint hotSpot) { }
        public void Dispose() { }
        public static Avalonia.Input.Cursor Parse(string s) { throw null; }
        public override string ToString() { throw null; }
    }
    public static partial class DataFormats
    {
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.ObsoleteAttribute("Use DataFormats.Files, this format is supported only on desktop platforms.")]
        public static readonly string FileNames;
        public static readonly string Files;
        public static readonly string Text;
    }
    public partial class DataObject : Avalonia.Input.IDataObject
    {
        public DataObject() { }
        public bool Contains(string dataFormat) { throw null; }
        public object? Get(string dataFormat) { throw null; }
        public System.Collections.Generic.IEnumerable<string> GetDataFormats() { throw null; }
        public void Set(string dataFormat, object value) { }
    }
    public static partial class DataObjectExtensions
    {
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.ObsoleteAttribute("Use GetFiles, this method is supported only on desktop platforms.")]
        public static System.Collections.Generic.IEnumerable<string>? GetFileNames(this Avalonia.Input.IDataObject dataObject) { throw null; }
        public static System.Collections.Generic.IEnumerable<Avalonia.Platform.Storage.IStorageItem>? GetFiles(this Avalonia.Input.IDataObject dataObject) { throw null; }
        public static string? GetText(this Avalonia.Input.IDataObject dataObject) { throw null; }
    }
    public static partial class DragDrop
    {
        public static readonly Avalonia.AttachedProperty<bool> AllowDropProperty;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.DragEventArgs> DragEnterEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.DragEventArgs> DragLeaveEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.DragEventArgs> DragOverEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.DragEventArgs> DropEvent;
        public static System.Threading.Tasks.Task<Avalonia.Input.DragDropEffects> DoDragDrop(Avalonia.Input.PointerEventArgs triggerEvent, Avalonia.Input.IDataObject data, Avalonia.Input.DragDropEffects allowedEffects) { throw null; }
        public static bool GetAllowDrop(Avalonia.Interactivity.Interactive interactive) { throw null; }
        public static void SetAllowDrop(Avalonia.Interactivity.Interactive interactive, bool value) { }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class DragDropDevice : Avalonia.Input.IInputDevice, Avalonia.Input.Raw.IDragDropDevice
    {
        public static readonly Avalonia.Input.DragDropDevice Instance;
        public DragDropDevice() { }
        public void ProcessRawEvent(Avalonia.Input.Raw.RawInputEventArgs e) { }
    }
    [System.FlagsAttribute]
    public enum DragDropEffects
    {
        None = 0,
        Copy = 1,
        Move = 2,
        Link = 4,
    }
    public partial class DragEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        [Avalonia.Metadata.UnstableAttribute("This constructor might be removed in 12.0. For unit testing, consider using DragDrop.DoDragDrop or IHeadlessWindow.DragDrop.")]
        public DragEventArgs(Avalonia.Interactivity.RoutedEvent<Avalonia.Input.DragEventArgs> routedEvent, Avalonia.Input.IDataObject data, Avalonia.Interactivity.Interactive target, Avalonia.Point targetLocation, Avalonia.Input.KeyModifiers keyModifiers) { }
        public Avalonia.Input.IDataObject Data { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Input.DragDropEffects DragEffects { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.KeyModifiers KeyModifiers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Point GetPosition(Avalonia.Visual relativeTo) { throw null; }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class FocusManager : Avalonia.Input.IFocusManager
    {
        public FocusManager() { }
        public Avalonia.Input.IFocusScope? Scope { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public void ClearFocus() { }
        public bool Focus(Avalonia.Input.IInputElement? control, Avalonia.Input.NavigationMethod method = Avalonia.Input.NavigationMethod.Unspecified, Avalonia.Input.KeyModifiers keyModifiers = Avalonia.Input.KeyModifiers.None) { throw null; }
        public Avalonia.Input.IInputElement? GetFocusedElement() { throw null; }
        public Avalonia.Input.IInputElement? GetFocusedElement(Avalonia.Input.IFocusScope scope) { throw null; }
        public static bool GetIsFocusScope(Avalonia.Input.IInputElement e) { throw null; }
        public void RemoveFocusScope(Avalonia.Input.IFocusScope scope) { }
        public bool SetFocusedElement(Avalonia.Input.IFocusScope scope, Avalonia.Input.IInputElement? element, Avalonia.Input.NavigationMethod method = Avalonia.Input.NavigationMethod.Unspecified, Avalonia.Input.KeyModifiers keyModifiers = Avalonia.Input.KeyModifiers.None) { throw null; }
        public void SetFocusScope(Avalonia.Input.IFocusScope scope) { }
    }
    public static partial class Gestures
    {
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.TappedEventArgs> DoubleTappedEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.HoldingRoutedEventArgs> HoldingEvent;
        public static readonly Avalonia.AttachedProperty<bool> IsHoldingEnabledProperty;
        public static readonly Avalonia.AttachedProperty<bool> IsHoldWithMouseEnabledProperty;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.PinchEndedEventArgs> PinchEndedEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.PinchEventArgs> PinchEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.PointerDeltaEventArgs> PointerTouchPadGestureMagnifyEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.PointerDeltaEventArgs> PointerTouchPadGestureRotateEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.PointerDeltaEventArgs> PointerTouchPadGestureSwipeEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.PullGestureEndedEventArgs> PullGestureEndedEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.PullGestureEventArgs> PullGestureEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.TappedEventArgs> RightTappedEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.ScrollGestureEndedEventArgs> ScrollGestureEndedEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.ScrollGestureEventArgs> ScrollGestureEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.ScrollGestureInertiaStartingEventArgs> ScrollGestureInertiaStartingEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.TappedEventArgs> TappedEvent;
        public static void AddDoubleTappedHandler(Avalonia.Interactivity.Interactive element, System.EventHandler<Avalonia.Interactivity.RoutedEventArgs> handler) { }
        public static void AddRightTappedHandler(Avalonia.Interactivity.Interactive element, System.EventHandler<Avalonia.Interactivity.RoutedEventArgs> handler) { }
        public static void AddTappedHandler(Avalonia.Interactivity.Interactive element, System.EventHandler<Avalonia.Interactivity.RoutedEventArgs> handler) { }
        public static bool GetIsHoldingEnabled(Avalonia.StyledElement element) { throw null; }
        public static bool GetIsHoldWithMouseEnabled(Avalonia.StyledElement element) { throw null; }
        public static void RemoveDoubleTappedHandler(Avalonia.Interactivity.Interactive element, System.EventHandler<Avalonia.Interactivity.RoutedEventArgs> handler) { }
        public static void RemoveRightTappedHandler(Avalonia.Interactivity.Interactive element, System.EventHandler<Avalonia.Interactivity.RoutedEventArgs> handler) { }
        public static void RemoveTappedHandler(Avalonia.Interactivity.Interactive element, System.EventHandler<Avalonia.Interactivity.RoutedEventArgs> handler) { }
        public static void SetIsHoldingEnabled(Avalonia.StyledElement element, bool value) { }
        public static void SetIsHoldWithMouseEnabled(Avalonia.StyledElement element, bool value) { }
    }
    public partial class GotFocusEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        public GotFocusEventArgs() { }
        public Avalonia.Input.KeyModifiers KeyModifiers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.NavigationMethod NavigationMethod { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    public partial class HoldingRoutedEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        public HoldingRoutedEventArgs(Avalonia.Input.HoldingState holdingState, Avalonia.Point position, Avalonia.Input.PointerType pointerType) { }
        public Avalonia.Input.HoldingState HoldingState { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Input.PointerType PointerType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Point Position { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public enum HoldingState
    {
        Started = 0,
        Completed = 1,
        Cancelled = 2,
    }
    public partial interface ICloseable
    {
        event System.EventHandler? Closed;
    }
    public partial interface ICommandSource
    {
        System.Windows.Input.ICommand? Command { get; }
        object? CommandParameter { get; }
        bool IsEffectivelyEnabled { get; }
        void CanExecuteChanged(object sender, System.EventArgs e);
    }
    public partial interface ICustomKeyboardNavigation
    {
        (bool handled, Avalonia.Input.IInputElement? next) GetNext(Avalonia.Input.IInputElement element, Avalonia.Input.NavigationDirection direction);
    }
    public partial interface IDataObject
    {
        bool Contains(string dataFormat);
        object? Get(string dataFormat);
        System.Collections.Generic.IEnumerable<string> GetDataFormats();
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IFocusManager
    {
        [Avalonia.Metadata.UnstableAttribute("This API might be removed in 11.x minor updates. Please consider focusing another element instead of removing focus at all for better UX.")]
        void ClearFocus();
        Avalonia.Input.IInputElement? GetFocusedElement();
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IFocusScope
    {
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial interface IInputDevice
    {
        void ProcessRawEvent(Avalonia.Input.Raw.RawInputEventArgs ev);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IInputElement
    {
        Avalonia.Input.Cursor? Cursor { get; }
        bool Focusable { get; }
        bool IsEffectivelyEnabled { get; }
        bool IsEffectivelyVisible { get; }
        bool IsEnabled { get; }
        bool IsFocused { get; }
        bool IsHitTestVisible { get; }
        bool IsKeyboardFocusWithin { get; }
        bool IsPointerOver { get; }
        System.Collections.Generic.List<Avalonia.Input.KeyBinding> KeyBindings { get; }
        event System.EventHandler<Avalonia.Input.GotFocusEventArgs>? GotFocus;
        event System.EventHandler<Avalonia.Input.KeyEventArgs>? KeyDown;
        event System.EventHandler<Avalonia.Input.KeyEventArgs>? KeyUp;
        event System.EventHandler<Avalonia.Interactivity.RoutedEventArgs>? LostFocus;
        event System.EventHandler<Avalonia.Input.PointerEventArgs>? PointerEntered;
        event System.EventHandler<Avalonia.Input.PointerEventArgs>? PointerExited;
        event System.EventHandler<Avalonia.Input.PointerEventArgs>? PointerMoved;
        event System.EventHandler<Avalonia.Input.PointerPressedEventArgs>? PointerPressed;
        event System.EventHandler<Avalonia.Input.PointerReleasedEventArgs>? PointerReleased;
        event System.EventHandler<Avalonia.Input.PointerWheelEventArgs>? PointerWheelChanged;
        event System.EventHandler<Avalonia.Input.TextInputEventArgs>? TextInput;
        void AddHandler(Avalonia.Interactivity.RoutedEvent routedEvent, System.Delegate handler, Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble | Avalonia.Interactivity.RoutingStrategies.Direct, bool handledEventsToo = false);
        bool Focus(Avalonia.Input.NavigationMethod method = Avalonia.Input.NavigationMethod.Unspecified, Avalonia.Input.KeyModifiers keyModifiers = Avalonia.Input.KeyModifiers.None);
        void RaiseEvent(Avalonia.Interactivity.RoutedEventArgs e);
        void RemoveHandler(Avalonia.Interactivity.RoutedEvent routedEvent, System.Delegate handler);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial interface IInputManager
    {
        System.IObservable<Avalonia.Input.Raw.RawInputEventArgs> PostProcess { get; }
        System.IObservable<Avalonia.Input.Raw.RawInputEventArgs> PreProcess { get; }
        System.IObservable<Avalonia.Input.Raw.RawInputEventArgs> Process { get; }
        void ProcessInput(Avalonia.Input.Raw.RawInputEventArgs e);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IInputRoot : Avalonia.Input.IInputElement
    {
        Avalonia.Input.IFocusManager? FocusManager { get; }
        Avalonia.Input.IKeyboardNavigationHandler KeyboardNavigationHandler { get; }
        Avalonia.Platform.IPlatformSettings? PlatformSettings { get; }
        Avalonia.Input.IInputElement? PointerOverElement { get; set; }
        bool ShowAccessKeys { get; set; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IKeyboardDevice : Avalonia.Input.IInputDevice
    {
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IKeyboardNavigationHandler
    {
        void Move(Avalonia.Input.IInputElement element, Avalonia.Input.NavigationDirection direction, Avalonia.Input.KeyModifiers keyModifiers = Avalonia.Input.KeyModifiers.None);
        [Avalonia.Metadata.PrivateApiAttribute]
        void SetOwner(Avalonia.Input.IInputRoot owner);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IMouseDevice : Avalonia.Input.IInputDevice, Avalonia.Input.IPointerDevice
    {
    }
    public partial interface INavigableContainer
    {
        Avalonia.Input.IInputElement? GetControl(Avalonia.Input.NavigationDirection direction, Avalonia.Input.IInputElement? from, bool wrap);
    }
    [Avalonia.Controls.Metadata.PseudoClassesAttribute(new string[]{ ":disabled", ":focus", ":focus-visible", ":focus-within", ":pointerover"})]
    public partial class InputElement : Avalonia.Interactivity.Interactive, Avalonia.Input.IInputElement
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Input.Cursor?> CursorProperty;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.TappedEventArgs> DoubleTappedEvent;
        public static readonly Avalonia.StyledProperty<bool> FocusableProperty;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.GotFocusEventArgs> GotFocusEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.HoldingRoutedEventArgs> HoldingEvent;
        public static readonly Avalonia.DirectProperty<Avalonia.Input.InputElement, bool> IsEffectivelyEnabledProperty;
        public static readonly Avalonia.StyledProperty<bool> IsEnabledProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Input.InputElement, bool> IsFocusedProperty;
        public static readonly Avalonia.StyledProperty<bool> IsHitTestVisibleProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Input.InputElement, bool> IsKeyboardFocusWithinProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Input.InputElement, bool> IsPointerOverProperty;
        public static readonly Avalonia.StyledProperty<bool> IsTabStopProperty;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.KeyEventArgs> KeyDownEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.KeyEventArgs> KeyUpEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Interactivity.RoutedEventArgs> LostFocusEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.PointerCaptureLostEventArgs> PointerCaptureLostEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.PointerEventArgs> PointerEnteredEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.PointerEventArgs> PointerExitedEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.PointerEventArgs> PointerMovedEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.PointerPressedEventArgs> PointerPressedEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.PointerReleasedEventArgs> PointerReleasedEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.PointerWheelEventArgs> PointerWheelChangedEvent;
        public static readonly Avalonia.StyledProperty<int> TabIndexProperty;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.TappedEventArgs> TappedEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.TextInputEventArgs> TextInputEvent;
        public static readonly Avalonia.Interactivity.RoutedEvent<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs> TextInputMethodClientRequestedEvent;
        public InputElement() { }
        public Avalonia.Input.Cursor? Cursor { get { throw null; } set { } }
        public bool Focusable { get { throw null; } set { } }
        public Avalonia.Input.GestureRecognizers.GestureRecognizerCollection GestureRecognizers { get { throw null; } }
        public bool IsEffectivelyEnabled { get { throw null; } }
        public bool IsEnabled { get { throw null; } set { } }
        protected virtual bool IsEnabledCore { get { throw null; } }
        public bool IsFocused { get { throw null; } }
        public bool IsHitTestVisible { get { throw null; } set { } }
        public bool IsKeyboardFocusWithin { get { throw null; } }
        public bool IsPointerOver { get { throw null; } }
        public bool IsTabStop { get { throw null; } set { } }
        public System.Collections.Generic.List<Avalonia.Input.KeyBinding> KeyBindings { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int TabIndex { get { throw null; } set { } }
        public event System.EventHandler<Avalonia.Input.TappedEventArgs>? DoubleTapped { add { } remove { } }
        public event System.EventHandler<Avalonia.Input.GotFocusEventArgs>? GotFocus { add { } remove { } }
        public event System.EventHandler<Avalonia.Input.HoldingRoutedEventArgs>? Holding { add { } remove { } }
        public event System.EventHandler<Avalonia.Input.KeyEventArgs>? KeyDown { add { } remove { } }
        public event System.EventHandler<Avalonia.Input.KeyEventArgs>? KeyUp { add { } remove { } }
        public event System.EventHandler<Avalonia.Interactivity.RoutedEventArgs>? LostFocus { add { } remove { } }
        public event System.EventHandler<Avalonia.Input.PointerCaptureLostEventArgs>? PointerCaptureLost { add { } remove { } }
        public event System.EventHandler<Avalonia.Input.PointerEventArgs>? PointerEntered { add { } remove { } }
        public event System.EventHandler<Avalonia.Input.PointerEventArgs>? PointerExited { add { } remove { } }
        public event System.EventHandler<Avalonia.Input.PointerEventArgs>? PointerMoved { add { } remove { } }
        public event System.EventHandler<Avalonia.Input.PointerPressedEventArgs>? PointerPressed { add { } remove { } }
        public event System.EventHandler<Avalonia.Input.PointerReleasedEventArgs>? PointerReleased { add { } remove { } }
        public event System.EventHandler<Avalonia.Input.PointerWheelEventArgs>? PointerWheelChanged { add { } remove { } }
        public event System.EventHandler<Avalonia.Input.TappedEventArgs>? Tapped { add { } remove { } }
        public event System.EventHandler<Avalonia.Input.TextInputEventArgs>? TextInput { add { } remove { } }
        public event System.EventHandler<Avalonia.Input.TextInput.TextInputMethodClientRequestedEventArgs>? TextInputMethodClientRequested { add { } remove { } }
        public bool Focus(Avalonia.Input.NavigationMethod method = Avalonia.Input.NavigationMethod.Unspecified, Avalonia.Input.KeyModifiers keyModifiers = Avalonia.Input.KeyModifiers.None) { throw null; }
        protected override void OnAttachedToVisualTreeCore(Avalonia.VisualTreeAttachmentEventArgs e) { }
        protected override void OnDetachedFromVisualTreeCore(Avalonia.VisualTreeAttachmentEventArgs e) { }
        protected virtual void OnGotFocus(Avalonia.Input.GotFocusEventArgs e) { }
        protected virtual void OnKeyDown(Avalonia.Input.KeyEventArgs e) { }
        protected virtual void OnKeyUp(Avalonia.Input.KeyEventArgs e) { }
        protected virtual void OnLostFocus(Avalonia.Interactivity.RoutedEventArgs e) { }
        protected virtual void OnPointerCaptureLost(Avalonia.Input.PointerCaptureLostEventArgs e) { }
        protected virtual void OnPointerEntered(Avalonia.Input.PointerEventArgs e) { }
        protected virtual void OnPointerExited(Avalonia.Input.PointerEventArgs e) { }
        protected virtual void OnPointerMoved(Avalonia.Input.PointerEventArgs e) { }
        protected virtual void OnPointerPressed(Avalonia.Input.PointerPressedEventArgs e) { }
        protected virtual void OnPointerReleased(Avalonia.Input.PointerReleasedEventArgs e) { }
        protected virtual void OnPointerWheelChanged(Avalonia.Input.PointerWheelEventArgs e) { }
        protected override void OnPropertyChanged(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
        protected virtual void OnTextInput(Avalonia.Input.TextInputEventArgs e) { }
        protected void UpdateIsEffectivelyEnabled() { }
    }
    public static partial class InputExtensions
    {
        public static System.Collections.Generic.IEnumerable<Avalonia.Input.IInputElement> GetInputElementsAt(this Avalonia.Input.IInputElement element, Avalonia.Point p) { throw null; }
        public static Avalonia.Input.IInputElement? InputHitTest(this Avalonia.Input.IInputElement element, Avalonia.Point p) { throw null; }
        public static Avalonia.Input.IInputElement? InputHitTest(this Avalonia.Input.IInputElement element, Avalonia.Point p, System.Func<Avalonia.Visual, bool> filter) { throw null; }
    }
    public partial class InputMethod
    {
        internal InputMethod() { }
        public static readonly Avalonia.AvaloniaProperty<bool> IsInputMethodEnabledProperty;
        public static bool GetIsInputMethodEnabled(Avalonia.Input.InputElement target) { throw null; }
        public static void SetIsInputMethodEnabled(Avalonia.Input.InputElement target, bool value) { }
    }
    public partial interface IPenDevice : Avalonia.Input.IInputDevice, Avalonia.Input.IPointerDevice
    {
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IPointer
    {
        Avalonia.Input.IInputElement? Captured { get; }
        int Id { get; }
        bool IsPrimary { get; }
        Avalonia.Input.PointerType Type { get; }
        void Capture(Avalonia.Input.IInputElement? control);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IPointerDevice : Avalonia.Input.IInputDevice
    {
        Avalonia.Input.IPointer? TryGetPointer(Avalonia.Input.Raw.RawPointerEventArgs ev);
    }
    public enum Key
    {
        None = 0,
        Cancel = 1,
        Back = 2,
        Tab = 3,
        LineFeed = 4,
        Clear = 5,
        Enter = 6,
        Return = 6,
        Pause = 7,
        Capital = 8,
        CapsLock = 8,
        HangulMode = 9,
        KanaMode = 9,
        JunjaMode = 10,
        FinalMode = 11,
        HanjaMode = 12,
        KanjiMode = 12,
        Escape = 13,
        ImeConvert = 14,
        ImeNonConvert = 15,
        ImeAccept = 16,
        ImeModeChange = 17,
        Space = 18,
        PageUp = 19,
        Prior = 19,
        Next = 20,
        PageDown = 20,
        End = 21,
        Home = 22,
        Left = 23,
        Up = 24,
        Right = 25,
        Down = 26,
        Select = 27,
        Print = 28,
        Execute = 29,
        PrintScreen = 30,
        Snapshot = 30,
        Insert = 31,
        Delete = 32,
        Help = 33,
        D0 = 34,
        D1 = 35,
        D2 = 36,
        D3 = 37,
        D4 = 38,
        D5 = 39,
        D6 = 40,
        D7 = 41,
        D8 = 42,
        D9 = 43,
        A = 44,
        B = 45,
        C = 46,
        D = 47,
        E = 48,
        F = 49,
        G = 50,
        H = 51,
        I = 52,
        J = 53,
        K = 54,
        L = 55,
        M = 56,
        N = 57,
        O = 58,
        P = 59,
        Q = 60,
        R = 61,
        S = 62,
        T = 63,
        U = 64,
        V = 65,
        W = 66,
        X = 67,
        Y = 68,
        Z = 69,
        LWin = 70,
        RWin = 71,
        Apps = 72,
        Sleep = 73,
        NumPad0 = 74,
        NumPad1 = 75,
        NumPad2 = 76,
        NumPad3 = 77,
        NumPad4 = 78,
        NumPad5 = 79,
        NumPad6 = 80,
        NumPad7 = 81,
        NumPad8 = 82,
        NumPad9 = 83,
        Multiply = 84,
        Add = 85,
        Separator = 86,
        Subtract = 87,
        Decimal = 88,
        Divide = 89,
        F1 = 90,
        F2 = 91,
        F3 = 92,
        F4 = 93,
        F5 = 94,
        F6 = 95,
        F7 = 96,
        F8 = 97,
        F9 = 98,
        F10 = 99,
        F11 = 100,
        F12 = 101,
        F13 = 102,
        F14 = 103,
        F15 = 104,
        F16 = 105,
        F17 = 106,
        F18 = 107,
        F19 = 108,
        F20 = 109,
        F21 = 110,
        F22 = 111,
        F23 = 112,
        F24 = 113,
        NumLock = 114,
        Scroll = 115,
        LeftShift = 116,
        RightShift = 117,
        LeftCtrl = 118,
        RightCtrl = 119,
        LeftAlt = 120,
        RightAlt = 121,
        BrowserBack = 122,
        BrowserForward = 123,
        BrowserRefresh = 124,
        BrowserStop = 125,
        BrowserSearch = 126,
        BrowserFavorites = 127,
        BrowserHome = 128,
        VolumeMute = 129,
        VolumeDown = 130,
        VolumeUp = 131,
        MediaNextTrack = 132,
        MediaPreviousTrack = 133,
        MediaStop = 134,
        MediaPlayPause = 135,
        LaunchMail = 136,
        SelectMedia = 137,
        LaunchApplication1 = 138,
        LaunchApplication2 = 139,
        Oem1 = 140,
        OemSemicolon = 140,
        OemPlus = 141,
        OemComma = 142,
        OemMinus = 143,
        OemPeriod = 144,
        Oem2 = 145,
        OemQuestion = 145,
        Oem3 = 146,
        OemTilde = 146,
        AbntC1 = 147,
        AbntC2 = 148,
        Oem4 = 149,
        OemOpenBrackets = 149,
        Oem5 = 150,
        OemPipe = 150,
        Oem6 = 151,
        OemCloseBrackets = 151,
        Oem7 = 152,
        OemQuotes = 152,
        Oem8 = 153,
        Oem102 = 154,
        OemBackslash = 154,
        ImeProcessed = 155,
        System = 156,
        DbeAlphanumeric = 157,
        OemAttn = 157,
        DbeKatakana = 158,
        OemFinish = 158,
        DbeHiragana = 159,
        OemCopy = 159,
        DbeSbcsChar = 160,
        OemAuto = 160,
        DbeDbcsChar = 161,
        OemEnlw = 161,
        DbeRoman = 162,
        OemBackTab = 162,
        Attn = 163,
        DbeNoRoman = 163,
        CrSel = 164,
        DbeEnterWordRegisterMode = 164,
        DbeEnterImeConfigureMode = 165,
        ExSel = 165,
        DbeFlushString = 166,
        EraseEof = 166,
        DbeCodeInput = 167,
        Play = 167,
        DbeNoCodeInput = 168,
        Zoom = 168,
        DbeDetermineString = 169,
        NoName = 169,
        DbeEnterDialogConversionMode = 170,
        Pa1 = 170,
        OemClear = 171,
        DeadCharProcessed = 172,
        FnLeftArrow = 10001,
        FnRightArrow = 10002,
        FnUpArrow = 10003,
        FnDownArrow = 10004,
    }
    public partial class KeyBinding : Avalonia.AvaloniaObject
    {
        public static readonly Avalonia.StyledProperty<object> CommandParameterProperty;
        public static readonly Avalonia.StyledProperty<System.Windows.Input.ICommand> CommandProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Input.KeyGesture> GestureProperty;
        public KeyBinding() { }
        public System.Windows.Input.ICommand Command { get { throw null; } set { } }
        public object CommandParameter { get { throw null; } set { } }
        public Avalonia.Input.KeyGesture Gesture { get { throw null; } set { } }
        public void TryHandle(Avalonia.Input.KeyEventArgs args) { }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class KeyboardDevice : Avalonia.Input.IInputDevice, Avalonia.Input.IKeyboardDevice, System.ComponentModel.INotifyPropertyChanged
    {
        public KeyboardDevice() { }
        public Avalonia.Input.IInputElement? FocusedElement { get { throw null; } }
        public Avalonia.Input.IFocusManager? FocusManager { get { throw null; } }
        public Avalonia.Input.IInputManager? InputManager { get { throw null; } }
        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged { add { } remove { } }
        public void ProcessRawEvent(Avalonia.Input.Raw.RawInputEventArgs e) { }
        protected void RaisePropertyChanged([System.Runtime.CompilerServices.CallerMemberNameAttribute] string propertyName = "") { }
        public void SetFocusedElement(Avalonia.Input.IInputElement? element, Avalonia.Input.NavigationMethod method, Avalonia.Input.KeyModifiers keyModifiers) { }
    }
    public static partial class KeyboardNavigation
    {
        public static readonly Avalonia.AttachedProperty<bool> IsTabStopProperty;
        public static readonly Avalonia.AttachedProperty<int> TabIndexProperty;
        public static readonly Avalonia.AttachedProperty<Avalonia.Input.KeyboardNavigationMode> TabNavigationProperty;
        public static readonly Avalonia.AttachedProperty<Avalonia.Input.IInputElement?> TabOnceActiveElementProperty;
        public static bool GetIsTabStop(Avalonia.Input.InputElement element) { throw null; }
        public static int GetTabIndex(Avalonia.Input.IInputElement element) { throw null; }
        public static Avalonia.Input.KeyboardNavigationMode GetTabNavigation(Avalonia.Input.InputElement element) { throw null; }
        public static Avalonia.Input.IInputElement? GetTabOnceActiveElement(Avalonia.Input.InputElement element) { throw null; }
        public static void SetIsTabStop(Avalonia.Input.InputElement element, bool value) { }
        public static void SetTabIndex(Avalonia.Input.IInputElement element, int value) { }
        public static void SetTabNavigation(Avalonia.Input.InputElement element, Avalonia.Input.KeyboardNavigationMode value) { }
        public static void SetTabOnceActiveElement(Avalonia.Input.InputElement element, Avalonia.Input.IInputElement? value) { }
    }
    [Avalonia.Metadata.UnstableAttribute]
    public sealed partial class KeyboardNavigationHandler : Avalonia.Input.IKeyboardNavigationHandler
    {
        public KeyboardNavigationHandler() { }
        public static Avalonia.Input.IInputElement? GetNext(Avalonia.Input.IInputElement element, Avalonia.Input.NavigationDirection direction) { throw null; }
        public void Move(Avalonia.Input.IInputElement? element, Avalonia.Input.NavigationDirection direction, Avalonia.Input.KeyModifiers keyModifiers = Avalonia.Input.KeyModifiers.None) { }
        [Avalonia.Metadata.PrivateApiAttribute]
        public void SetOwner(Avalonia.Input.IInputRoot owner) { }
    }
    public enum KeyboardNavigationMode
    {
        Continue = 0,
        Cycle = 1,
        Contained = 2,
        Once = 3,
        None = 4,
        Local = 5,
    }
    public partial class KeyEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        public KeyEventArgs() { }
        public Avalonia.Input.IKeyboardDevice? Device { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.Key Key { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.KeyModifiers KeyModifiers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    public sealed partial class KeyGesture : System.IEquatable<Avalonia.Input.KeyGesture>
    {
        public KeyGesture(Avalonia.Input.Key key, Avalonia.Input.KeyModifiers modifiers = Avalonia.Input.KeyModifiers.None) { }
        public Avalonia.Input.Key Key { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Input.KeyModifiers KeyModifiers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.Input.KeyGesture? other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public bool Matches(Avalonia.Input.KeyEventArgs? keyEvent) { throw null; }
        public static bool operator ==(Avalonia.Input.KeyGesture? left, Avalonia.Input.KeyGesture? right) { throw null; }
        public static bool operator !=(Avalonia.Input.KeyGesture? left, Avalonia.Input.KeyGesture? right) { throw null; }
        public static Avalonia.Input.KeyGesture Parse(string gesture) { throw null; }
        public override string ToString() { throw null; }
    }
    [System.FlagsAttribute]
    public enum KeyModifiers
    {
        None = 0,
        Alt = 1,
        Control = 2,
        Shift = 4,
        Meta = 8,
    }
    [System.FlagsAttribute]
    public enum KeyStates
    {
        None = 0,
        Down = 1,
        Toggled = 2,
    }
    public enum MouseButton
    {
        None = 0,
        Left = 1,
        Right = 2,
        Middle = 3,
        XButton1 = 4,
        XButton2 = 5,
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class MouseDevice : Avalonia.Input.IInputDevice, Avalonia.Input.IMouseDevice, Avalonia.Input.IPointerDevice, System.IDisposable
    {
        public MouseDevice(Avalonia.Input.Pointer? pointer = null) { }
        public void Dispose() { }
        public void ProcessRawEvent(Avalonia.Input.Raw.RawInputEventArgs e) { }
        public Avalonia.Input.IPointer? TryGetPointer(Avalonia.Input.Raw.RawPointerEventArgs ev) { throw null; }
    }
    public enum NavigationDirection
    {
        Next = 0,
        Previous = 1,
        First = 2,
        Last = 3,
        Left = 4,
        Right = 5,
        Up = 6,
        Down = 7,
        PageUp = 8,
        PageDown = 9,
    }
    public static partial class NavigationDirectionExtensions
    {
        public static bool IsDirectional(this Avalonia.Input.NavigationDirection direction) { throw null; }
        public static bool IsTab(this Avalonia.Input.NavigationDirection direction) { throw null; }
        public static Avalonia.Input.NavigationDirection? ToNavigationDirection(this Avalonia.Input.Key key, Avalonia.Input.KeyModifiers modifiers = Avalonia.Input.KeyModifiers.None) { throw null; }
    }
    public enum NavigationMethod
    {
        Unspecified = 0,
        Tab = 1,
        Directional = 2,
        Pointer = 3,
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class PenDevice : Avalonia.Input.IInputDevice, Avalonia.Input.IPenDevice, Avalonia.Input.IPointerDevice, System.IDisposable
    {
        public PenDevice() { }
        public void Dispose() { }
        public void ProcessRawEvent(Avalonia.Input.Raw.RawInputEventArgs e) { }
        public Avalonia.Input.IPointer? TryGetPointer(Avalonia.Input.Raw.RawPointerEventArgs ev) { throw null; }
    }
    public partial class PinchEndedEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        public PinchEndedEventArgs() { }
    }
    public partial class PinchEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        public PinchEventArgs(double scale, Avalonia.Point scaleOrigin) { }
        public double Scale { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Point ScaleOrigin { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class PinchGestureRecognizer : Avalonia.StyledElement, Avalonia.Input.GestureRecognizers.IGestureRecognizer
    {
        public PinchGestureRecognizer() { }
        public void Initialize(Avalonia.Input.IInputElement target, Avalonia.Input.GestureRecognizers.IGestureRecognizerActionsDispatcher actions) { }
        public void PointerCaptureLost(Avalonia.Input.IPointer pointer) { }
        public void PointerMoved(Avalonia.Input.PointerEventArgs e) { }
        public void PointerPressed(Avalonia.Input.PointerPressedEventArgs e) { }
        public void PointerReleased(Avalonia.Input.PointerReleasedEventArgs e) { }
    }
    public partial class Pointer : Avalonia.Input.IPointer, System.IDisposable
    {
        public Pointer(int id, Avalonia.Input.PointerType type, bool isPrimary) { }
        public Avalonia.Input.IInputElement? Captured { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int Id { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsPrimary { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Input.PointerType Type { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public void Capture(Avalonia.Input.IInputElement? control) { }
        public void Dispose() { }
        public static int GetNextFreeId() { throw null; }
        protected virtual void PlatformCapture(Avalonia.Input.IInputElement? element) { }
    }
    public partial class PointerCaptureLostEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        [Avalonia.Metadata.UnstableAttribute("This constructor might be removed in 12.0. If you need to remove capture, use stable methods on the IPointer instance.,")]
        public PointerCaptureLostEventArgs(object source, Avalonia.Input.IPointer pointer) { }
        public Avalonia.Input.IPointer Pointer { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class PointerDeltaEventArgs : Avalonia.Input.PointerEventArgs
    {
        [Avalonia.Metadata.UnstableAttribute("This constructor might be removed in 12.0.")]
        public PointerDeltaEventArgs(Avalonia.Interactivity.RoutedEvent routedEvent, object? source, Avalonia.Input.IPointer pointer, Avalonia.Visual rootVisual, Avalonia.Point rootVisualPosition, ulong timestamp, Avalonia.Input.PointerPointProperties properties, Avalonia.Input.KeyModifiers modifiers, Avalonia.Vector delta) : base (default(Avalonia.Interactivity.RoutedEvent), default(object), default(Avalonia.Input.IPointer), default(Avalonia.Visual), default(Avalonia.Point), default(ulong), default(Avalonia.Input.PointerPointProperties), default(Avalonia.Input.KeyModifiers)) { }
        public Avalonia.Vector Delta { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class PointerEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        [Avalonia.Metadata.UnstableAttribute("This constructor might be removed in 12.0. For unit testing, consider using IHeadlessWindow mouse methods.")]
        public PointerEventArgs(Avalonia.Interactivity.RoutedEvent routedEvent, object? source, Avalonia.Input.IPointer pointer, Avalonia.Visual? rootVisual, Avalonia.Point rootVisualPosition, ulong timestamp, Avalonia.Input.PointerPointProperties properties, Avalonia.Input.KeyModifiers modifiers) { }
        public Avalonia.Input.KeyModifiers KeyModifiers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Input.IPointer Pointer { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        protected Avalonia.Input.PointerPointProperties Properties { get { throw null; } }
        public ulong Timestamp { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Input.PointerPoint GetCurrentPoint(Avalonia.Visual? relativeTo) { throw null; }
        public System.Collections.Generic.IReadOnlyList<Avalonia.Input.PointerPoint> GetIntermediatePoints(Avalonia.Visual? relativeTo) { throw null; }
        public Avalonia.Point GetPosition(Avalonia.Visual? relativeTo) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct PointerPoint : System.IEquatable<Avalonia.Input.PointerPoint>
    {
        private object _dummy;
        private int _dummyPrimitive;
        public PointerPoint(Avalonia.Input.IPointer pointer, Avalonia.Point position, Avalonia.Input.PointerPointProperties properties) { throw null; }
        public Avalonia.Input.IPointer Pointer { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Point Position { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Input.PointerPointProperties Properties { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Input.PointerPoint other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Input.PointerPoint left, Avalonia.Input.PointerPoint right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Input.PointerPoint left, Avalonia.Input.PointerPoint right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct PointerPointProperties : System.IEquatable<Avalonia.Input.PointerPointProperties>
    {
        private int _dummyPrimitive;
        public PointerPointProperties() { throw null; }
        public PointerPointProperties(Avalonia.Input.RawInputModifiers modifiers, Avalonia.Input.PointerUpdateKind kind) { throw null; }
        public PointerPointProperties(Avalonia.Input.RawInputModifiers modifiers, Avalonia.Input.PointerUpdateKind kind, float twist, float pressure, float xTilt, float yTilt) { throw null; }
        public bool IsBarrelButtonPressed { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsEraser { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsInverted { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsLeftButtonPressed { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsMiddleButtonPressed { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsRightButtonPressed { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsXButton1Pressed { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsXButton2Pressed { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Input.PointerPointProperties None { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Input.PointerUpdateKind PointerUpdateKind { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public float Pressure { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public float Twist { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public float XTilt { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public float YTilt { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Input.PointerPointProperties other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Input.PointerPointProperties left, Avalonia.Input.PointerPointProperties right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Input.PointerPointProperties left, Avalonia.Input.PointerPointProperties right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public partial class PointerPressedEventArgs : Avalonia.Input.PointerEventArgs
    {
        [Avalonia.Metadata.UnstableAttribute("This constructor might be removed in 12.0. For unit testing, consider using IHeadlessWindow mouse methods.")]
        public PointerPressedEventArgs(object source, Avalonia.Input.IPointer pointer, Avalonia.Visual rootVisual, Avalonia.Point rootVisualPosition, ulong timestamp, Avalonia.Input.PointerPointProperties properties, Avalonia.Input.KeyModifiers modifiers, int clickCount = 1) : base (default(Avalonia.Interactivity.RoutedEvent), default(object), default(Avalonia.Input.IPointer), default(Avalonia.Visual), default(Avalonia.Point), default(ulong), default(Avalonia.Input.PointerPointProperties), default(Avalonia.Input.KeyModifiers)) { }
        public int ClickCount { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class PointerReleasedEventArgs : Avalonia.Input.PointerEventArgs
    {
        [Avalonia.Metadata.UnstableAttribute("This constructor might be removed in 12.0. For unit testing, consider using IHeadlessWindow mouse methods.")]
        public PointerReleasedEventArgs(object source, Avalonia.Input.IPointer pointer, Avalonia.Visual rootVisual, Avalonia.Point rootVisualPosition, ulong timestamp, Avalonia.Input.PointerPointProperties properties, Avalonia.Input.KeyModifiers modifiers, Avalonia.Input.MouseButton initialPressMouseButton) : base (default(Avalonia.Interactivity.RoutedEvent), default(object), default(Avalonia.Input.IPointer), default(Avalonia.Visual), default(Avalonia.Point), default(ulong), default(Avalonia.Input.PointerPointProperties), default(Avalonia.Input.KeyModifiers)) { }
        public Avalonia.Input.MouseButton InitialPressMouseButton { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public enum PointerType
    {
        Mouse = 0,
        Touch = 1,
        Pen = 2,
    }
    public enum PointerUpdateKind
    {
        LeftButtonPressed = 0,
        MiddleButtonPressed = 1,
        RightButtonPressed = 2,
        XButton1Pressed = 3,
        XButton2Pressed = 4,
        LeftButtonReleased = 5,
        MiddleButtonReleased = 6,
        RightButtonReleased = 7,
        XButton1Released = 8,
        XButton2Released = 9,
        Other = 10,
    }
    public static partial class PointerUpdateKindExtensions
    {
        public static Avalonia.Input.MouseButton GetMouseButton(this Avalonia.Input.PointerUpdateKind kind) { throw null; }
    }
    public partial class PointerWheelEventArgs : Avalonia.Input.PointerEventArgs
    {
        [Avalonia.Metadata.UnstableAttribute("This constructor might be removed in 12.0. For unit testing, consider using IHeadlessWindow.MouseWheel.")]
        public PointerWheelEventArgs(object source, Avalonia.Input.IPointer pointer, Avalonia.Visual rootVisual, Avalonia.Point rootVisualPosition, ulong timestamp, Avalonia.Input.PointerPointProperties properties, Avalonia.Input.KeyModifiers modifiers, Avalonia.Vector delta) : base (default(Avalonia.Interactivity.RoutedEvent), default(object), default(Avalonia.Input.IPointer), default(Avalonia.Visual), default(Avalonia.Point), default(ulong), default(Avalonia.Input.PointerPointProperties), default(Avalonia.Input.KeyModifiers)) { }
        public Avalonia.Vector Delta { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public enum PullDirection
    {
        TopToBottom = 0,
        BottomToTop = 1,
        LeftToRight = 2,
        RightToLeft = 3,
    }
    public partial class PullGestureEndedEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        public PullGestureEndedEventArgs(int id, Avalonia.Input.PullDirection pullDirection) { }
        public int Id { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Input.PullDirection PullDirection { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class PullGestureEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        public PullGestureEventArgs(int id, Avalonia.Vector delta, Avalonia.Input.PullDirection pullDirection) { }
        public Avalonia.Vector Delta { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int Id { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Input.PullDirection PullDirection { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class PullGestureRecognizer : Avalonia.StyledElement, Avalonia.Input.GestureRecognizers.IGestureRecognizer
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Input.PullDirection> PullDirectionProperty;
        public PullGestureRecognizer() { }
        public PullGestureRecognizer(Avalonia.Input.PullDirection pullDirection) { }
        public Avalonia.Input.PullDirection PullDirection { get { throw null; } set { } }
        public void Initialize(Avalonia.Input.IInputElement target, Avalonia.Input.GestureRecognizers.IGestureRecognizerActionsDispatcher actions) { }
        public void PointerCaptureLost(Avalonia.Input.IPointer pointer) { }
        public void PointerMoved(Avalonia.Input.PointerEventArgs e) { }
        public void PointerPressed(Avalonia.Input.PointerPressedEventArgs e) { }
        public void PointerReleased(Avalonia.Input.PointerReleasedEventArgs e) { }
    }
    [System.FlagsAttribute]
    public enum RawInputModifiers
    {
        None = 0,
        Alt = 1,
        Control = 2,
        Shift = 4,
        Meta = 8,
        KeyboardMask = 15,
        LeftMouseButton = 16,
        RightMouseButton = 32,
        MiddleMouseButton = 64,
        XButton1MouseButton = 128,
        XButton2MouseButton = 256,
        PenInverted = 512,
        PenEraser = 1024,
        PenBarrelButton = 2048,
    }
    public partial class ScrollGestureEndedEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        public ScrollGestureEndedEventArgs(int id) { }
        public int Id { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class ScrollGestureEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        public ScrollGestureEventArgs(int id, Avalonia.Vector delta) { }
        public Avalonia.Vector Delta { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int Id { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool ShouldEndScrollGesture { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public static int GetNextFreeId() { throw null; }
    }
    public partial class ScrollGestureInertiaStartingEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        internal ScrollGestureInertiaStartingEventArgs() { }
        public int Id { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Vector Inertia { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public enum StandardCursorType
    {
        Arrow = 0,
        Ibeam = 1,
        Wait = 2,
        Cross = 3,
        UpArrow = 4,
        SizeWestEast = 5,
        SizeNorthSouth = 6,
        SizeAll = 7,
        No = 8,
        Hand = 9,
        AppStarting = 10,
        Help = 11,
        TopSide = 12,
        BottomSide = 13,
        LeftSide = 14,
        RightSide = 15,
        TopLeftCorner = 16,
        TopRightCorner = 17,
        BottomLeftCorner = 18,
        BottomRightCorner = 19,
        DragMove = 20,
        DragCopy = 21,
        DragLink = 22,
        None = 23,
    }
    public partial class TappedEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        public TappedEventArgs(Avalonia.Interactivity.RoutedEvent routedEvent, Avalonia.Input.PointerEventArgs lastPointerEventArgs) { }
        public Avalonia.Input.KeyModifiers KeyModifiers { get { throw null; } }
        public Avalonia.Input.IPointer Pointer { get { throw null; } }
        public ulong Timestamp { get { throw null; } }
        public Avalonia.Point GetPosition(Avalonia.Visual? relativeTo) { throw null; }
    }
    public partial class TextInputEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        public TextInputEventArgs() { }
        public Avalonia.Input.IKeyboardDevice? Device { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public string? Text { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class TouchDevice : Avalonia.Input.IInputDevice, Avalonia.Input.IPointerDevice, System.IDisposable
    {
        public TouchDevice() { }
        public void Dispose() { }
        public void ProcessRawEvent(Avalonia.Input.Raw.RawInputEventArgs ev) { }
        public Avalonia.Input.IPointer? TryGetPointer(Avalonia.Input.Raw.RawPointerEventArgs ev) { throw null; }
    }
    public partial class VectorEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        public VectorEventArgs() { }
        public Avalonia.Vector Vector { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
}
namespace Avalonia.Input.GestureRecognizers
{
    public partial class GestureRecognizerCollection : Avalonia.Input.GestureRecognizers.IGestureRecognizerActionsDispatcher, System.Collections.Generic.IEnumerable<Avalonia.Input.GestureRecognizers.IGestureRecognizer>, System.Collections.Generic.IReadOnlyCollection<Avalonia.Input.GestureRecognizers.IGestureRecognizer>, System.Collections.IEnumerable
    {
        public GestureRecognizerCollection(Avalonia.Input.IInputElement inputElement) { }
        public int Count { get { throw null; } }
        public void Add(Avalonia.Input.GestureRecognizers.IGestureRecognizer recognizer) { }
        void Avalonia.Input.GestureRecognizers.IGestureRecognizerActionsDispatcher.Capture(Avalonia.Input.IPointer pointer, Avalonia.Input.GestureRecognizers.IGestureRecognizer recognizer) { }
        public System.Collections.Generic.IEnumerator<Avalonia.Input.GestureRecognizers.IGestureRecognizer> GetEnumerator() { throw null; }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
    }
    public enum GestureRecognizerResult
    {
        None = 0,
        Capture = 1,
        ReleaseCapture = 2,
    }
    public partial interface IGestureRecognizer
    {
        void Initialize(Avalonia.Input.IInputElement target, Avalonia.Input.GestureRecognizers.IGestureRecognizerActionsDispatcher actions);
        void PointerCaptureLost(Avalonia.Input.IPointer pointer);
        void PointerMoved(Avalonia.Input.PointerEventArgs e);
        void PointerPressed(Avalonia.Input.PointerPressedEventArgs e);
        void PointerReleased(Avalonia.Input.PointerReleasedEventArgs e);
    }
    public partial interface IGestureRecognizerActionsDispatcher
    {
        void Capture(Avalonia.Input.IPointer pointer, Avalonia.Input.GestureRecognizers.IGestureRecognizer recognizer);
    }
    public partial class ScrollGestureRecognizer : Avalonia.AvaloniaObject, Avalonia.Input.GestureRecognizers.IGestureRecognizer
    {
        public static readonly Avalonia.DirectProperty<Avalonia.Input.GestureRecognizers.ScrollGestureRecognizer, bool> CanHorizontallyScrollProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Input.GestureRecognizers.ScrollGestureRecognizer, bool> CanVerticallyScrollProperty;
        public const double InertialResistance = 0.15;
        public static readonly Avalonia.DirectProperty<Avalonia.Input.GestureRecognizers.ScrollGestureRecognizer, bool> IsScrollInertiaEnabledProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Input.GestureRecognizers.ScrollGestureRecognizer, int> ScrollStartDistanceProperty;
        public ScrollGestureRecognizer() { }
        public bool CanHorizontallyScroll { get { throw null; } set { } }
        public bool CanVerticallyScroll { get { throw null; } set { } }
        public bool IsScrollInertiaEnabled { get { throw null; } set { } }
        public int ScrollStartDistance { get { throw null; } set { } }
        public void Initialize(Avalonia.Input.IInputElement target, Avalonia.Input.GestureRecognizers.IGestureRecognizerActionsDispatcher actions) { }
        public void PointerCaptureLost(Avalonia.Input.IPointer pointer) { }
        public void PointerMoved(Avalonia.Input.PointerEventArgs e) { }
        public void PointerPressed(Avalonia.Input.PointerPressedEventArgs e) { }
        public void PointerReleased(Avalonia.Input.PointerReleasedEventArgs e) { }
    }
}
namespace Avalonia.Input.Platform
{
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IClipboard
    {
        System.Threading.Tasks.Task ClearAsync();
        System.Threading.Tasks.Task<object?> GetDataAsync(string format);
        System.Threading.Tasks.Task<string[]> GetFormatsAsync();
        System.Threading.Tasks.Task<string?> GetTextAsync();
        System.Threading.Tasks.Task SetDataObjectAsync(Avalonia.Input.IDataObject data);
        System.Threading.Tasks.Task SetTextAsync(string? text);
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IPlatformDragSource
    {
        System.Threading.Tasks.Task<Avalonia.Input.DragDropEffects> DoDragDrop(Avalonia.Input.PointerEventArgs triggerEvent, Avalonia.Input.IDataObject data, Avalonia.Input.DragDropEffects allowedEffects);
    }
    public sealed partial class PlatformHotkeyConfiguration
    {
        [Avalonia.Metadata.PrivateApiAttribute]
        public PlatformHotkeyConfiguration() { }
        [Avalonia.Metadata.PrivateApiAttribute]
        public PlatformHotkeyConfiguration(Avalonia.Input.KeyModifiers commandModifiers, Avalonia.Input.KeyModifiers selectionModifiers = Avalonia.Input.KeyModifiers.Shift, Avalonia.Input.KeyModifiers wholeWordTextActionModifiers = Avalonia.Input.KeyModifiers.Control) { }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> Back { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.KeyModifiers CommandModifiers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> Copy { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> Cut { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public static Avalonia.Input.Platform.PlatformHotkeyConfiguration? Instance { get { throw null; } }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> MoveCursorToTheEndOfDocument { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> MoveCursorToTheEndOfDocumentWithSelection { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> MoveCursorToTheEndOfLine { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> MoveCursorToTheEndOfLineWithSelection { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> MoveCursorToTheStartOfDocument { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> MoveCursorToTheStartOfDocumentWithSelection { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> MoveCursorToTheStartOfLine { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> MoveCursorToTheStartOfLineWithSelection { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> OpenContextMenu { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> Paste { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> Redo { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> SelectAll { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.KeyModifiers SelectionModifiers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.List<Avalonia.Input.KeyGesture> Undo { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.KeyModifiers WholeWordTextActionModifiers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
}
namespace Avalonia.Input.Raw
{
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IDragDropDevice : Avalonia.Input.IInputDevice
    {
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class RawDragEvent : Avalonia.Input.Raw.RawInputEventArgs
    {
        public RawDragEvent(Avalonia.Input.Raw.IDragDropDevice inputDevice, Avalonia.Input.Raw.RawDragEventType type, Avalonia.Input.IInputRoot root, Avalonia.Point location, Avalonia.Input.IDataObject data, Avalonia.Input.DragDropEffects effects, Avalonia.Input.RawInputModifiers modifiers) : base (default(Avalonia.Input.IInputDevice), default(ulong), default(Avalonia.Input.IInputRoot)) { }
        public Avalonia.Input.IDataObject Data { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Input.DragDropEffects Effects { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.KeyModifiers KeyModifiers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Point Location { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.Raw.RawDragEventType Type { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public enum RawDragEventType
    {
        DragEnter = 0,
        DragOver = 1,
        DragLeave = 2,
        Drop = 3,
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class RawInputEventArgs : System.EventArgs
    {
        public RawInputEventArgs(Avalonia.Input.IInputDevice device, ulong timestamp, Avalonia.Input.IInputRoot root) { }
        public Avalonia.Input.IInputDevice Device { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Handled { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.IInputRoot Root { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public ulong Timestamp { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class RawKeyEventArgs : Avalonia.Input.Raw.RawInputEventArgs
    {
        public RawKeyEventArgs(Avalonia.Input.IKeyboardDevice device, ulong timestamp, Avalonia.Input.IInputRoot root, Avalonia.Input.Raw.RawKeyEventType type, Avalonia.Input.Key key, Avalonia.Input.RawInputModifiers modifiers) : base (default(Avalonia.Input.IInputDevice), default(ulong), default(Avalonia.Input.IInputRoot)) { }
        public Avalonia.Input.Key Key { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.RawInputModifiers Modifiers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.Raw.RawKeyEventType Type { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    public enum RawKeyEventType
    {
        KeyDown = 0,
        KeyUp = 1,
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class RawMouseWheelEventArgs : Avalonia.Input.Raw.RawPointerEventArgs
    {
        public RawMouseWheelEventArgs(Avalonia.Input.IInputDevice device, ulong timestamp, Avalonia.Input.IInputRoot root, Avalonia.Point position, Avalonia.Vector delta, Avalonia.Input.RawInputModifiers inputModifiers) : base (default(Avalonia.Input.IInputDevice), default(ulong), default(Avalonia.Input.IInputRoot), default(Avalonia.Input.Raw.RawPointerEventType), default(Avalonia.Point), default(Avalonia.Input.RawInputModifiers)) { }
        public Avalonia.Vector Delta { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class RawPointerEventArgs : Avalonia.Input.Raw.RawInputEventArgs
    {
        public RawPointerEventArgs(Avalonia.Input.IInputDevice device, ulong timestamp, Avalonia.Input.IInputRoot root, Avalonia.Input.Raw.RawPointerEventType type, Avalonia.Input.Raw.RawPointerPoint point, Avalonia.Input.RawInputModifiers inputModifiers) : base (default(Avalonia.Input.IInputDevice), default(ulong), default(Avalonia.Input.IInputRoot)) { }
        public RawPointerEventArgs(Avalonia.Input.IInputDevice device, ulong timestamp, Avalonia.Input.IInputRoot root, Avalonia.Input.Raw.RawPointerEventType type, Avalonia.Point position, Avalonia.Input.RawInputModifiers inputModifiers) : base (default(Avalonia.Input.IInputDevice), default(ulong), default(Avalonia.Input.IInputRoot)) { }
        public Avalonia.Input.RawInputModifiers InputModifiers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Lazy<System.Collections.Generic.IReadOnlyList<Avalonia.Input.Raw.RawPointerPoint>?>? IntermediatePoints { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.Raw.RawPointerPoint Point { get { throw null; } set { } }
        public Avalonia.Point Position { get { throw null; } set { } }
        public long RawPointerId { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.Raw.RawPointerEventType Type { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    public enum RawPointerEventType
    {
        LeaveWindow = 0,
        LeftButtonDown = 1,
        LeftButtonUp = 2,
        RightButtonDown = 3,
        RightButtonUp = 4,
        MiddleButtonDown = 5,
        MiddleButtonUp = 6,
        XButton1Down = 7,
        XButton1Up = 8,
        XButton2Down = 9,
        XButton2Up = 10,
        Move = 11,
        Wheel = 12,
        NonClientLeftButtonDown = 13,
        TouchBegin = 14,
        TouchUpdate = 15,
        TouchEnd = 16,
        TouchCancel = 17,
        Magnify = 18,
        Rotate = 19,
        Swipe = 20,
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class RawPointerGestureEventArgs : Avalonia.Input.Raw.RawPointerEventArgs
    {
        public RawPointerGestureEventArgs(Avalonia.Input.IInputDevice device, ulong timestamp, Avalonia.Input.IInputRoot root, Avalonia.Input.Raw.RawPointerEventType gestureType, Avalonia.Point position, Avalonia.Vector delta, Avalonia.Input.RawInputModifiers inputModifiers) : base (default(Avalonia.Input.IInputDevice), default(ulong), default(Avalonia.Input.IInputRoot), default(Avalonia.Input.Raw.RawPointerEventType), default(Avalonia.Point), default(Avalonia.Input.RawInputModifiers)) { }
        public Avalonia.Vector Delta { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct RawPointerPoint : System.IEquatable<Avalonia.Input.Raw.RawPointerPoint>
    {
        private int _dummyPrimitive;
        public RawPointerPoint() { throw null; }
        public Avalonia.Point Position { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public float Pressure { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public float Twist { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public float XTilt { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public float YTilt { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Input.Raw.RawPointerPoint other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Input.Raw.RawPointerPoint left, Avalonia.Input.Raw.RawPointerPoint right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Input.Raw.RawPointerPoint left, Avalonia.Input.Raw.RawPointerPoint right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class RawSizeEventArgs : System.EventArgs
    {
        public RawSizeEventArgs(Avalonia.Size size) { }
        public RawSizeEventArgs(double width, double height) { }
        public Avalonia.Size Size { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class RawTextInputEventArgs : Avalonia.Input.Raw.RawInputEventArgs
    {
        public RawTextInputEventArgs(Avalonia.Input.IKeyboardDevice device, ulong timestamp, Avalonia.Input.IInputRoot root, string text) : base (default(Avalonia.Input.IInputDevice), default(ulong), default(Avalonia.Input.IInputRoot)) { }
        public string Text { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class RawTouchEventArgs : Avalonia.Input.Raw.RawPointerEventArgs
    {
        public RawTouchEventArgs(Avalonia.Input.IInputDevice device, ulong timestamp, Avalonia.Input.IInputRoot root, Avalonia.Input.Raw.RawPointerEventType type, Avalonia.Input.Raw.RawPointerPoint point, Avalonia.Input.RawInputModifiers inputModifiers, long rawPointerId) : base (default(Avalonia.Input.IInputDevice), default(ulong), default(Avalonia.Input.IInputRoot), default(Avalonia.Input.Raw.RawPointerEventType), default(Avalonia.Point), default(Avalonia.Input.RawInputModifiers)) { }
        public RawTouchEventArgs(Avalonia.Input.IInputDevice device, ulong timestamp, Avalonia.Input.IInputRoot root, Avalonia.Input.Raw.RawPointerEventType type, Avalonia.Point position, Avalonia.Input.RawInputModifiers inputModifiers, long rawPointerId) : base (default(Avalonia.Input.IInputDevice), default(ulong), default(Avalonia.Input.IInputRoot), default(Avalonia.Input.Raw.RawPointerEventType), default(Avalonia.Point), default(Avalonia.Input.RawInputModifiers)) { }
    }
}
namespace Avalonia.Input.TextInput
{
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ITextEditable
    {
        int CompositionEnd { get; }
        int CompositionStart { get; }
        int SelectionEnd { get; set; }
        int SelectionStart { get; set; }
        string? Text { get; set; }
        event System.EventHandler CompositionChanged;
        event System.EventHandler SelectionChanged;
        event System.EventHandler TextChanged;
    }
    public partial interface ITextInputMethodClient
    {
        Avalonia.Rect CursorRectangle { get; }
        bool SupportsPreedit { get; }
        bool SupportsSurroundingText { get; }
        Avalonia.Input.TextInput.TextInputMethodSurroundingText SurroundingText { get; }
        Avalonia.Input.TextInput.ITextEditable? TextEditable { get; set; }
        Avalonia.Visual TextViewVisual { get; }
        event System.EventHandler? CursorRectangleChanged;
        event System.EventHandler? SurroundingTextChanged;
        event System.EventHandler? TextViewVisualChanged;
        void SelectInSurroundingText(int start, int end);
        void SetComposingRegion(Avalonia.Media.TextFormatting.TextRange? region);
        void SetPreeditText(string? text);
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface ITextInputMethodImpl
    {
        void Reset();
        void SetClient(Avalonia.Input.TextInput.ITextInputMethodClient? client);
        void SetCursorRect(Avalonia.Rect rect);
        void SetOptions(Avalonia.Input.TextInput.TextInputOptions options);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ITextInputMethodRoot : Avalonia.Input.IInputElement, Avalonia.Input.IInputRoot
    {
        Avalonia.Input.TextInput.ITextInputMethodImpl? InputMethod { get; }
    }
    public enum TextInputContentType
    {
        Normal = 0,
        Alpha = 1,
        Digits = 2,
        Pin = 3,
        Number = 4,
        Email = 5,
        Url = 6,
        Name = 7,
        Password = 8,
        Social = 9,
        Search = 10,
    }
    public partial class TextInputMethodClientRequestedEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        public TextInputMethodClientRequestedEventArgs() { }
        public Avalonia.Input.TextInput.ITextInputMethodClient? Client { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct TextInputMethodSurroundingText : System.IEquatable<Avalonia.Input.TextInput.TextInputMethodSurroundingText>
    {
        private object _dummy;
        private int _dummyPrimitive;
        public int AnchorOffset { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int CursorOffset { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public string Text { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Input.TextInput.TextInputMethodSurroundingText other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Input.TextInput.TextInputMethodSurroundingText left, Avalonia.Input.TextInput.TextInputMethodSurroundingText right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Input.TextInput.TextInputMethodSurroundingText left, Avalonia.Input.TextInput.TextInputMethodSurroundingText right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public partial class TextInputOptions
    {
        public static readonly Avalonia.AttachedProperty<bool> AutoCapitalizationProperty;
        public static readonly Avalonia.AttachedProperty<Avalonia.Input.TextInput.TextInputContentType> ContentTypeProperty;
        public static readonly Avalonia.Input.TextInput.TextInputOptions Default;
        public static readonly Avalonia.AttachedProperty<bool> IsSensitiveProperty;
        public static readonly Avalonia.AttachedProperty<bool> LowercaseProperty;
        public static readonly Avalonia.AttachedProperty<bool> MultilineProperty;
        public static readonly Avalonia.AttachedProperty<Avalonia.Input.TextInput.TextInputReturnKeyType> ReturnKeyTypeProperty;
        public static readonly Avalonia.AttachedProperty<bool> UppercaseProperty;
        public TextInputOptions() { }
        public bool AutoCapitalization { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.TextInput.TextInputContentType ContentType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public bool IsSensitive { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public bool Lowercase { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public bool Multiline { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Input.TextInput.TextInputReturnKeyType ReturnKeyType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public bool Uppercase { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public static Avalonia.Input.TextInput.TextInputOptions FromStyledElement(Avalonia.StyledElement avaloniaObject) { throw null; }
        public static bool GetAutoCapitalization(Avalonia.StyledElement avaloniaObject) { throw null; }
        public static Avalonia.Input.TextInput.TextInputContentType GetContentType(Avalonia.StyledElement avaloniaObject) { throw null; }
        public static bool GetIsSensitive(Avalonia.StyledElement avaloniaObject) { throw null; }
        public static bool GetLowercase(Avalonia.StyledElement avaloniaObject) { throw null; }
        public static bool GetMultiline(Avalonia.StyledElement avaloniaObject) { throw null; }
        public static Avalonia.Input.TextInput.TextInputReturnKeyType GetReturnKeyType(Avalonia.StyledElement avaloniaObject) { throw null; }
        public static bool GetUppercase(Avalonia.StyledElement avaloniaObject) { throw null; }
        public static void SetAutoCapitalization(Avalonia.StyledElement avaloniaObject, bool value) { }
        public static void SetContentType(Avalonia.StyledElement avaloniaObject, Avalonia.Input.TextInput.TextInputContentType value) { }
        public static void SetIsSensitive(Avalonia.StyledElement avaloniaObject, bool value) { }
        public static void SetLowercase(Avalonia.StyledElement avaloniaObject, bool value) { }
        public static void SetMultiline(Avalonia.StyledElement avaloniaObject, bool value) { }
        public static void SetReturnKeyType(Avalonia.StyledElement avaloniaObject, Avalonia.Input.TextInput.TextInputReturnKeyType value) { }
        public static void SetUppercase(Avalonia.StyledElement avaloniaObject, bool value) { }
    }
    public enum TextInputReturnKeyType
    {
        Default = 0,
        Return = 1,
        Done = 2,
        Go = 3,
        Send = 4,
        Search = 5,
        Next = 6,
        Previous = 7,
    }
}
namespace Avalonia.Interactivity
{
    public partial class CancelRoutedEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        public CancelRoutedEventArgs() { }
        public CancelRoutedEventArgs(Avalonia.Interactivity.RoutedEvent? routedEvent) { }
        public CancelRoutedEventArgs(Avalonia.Interactivity.RoutedEvent? routedEvent, object? source) { }
        public bool Cancel { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    public partial class EventRoute : System.IDisposable
    {
        public EventRoute(Avalonia.Interactivity.RoutedEvent e) { }
        public bool HasHandlers { get { throw null; } }
        public void Add(Avalonia.Interactivity.Interactive target, System.Delegate handler, Avalonia.Interactivity.RoutingStrategies routes, bool handledEventsToo = false, System.Action<System.Delegate, object, Avalonia.Interactivity.RoutedEventArgs>? adapter = null) { }
        public void AddClassHandler(Avalonia.Interactivity.Interactive target) { }
        public void Dispose() { }
        public void RaiseEvent(Avalonia.Interactivity.Interactive source, Avalonia.Interactivity.RoutedEventArgs e) { }
    }
    public partial class Interactive : Avalonia.Layout.Layoutable
    {
        public Interactive() { }
        public void AddHandler(Avalonia.Interactivity.RoutedEvent routedEvent, System.Delegate handler, Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble | Avalonia.Interactivity.RoutingStrategies.Direct, bool handledEventsToo = false) { }
        public void AddHandler<TEventArgs>(Avalonia.Interactivity.RoutedEvent<TEventArgs> routedEvent, System.EventHandler<TEventArgs>? handler, Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble | Avalonia.Interactivity.RoutingStrategies.Direct, bool handledEventsToo = false) where TEventArgs : Avalonia.Interactivity.RoutedEventArgs { }
        protected Avalonia.Interactivity.EventRoute BuildEventRoute(Avalonia.Interactivity.RoutedEvent e) { throw null; }
        public void RaiseEvent(Avalonia.Interactivity.RoutedEventArgs e) { }
        public void RemoveHandler(Avalonia.Interactivity.RoutedEvent routedEvent, System.Delegate handler) { }
        public void RemoveHandler<TEventArgs>(Avalonia.Interactivity.RoutedEvent<TEventArgs> routedEvent, System.EventHandler<TEventArgs>? handler) where TEventArgs : Avalonia.Interactivity.RoutedEventArgs { }
    }
    public static partial class InteractiveExtensions
    {
        public static System.IDisposable AddDisposableHandler<TEventArgs>(this Avalonia.Interactivity.Interactive o, Avalonia.Interactivity.RoutedEvent<TEventArgs> routedEvent, System.EventHandler<TEventArgs> handler, Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble | Avalonia.Interactivity.RoutingStrategies.Direct, bool handledEventsToo = false) where TEventArgs : Avalonia.Interactivity.RoutedEventArgs { throw null; }
        public static Avalonia.Interactivity.Interactive? GetInteractiveParent(this Avalonia.Interactivity.Interactive o) { throw null; }
        public static System.IObservable<TEventArgs> GetObservable<TEventArgs>(this Avalonia.Interactivity.Interactive o, Avalonia.Interactivity.RoutedEvent<TEventArgs> routedEvent, Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble | Avalonia.Interactivity.RoutingStrategies.Direct, bool handledEventsToo = false) where TEventArgs : Avalonia.Interactivity.RoutedEventArgs { throw null; }
    }
    public partial class RoutedEvent
    {
        public RoutedEvent(string name, Avalonia.Interactivity.RoutingStrategies routingStrategies, System.Type eventArgsType, System.Type ownerType) { }
        public System.Type EventArgsType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool HasRaisedSubscriptions { get { throw null; } }
        public string Name { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.Type OwnerType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.IObservable<(object, Avalonia.Interactivity.RoutedEventArgs)> Raised { get { throw null; } }
        public System.IObservable<Avalonia.Interactivity.RoutedEventArgs> RouteFinished { get { throw null; } }
        public Avalonia.Interactivity.RoutingStrategies RoutingStrategies { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.IDisposable AddClassHandler(System.Type targetType, System.EventHandler<Avalonia.Interactivity.RoutedEventArgs> handler, Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble | Avalonia.Interactivity.RoutingStrategies.Direct, bool handledEventsToo = false) { throw null; }
        public static Avalonia.Interactivity.RoutedEvent<TEventArgs> Register<TEventArgs>(string name, Avalonia.Interactivity.RoutingStrategies routingStrategy, System.Type ownerType) where TEventArgs : Avalonia.Interactivity.RoutedEventArgs { throw null; }
        public static Avalonia.Interactivity.RoutedEvent<TEventArgs> Register<TOwner, TEventArgs>(string name, Avalonia.Interactivity.RoutingStrategies routingStrategy) where TEventArgs : Avalonia.Interactivity.RoutedEventArgs { throw null; }
    }
    public partial class RoutedEventArgs : System.EventArgs
    {
        public RoutedEventArgs() { }
        public RoutedEventArgs(Avalonia.Interactivity.RoutedEvent? routedEvent) { }
        public RoutedEventArgs(Avalonia.Interactivity.RoutedEvent? routedEvent, object? source) { }
        public bool Handled { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Interactivity.RoutingStrategies Route { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Interactivity.RoutedEvent? RoutedEvent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public object? Source { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    public partial class RoutedEventRegistry
    {
        public RoutedEventRegistry() { }
        public static Avalonia.Interactivity.RoutedEventRegistry Instance { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.Collections.Generic.IEnumerable<Avalonia.Interactivity.RoutedEvent> GetAllRegistered() { throw null; }
        public System.Collections.Generic.IReadOnlyList<Avalonia.Interactivity.RoutedEvent> GetRegistered(System.Type type) { throw null; }
        public System.Collections.Generic.IReadOnlyList<Avalonia.Interactivity.RoutedEvent> GetRegistered<TOwner>() { throw null; }
        public void Register(System.Type type, Avalonia.Interactivity.RoutedEvent @event) { }
    }
    public partial class RoutedEvent<TEventArgs> : Avalonia.Interactivity.RoutedEvent where TEventArgs : Avalonia.Interactivity.RoutedEventArgs
    {
        public RoutedEvent(string name, Avalonia.Interactivity.RoutingStrategies routingStrategies, System.Type ownerType) : base (default(string), default(Avalonia.Interactivity.RoutingStrategies), default(System.Type), default(System.Type)) { }
        public System.IDisposable AddClassHandler<TTarget>(System.Action<TTarget, TEventArgs> handler, Avalonia.Interactivity.RoutingStrategies routes = Avalonia.Interactivity.RoutingStrategies.Bubble | Avalonia.Interactivity.RoutingStrategies.Direct, bool handledEventsToo = false) where TTarget : Avalonia.Interactivity.Interactive { throw null; }
    }
    [System.FlagsAttribute]
    public enum RoutingStrategies
    {
        Direct = 1,
        Tunnel = 2,
        Bubble = 4,
    }
}
namespace Avalonia.Layout
{
    public partial class EffectiveViewportChangedEventArgs : System.EventArgs
    {
        public EffectiveViewportChangedEventArgs(Avalonia.Rect effectiveViewport) { }
        public Avalonia.Rect EffectiveViewport { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public enum HorizontalAlignment
    {
        Stretch = 0,
        Left = 1,
        Center = 2,
        Right = 3,
    }
    public partial interface IEmbeddedLayoutRoot : Avalonia.Layout.ILayoutRoot
    {
        Avalonia.Size AllocatedSize { get; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ILayoutRoot
    {
        Avalonia.Size ClientSize { get; }
        double LayoutScaling { get; }
    }
    public partial class Layoutable : Avalonia.Visual
    {
        public static readonly Avalonia.DirectProperty<Avalonia.Layout.Layoutable, Avalonia.Size> DesiredSizeProperty;
        public static readonly Avalonia.StyledProperty<double> HeightProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Layout.HorizontalAlignment> HorizontalAlignmentProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Thickness> MarginProperty;
        public static readonly Avalonia.StyledProperty<double> MaxHeightProperty;
        public static readonly Avalonia.StyledProperty<double> MaxWidthProperty;
        public static readonly Avalonia.StyledProperty<double> MinHeightProperty;
        public static readonly Avalonia.StyledProperty<double> MinWidthProperty;
        public static readonly Avalonia.StyledProperty<bool> UseLayoutRoundingProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Layout.VerticalAlignment> VerticalAlignmentProperty;
        public static readonly Avalonia.StyledProperty<double> WidthProperty;
        public Layoutable() { }
        public Avalonia.Size DesiredSize { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double Height { get { throw null; } set { } }
        public Avalonia.Layout.HorizontalAlignment HorizontalAlignment { get { throw null; } set { } }
        public bool IsArrangeValid { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsMeasureValid { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Thickness Margin { get { throw null; } set { } }
        public double MaxHeight { get { throw null; } set { } }
        public double MaxWidth { get { throw null; } set { } }
        public double MinHeight { get { throw null; } set { } }
        public double MinWidth { get { throw null; } set { } }
        public bool UseLayoutRounding { get { throw null; } set { } }
        public Avalonia.Layout.VerticalAlignment VerticalAlignment { get { throw null; } set { } }
        public double Width { get { throw null; } set { } }
        public event System.EventHandler<Avalonia.Layout.EffectiveViewportChangedEventArgs>? EffectiveViewportChanged { add { } remove { } }
        public event System.EventHandler? LayoutUpdated { add { } remove { } }
        protected static void AffectsArrange<T>(params Avalonia.AvaloniaProperty[] properties) where T : Avalonia.Layout.Layoutable { }
        protected static void AffectsMeasure<T>(params Avalonia.AvaloniaProperty[] properties) where T : Avalonia.Layout.Layoutable { }
        public virtual void ApplyTemplate() { }
        public void Arrange(Avalonia.Rect rect) { }
        protected virtual void ArrangeCore(Avalonia.Rect finalRect) { }
        protected virtual Avalonia.Size ArrangeOverride(Avalonia.Size finalSize) { throw null; }
        public void InvalidateArrange() { }
        public void InvalidateMeasure() { }
        public void Measure(Avalonia.Size availableSize) { }
        protected virtual Avalonia.Size MeasureCore(Avalonia.Size availableSize) { throw null; }
        protected virtual Avalonia.Size MeasureOverride(Avalonia.Size availableSize) { throw null; }
        protected override void OnAttachedToVisualTreeCore(Avalonia.VisualTreeAttachmentEventArgs e) { }
        protected override void OnDetachedFromVisualTreeCore(Avalonia.VisualTreeAttachmentEventArgs e) { }
        protected virtual void OnMeasureInvalidated() { }
        protected override void OnPropertyChanged(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
        protected sealed override void OnVisualParentChanged(Avalonia.Visual? oldParent, Avalonia.Visual? newParent) { }
        public void UpdateLayout() { }
    }
    public static partial class LayoutExtensions
    {
        public static Avalonia.Rect Align(this Avalonia.Rect rect, Avalonia.Rect constraint, Avalonia.Layout.HorizontalAlignment horizontalAlignment, Avalonia.Layout.VerticalAlignment verticalAlignment) { throw null; }
    }
    public static partial class LayoutHelper
    {
        public static double LayoutEpsilon { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Size ApplyLayoutConstraints(Avalonia.Layout.Layoutable control, Avalonia.Size constraints) { throw null; }
        public static Avalonia.Size ArrangeChild(Avalonia.Layout.Layoutable? child, Avalonia.Size availableSize, Avalonia.Thickness padding) { throw null; }
        public static Avalonia.Size ArrangeChild(Avalonia.Layout.Layoutable? child, Avalonia.Size availableSize, Avalonia.Thickness padding, Avalonia.Thickness borderThickness) { throw null; }
        public static double GetLayoutScale(Avalonia.Layout.Layoutable control) { throw null; }
        public static void InvalidateSelfAndChildrenMeasure(Avalonia.Layout.Layoutable control) { }
        public static Avalonia.Size MeasureChild(Avalonia.Layout.Layoutable? control, Avalonia.Size availableSize, Avalonia.Thickness padding) { throw null; }
        public static Avalonia.Size MeasureChild(Avalonia.Layout.Layoutable? control, Avalonia.Size availableSize, Avalonia.Thickness padding, Avalonia.Thickness borderThickness) { throw null; }
        public static Avalonia.Size RoundLayoutSizeUp(Avalonia.Size size, double dpiScaleX, double dpiScaleY) { throw null; }
        public static Avalonia.Thickness RoundLayoutThickness(Avalonia.Thickness thickness, double dpiScaleX, double dpiScaleY) { throw null; }
        public static double RoundLayoutValue(double value, double dpiScale) { throw null; }
        public static double RoundLayoutValueUp(double value, double dpiScale) { throw null; }
    }
    public static partial class LayoutInformation
    {
        public static Avalonia.Rect? GetPreviousArrangeBounds(Avalonia.Layout.Layoutable control) { throw null; }
        public static Avalonia.Size? GetPreviousMeasureConstraint(Avalonia.Layout.Layoutable control) { throw null; }
    }
    public enum Orientation
    {
        Horizontal = 0,
        Vertical = 1,
    }
    public enum VerticalAlignment
    {
        Stretch = 0,
        Top = 1,
        Center = 2,
        Bottom = 3,
    }
}
namespace Avalonia.Logging
{
    public partial interface ILogSink
    {
        bool IsEnabled(Avalonia.Logging.LogEventLevel level, string area);
        void Log(Avalonia.Logging.LogEventLevel level, string area, object? source, string messageTemplate);
        void Log(Avalonia.Logging.LogEventLevel level, string area, object? source, string messageTemplate, params object?[] propertyValues);
    }
    public static partial class LogArea
    {
        public const string AndroidPlatform = "AndroidPlatform";
        public const string Animations = "Animations";
        public const string Binding = "Binding";
        public const string Control = "Control";
        public const string FreeDesktopPlatform = "FreeDesktopPlatform";
        public const string IOSPlatform = "IOSPlatform";
        public const string Layout = "Layout";
        public const string LinuxFramebufferPlatform = "LinuxFramebufferPlatform";
        public const string macOSPlatform = "macOSPlatform";
        public const string Platform = "Platform";
        public const string Property = "Property";
        public const string Visual = "Visual";
        public const string Win32Platform = "Win32Platform";
        public const string X11Platform = "X11Platform";
    }
    public enum LogEventLevel
    {
        Verbose = 0,
        Debug = 1,
        Information = 2,
        Warning = 3,
        Error = 4,
        Fatal = 5,
    }
    public static partial class Logger
    {
        public static Avalonia.Logging.ILogSink? Sink { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public static bool IsEnabled(Avalonia.Logging.LogEventLevel level, string area) { throw null; }
        public static Avalonia.Logging.ParametrizedLogger? TryGet(Avalonia.Logging.LogEventLevel level, string area) { throw null; }
        public static bool TryGet(Avalonia.Logging.LogEventLevel level, string area, out Avalonia.Logging.ParametrizedLogger outLogger) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct ParametrizedLogger : System.IEquatable<Avalonia.Logging.ParametrizedLogger>
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public ParametrizedLogger(Avalonia.Logging.ILogSink sink, Avalonia.Logging.LogEventLevel level, string area) { throw null; }
        public bool IsValid { get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Logging.ParametrizedLogger other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public void Log(object? source, string messageTemplate) { }
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public void Log<T0>(object? source, string messageTemplate, T0 propertyValue0) { }
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public void Log<T0, T1>(object? source, string messageTemplate, T0 propertyValue0, T1 propertyValue1) { }
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public void Log<T0, T1, T2>(object? source, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2) { }
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public void Log<T0, T1, T2, T3>(object? source, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2, T3 propertyValue3) { }
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public void Log<T0, T1, T2, T3, T4>(object? source, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2, T3 propertyValue3, T4 propertyValue4) { }
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public void Log<T0, T1, T2, T3, T4, T5>(object? source, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2, T3 propertyValue3, T4 propertyValue4, T5 propertyValue5) { }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Logging.ParametrizedLogger left, Avalonia.Logging.ParametrizedLogger right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Logging.ParametrizedLogger left, Avalonia.Logging.ParametrizedLogger right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
}
namespace Avalonia.LogicalTree
{
    public enum ChildIndexChangedAction
    {
        ChildIndexChanged = 0,
        ChildIndexesReset = 1,
        TotalCountChanged = 2,
    }
    public partial class ChildIndexChangedEventArgs : System.EventArgs
    {
        public ChildIndexChangedEventArgs(Avalonia.LogicalTree.ILogical child, int index) { }
        public Avalonia.LogicalTree.ChildIndexChangedAction Action { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.LogicalTree.ILogical? Child { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.LogicalTree.ChildIndexChangedEventArgs ChildIndexesReset { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int Index { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.LogicalTree.ChildIndexChangedEventArgs TotalCountChanged { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public static partial class ControlLocator
    {
        public static System.IObservable<Avalonia.LogicalTree.ILogical?> Track(Avalonia.LogicalTree.ILogical relativeTo, int ancestorLevel, System.Type? ancestorType = null) { throw null; }
    }
    public partial interface IChildIndexProvider
    {
        event System.EventHandler<Avalonia.LogicalTree.ChildIndexChangedEventArgs>? ChildIndexChanged;
        int GetChildIndex(Avalonia.LogicalTree.ILogical child);
        bool TryGetTotalCount(out int count);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ILogical
    {
        bool IsAttachedToLogicalTree { get; }
        Avalonia.Collections.IAvaloniaReadOnlyList<Avalonia.LogicalTree.ILogical> LogicalChildren { get; }
        Avalonia.LogicalTree.ILogical? LogicalParent { get; }
        event System.EventHandler<Avalonia.LogicalTree.LogicalTreeAttachmentEventArgs>? AttachedToLogicalTree;
        event System.EventHandler<Avalonia.LogicalTree.LogicalTreeAttachmentEventArgs>? DetachedFromLogicalTree;
        void NotifyAttachedToLogicalTree(Avalonia.LogicalTree.LogicalTreeAttachmentEventArgs e);
        void NotifyDetachedFromLogicalTree(Avalonia.LogicalTree.LogicalTreeAttachmentEventArgs e);
        void NotifyResourcesChanged(Avalonia.Controls.ResourcesChangedEventArgs e);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ILogicalRoot : Avalonia.LogicalTree.ILogical
    {
    }
    public static partial class LogicalExtensions
    {
        public static T? FindLogicalAncestorOfType<T>(this Avalonia.LogicalTree.ILogical? logical, bool includeSelf = false) where T : class { throw null; }
        public static T? FindLogicalDescendantOfType<T>(this Avalonia.LogicalTree.ILogical? logical, bool includeSelf = false) where T : class { throw null; }
        public static System.Collections.Generic.IEnumerable<Avalonia.LogicalTree.ILogical> GetLogicalAncestors(this Avalonia.LogicalTree.ILogical logical) { throw null; }
        public static System.Collections.Generic.IEnumerable<Avalonia.LogicalTree.ILogical> GetLogicalChildren(this Avalonia.LogicalTree.ILogical logical) { throw null; }
        public static System.Collections.Generic.IEnumerable<Avalonia.LogicalTree.ILogical> GetLogicalDescendants(this Avalonia.LogicalTree.ILogical logical) { throw null; }
        public static Avalonia.LogicalTree.ILogical? GetLogicalParent(this Avalonia.LogicalTree.ILogical logical) { throw null; }
        public static T? GetLogicalParent<T>(this Avalonia.LogicalTree.ILogical logical) where T : class { throw null; }
        public static System.Collections.Generic.IEnumerable<Avalonia.LogicalTree.ILogical> GetLogicalSiblings(this Avalonia.LogicalTree.ILogical logical) { throw null; }
        public static System.Collections.Generic.IEnumerable<Avalonia.LogicalTree.ILogical> GetSelfAndLogicalAncestors(this Avalonia.LogicalTree.ILogical logical) { throw null; }
        public static System.Collections.Generic.IEnumerable<Avalonia.LogicalTree.ILogical> GetSelfAndLogicalDescendants(this Avalonia.LogicalTree.ILogical logical) { throw null; }
        public static bool IsLogicalAncestorOf(this Avalonia.LogicalTree.ILogical? logical, Avalonia.LogicalTree.ILogical? target) { throw null; }
    }
    public partial class LogicalTreeAttachmentEventArgs : System.EventArgs
    {
        public LogicalTreeAttachmentEventArgs(Avalonia.LogicalTree.ILogicalRoot root, Avalonia.LogicalTree.ILogical source, Avalonia.LogicalTree.ILogical? parent) { }
        public Avalonia.LogicalTree.ILogical? Parent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.LogicalTree.ILogicalRoot Root { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.LogicalTree.ILogical Source { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
}
namespace Avalonia.Media
{
    public enum AcrylicBackgroundSource
    {
        None = 0,
        Digger = 1,
    }
    public enum AlignmentX
    {
        Left = 0,
        Center = 1,
        Right = 2,
    }
    public enum AlignmentY
    {
        Top = 0,
        Center = 1,
        Bottom = 2,
    }
    public sealed partial class ArcSegment : Avalonia.Media.PathSegment
    {
        public static readonly Avalonia.StyledProperty<bool> IsLargeArcProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Point> PointProperty;
        public static readonly Avalonia.StyledProperty<double> RotationAngleProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Size> SizeProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.SweepDirection> SweepDirectionProperty;
        public ArcSegment() { }
        public bool IsLargeArc { get { throw null; } set { } }
        public Avalonia.Point Point { get { throw null; } set { } }
        public double RotationAngle { get { throw null; } set { } }
        public Avalonia.Size Size { get { throw null; } set { } }
        public Avalonia.Media.SweepDirection SweepDirection { get { throw null; } set { } }
        public override string ToString() { throw null; }
    }
    public enum BaselineAlignment
    {
        Top = 0,
        Center = 1,
        Bottom = 2,
        Baseline = 3,
        TextTop = 4,
        TextBottom = 5,
        Subscript = 6,
        Superscript = 7,
    }
    public sealed partial class BezierSegment : Avalonia.Media.PathSegment
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Point> Point1Property;
        public static readonly Avalonia.StyledProperty<Avalonia.Point> Point2Property;
        public static readonly Avalonia.StyledProperty<Avalonia.Point> Point3Property;
        public BezierSegment() { }
        public Avalonia.Point Point1 { get { throw null; } set { } }
        public Avalonia.Point Point2 { get { throw null; } set { } }
        public Avalonia.Point Point3 { get { throw null; } set { } }
        public override string ToString() { throw null; }
    }
    public sealed partial class BlurEffect : Avalonia.Media.Effect, Avalonia.Media.IBlurEffect, Avalonia.Media.IEffect, Avalonia.Media.IMutableEffect
    {
        public static readonly Avalonia.StyledProperty<double> RadiusProperty;
        public BlurEffect() { }
        public double Radius { get { throw null; } set { } }
        public Avalonia.Media.IImmutableEffect ToImmutable() { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct BoxShadow
    {
        private int _dummyPrimitive;
        public double Blur { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Media.Color Color { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public bool IsInset { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public double OffsetX { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public double OffsetY { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public double Spread { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public bool Equals(in Avalonia.Media.BoxShadow other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Media.BoxShadow left, Avalonia.Media.BoxShadow right) { throw null; }
        public static bool operator !=(Avalonia.Media.BoxShadow left, Avalonia.Media.BoxShadow right) { throw null; }
        public static Avalonia.Media.BoxShadow Parse(string s) { throw null; }
        public override string ToString() { throw null; }
        public Avalonia.Rect TransformBounds(in Avalonia.Rect rect) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct BoxShadows
    {
        private object _dummy;
        private int _dummyPrimitive;
        public BoxShadows(Avalonia.Media.BoxShadow shadow) { throw null; }
        public BoxShadows(Avalonia.Media.BoxShadow first, Avalonia.Media.BoxShadow[] rest) { throw null; }
        public int Count { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool HasInsetShadows { get { throw null; } }
        public Avalonia.Media.BoxShadow this[int c] { get { throw null; } }
        public bool Equals(Avalonia.Media.BoxShadows other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public Avalonia.Media.BoxShadows.BoxShadowsEnumerator GetEnumerator() { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Media.BoxShadows left, Avalonia.Media.BoxShadows right) { throw null; }
        public static bool operator !=(Avalonia.Media.BoxShadows left, Avalonia.Media.BoxShadows right) { throw null; }
        public static Avalonia.Media.BoxShadows Parse(string s) { throw null; }
        public override string ToString() { throw null; }
        public Avalonia.Rect TransformBounds(in Avalonia.Rect rect) { throw null; }
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public partial struct BoxShadowsEnumerator
        {
            private object _dummy;
            private int _dummyPrimitive;
            public BoxShadowsEnumerator(Avalonia.Media.BoxShadows shadows) { throw null; }
            public Avalonia.Media.BoxShadow Current { get { throw null; } }
            public bool MoveNext() { throw null; }
        }
    }
    [System.ComponentModel.TypeConverterAttribute(typeof(Avalonia.Media.BrushConverter))]
    public abstract partial class Brush : Avalonia.Animation.Animatable, Avalonia.Media.IBrush
    {
        public static readonly Avalonia.StyledProperty<double> OpacityProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.RelativePoint> TransformOriginProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.ITransform?> TransformProperty;
        protected Brush() { }
        internal abstract System.Func<Avalonia.Rendering.Composition.Compositor, Avalonia.Rendering.Composition.Server.ServerCompositionSimpleBrush> Factory { get; }
        public double Opacity { get { throw null; } set { } }
        public Avalonia.Media.ITransform? Transform { get { throw null; } set { } }
        public Avalonia.RelativePoint TransformOrigin { get { throw null; } set { } }
        protected override void OnPropertyChanged(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
        protected virtual void OnUnreferencedFromCompositor(Avalonia.Rendering.Composition.Compositor c) { }
        public static Avalonia.Media.IBrush Parse(string s) { throw null; }
    }
    public partial class BrushConverter : System.ComponentModel.TypeConverter
    {
        public BrushConverter() { }
        public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Type sourceType) { throw null; }
        public override object? ConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object? value) { throw null; }
    }
    public static partial class Brushes
    {
        public static Avalonia.Media.IImmutableSolidColorBrush AliceBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush AntiqueWhite { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Aqua { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Aquamarine { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Azure { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Beige { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Bisque { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Black { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush BlanchedAlmond { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Blue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush BlueViolet { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Brown { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush BurlyWood { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush CadetBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Chartreuse { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Chocolate { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Coral { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush CornflowerBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Cornsilk { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Crimson { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Cyan { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkCyan { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkGoldenrod { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkGray { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkGreen { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkKhaki { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkMagenta { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkOliveGreen { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkOrange { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkOrchid { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkRed { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkSalmon { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkSeaGreen { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkSlateBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkSlateGray { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkTurquoise { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DarkViolet { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DeepPink { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DeepSkyBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DimGray { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush DodgerBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Firebrick { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush FloralWhite { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush ForestGreen { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Fuchsia { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Gainsboro { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush GhostWhite { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Gold { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Goldenrod { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Gray { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Green { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush GreenYellow { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Honeydew { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush HotPink { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush IndianRed { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Indigo { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Ivory { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Khaki { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Lavender { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LavenderBlush { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LawnGreen { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LemonChiffon { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LightBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LightCoral { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LightCyan { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LightGoldenrodYellow { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LightGray { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LightGreen { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LightPink { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LightSalmon { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LightSeaGreen { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LightSkyBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LightSlateGray { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LightSteelBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LightYellow { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Lime { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush LimeGreen { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Linen { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Magenta { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Maroon { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush MediumAquamarine { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush MediumBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush MediumOrchid { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush MediumPurple { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush MediumSeaGreen { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush MediumSlateBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush MediumSpringGreen { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush MediumTurquoise { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush MediumVioletRed { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush MidnightBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush MintCream { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush MistyRose { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Moccasin { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush NavajoWhite { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Navy { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush OldLace { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Olive { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush OliveDrab { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Orange { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush OrangeRed { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Orchid { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush PaleGoldenrod { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush PaleGreen { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush PaleTurquoise { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush PaleVioletRed { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush PapayaWhip { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush PeachPuff { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Peru { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Pink { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Plum { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush PowderBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Purple { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Red { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush RosyBrown { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush RoyalBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush SaddleBrown { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Salmon { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush SandyBrown { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush SeaGreen { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush SeaShell { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Sienna { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Silver { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush SkyBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush SlateBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush SlateGray { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Snow { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush SpringGreen { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush SteelBlue { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Tan { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Teal { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Thistle { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Tomato { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Transparent { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Turquoise { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Violet { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Wheat { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush White { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush WhiteSmoke { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush Yellow { get { throw null; } }
        public static Avalonia.Media.IImmutableSolidColorBrush YellowGreen { get { throw null; } }
    }
    public static partial class BrushExtensions
    {
        public static Avalonia.Media.IImmutableBrush ToImmutable(this Avalonia.Media.IBrush brush) { throw null; }
        public static Avalonia.Media.Immutable.ImmutableDashStyle ToImmutable(this Avalonia.Media.IDashStyle style) { throw null; }
        public static Avalonia.Media.Immutable.ImmutablePen ToImmutable(this Avalonia.Media.IPen pen) { throw null; }
    }
    public enum BrushMappingMode
    {
        Absolute = 0,
        RelativeToBoundingBox = 1,
    }
    [System.Diagnostics.DebuggerDisplayAttribute("CharacterHit({FirstCharacterIndex}, {TrailingLength})")]
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct CharacterHit : System.IEquatable<Avalonia.Media.CharacterHit>
    {
        private readonly int _dummyPrimitive;
        [System.Diagnostics.DebuggerStepThroughAttribute]
        public CharacterHit(int firstCharacterIndex, int trailingLength = 0) { throw null; }
        public int FirstCharacterIndex { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int TrailingLength { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.Media.CharacterHit other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Media.CharacterHit left, Avalonia.Media.CharacterHit right) { throw null; }
        public static bool operator !=(Avalonia.Media.CharacterHit left, Avalonia.Media.CharacterHit right) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct Color : System.IEquatable<Avalonia.Media.Color>
    {
        private readonly int _dummyPrimitive;
        public Color(byte a, byte r, byte g, byte b) { throw null; }
        public byte A { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public byte B { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public byte G { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public byte R { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.Media.Color other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public static Avalonia.Media.Color FromArgb(byte a, byte r, byte g, byte b) { throw null; }
        public static Avalonia.Media.Color FromRgb(byte r, byte g, byte b) { throw null; }
        public static Avalonia.Media.Color FromUInt32(uint value) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Media.Color left, Avalonia.Media.Color right) { throw null; }
        public static bool operator !=(Avalonia.Media.Color left, Avalonia.Media.Color right) { throw null; }
        public static Avalonia.Media.Color Parse(System.ReadOnlySpan<char> s) { throw null; }
        public static Avalonia.Media.Color Parse(string s) { throw null; }
        public Avalonia.Media.HslColor ToHsl() { throw null; }
        public static Avalonia.Media.HslColor ToHsl(byte red, byte green, byte blue, byte alpha = (byte)255) { throw null; }
        public Avalonia.Media.HsvColor ToHsv() { throw null; }
        public static Avalonia.Media.HsvColor ToHsv(byte red, byte green, byte blue, byte alpha = (byte)255) { throw null; }
        public override string ToString() { throw null; }
        public uint ToUInt32() { throw null; }
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.ObsoleteAttribute("Use Color.ToUInt32() instead.")]
        public uint ToUint32() { throw null; }
        public static bool TryParse(System.ReadOnlySpan<char> s, out Avalonia.Media.Color color) { throw null; }
        public static bool TryParse(string? s, out Avalonia.Media.Color color) { throw null; }
    }
    public sealed partial class Colors
    {
        public Colors() { }
        public static Avalonia.Media.Color AliceBlue { get { throw null; } }
        public static Avalonia.Media.Color AntiqueWhite { get { throw null; } }
        public static Avalonia.Media.Color Aqua { get { throw null; } }
        public static Avalonia.Media.Color Aquamarine { get { throw null; } }
        public static Avalonia.Media.Color Azure { get { throw null; } }
        public static Avalonia.Media.Color Beige { get { throw null; } }
        public static Avalonia.Media.Color Bisque { get { throw null; } }
        public static Avalonia.Media.Color Black { get { throw null; } }
        public static Avalonia.Media.Color BlanchedAlmond { get { throw null; } }
        public static Avalonia.Media.Color Blue { get { throw null; } }
        public static Avalonia.Media.Color BlueViolet { get { throw null; } }
        public static Avalonia.Media.Color Brown { get { throw null; } }
        public static Avalonia.Media.Color BurlyWood { get { throw null; } }
        public static Avalonia.Media.Color CadetBlue { get { throw null; } }
        public static Avalonia.Media.Color Chartreuse { get { throw null; } }
        public static Avalonia.Media.Color Chocolate { get { throw null; } }
        public static Avalonia.Media.Color Coral { get { throw null; } }
        public static Avalonia.Media.Color CornflowerBlue { get { throw null; } }
        public static Avalonia.Media.Color Cornsilk { get { throw null; } }
        public static Avalonia.Media.Color Crimson { get { throw null; } }
        public static Avalonia.Media.Color Cyan { get { throw null; } }
        public static Avalonia.Media.Color DarkBlue { get { throw null; } }
        public static Avalonia.Media.Color DarkCyan { get { throw null; } }
        public static Avalonia.Media.Color DarkGoldenrod { get { throw null; } }
        public static Avalonia.Media.Color DarkGray { get { throw null; } }
        public static Avalonia.Media.Color DarkGreen { get { throw null; } }
        public static Avalonia.Media.Color DarkKhaki { get { throw null; } }
        public static Avalonia.Media.Color DarkMagenta { get { throw null; } }
        public static Avalonia.Media.Color DarkOliveGreen { get { throw null; } }
        public static Avalonia.Media.Color DarkOrange { get { throw null; } }
        public static Avalonia.Media.Color DarkOrchid { get { throw null; } }
        public static Avalonia.Media.Color DarkRed { get { throw null; } }
        public static Avalonia.Media.Color DarkSalmon { get { throw null; } }
        public static Avalonia.Media.Color DarkSeaGreen { get { throw null; } }
        public static Avalonia.Media.Color DarkSlateBlue { get { throw null; } }
        public static Avalonia.Media.Color DarkSlateGray { get { throw null; } }
        public static Avalonia.Media.Color DarkTurquoise { get { throw null; } }
        public static Avalonia.Media.Color DarkViolet { get { throw null; } }
        public static Avalonia.Media.Color DeepPink { get { throw null; } }
        public static Avalonia.Media.Color DeepSkyBlue { get { throw null; } }
        public static Avalonia.Media.Color DimGray { get { throw null; } }
        public static Avalonia.Media.Color DodgerBlue { get { throw null; } }
        public static Avalonia.Media.Color Firebrick { get { throw null; } }
        public static Avalonia.Media.Color FloralWhite { get { throw null; } }
        public static Avalonia.Media.Color ForestGreen { get { throw null; } }
        public static Avalonia.Media.Color Fuchsia { get { throw null; } }
        public static Avalonia.Media.Color Gainsboro { get { throw null; } }
        public static Avalonia.Media.Color GhostWhite { get { throw null; } }
        public static Avalonia.Media.Color Gold { get { throw null; } }
        public static Avalonia.Media.Color Goldenrod { get { throw null; } }
        public static Avalonia.Media.Color Gray { get { throw null; } }
        public static Avalonia.Media.Color Green { get { throw null; } }
        public static Avalonia.Media.Color GreenYellow { get { throw null; } }
        public static Avalonia.Media.Color Honeydew { get { throw null; } }
        public static Avalonia.Media.Color HotPink { get { throw null; } }
        public static Avalonia.Media.Color IndianRed { get { throw null; } }
        public static Avalonia.Media.Color Indigo { get { throw null; } }
        public static Avalonia.Media.Color Ivory { get { throw null; } }
        public static Avalonia.Media.Color Khaki { get { throw null; } }
        public static Avalonia.Media.Color Lavender { get { throw null; } }
        public static Avalonia.Media.Color LavenderBlush { get { throw null; } }
        public static Avalonia.Media.Color LawnGreen { get { throw null; } }
        public static Avalonia.Media.Color LemonChiffon { get { throw null; } }
        public static Avalonia.Media.Color LightBlue { get { throw null; } }
        public static Avalonia.Media.Color LightCoral { get { throw null; } }
        public static Avalonia.Media.Color LightCyan { get { throw null; } }
        public static Avalonia.Media.Color LightGoldenrodYellow { get { throw null; } }
        public static Avalonia.Media.Color LightGray { get { throw null; } }
        public static Avalonia.Media.Color LightGreen { get { throw null; } }
        public static Avalonia.Media.Color LightPink { get { throw null; } }
        public static Avalonia.Media.Color LightSalmon { get { throw null; } }
        public static Avalonia.Media.Color LightSeaGreen { get { throw null; } }
        public static Avalonia.Media.Color LightSkyBlue { get { throw null; } }
        public static Avalonia.Media.Color LightSlateGray { get { throw null; } }
        public static Avalonia.Media.Color LightSteelBlue { get { throw null; } }
        public static Avalonia.Media.Color LightYellow { get { throw null; } }
        public static Avalonia.Media.Color Lime { get { throw null; } }
        public static Avalonia.Media.Color LimeGreen { get { throw null; } }
        public static Avalonia.Media.Color Linen { get { throw null; } }
        public static Avalonia.Media.Color Magenta { get { throw null; } }
        public static Avalonia.Media.Color Maroon { get { throw null; } }
        public static Avalonia.Media.Color MediumAquamarine { get { throw null; } }
        public static Avalonia.Media.Color MediumBlue { get { throw null; } }
        public static Avalonia.Media.Color MediumOrchid { get { throw null; } }
        public static Avalonia.Media.Color MediumPurple { get { throw null; } }
        public static Avalonia.Media.Color MediumSeaGreen { get { throw null; } }
        public static Avalonia.Media.Color MediumSlateBlue { get { throw null; } }
        public static Avalonia.Media.Color MediumSpringGreen { get { throw null; } }
        public static Avalonia.Media.Color MediumTurquoise { get { throw null; } }
        public static Avalonia.Media.Color MediumVioletRed { get { throw null; } }
        public static Avalonia.Media.Color MidnightBlue { get { throw null; } }
        public static Avalonia.Media.Color MintCream { get { throw null; } }
        public static Avalonia.Media.Color MistyRose { get { throw null; } }
        public static Avalonia.Media.Color Moccasin { get { throw null; } }
        public static Avalonia.Media.Color NavajoWhite { get { throw null; } }
        public static Avalonia.Media.Color Navy { get { throw null; } }
        public static Avalonia.Media.Color OldLace { get { throw null; } }
        public static Avalonia.Media.Color Olive { get { throw null; } }
        public static Avalonia.Media.Color OliveDrab { get { throw null; } }
        public static Avalonia.Media.Color Orange { get { throw null; } }
        public static Avalonia.Media.Color OrangeRed { get { throw null; } }
        public static Avalonia.Media.Color Orchid { get { throw null; } }
        public static Avalonia.Media.Color PaleGoldenrod { get { throw null; } }
        public static Avalonia.Media.Color PaleGreen { get { throw null; } }
        public static Avalonia.Media.Color PaleTurquoise { get { throw null; } }
        public static Avalonia.Media.Color PaleVioletRed { get { throw null; } }
        public static Avalonia.Media.Color PapayaWhip { get { throw null; } }
        public static Avalonia.Media.Color PeachPuff { get { throw null; } }
        public static Avalonia.Media.Color Peru { get { throw null; } }
        public static Avalonia.Media.Color Pink { get { throw null; } }
        public static Avalonia.Media.Color Plum { get { throw null; } }
        public static Avalonia.Media.Color PowderBlue { get { throw null; } }
        public static Avalonia.Media.Color Purple { get { throw null; } }
        public static Avalonia.Media.Color Red { get { throw null; } }
        public static Avalonia.Media.Color RosyBrown { get { throw null; } }
        public static Avalonia.Media.Color RoyalBlue { get { throw null; } }
        public static Avalonia.Media.Color SaddleBrown { get { throw null; } }
        public static Avalonia.Media.Color Salmon { get { throw null; } }
        public static Avalonia.Media.Color SandyBrown { get { throw null; } }
        public static Avalonia.Media.Color SeaGreen { get { throw null; } }
        public static Avalonia.Media.Color SeaShell { get { throw null; } }
        public static Avalonia.Media.Color Sienna { get { throw null; } }
        public static Avalonia.Media.Color Silver { get { throw null; } }
        public static Avalonia.Media.Color SkyBlue { get { throw null; } }
        public static Avalonia.Media.Color SlateBlue { get { throw null; } }
        public static Avalonia.Media.Color SlateGray { get { throw null; } }
        public static Avalonia.Media.Color Snow { get { throw null; } }
        public static Avalonia.Media.Color SpringGreen { get { throw null; } }
        public static Avalonia.Media.Color SteelBlue { get { throw null; } }
        public static Avalonia.Media.Color Tan { get { throw null; } }
        public static Avalonia.Media.Color Teal { get { throw null; } }
        public static Avalonia.Media.Color Thistle { get { throw null; } }
        public static Avalonia.Media.Color Tomato { get { throw null; } }
        public static Avalonia.Media.Color Transparent { get { throw null; } }
        public static Avalonia.Media.Color Turquoise { get { throw null; } }
        public static Avalonia.Media.Color Violet { get { throw null; } }
        public static Avalonia.Media.Color Wheat { get { throw null; } }
        public static Avalonia.Media.Color White { get { throw null; } }
        public static Avalonia.Media.Color WhiteSmoke { get { throw null; } }
        public static Avalonia.Media.Color Yellow { get { throw null; } }
        public static Avalonia.Media.Color YellowGreen { get { throw null; } }
    }
    public partial class CombinedGeometry : Avalonia.Media.Geometry
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Geometry?> Geometry1Property;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Geometry?> Geometry2Property;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.GeometryCombineMode> GeometryCombineModeProperty;
        public CombinedGeometry() { }
        public CombinedGeometry(Avalonia.Media.Geometry geometry1, Avalonia.Media.Geometry geometry2) { }
        public CombinedGeometry(Avalonia.Media.GeometryCombineMode combineMode, Avalonia.Media.Geometry? geometry1, Avalonia.Media.Geometry? geometry2) { }
        public CombinedGeometry(Avalonia.Media.GeometryCombineMode combineMode, Avalonia.Media.Geometry? geometry1, Avalonia.Media.Geometry? geometry2, Avalonia.Media.Transform? transform) { }
        public Avalonia.Media.Geometry? Geometry1 { get { throw null; } set { } }
        public Avalonia.Media.Geometry? Geometry2 { get { throw null; } set { } }
        public Avalonia.Media.GeometryCombineMode GeometryCombineMode { get { throw null; } set { } }
        public override Avalonia.Media.Geometry Clone() { throw null; }
        protected override Avalonia.Platform.IGeometryImpl? CreateDefiningGeometry() { throw null; }
    }
    public sealed partial class ConicGradientBrush : Avalonia.Media.GradientBrush, Avalonia.Media.IBrush, Avalonia.Media.IConicGradientBrush, Avalonia.Media.IGradientBrush
    {
        public static readonly Avalonia.StyledProperty<double> AngleProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.RelativePoint> CenterProperty;
        public ConicGradientBrush() { }
        public double Angle { get { throw null; } set { } }
        public Avalonia.RelativePoint Center { get { throw null; } set { } }
        public override Avalonia.Media.IImmutableBrush ToImmutable() { throw null; }
    }
    public sealed partial class DashStyle : Avalonia.Animation.Animatable, Avalonia.Media.IDashStyle
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Collections.AvaloniaList<double>?> DashesProperty;
        public static readonly Avalonia.StyledProperty<double> OffsetProperty;
        public DashStyle() { }
        public DashStyle(System.Collections.Generic.IEnumerable<double>? dashes, double offset) { }
        System.Collections.Generic.IReadOnlyList<double>? Avalonia.Media.IDashStyle.Dashes { get { throw null; } }
        public static Avalonia.Media.IDashStyle Dash { get { throw null; } }
        public static Avalonia.Media.IDashStyle DashDot { get { throw null; } }
        public static Avalonia.Media.IDashStyle DashDotDot { get { throw null; } }
        public Avalonia.Collections.AvaloniaList<double>? Dashes { get { throw null; } set { } }
        public static Avalonia.Media.IDashStyle Dot { get { throw null; } }
        public double Offset { get { throw null; } set { } }
        protected override void OnPropertyChanged(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
        public Avalonia.Media.Immutable.ImmutableDashStyle ToImmutable() { throw null; }
    }
    public abstract partial class Drawing : Avalonia.AvaloniaObject
    {
        internal Drawing() { }
        public void Draw(Avalonia.Media.DrawingContext context) { }
        public abstract Avalonia.Rect GetBounds();
    }
    public sealed partial class DrawingBrush : Avalonia.Media.TileBrush, Avalonia.Media.IBrush, Avalonia.Media.ISceneBrush, Avalonia.Media.ITileBrush
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Drawing?> DrawingProperty;
        public DrawingBrush() { }
        public DrawingBrush(Avalonia.Media.Drawing visual) { }
        public Avalonia.Media.Drawing? Drawing { get { throw null; } set { } }
        Avalonia.Media.ISceneBrushContent? Avalonia.Media.ISceneBrush.CreateContent() { throw null; }
        protected override void OnUnreferencedFromCompositor(Avalonia.Rendering.Composition.Compositor c) { }
    }
    public sealed partial class DrawingCollection : Avalonia.Collections.AvaloniaList<Avalonia.Media.Drawing>
    {
        public DrawingCollection() { }
        public DrawingCollection(System.Collections.Generic.IEnumerable<Avalonia.Media.Drawing> items) { }
    }
    public abstract partial class DrawingContext : System.IDisposable
    {
        internal DrawingContext() { }
        public abstract void Custom(Avalonia.Rendering.SceneGraph.ICustomDrawOperation custom);
        public void Dispose() { }
        protected abstract void DisposeCore();
        public void DrawEllipse(Avalonia.Media.IBrush? brush, Avalonia.Media.IPen? pen, Avalonia.Point center, double radiusX, double radiusY) { }
        public void DrawEllipse(Avalonia.Media.IBrush? brush, Avalonia.Media.IPen? pen, Avalonia.Rect rect) { }
        protected abstract void DrawEllipseCore(Avalonia.Media.IBrush? brush, Avalonia.Media.IPen? pen, Avalonia.Rect rect);
        public void DrawGeometry(Avalonia.Media.IBrush? brush, Avalonia.Media.IPen? pen, Avalonia.Media.Geometry geometry) { }
        public void DrawGeometry(Avalonia.Media.IBrush? brush, Avalonia.Media.IPen? pen, Avalonia.Platform.IGeometryImpl geometry) { }
        protected abstract void DrawGeometryCore(Avalonia.Media.IBrush? brush, Avalonia.Media.IPen? pen, Avalonia.Platform.IGeometryImpl geometry);
        public abstract void DrawGlyphRun(Avalonia.Media.IBrush? foreground, Avalonia.Media.GlyphRun glyphRun);
        public virtual void DrawImage(Avalonia.Media.IImage source, Avalonia.Rect rect) { }
        public virtual void DrawImage(Avalonia.Media.IImage source, Avalonia.Rect sourceRect, Avalonia.Rect destRect) { }
        public void DrawLine(Avalonia.Media.IPen pen, Avalonia.Point p1, Avalonia.Point p2) { }
        protected abstract void DrawLineCore(Avalonia.Media.IPen pen, Avalonia.Point p1, Avalonia.Point p2);
        public void DrawRectangle(Avalonia.Media.IBrush? brush, Avalonia.Media.IPen? pen, Avalonia.Rect rect, double radiusX = 0, double radiusY = 0, Avalonia.Media.BoxShadows boxShadows = default(Avalonia.Media.BoxShadows)) { }
        public void DrawRectangle(Avalonia.Media.IBrush? brush, Avalonia.Media.IPen? pen, Avalonia.RoundedRect rrect, Avalonia.Media.BoxShadows boxShadows = default(Avalonia.Media.BoxShadows)) { }
        public void DrawRectangle(Avalonia.Media.IPen pen, Avalonia.Rect rect, float cornerRadius = 0f) { }
        protected abstract void DrawRectangleCore(Avalonia.Media.IBrush? brush, Avalonia.Media.IPen? pen, Avalonia.RoundedRect rrect, Avalonia.Media.BoxShadows boxShadows = default(Avalonia.Media.BoxShadows));
        public virtual void DrawText(Avalonia.Media.FormattedText text, Avalonia.Point origin) { }
        public void FillRectangle(Avalonia.Media.IBrush brush, Avalonia.Rect rect, float cornerRadius = 0f) { }
        protected abstract void PopClipCore();
        protected abstract void PopGeometryClipCore();
        protected abstract void PopOpacityCore();
        protected abstract void PopOpacityMaskCore();
        protected abstract void PopTransformCore();
        public Avalonia.Media.DrawingContext.PushedState PushClip(Avalonia.Rect clip) { throw null; }
        public Avalonia.Media.DrawingContext.PushedState PushClip(Avalonia.RoundedRect clip) { throw null; }
        protected abstract void PushClipCore(Avalonia.Rect rect);
        protected abstract void PushClipCore(Avalonia.RoundedRect rect);
        public Avalonia.Media.DrawingContext.PushedState PushGeometryClip(Avalonia.Media.Geometry clip) { throw null; }
        protected abstract void PushGeometryClipCore(Avalonia.Media.Geometry clip);
        public Avalonia.Media.DrawingContext.PushedState PushOpacity(double opacity) { throw null; }
        protected abstract void PushOpacityCore(double opacity);
        public Avalonia.Media.DrawingContext.PushedState PushOpacityMask(Avalonia.Media.IBrush mask, Avalonia.Rect bounds) { throw null; }
        protected abstract void PushOpacityMaskCore(Avalonia.Media.IBrush mask, Avalonia.Rect bounds);
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.ObsoleteAttribute("Use PushTransform")]
        public Avalonia.Media.DrawingContext.PushedState PushPostTransform(Avalonia.Matrix matrix) { throw null; }
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.ObsoleteAttribute("Use PushTransform")]
        public Avalonia.Media.DrawingContext.PushedState PushPreTransform(Avalonia.Matrix matrix) { throw null; }
        public Avalonia.Media.DrawingContext.PushedState PushTransform(Avalonia.Matrix matrix) { throw null; }
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.ObsoleteAttribute("Use PushTransform")]
        public Avalonia.Media.DrawingContext.PushedState PushTransformContainer() { throw null; }
        protected abstract void PushTransformCore(Avalonia.Matrix matrix);
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public partial struct PushedState : System.IDisposable, System.IEquatable<Avalonia.Media.DrawingContext.PushedState>
        {
            private object _dummy;
            private int _dummyPrimitive;
            public PushedState(Avalonia.Media.DrawingContext context) { throw null; }
            public void Dispose() { }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public bool Equals(Avalonia.Media.DrawingContext.PushedState other) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override bool Equals(object obj) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override int GetHashCode() { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public static bool operator ==(Avalonia.Media.DrawingContext.PushedState left, Avalonia.Media.DrawingContext.PushedState right) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public static bool operator !=(Avalonia.Media.DrawingContext.PushedState left, Avalonia.Media.DrawingContext.PushedState right) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override string ToString() { throw null; }
        }
    }
    public sealed partial class DrawingGroup : Avalonia.Media.Drawing
    {
        public static readonly Avalonia.DirectProperty<Avalonia.Media.DrawingGroup, Avalonia.Media.DrawingCollection> ChildrenProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Geometry?> ClipGeometryProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.IBrush?> OpacityMaskProperty;
        public static readonly Avalonia.StyledProperty<double> OpacityProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Transform?> TransformProperty;
        public DrawingGroup() { }
        [Avalonia.Metadata.ContentAttribute]
        public Avalonia.Media.DrawingCollection Children { get { throw null; } set { } }
        public Avalonia.Media.Geometry? ClipGeometry { get { throw null; } set { } }
        public double Opacity { get { throw null; } set { } }
        public Avalonia.Media.IBrush? OpacityMask { get { throw null; } set { } }
        public Avalonia.Media.Transform? Transform { get { throw null; } set { } }
        public override Avalonia.Rect GetBounds() { throw null; }
        public Avalonia.Media.DrawingContext Open() { throw null; }
    }
    public partial class DrawingImage : Avalonia.AvaloniaObject, Avalonia.Media.IImage
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Drawing?> DrawingProperty;
        public DrawingImage() { }
        public DrawingImage(Avalonia.Media.Drawing drawing) { }
        [Avalonia.Metadata.ContentAttribute]
        public Avalonia.Media.Drawing? Drawing { get { throw null; } set { } }
        public Avalonia.Size Size { get { throw null; } }
        public event System.EventHandler? Invalidated { add { } remove { } }
        void Avalonia.Media.IImage.Draw(Avalonia.Media.DrawingContext context, Avalonia.Rect sourceRect, Avalonia.Rect destRect) { }
        protected override void OnPropertyChanged(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
        protected void RaiseInvalidated(System.EventArgs e) { }
    }
    public sealed partial class DropShadowDirectionEffect : Avalonia.Media.DropShadowEffectBase, Avalonia.Media.IDropShadowEffect, Avalonia.Media.IEffect, Avalonia.Media.IMutableEffect
    {
        public static readonly Avalonia.StyledProperty<double> DirectionProperty;
        public static readonly Avalonia.StyledProperty<double> ShadowDepthProperty;
        public DropShadowDirectionEffect() { }
        public double Direction { get { throw null; } set { } }
        public double OffsetX { get { throw null; } }
        public double OffsetY { get { throw null; } }
        public double ShadowDepth { get { throw null; } set { } }
        public Avalonia.Media.IImmutableEffect ToImmutable() { throw null; }
    }
    public sealed partial class DropShadowEffect : Avalonia.Media.DropShadowEffectBase, Avalonia.Media.IDropShadowEffect, Avalonia.Media.IEffect, Avalonia.Media.IMutableEffect
    {
        public static readonly Avalonia.StyledProperty<double> OffsetXProperty;
        public static readonly Avalonia.StyledProperty<double> OffsetYProperty;
        public DropShadowEffect() { }
        public double OffsetX { get { throw null; } set { } }
        public double OffsetY { get { throw null; } set { } }
        public Avalonia.Media.IImmutableEffect ToImmutable() { throw null; }
    }
    public abstract partial class DropShadowEffectBase : Avalonia.Media.Effect
    {
        public static readonly Avalonia.StyledProperty<double> BlurRadiusProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Color> ColorProperty;
        public static readonly Avalonia.StyledProperty<double> OpacityProperty;
        protected DropShadowEffectBase() { }
        public double BlurRadius { get { throw null; } set { } }
        public Avalonia.Media.Color Color { get { throw null; } set { } }
        public double Opacity { get { throw null; } set { } }
    }
    public enum EdgeMode : byte
    {
        Unspecified = (byte)0,
        Antialias = (byte)1,
        Aliased = (byte)2,
    }
    public partial class Effect : Avalonia.Animation.Animatable
    {
        internal Effect() { }
        public event System.EventHandler? Invalidated { add { } remove { } }
        protected static void AffectsRender<T>(params Avalonia.AvaloniaProperty[] properties) where T : Avalonia.Media.Effect { }
        public static Avalonia.Media.IEffect Parse(string s) { throw null; }
        protected void RaiseInvalidated(System.EventArgs e) { }
    }
    public partial class EffectConverter : System.ComponentModel.TypeConverter
    {
        public EffectConverter() { }
        public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Type sourceType) { throw null; }
        public override object? ConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object? value) { throw null; }
    }
    public static partial class EffectExtensions
    {
        public static Avalonia.Media.IImmutableEffect ToImmutable(this Avalonia.Media.IEffect effect) { throw null; }
    }
    public partial class EllipseGeometry : Avalonia.Media.Geometry
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Point> CenterProperty;
        public static readonly Avalonia.StyledProperty<double> RadiusXProperty;
        public static readonly Avalonia.StyledProperty<double> RadiusYProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Rect> RectProperty;
        public EllipseGeometry() { }
        public EllipseGeometry(Avalonia.Rect rect) { }
        public Avalonia.Point Center { get { throw null; } set { } }
        public double RadiusX { get { throw null; } set { } }
        public double RadiusY { get { throw null; } set { } }
        public Avalonia.Rect Rect { get { throw null; } set { } }
        public override Avalonia.Media.Geometry Clone() { throw null; }
        protected override Avalonia.Platform.IGeometryImpl? CreateDefiningGeometry() { throw null; }
    }
    public partial class ExperimentalAcrylicMaterial : Avalonia.AvaloniaObject, Avalonia.Media.IExperimentalAcrylicMaterial, Avalonia.Media.IMutableExperimentalAcrylicMaterial
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Media.AcrylicBackgroundSource> BackgroundSourceProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Color> FallbackColorProperty;
        public static readonly Avalonia.StyledProperty<double> MaterialOpacityProperty;
        public static readonly Avalonia.StyledProperty<double> PlatformTransparencyCompensationLevelProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Color> TintColorProperty;
        public static readonly Avalonia.StyledProperty<double> TintOpacityProperty;
        public ExperimentalAcrylicMaterial() { }
        Avalonia.Media.Color Avalonia.Media.IExperimentalAcrylicMaterial.MaterialColor { get { throw null; } }
        Avalonia.Media.Color Avalonia.Media.IExperimentalAcrylicMaterial.TintColor { get { throw null; } }
        public Avalonia.Media.AcrylicBackgroundSource BackgroundSource { get { throw null; } set { } }
        public Avalonia.Media.Color FallbackColor { get { throw null; } set { } }
        public double MaterialOpacity { get { throw null; } set { } }
        public double PlatformTransparencyCompensationLevel { get { throw null; } set { } }
        public Avalonia.Media.Color TintColor { get { throw null; } set { } }
        public double TintOpacity { get { throw null; } set { } }
        public event System.EventHandler? Invalidated { add { } remove { } }
        protected static void AffectsRender<T>(params Avalonia.AvaloniaProperty[] properties) where T : Avalonia.Media.ExperimentalAcrylicMaterial { }
        protected void RaiseInvalidated(System.EventArgs e) { }
        public Avalonia.Media.IExperimentalAcrylicMaterial ToImmutable() { throw null; }
    }
    public enum FillRule
    {
        EvenOdd = 0,
        NonZero = 1,
    }
    public enum FlowDirection
    {
        LeftToRight = 0,
        RightToLeft = 1,
    }
    public partial class FontFallback
    {
        public FontFallback() { }
        public Avalonia.Media.FontFamily FontFamily { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Media.UnicodeRange UnicodeRange { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    public sealed partial class FontFamily
    {
        public const string DefaultFontFamilyName = "$Default";
        public FontFamily(string name) { }
        public FontFamily(System.Uri? baseUri, string name) { }
        public static Avalonia.Media.FontFamily Default { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.Fonts.FamilyNameCollection FamilyNames { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.Fonts.FontFamilyKey? Key { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public string Name { get { throw null; } }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Media.FontFamily? a, Avalonia.Media.FontFamily? b) { throw null; }
        public static implicit operator Avalonia.Media.FontFamily (string s) { throw null; }
        public static bool operator !=(Avalonia.Media.FontFamily? a, Avalonia.Media.FontFamily? b) { throw null; }
        public static Avalonia.Media.FontFamily Parse(string s) { throw null; }
        public static Avalonia.Media.FontFamily Parse(string s, System.Uri? baseUri) { throw null; }
        public override string ToString() { throw null; }
    }
    public sealed partial class FontManager
    {
        public const string FontCollectionScheme = "fonts";
        public FontManager(Avalonia.Platform.IFontManagerImpl platformImpl) { }
        public static Avalonia.Media.FontManager Current { get { throw null; } }
        public Avalonia.Media.FontFamily DefaultFontFamily { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.Fonts.IFontCollection SystemFonts { get { throw null; } }
        public void AddFontCollection(Avalonia.Media.Fonts.IFontCollection fontCollection) { }
        public void RemoveFontCollection(System.Uri key) { }
        public bool TryGetGlyphTypeface(Avalonia.Media.Typeface typeface, [System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] out Avalonia.Media.IGlyphTypeface? glyphTypeface) { throw null; }
        public bool TryMatchCharacter(int codepoint, Avalonia.Media.FontStyle fontStyle, Avalonia.Media.FontWeight fontWeight, Avalonia.Media.FontStretch fontStretch, Avalonia.Media.FontFamily? fontFamily, System.Globalization.CultureInfo? culture, out Avalonia.Media.Typeface typeface) { throw null; }
    }
    public partial class FontManagerOptions
    {
        public FontManagerOptions() { }
        public string? DefaultFamilyName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.IReadOnlyList<Avalonia.Media.FontFallback>? FontFallbacks { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct FontMetrics : System.IEquatable<Avalonia.Media.FontMetrics>
    {
        private readonly int _dummyPrimitive;
        public int Ascent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int Descent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public short DesignEmHeight { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public bool IsFixedPitch { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int LineGap { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int LineSpacing { get { throw null; } }
        public int StrikethroughPosition { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int StrikethroughThickness { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int UnderlinePosition { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int UnderlineThickness { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.FontMetrics other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.FontMetrics left, Avalonia.Media.FontMetrics right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.FontMetrics left, Avalonia.Media.FontMetrics right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    [System.FlagsAttribute]
    public enum FontSimulations : byte
    {
        None = (byte)0,
        Bold = (byte)1,
        Oblique = (byte)2,
    }
    public enum FontStretch
    {
        UltraCondensed = 1,
        ExtraCondensed = 2,
        Condensed = 3,
        SemiCondensed = 4,
        Normal = 5,
        SemiExpanded = 6,
        Expanded = 7,
        ExtraExpanded = 8,
        UltraExpanded = 9,
    }
    public enum FontStyle
    {
        Normal = 0,
        Italic = 1,
        Oblique = 2,
    }
    public enum FontWeight
    {
        Thin = 100,
        ExtraLight = 200,
        UltraLight = 200,
        Light = 300,
        SemiLight = 350,
        Normal = 400,
        Regular = 400,
        Medium = 500,
        DemiBold = 600,
        SemiBold = 600,
        Bold = 700,
        ExtraBold = 800,
        UltraBold = 800,
        Black = 900,
        Heavy = 900,
        ExtraBlack = 950,
        UltraBlack = 950,
    }
    public partial class FormattedText
    {
        public const double DefaultIdealToReal = 0.0033333333333333335;
        public const double DefaultRealToIdeal = 300;
        public const double GreatestMultiplierOfEm = 100;
        public const int IdealInfiniteWidth = 1073741822;
        public const double RealInfiniteWidth = 3579139.4066666667;
        public FormattedText(string textToFormat, System.Globalization.CultureInfo culture, Avalonia.Media.FlowDirection flowDirection, Avalonia.Media.Typeface typeface, double emSize, Avalonia.Media.IBrush? foreground) { }
        public double Baseline { get { throw null; } }
        public double Extent { get { throw null; } }
        public Avalonia.Media.FlowDirection FlowDirection { get { throw null; } set { } }
        public double Height { get { throw null; } }
        public double LineHeight { get { throw null; } set { } }
        public int MaxLineCount { get { throw null; } set { } }
        public double MaxTextHeight { get { throw null; } set { } }
        public double MaxTextWidth { get { throw null; } set { } }
        public double OverhangAfter { get { throw null; } }
        public double OverhangLeading { get { throw null; } }
        public double OverhangTrailing { get { throw null; } }
        public Avalonia.Media.TextAlignment TextAlignment { get { throw null; } set { } }
        public Avalonia.Media.TextTrimming Trimming { get { throw null; } set { } }
        public double Width { get { throw null; } }
        public double WidthIncludingTrailingWhitespace { get { throw null; } }
        public Avalonia.Media.Geometry? BuildGeometry(Avalonia.Point origin) { throw null; }
        public Avalonia.Media.Geometry? BuildHighlightGeometry(Avalonia.Point origin) { throw null; }
        public Avalonia.Media.Geometry? BuildHighlightGeometry(Avalonia.Point origin, int startIndex, int count) { throw null; }
        public double[] GetMaxTextWidths() { throw null; }
        public void SetCulture(System.Globalization.CultureInfo culture) { }
        public void SetCulture(System.Globalization.CultureInfo culture, int startIndex, int count) { }
        public void SetFontFamily(Avalonia.Media.FontFamily fontFamily) { }
        public void SetFontFamily(Avalonia.Media.FontFamily fontFamily, int startIndex, int count) { }
        public void SetFontFamily(string fontFamily) { }
        public void SetFontFamily(string fontFamily, int startIndex, int count) { }
        public void SetFontSize(double emSize) { }
        public void SetFontSize(double emSize, int startIndex, int count) { }
        public void SetFontStyle(Avalonia.Media.FontStyle style) { }
        public void SetFontStyle(Avalonia.Media.FontStyle style, int startIndex, int count) { }
        public void SetFontTypeface(Avalonia.Media.Typeface typeface) { }
        public void SetFontTypeface(Avalonia.Media.Typeface typeface, int startIndex, int count) { }
        public void SetFontWeight(Avalonia.Media.FontWeight weight) { }
        public void SetFontWeight(Avalonia.Media.FontWeight weight, int startIndex, int count) { }
        public void SetForegroundBrush(Avalonia.Media.IBrush foregroundBrush) { }
        public void SetForegroundBrush(Avalonia.Media.IBrush? foregroundBrush, int startIndex, int count) { }
        public void SetMaxTextWidths(double[] maxTextWidths) { }
        public void SetTextDecorations(Avalonia.Media.TextDecorationCollection textDecorations) { }
        public void SetTextDecorations(Avalonia.Media.TextDecorationCollection textDecorations, int startIndex, int count) { }
    }
    [System.ComponentModel.TypeConverterAttribute(typeof(Avalonia.Media.GeometryTypeConverter))]
    public abstract partial class Geometry : Avalonia.AvaloniaObject
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Transform?> TransformProperty;
        protected Geometry() { }
        public Avalonia.Rect Bounds { get { throw null; } }
        public double ContourLength { get { throw null; } }
        public Avalonia.Media.Transform? Transform { get { throw null; } set { } }
        public event System.EventHandler? Changed { add { } remove { } }
        protected static void AffectsGeometry(params Avalonia.AvaloniaProperty[] properties) { }
        public abstract Avalonia.Media.Geometry Clone();
        public static Avalonia.Media.Geometry Combine(Avalonia.Media.Geometry geometry1, Avalonia.Media.RectangleGeometry geometry2, Avalonia.Media.GeometryCombineMode combineMode, Avalonia.Media.Transform? transform = null) { throw null; }
        protected abstract Avalonia.Platform.IGeometryImpl? CreateDefiningGeometry();
        public bool FillContains(Avalonia.Point point) { throw null; }
        public Avalonia.Rect GetRenderBounds(Avalonia.Media.IPen pen) { throw null; }
        protected void InvalidateGeometry() { }
        public static Avalonia.Media.Geometry Parse(string s) { throw null; }
        public bool StrokeContains(Avalonia.Media.IPen pen, Avalonia.Point point) { throw null; }
        public bool TryGetPointAndTangentAtDistance(double distance, out Avalonia.Point point, out Avalonia.Point tangent) { throw null; }
        public bool TryGetPointAtDistance(double distance, out Avalonia.Point point) { throw null; }
        public bool TryGetSegment(double startDistance, double stopDistance, bool startOnBeginFigure, [System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] out Avalonia.Media.Geometry? segmentGeometry) { throw null; }
    }
    public sealed partial class GeometryCollection : Avalonia.Collections.AvaloniaList<Avalonia.Media.Geometry>
    {
        public GeometryCollection() { }
        public GeometryCollection(System.Collections.Generic.IEnumerable<Avalonia.Media.Geometry> items) { }
        public Avalonia.Media.GeometryGroup? Parent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    public enum GeometryCombineMode
    {
        Union = 0,
        Intersect = 1,
        Xor = 2,
        Exclude = 3,
    }
    public sealed partial class GeometryDrawing : Avalonia.Media.Drawing
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Media.IBrush?> BrushProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Geometry?> GeometryProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.IPen?> PenProperty;
        public GeometryDrawing() { }
        public Avalonia.Media.IBrush? Brush { get { throw null; } set { } }
        [Avalonia.Metadata.ContentAttribute]
        public Avalonia.Media.Geometry? Geometry { get { throw null; } set { } }
        public Avalonia.Media.IPen? Pen { get { throw null; } set { } }
        public override Avalonia.Rect GetBounds() { throw null; }
    }
    public partial class GeometryGroup : Avalonia.Media.Geometry
    {
        public static readonly Avalonia.DirectProperty<Avalonia.Media.GeometryGroup, Avalonia.Media.GeometryCollection> ChildrenProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.FillRule> FillRuleProperty;
        public GeometryGroup() { }
        [Avalonia.Metadata.ContentAttribute]
        public Avalonia.Media.GeometryCollection Children { get { throw null; } set { } }
        public Avalonia.Media.FillRule FillRule { get { throw null; } set { } }
        public override Avalonia.Media.Geometry Clone() { throw null; }
        protected override Avalonia.Platform.IGeometryImpl? CreateDefiningGeometry() { throw null; }
        protected void OnChildrenChanged(Avalonia.Media.GeometryCollection oldChildren, Avalonia.Media.GeometryCollection newChildren) { }
        protected override void OnPropertyChanged(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
    }
    public partial class GeometryTypeConverter : System.ComponentModel.TypeConverter
    {
        public GeometryTypeConverter() { }
        public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Type sourceType) { throw null; }
        public override object? ConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object value) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct GlyphMetrics : System.IEquatable<Avalonia.Media.GlyphMetrics>
    {
        private readonly int _dummyPrimitive;
        public int Height { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int Width { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int XBearing { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int YBearing { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.GlyphMetrics other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.GlyphMetrics left, Avalonia.Media.GlyphMetrics right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.GlyphMetrics left, Avalonia.Media.GlyphMetrics right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public sealed partial class GlyphRun : System.IDisposable
    {
        public GlyphRun(Avalonia.Media.IGlyphTypeface glyphTypeface, double fontRenderingEmSize, System.ReadOnlyMemory<char> characters, System.Collections.Generic.IReadOnlyList<Avalonia.Media.TextFormatting.GlyphInfo> glyphInfos, Avalonia.Point? baselineOrigin = default(Avalonia.Point?), int biDiLevel = 0) { }
        public GlyphRun(Avalonia.Media.IGlyphTypeface glyphTypeface, double fontRenderingEmSize, System.ReadOnlyMemory<char> characters, System.Collections.Generic.IReadOnlyList<ushort> glyphIndices, Avalonia.Point? baselineOrigin = default(Avalonia.Point?), int biDiLevel = 0) { }
        public Avalonia.Point BaselineOrigin { get { throw null; } set { } }
        public int BiDiLevel { get { throw null; } set { } }
        public Avalonia.Rect Bounds { get { throw null; } }
        public System.ReadOnlyMemory<char> Characters { get { throw null; } set { } }
        public double FontRenderingEmSize { get { throw null; } set { } }
        public System.Collections.Generic.IReadOnlyList<Avalonia.Media.TextFormatting.GlyphInfo> GlyphInfos { get { throw null; } set { } }
        public Avalonia.Media.IGlyphTypeface GlyphTypeface { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Rect InkBounds { get { throw null; } }
        public bool IsLeftToRight { get { throw null; } }
        public Avalonia.Media.GlyphRunMetrics Metrics { get { throw null; } }
        public Avalonia.Media.Geometry BuildGeometry() { throw null; }
        public void Dispose() { }
        public int FindGlyphIndex(int characterIndex) { throw null; }
        public Avalonia.Media.CharacterHit FindNearestCharacterHit(int index, out double width) { throw null; }
        public Avalonia.Media.CharacterHit GetCharacterHitFromDistance(double distance, out bool isInside) { throw null; }
        public double GetDistanceFromCharacterHit(Avalonia.Media.CharacterHit characterHit) { throw null; }
        public System.Collections.Generic.IReadOnlyList<float> GetIntersections(float lowerLimit, float upperLimit) { throw null; }
        public Avalonia.Media.CharacterHit GetNextCaretCharacterHit(Avalonia.Media.CharacterHit characterHit) { throw null; }
        public Avalonia.Media.CharacterHit GetPreviousCaretCharacterHit(Avalonia.Media.CharacterHit characterHit) { throw null; }
        public Avalonia.Media.IImmutableGlyphRunReference? TryCreateImmutableGlyphRunReference() { throw null; }
    }
    public sealed partial class GlyphRunDrawing : Avalonia.Media.Drawing
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Media.IBrush?> ForegroundProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.GlyphRun?> GlyphRunProperty;
        public GlyphRunDrawing() { }
        public Avalonia.Media.IBrush? Foreground { get { throw null; } set { } }
        public Avalonia.Media.GlyphRun? GlyphRun { get { throw null; } set { } }
        public override Avalonia.Rect GetBounds() { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct GlyphRunMetrics : System.IEquatable<Avalonia.Media.GlyphRunMetrics>
    {
        private readonly int _dummyPrimitive;
        public double Baseline { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int FirstCluster { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public double Height { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int LastCluster { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int NewLineLength { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int TrailingWhitespaceLength { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public double Width { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public double WidthIncludingTrailingWhitespace { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.GlyphRunMetrics other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.GlyphRunMetrics left, Avalonia.Media.GlyphRunMetrics right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.GlyphRunMetrics left, Avalonia.Media.GlyphRunMetrics right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public abstract partial class GradientBrush : Avalonia.Media.Brush, Avalonia.Media.IBrush, Avalonia.Media.IGradientBrush
    {
        internal GradientBrush() { }
        public static readonly Avalonia.StyledProperty<Avalonia.Media.GradientStops> GradientStopsProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.GradientSpreadMethod> SpreadMethodProperty;
        System.Collections.Generic.IReadOnlyList<Avalonia.Media.IGradientStop> Avalonia.Media.IGradientBrush.GradientStops { get { throw null; } }
        [Avalonia.Metadata.ContentAttribute]
        public Avalonia.Media.GradientStops GradientStops { get { throw null; } set { } }
        public Avalonia.Media.GradientSpreadMethod SpreadMethod { get { throw null; } set { } }
        protected override void OnPropertyChanged(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
        public abstract Avalonia.Media.IImmutableBrush ToImmutable();
    }
    public enum GradientSpreadMethod
    {
        Pad = 0,
        Reflect = 1,
        Repeat = 2,
    }
    public sealed partial class GradientStop : Avalonia.AvaloniaObject, Avalonia.Media.IGradientStop
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Color> ColorProperty;
        public static readonly Avalonia.StyledProperty<double> OffsetProperty;
        public GradientStop() { }
        public GradientStop(Avalonia.Media.Color color, double offset) { }
        public Avalonia.Media.Color Color { get { throw null; } set { } }
        public double Offset { get { throw null; } set { } }
    }
    public partial class GradientStops : Avalonia.Collections.AvaloniaList<Avalonia.Media.GradientStop>
    {
        public GradientStops() { }
        public System.Collections.Generic.IReadOnlyList<Avalonia.Media.Immutable.ImmutableGradientStop> ToImmutable() { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct HslColor : System.IEquatable<Avalonia.Media.HslColor>
    {
        private readonly int _dummyPrimitive;
        public HslColor(Avalonia.Media.Color color) { throw null; }
        public HslColor(double alpha, double hue, double saturation, double lightness) { throw null; }
        public double A { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double H { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double L { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double S { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.Media.HslColor other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public static Avalonia.Media.HslColor FromAhsl(double a, double h, double s, double l) { throw null; }
        public static Avalonia.Media.HslColor FromHsl(double h, double s, double l) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Media.HslColor left, Avalonia.Media.HslColor right) { throw null; }
        public static explicit operator Avalonia.Media.Color (Avalonia.Media.HslColor hslColor) { throw null; }
        public static bool operator !=(Avalonia.Media.HslColor left, Avalonia.Media.HslColor right) { throw null; }
        public static Avalonia.Media.HslColor Parse(string s) { throw null; }
        public Avalonia.Media.HsvColor ToHsv() { throw null; }
        public static Avalonia.Media.HsvColor ToHsv(double hue, double saturation, double lightness, double alpha = 1) { throw null; }
        public Avalonia.Media.Color ToRgb() { throw null; }
        public static Avalonia.Media.Color ToRgb(double hue, double saturation, double lightness, double alpha = 1) { throw null; }
        public override string ToString() { throw null; }
        public static bool TryParse(string? s, out Avalonia.Media.HslColor hslColor) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct HsvColor : System.IEquatable<Avalonia.Media.HsvColor>
    {
        private readonly int _dummyPrimitive;
        public HsvColor(Avalonia.Media.Color color) { throw null; }
        public HsvColor(double alpha, double hue, double saturation, double value) { throw null; }
        public double A { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double H { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double S { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double V { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.Media.HsvColor other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public static Avalonia.Media.HsvColor FromAhsv(double a, double h, double s, double v) { throw null; }
        public static Avalonia.Media.HsvColor FromHsv(double h, double s, double v) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Media.HsvColor left, Avalonia.Media.HsvColor right) { throw null; }
        public static explicit operator Avalonia.Media.Color (Avalonia.Media.HsvColor hsvColor) { throw null; }
        public static bool operator !=(Avalonia.Media.HsvColor left, Avalonia.Media.HsvColor right) { throw null; }
        public static Avalonia.Media.HsvColor Parse(string s) { throw null; }
        public Avalonia.Media.HslColor ToHsl() { throw null; }
        public static Avalonia.Media.HslColor ToHsl(double hue, double saturation, double value, double alpha = 1) { throw null; }
        public Avalonia.Media.Color ToRgb() { throw null; }
        public static Avalonia.Media.Color ToRgb(double hue, double saturation, double value, double alpha = 1) { throw null; }
        public override string ToString() { throw null; }
        public static bool TryParse(string? s, out Avalonia.Media.HsvColor hsvColor) { throw null; }
    }
    public partial interface IBlurEffect : Avalonia.Media.IEffect
    {
        double Radius { get; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    [System.ComponentModel.TypeConverterAttribute(typeof(Avalonia.Media.BrushConverter))]
    public partial interface IBrush
    {
        double Opacity { get; }
        Avalonia.Media.ITransform? Transform { get; }
        Avalonia.RelativePoint TransformOrigin { get; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IConicGradientBrush : Avalonia.Media.IBrush, Avalonia.Media.IGradientBrush
    {
        double Angle { get; }
        Avalonia.RelativePoint Center { get; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IDashStyle
    {
        System.Collections.Generic.IReadOnlyList<double>? Dashes { get; }
        double Offset { get; }
    }
    public partial interface IDropShadowEffect : Avalonia.Media.IEffect
    {
        double BlurRadius { get; }
        Avalonia.Media.Color Color { get; }
        double OffsetX { get; }
        double OffsetY { get; }
        double Opacity { get; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    [System.ComponentModel.TypeConverterAttribute(typeof(Avalonia.Media.EffectConverter))]
    public partial interface IEffect
    {
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IExperimentalAcrylicMaterial
    {
        Avalonia.Media.AcrylicBackgroundSource BackgroundSource { get; }
        Avalonia.Media.Color FallbackColor { get; }
        Avalonia.Media.Color MaterialColor { get; }
        Avalonia.Media.Color TintColor { get; }
        double TintOpacity { get; }
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IGlyphTypeface : System.IDisposable
    {
        string FamilyName { get; }
        Avalonia.Media.FontSimulations FontSimulations { get; }
        int GlyphCount { get; }
        Avalonia.Media.FontMetrics Metrics { get; }
        Avalonia.Media.FontStretch Stretch { get; }
        Avalonia.Media.FontStyle Style { get; }
        Avalonia.Media.FontWeight Weight { get; }
        ushort GetGlyph(uint codepoint);
        int GetGlyphAdvance(ushort glyph);
        int[] GetGlyphAdvances(System.ReadOnlySpan<ushort> glyphs);
        ushort[] GetGlyphs(System.ReadOnlySpan<uint> codepoints);
        bool TryGetGlyph(uint codepoint, out ushort glyph);
        bool TryGetGlyphMetrics(ushort glyph, out Avalonia.Media.GlyphMetrics metrics);
        bool TryGetTable(uint tag, out byte[] table);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IGradientBrush : Avalonia.Media.IBrush
    {
        System.Collections.Generic.IReadOnlyList<Avalonia.Media.IGradientStop> GradientStops { get; }
        Avalonia.Media.GradientSpreadMethod SpreadMethod { get; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IGradientStop
    {
        Avalonia.Media.Color Color { get; }
        double Offset { get; }
    }
    public partial interface IImage
    {
        Avalonia.Size Size { get; }
        void Draw(Avalonia.Media.DrawingContext context, Avalonia.Rect sourceRect, Avalonia.Rect destRect);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IImageBrush : Avalonia.Media.IBrush, Avalonia.Media.ITileBrush
    {
        Avalonia.Media.IImageBrushSource? Source { get; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IImageBrushSource
    {
    }
    public partial interface IImmutableBrush : Avalonia.Media.IBrush
    {
    }
    public partial interface IImmutableEffect : Avalonia.Media.IEffect, System.IEquatable<Avalonia.Media.IEffect>
    {
    }
    public partial interface IImmutableGlyphRunReference : System.IDisposable
    {
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IImmutableSolidColorBrush : Avalonia.Media.IBrush, Avalonia.Media.IImmutableBrush, Avalonia.Media.ISolidColorBrush
    {
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ILinearGradientBrush : Avalonia.Media.IBrush, Avalonia.Media.IGradientBrush
    {
        Avalonia.RelativePoint EndPoint { get; }
        Avalonia.RelativePoint StartPoint { get; }
    }
    public sealed partial class ImageBrush : Avalonia.Media.TileBrush, Avalonia.Media.IBrush, Avalonia.Media.IImageBrush, Avalonia.Media.ITileBrush
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Media.IImageBrushSource?> SourceProperty;
        public ImageBrush() { }
        public ImageBrush(Avalonia.Media.IImageBrushSource? source) { }
        public Avalonia.Media.IImageBrushSource? Source { get { throw null; } set { } }
        public Avalonia.Media.IImmutableBrush ToImmutable() { throw null; }
    }
    public sealed partial class ImageDrawing : Avalonia.Media.Drawing
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Media.IImage?> ImageSourceProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Rect> RectProperty;
        public ImageDrawing() { }
        public Avalonia.Media.IImage? ImageSource { get { throw null; } set { } }
        public Avalonia.Rect Rect { get { throw null; } set { } }
        public override Avalonia.Rect GetBounds() { throw null; }
    }
    public sealed partial class ImmediateDrawingContext : Avalonia.Platform.IOptionalFeatureProvider, System.IDisposable
    {
        internal ImmediateDrawingContext() { }
        public Avalonia.Matrix CurrentTransform { get { throw null; } }
        public Avalonia.Platform.IDrawingContextImpl PlatformImpl { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public void Dispose() { }
        public void DrawBitmap(Avalonia.Media.Imaging.Bitmap source, Avalonia.Rect rect) { }
        public void DrawBitmap(Avalonia.Media.Imaging.Bitmap source, Avalonia.Rect sourceRect, Avalonia.Rect destRect) { }
        public void DrawEllipse(Avalonia.Media.IImmutableBrush? brush, Avalonia.Media.Immutable.ImmutablePen? pen, Avalonia.Point center, double radiusX, double radiusY) { }
        public void DrawGlyphRun(Avalonia.Media.IImmutableBrush foreground, Avalonia.Media.IImmutableGlyphRunReference glyphRun) { }
        public void DrawLine(Avalonia.Media.Immutable.ImmutablePen pen, Avalonia.Point p1, Avalonia.Point p2) { }
        public void DrawRectangle(Avalonia.Media.IImmutableBrush? brush, Avalonia.Media.Immutable.ImmutablePen? pen, Avalonia.Rect rect, double radiusX = 0, double radiusY = 0, Avalonia.Media.BoxShadows boxShadows = default(Avalonia.Media.BoxShadows)) { }
        public void DrawRectangle(Avalonia.Media.Immutable.ImmutablePen pen, Avalonia.Rect rect, float cornerRadius = 0f) { }
        public void FillRectangle(Avalonia.Media.IImmutableBrush brush, Avalonia.Rect rect, float cornerRadius = 0f) { }
        public Avalonia.Media.ImmediateDrawingContext.PushedState PushClip(Avalonia.Rect clip) { throw null; }
        public Avalonia.Media.ImmediateDrawingContext.PushedState PushClip(Avalonia.RoundedRect clip) { throw null; }
        public Avalonia.Media.ImmediateDrawingContext.PushedState PushOpacity(double opacity, Avalonia.Rect bounds) { throw null; }
        public Avalonia.Media.ImmediateDrawingContext.PushedState PushOpacityMask(Avalonia.Media.IImmutableBrush mask, Avalonia.Rect bounds) { throw null; }
        public Avalonia.Media.ImmediateDrawingContext.PushedState PushPostTransform(Avalonia.Matrix matrix) { throw null; }
        public Avalonia.Media.ImmediateDrawingContext.PushedState PushPreTransform(Avalonia.Matrix matrix) { throw null; }
        public Avalonia.Media.ImmediateDrawingContext.PushedState PushSetTransform(Avalonia.Matrix matrix) { throw null; }
        public Avalonia.Media.ImmediateDrawingContext.PushedState PushTransformContainer() { throw null; }
        public object? TryGetFeature(System.Type type) { throw null; }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public readonly partial struct PushedState : System.IDisposable, System.IEquatable<Avalonia.Media.ImmediateDrawingContext.PushedState>
        {
            private readonly object _dummy;
            private readonly int _dummyPrimitive;
            public void Dispose() { }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public bool Equals(Avalonia.Media.ImmediateDrawingContext.PushedState other) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override bool Equals(object obj) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override int GetHashCode() { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public static bool operator ==(Avalonia.Media.ImmediateDrawingContext.PushedState left, Avalonia.Media.ImmediateDrawingContext.PushedState right) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public static bool operator !=(Avalonia.Media.ImmediateDrawingContext.PushedState left, Avalonia.Media.ImmediateDrawingContext.PushedState right) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override string ToString() { throw null; }
            public enum PushedStateType
            {
                None = 0,
                Matrix = 1,
                Opacity = 2,
                Clip = 3,
                MatrixContainer = 4,
                GeometryClip = 5,
                OpacityMask = 6,
            }
        }
    }
    public partial class ImmutableBlurEffect : Avalonia.Media.IBlurEffect, Avalonia.Media.IEffect, Avalonia.Media.IImmutableEffect, System.IEquatable<Avalonia.Media.IEffect>
    {
        public ImmutableBlurEffect(double radius) { }
        public double Radius { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.Media.IEffect? other) { throw null; }
    }
    public partial class ImmutableDropShadowDirectionEffect : Avalonia.Media.IDropShadowEffect, Avalonia.Media.IEffect, Avalonia.Media.IImmutableEffect, System.IEquatable<Avalonia.Media.IEffect>
    {
        public ImmutableDropShadowDirectionEffect(double direction, double shadowDepth, double blurRadius, Avalonia.Media.Color color, double opacity) { }
        public double BlurRadius { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.Color Color { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double Direction { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double OffsetX { get { throw null; } }
        public double OffsetY { get { throw null; } }
        public double Opacity { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double ShadowDepth { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.Media.IEffect? other) { throw null; }
    }
    public partial class ImmutableDropShadowEffect : Avalonia.Media.IDropShadowEffect, Avalonia.Media.IEffect, Avalonia.Media.IImmutableEffect, System.IEquatable<Avalonia.Media.IEffect>
    {
        public ImmutableDropShadowEffect(double offsetX, double offsetY, double blurRadius, Avalonia.Media.Color color, double opacity) { }
        public double BlurRadius { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.Color Color { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double OffsetX { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double OffsetY { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double Opacity { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.Media.IEffect? other) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct ImmutableExperimentalAcrylicMaterial : Avalonia.Media.IExperimentalAcrylicMaterial, System.IEquatable<Avalonia.Media.ImmutableExperimentalAcrylicMaterial>
    {
        private readonly int _dummyPrimitive;
        public ImmutableExperimentalAcrylicMaterial(Avalonia.Media.IExperimentalAcrylicMaterial brush) { throw null; }
        public Avalonia.Media.AcrylicBackgroundSource BackgroundSource { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.Color FallbackColor { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.Color MaterialColor { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.Color TintColor { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double TintOpacity { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.Media.ImmutableExperimentalAcrylicMaterial other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public Avalonia.Media.Color GetEffectiveTintColor() { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Media.ImmutableExperimentalAcrylicMaterial left, Avalonia.Media.ImmutableExperimentalAcrylicMaterial right) { throw null; }
        public static bool operator !=(Avalonia.Media.ImmutableExperimentalAcrylicMaterial left, Avalonia.Media.ImmutableExperimentalAcrylicMaterial right) { throw null; }
    }
    public partial interface IMutableEffect : Avalonia.Media.IEffect
    {
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IMutableExperimentalAcrylicMaterial : Avalonia.Media.IExperimentalAcrylicMaterial
    {
        Avalonia.Media.IExperimentalAcrylicMaterial ToImmutable();
    }
    public partial interface IMutableTransform : Avalonia.Media.ITransform
    {
        event System.EventHandler Changed;
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IPen
    {
        Avalonia.Media.IBrush? Brush { get; }
        Avalonia.Media.IDashStyle? DashStyle { get; }
        Avalonia.Media.PenLineCap LineCap { get; }
        Avalonia.Media.PenLineJoin LineJoin { get; }
        double MiterLimit { get; }
        double Thickness { get; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IRadialGradientBrush : Avalonia.Media.IBrush, Avalonia.Media.IGradientBrush
    {
        Avalonia.RelativePoint Center { get; }
        Avalonia.RelativePoint GradientOrigin { get; }
        double Radius { get; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ISceneBrush : Avalonia.Media.IBrush, Avalonia.Media.ITileBrush
    {
        Avalonia.Media.ISceneBrushContent? CreateContent();
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ISceneBrushContent : Avalonia.Media.IBrush, Avalonia.Media.IImmutableBrush, System.IDisposable
    {
        Avalonia.Media.ITileBrush Brush { get; }
        Avalonia.Rect Rect { get; }
        void Render(Avalonia.Platform.IDrawingContextImpl context, Avalonia.Matrix? transform);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ISolidColorBrush : Avalonia.Media.IBrush
    {
        Avalonia.Media.Color Color { get; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ITileBrush : Avalonia.Media.IBrush
    {
        Avalonia.Media.AlignmentX AlignmentX { get; }
        Avalonia.Media.AlignmentY AlignmentY { get; }
        Avalonia.RelativeRect DestinationRect { get; }
        Avalonia.RelativeRect SourceRect { get; }
        Avalonia.Media.Stretch Stretch { get; }
        Avalonia.Media.TileMode TileMode { get; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    [System.ComponentModel.TypeConverterAttribute(typeof(Avalonia.Media.TransformConverter))]
    public partial interface ITransform
    {
        Avalonia.Matrix Value { get; }
    }
    public sealed partial class LinearGradientBrush : Avalonia.Media.GradientBrush, Avalonia.Media.IBrush, Avalonia.Media.IGradientBrush, Avalonia.Media.ILinearGradientBrush
    {
        public static readonly Avalonia.StyledProperty<Avalonia.RelativePoint> EndPointProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.RelativePoint> StartPointProperty;
        public LinearGradientBrush() { }
        public Avalonia.RelativePoint EndPoint { get { throw null; } set { } }
        public Avalonia.RelativePoint StartPoint { get { throw null; } set { } }
        public override Avalonia.Media.IImmutableBrush ToImmutable() { throw null; }
    }
    public partial class LineGeometry : Avalonia.Media.Geometry
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Point> EndPointProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Point> StartPointProperty;
        public LineGeometry() { }
        public LineGeometry(Avalonia.Point startPoint, Avalonia.Point endPoint) { }
        public Avalonia.Point EndPoint { get { throw null; } set { } }
        public Avalonia.Point StartPoint { get { throw null; } set { } }
        public override Avalonia.Media.Geometry Clone() { throw null; }
        protected override Avalonia.Platform.IGeometryImpl? CreateDefiningGeometry() { throw null; }
    }
    public sealed partial class LineSegment : Avalonia.Media.PathSegment
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Point> PointProperty;
        public LineSegment() { }
        public Avalonia.Point Point { get { throw null; } set { } }
        public override string ToString() { throw null; }
    }
    public static partial class MaterialExtensions
    {
        public static Avalonia.Media.IExperimentalAcrylicMaterial ToImmutable(this Avalonia.Media.IExperimentalAcrylicMaterial material) { throw null; }
    }
    public sealed partial class MatrixTransform : Avalonia.Media.Transform
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Matrix> MatrixProperty;
        public MatrixTransform() { }
        public MatrixTransform(Avalonia.Matrix matrix) { }
        public Avalonia.Matrix Matrix { get { throw null; } set { } }
        public override Avalonia.Matrix Value { get { throw null; } }
    }
    public static partial class MediaExtensions
    {
        public static Avalonia.Vector CalculateScaling(this Avalonia.Media.Stretch stretch, Avalonia.Size destinationSize, Avalonia.Size sourceSize, Avalonia.Media.StretchDirection stretchDirection = Avalonia.Media.StretchDirection.Both) { throw null; }
        public static Avalonia.Size CalculateSize(this Avalonia.Media.Stretch stretch, Avalonia.Size destinationSize, Avalonia.Size sourceSize, Avalonia.Media.StretchDirection stretchDirection = Avalonia.Media.StretchDirection.Both) { throw null; }
    }
    public sealed partial class PathFigure : Avalonia.AvaloniaObject
    {
        public static readonly Avalonia.StyledProperty<bool> IsClosedProperty;
        public static readonly Avalonia.StyledProperty<bool> IsFilledProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Media.PathFigure, Avalonia.Media.PathSegments?> SegmentsProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Point> StartPointProperty;
        public PathFigure() { }
        public bool IsClosed { get { throw null; } set { } }
        public bool IsFilled { get { throw null; } set { } }
        [Avalonia.Metadata.ContentAttribute]
        public Avalonia.Media.PathSegments? Segments { get { throw null; } set { } }
        public Avalonia.Point StartPoint { get { throw null; } set { } }
        public override string ToString() { throw null; }
    }
    public sealed partial class PathFigures : Avalonia.Collections.AvaloniaList<Avalonia.Media.PathFigure>
    {
        public PathFigures() { }
        public static Avalonia.Media.PathFigures Parse(string pathData) { throw null; }
    }
    public partial class PathGeometry : Avalonia.Media.StreamGeometry
    {
        public static readonly Avalonia.DirectProperty<Avalonia.Media.PathGeometry, Avalonia.Media.PathFigures?> FiguresProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.FillRule> FillRuleProperty;
        public PathGeometry() { }
        [Avalonia.Metadata.ContentAttribute]
        public Avalonia.Media.PathFigures? Figures { get { throw null; } set { } }
        public Avalonia.Media.FillRule FillRule { get { throw null; } set { } }
        protected override Avalonia.Platform.IGeometryImpl? CreateDefiningGeometry() { throw null; }
        public static new Avalonia.Media.PathGeometry Parse(string pathData) { throw null; }
        public override string ToString() { throw null; }
    }
    public partial class PathMarkupParser : System.IDisposable
    {
        public PathMarkupParser(Avalonia.Platform.IGeometryContext geometryContext) { }
        protected virtual void Dispose(bool disposing) { }
        public void Parse(string pathData) { }
        void System.IDisposable.Dispose() { }
    }
    public abstract partial class PathSegment : Avalonia.AvaloniaObject
    {
        protected PathSegment() { }
        internal abstract void ApplyTo(Avalonia.Media.StreamGeometryContext ctx);
    }
    public sealed partial class PathSegments : Avalonia.Collections.AvaloniaList<Avalonia.Media.PathSegment>
    {
        public PathSegments() { }
    }
    public sealed partial class Pen : Avalonia.AvaloniaObject, Avalonia.Media.IPen
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Media.IBrush?> BrushProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.IDashStyle?> DashStyleProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.PenLineCap> LineCapProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.PenLineJoin> LineJoinProperty;
        public static readonly Avalonia.StyledProperty<double> MiterLimitProperty;
        public static readonly Avalonia.StyledProperty<double> ThicknessProperty;
        public Pen() { }
        public Pen(Avalonia.Media.IBrush? brush, double thickness = 1, Avalonia.Media.IDashStyle? dashStyle = null, Avalonia.Media.PenLineCap lineCap = Avalonia.Media.PenLineCap.Flat, Avalonia.Media.PenLineJoin lineJoin = Avalonia.Media.PenLineJoin.Miter, double miterLimit = 10) { }
        public Pen(uint color, double thickness = 1, Avalonia.Media.IDashStyle? dashStyle = null, Avalonia.Media.PenLineCap lineCap = Avalonia.Media.PenLineCap.Flat, Avalonia.Media.PenLineJoin lineJoin = Avalonia.Media.PenLineJoin.Miter, double miterLimit = 10) { }
        public Avalonia.Media.IBrush? Brush { get { throw null; } set { } }
        public Avalonia.Media.IDashStyle? DashStyle { get { throw null; } set { } }
        public Avalonia.Media.PenLineCap LineCap { get { throw null; } set { } }
        public Avalonia.Media.PenLineJoin LineJoin { get { throw null; } set { } }
        public double MiterLimit { get { throw null; } set { } }
        public double Thickness { get { throw null; } set { } }
        protected override void OnPropertyChanged(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
        public Avalonia.Media.Immutable.ImmutablePen ToImmutable() { throw null; }
    }
    public enum PenLineCap
    {
        Flat = 0,
        Round = 1,
        Square = 2,
    }
    public enum PenLineJoin
    {
        Bevel = 0,
        Miter = 1,
        Round = 2,
    }
    public partial class PolylineGeometry : Avalonia.Media.Geometry
    {
        public static readonly Avalonia.StyledProperty<bool> IsFilledProperty;
        public static readonly Avalonia.DirectProperty<Avalonia.Media.PolylineGeometry, System.Collections.Generic.IList<Avalonia.Point>> PointsProperty;
        public PolylineGeometry() { }
        public PolylineGeometry(System.Collections.Generic.IEnumerable<Avalonia.Point> points, bool isFilled) { }
        public bool IsFilled { get { throw null; } set { } }
        [Avalonia.Metadata.ContentAttribute]
        public System.Collections.Generic.IList<Avalonia.Point> Points { get { throw null; } set { } }
        public override Avalonia.Media.Geometry Clone() { throw null; }
        protected override Avalonia.Platform.IGeometryImpl? CreateDefiningGeometry() { throw null; }
    }
    public sealed partial class PolyLineSegment : Avalonia.Media.PathSegment
    {
        public static readonly Avalonia.StyledProperty<System.Collections.Generic.IList<Avalonia.Point>> PointsProperty;
        public PolyLineSegment() { }
        public PolyLineSegment(System.Collections.Generic.IEnumerable<Avalonia.Point> points) { }
        public System.Collections.Generic.IList<Avalonia.Point> Points { get { throw null; } set { } }
        public override string ToString() { throw null; }
    }
    public sealed partial class QuadraticBezierSegment : Avalonia.Media.PathSegment
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Point> Point1Property;
        public static readonly Avalonia.StyledProperty<Avalonia.Point> Point2Property;
        public QuadraticBezierSegment() { }
        public Avalonia.Point Point1 { get { throw null; } set { } }
        public Avalonia.Point Point2 { get { throw null; } set { } }
        public override string ToString() { throw null; }
    }
    public sealed partial class RadialGradientBrush : Avalonia.Media.GradientBrush, Avalonia.Media.IBrush, Avalonia.Media.IGradientBrush, Avalonia.Media.IRadialGradientBrush
    {
        public static readonly Avalonia.StyledProperty<Avalonia.RelativePoint> CenterProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.RelativePoint> GradientOriginProperty;
        public static readonly Avalonia.StyledProperty<double> RadiusProperty;
        public RadialGradientBrush() { }
        public Avalonia.RelativePoint Center { get { throw null; } set { } }
        public Avalonia.RelativePoint GradientOrigin { get { throw null; } set { } }
        public double Radius { get { throw null; } set { } }
        public override Avalonia.Media.IImmutableBrush ToImmutable() { throw null; }
    }
    public partial class RectangleGeometry : Avalonia.Media.Geometry
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Rect> RectProperty;
        public RectangleGeometry() { }
        public RectangleGeometry(Avalonia.Rect rect) { }
        public Avalonia.Rect Rect { get { throw null; } set { } }
        public override Avalonia.Media.Geometry Clone() { throw null; }
        protected override Avalonia.Platform.IGeometryImpl? CreateDefiningGeometry() { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct RenderOptions : System.IEquatable<Avalonia.Media.RenderOptions>
    {
        private readonly int _dummyPrimitive;
        public Avalonia.Media.Imaging.BitmapBlendingMode BitmapBlendingMode { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Media.Imaging.BitmapInterpolationMode BitmapInterpolationMode { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Media.EdgeMode EdgeMode { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Media.TextRenderingMode TextRenderingMode { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.RenderOptions other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        public static Avalonia.Media.Imaging.BitmapBlendingMode GetBitmapBlendingMode(Avalonia.Visual visual) { throw null; }
        public static Avalonia.Media.Imaging.BitmapInterpolationMode GetBitmapInterpolationMode(Avalonia.Visual visual) { throw null; }
        public static Avalonia.Media.EdgeMode GetEdgeMode(Avalonia.Visual visual) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        public static Avalonia.Media.TextRenderingMode GetTextRenderingMode(Avalonia.Visual visual) { throw null; }
        public Avalonia.Media.RenderOptions MergeWith(Avalonia.Media.RenderOptions other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.RenderOptions left, Avalonia.Media.RenderOptions right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.RenderOptions left, Avalonia.Media.RenderOptions right) { throw null; }
        public static void SetBitmapBlendingMode(Avalonia.Visual visual, Avalonia.Media.Imaging.BitmapBlendingMode value) { }
        public static void SetBitmapInterpolationMode(Avalonia.Visual visual, Avalonia.Media.Imaging.BitmapInterpolationMode value) { }
        public static void SetEdgeMode(Avalonia.Visual visual, Avalonia.Media.EdgeMode value) { }
        public static void SetTextRenderingMode(Avalonia.Visual visual, Avalonia.Media.TextRenderingMode value) { }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public sealed partial class Rotate3DTransform : Avalonia.Media.Transform
    {
        public static readonly Avalonia.StyledProperty<double> AngleXProperty;
        public static readonly Avalonia.StyledProperty<double> AngleYProperty;
        public static readonly Avalonia.StyledProperty<double> AngleZProperty;
        public static readonly Avalonia.StyledProperty<double> CenterXProperty;
        public static readonly Avalonia.StyledProperty<double> CenterYProperty;
        public static readonly Avalonia.StyledProperty<double> CenterZProperty;
        public static readonly Avalonia.StyledProperty<double> DepthProperty;
        public Rotate3DTransform() { }
        public Rotate3DTransform(double angleX, double angleY, double angleZ, double centerX, double centerY, double centerZ, double depth) { }
        public double AngleX { get { throw null; } set { } }
        public double AngleY { get { throw null; } set { } }
        public double AngleZ { get { throw null; } set { } }
        public double CenterX { get { throw null; } set { } }
        public double CenterY { get { throw null; } set { } }
        public double CenterZ { get { throw null; } set { } }
        public double Depth { get { throw null; } set { } }
        public override Avalonia.Matrix Value { get { throw null; } }
        protected override void OnPropertyChanged(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
    }
    public sealed partial class RotateTransform : Avalonia.Media.Transform
    {
        public static readonly Avalonia.StyledProperty<double> AngleProperty;
        public static readonly Avalonia.StyledProperty<double> CenterXProperty;
        public static readonly Avalonia.StyledProperty<double> CenterYProperty;
        public RotateTransform() { }
        public RotateTransform(double angle) { }
        public RotateTransform(double angle, double centerX, double centerY) { }
        public double Angle { get { throw null; } set { } }
        public double CenterX { get { throw null; } set { } }
        public double CenterY { get { throw null; } set { } }
        public override Avalonia.Matrix Value { get { throw null; } }
    }
    public sealed partial class ScaleTransform : Avalonia.Media.Transform
    {
        public static readonly Avalonia.StyledProperty<double> ScaleXProperty;
        public static readonly Avalonia.StyledProperty<double> ScaleYProperty;
        public ScaleTransform() { }
        public ScaleTransform(double scaleX, double scaleY) { }
        public double ScaleX { get { throw null; } set { } }
        public double ScaleY { get { throw null; } set { } }
        public override Avalonia.Matrix Value { get { throw null; } }
        protected override void OnPropertyChanged(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
    }
    public sealed partial class SkewTransform : Avalonia.Media.Transform
    {
        public static readonly Avalonia.StyledProperty<double> AngleXProperty;
        public static readonly Avalonia.StyledProperty<double> AngleYProperty;
        public SkewTransform() { }
        public SkewTransform(double angleX, double angleY) { }
        public double AngleX { get { throw null; } set { } }
        public double AngleY { get { throw null; } set { } }
        public override Avalonia.Matrix Value { get { throw null; } }
        protected override void OnPropertyChanged(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
    }
    public sealed partial class SolidColorBrush : Avalonia.Media.Brush, Avalonia.Media.IBrush, Avalonia.Media.ISolidColorBrush
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Color> ColorProperty;
        public SolidColorBrush() { }
        public SolidColorBrush(Avalonia.Media.Color color, double opacity = 1) { }
        public SolidColorBrush(uint color) { }
        public Avalonia.Media.Color Color { get { throw null; } set { } }
        public static new Avalonia.Media.SolidColorBrush Parse(string s) { throw null; }
        public Avalonia.Media.IImmutableBrush ToImmutable() { throw null; }
        public override string ToString() { throw null; }
    }
    public partial class StreamGeometry : Avalonia.Media.Geometry
    {
        public StreamGeometry() { }
        public override Avalonia.Media.Geometry Clone() { throw null; }
        protected override Avalonia.Platform.IGeometryImpl? CreateDefiningGeometry() { throw null; }
        public Avalonia.Media.StreamGeometryContext Open() { throw null; }
        public static new Avalonia.Media.StreamGeometry Parse(string s) { throw null; }
    }
    public partial class StreamGeometryContext : Avalonia.Platform.IGeometryContext, System.IDisposable
    {
        public StreamGeometryContext(Avalonia.Platform.IStreamGeometryContextImpl impl) { }
        public void ArcTo(Avalonia.Point point, Avalonia.Size size, double rotationAngle, bool isLargeArc, Avalonia.Media.SweepDirection sweepDirection) { }
        public void BeginFigure(Avalonia.Point startPoint, bool isFilled) { }
        public void CubicBezierTo(Avalonia.Point point1, Avalonia.Point point2, Avalonia.Point point3) { }
        public void Dispose() { }
        public void EndFigure(bool isClosed) { }
        public void LineTo(Avalonia.Point point) { }
        public void PreciseArcTo(Avalonia.Point point, Avalonia.Size size, double rotationAngle, bool isLargeArc, Avalonia.Media.SweepDirection sweepDirection) { }
        public void QuadraticBezierTo(Avalonia.Point control, Avalonia.Point endPoint) { }
        public void SetFillRule(Avalonia.Media.FillRule fillRule) { }
    }
    public enum Stretch
    {
        None = 0,
        Fill = 1,
        Uniform = 2,
        UniformToFill = 3,
    }
    public enum StretchDirection
    {
        UpOnly = 0,
        DownOnly = 1,
        Both = 2,
    }
    public enum SweepDirection
    {
        CounterClockwise = 0,
        Clockwise = 1,
    }
    public enum TextAlignment
    {
        Left = 0,
        Center = 1,
        Right = 2,
        Start = 3,
        End = 4,
        DetectFromContent = 5,
        Justify = 6,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TextCollapsingCreateInfo : System.IEquatable<Avalonia.Media.TextCollapsingCreateInfo>
    {
        public readonly Avalonia.Media.FlowDirection FlowDirection;
        public readonly Avalonia.Media.TextFormatting.TextRunProperties TextRunProperties;
        public readonly double Width;
        public TextCollapsingCreateInfo(double width, Avalonia.Media.TextFormatting.TextRunProperties textRunProperties, Avalonia.Media.FlowDirection flowDirection) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.TextCollapsingCreateInfo other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.TextCollapsingCreateInfo left, Avalonia.Media.TextCollapsingCreateInfo right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.TextCollapsingCreateInfo left, Avalonia.Media.TextCollapsingCreateInfo right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public partial class TextDecoration : Avalonia.AvaloniaObject
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Media.TextDecorationLocation> LocationProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Collections.AvaloniaList<double>?> StrokeDashArrayProperty;
        public static readonly Avalonia.StyledProperty<double> StrokeDashOffsetProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.PenLineCap> StrokeLineCapProperty;
        public static readonly Avalonia.StyledProperty<double> StrokeOffsetProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.TextDecorationUnit> StrokeOffsetUnitProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.IBrush?> StrokeProperty;
        public static readonly Avalonia.StyledProperty<double> StrokeThicknessProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.TextDecorationUnit> StrokeThicknessUnitProperty;
        public TextDecoration() { }
        public Avalonia.Media.TextDecorationLocation Location { get { throw null; } set { } }
        public Avalonia.Media.IBrush? Stroke { get { throw null; } set { } }
        public Avalonia.Collections.AvaloniaList<double>? StrokeDashArray { get { throw null; } set { } }
        public double StrokeDashOffset { get { throw null; } set { } }
        public Avalonia.Media.PenLineCap StrokeLineCap { get { throw null; } set { } }
        public double StrokeOffset { get { throw null; } set { } }
        public Avalonia.Media.TextDecorationUnit StrokeOffsetUnit { get { throw null; } set { } }
        public double StrokeThickness { get { throw null; } set { } }
        public Avalonia.Media.TextDecorationUnit StrokeThicknessUnit { get { throw null; } set { } }
    }
    public partial class TextDecorationCollection : Avalonia.Collections.AvaloniaList<Avalonia.Media.TextDecoration>
    {
        public TextDecorationCollection() { }
        public TextDecorationCollection(System.Collections.Generic.IEnumerable<Avalonia.Media.TextDecoration> textDecorations) { }
        public static Avalonia.Media.TextDecorationCollection Parse(string s) { throw null; }
    }
    public enum TextDecorationLocation
    {
        Underline = 0,
        Overline = 1,
        Strikethrough = 2,
        Baseline = 3,
    }
    public static partial class TextDecorations
    {
        public static Avalonia.Media.TextDecorationCollection Baseline { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Media.TextDecorationCollection Overline { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Media.TextDecorationCollection Strikethrough { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Media.TextDecorationCollection Underline { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public enum TextDecorationUnit
    {
        FontRecommended = 0,
        FontRenderingEmSize = 1,
        Pixel = 2,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TextHitTestResult : System.IEquatable<Avalonia.Media.TextHitTestResult>
    {
        private readonly int _dummyPrimitive;
        public TextHitTestResult(Avalonia.Media.CharacterHit characterHit, int textPosition, bool isInside, bool isTrailing) { throw null; }
        public Avalonia.Media.CharacterHit CharacterHit { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsInside { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsTrailing { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int TextPosition { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.TextHitTestResult other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.TextHitTestResult left, Avalonia.Media.TextHitTestResult right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.TextHitTestResult left, Avalonia.Media.TextHitTestResult right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public sealed partial class TextLeadingPrefixTrimming : Avalonia.Media.TextTrimming
    {
        public TextLeadingPrefixTrimming(string ellipsis, int prefixLength) { }
        public override Avalonia.Media.TextFormatting.TextCollapsingProperties CreateCollapsingProperties(Avalonia.Media.TextCollapsingCreateInfo createInfo) { throw null; }
        public override string ToString() { throw null; }
    }
    public enum TextRenderingMode : byte
    {
        Unspecified = (byte)0,
        SubpixelAntialias = (byte)1,
        Antialias = (byte)2,
        Alias = (byte)3,
    }
    public sealed partial class TextTrailingTrimming : Avalonia.Media.TextTrimming
    {
        public TextTrailingTrimming(string ellipsis, bool isWordBased) { }
        public override Avalonia.Media.TextFormatting.TextCollapsingProperties CreateCollapsingProperties(Avalonia.Media.TextCollapsingCreateInfo createInfo) { throw null; }
        public override string ToString() { throw null; }
    }
    public abstract partial class TextTrimming
    {
        protected TextTrimming() { }
        public static Avalonia.Media.TextTrimming CharacterEllipsis { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Media.TextTrimming LeadingCharacterEllipsis { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Media.TextTrimming None { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Media.TextTrimming PrefixCharacterEllipsis { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Media.TextTrimming WordEllipsis { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public abstract Avalonia.Media.TextFormatting.TextCollapsingProperties CreateCollapsingProperties(Avalonia.Media.TextCollapsingCreateInfo createInfo);
        public static Avalonia.Media.TextTrimming Parse(string s) { throw null; }
    }
    public enum TextWrapping
    {
        NoWrap = 0,
        Wrap = 1,
        WrapWithOverflow = 2,
    }
    public abstract partial class TileBrush : Avalonia.Media.Brush, Avalonia.Media.IBrush, Avalonia.Media.ITileBrush
    {
        internal TileBrush() { }
        public static readonly Avalonia.StyledProperty<Avalonia.Media.AlignmentX> AlignmentXProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.AlignmentY> AlignmentYProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.RelativeRect> DestinationRectProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.RelativeRect> SourceRectProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Stretch> StretchProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.Media.TileMode> TileModeProperty;
        public Avalonia.Media.AlignmentX AlignmentX { get { throw null; } set { } }
        public Avalonia.Media.AlignmentY AlignmentY { get { throw null; } set { } }
        public Avalonia.RelativeRect DestinationRect { get { throw null; } set { } }
        public Avalonia.RelativeRect SourceRect { get { throw null; } set { } }
        public Avalonia.Media.Stretch Stretch { get { throw null; } set { } }
        public Avalonia.Media.TileMode TileMode { get { throw null; } set { } }
    }
    public enum TileMode
    {
        None = 0,
        FlipX = 1,
        FlipY = 2,
        FlipXY = 3,
        Tile = 4,
    }
    public abstract partial class Transform : Avalonia.Animation.Animatable, Avalonia.Media.IMutableTransform, Avalonia.Media.ITransform
    {
        internal Transform() { }
        public abstract Avalonia.Matrix Value { get; }
        public event System.EventHandler? Changed { add { } remove { } }
        public static Avalonia.Media.Transform Parse(string s) { throw null; }
        protected void RaiseChanged() { }
        public Avalonia.Media.Immutable.ImmutableTransform ToImmutable() { throw null; }
        public override string ToString() { throw null; }
    }
    public partial class TransformConverter : System.ComponentModel.TypeConverter
    {
        public TransformConverter() { }
        public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Type sourceType) { throw null; }
        public override object? ConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object? value) { throw null; }
    }
    public static partial class TransformExtensions
    {
        public static Avalonia.Media.Immutable.ImmutableTransform ToImmutable(this Avalonia.Media.ITransform transform) { throw null; }
    }
    public sealed partial class TransformGroup : Avalonia.Media.Transform
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Media.Transforms> ChildrenProperty;
        public TransformGroup() { }
        [Avalonia.Metadata.ContentAttribute]
        public Avalonia.Media.Transforms Children { get { throw null; } set { } }
        public override Avalonia.Matrix Value { get { throw null; } }
    }
    public sealed partial class Transforms : Avalonia.Collections.AvaloniaList<Avalonia.Media.Transform>
    {
        public Transforms() { }
    }
    public sealed partial class TranslateTransform : Avalonia.Media.Transform
    {
        public static readonly Avalonia.StyledProperty<double> XProperty;
        public static readonly Avalonia.StyledProperty<double> YProperty;
        public TranslateTransform() { }
        public TranslateTransform(double x, double y) { }
        public override Avalonia.Matrix Value { get { throw null; } }
        public double X { get { throw null; } set { } }
        public double Y { get { throw null; } set { } }
        protected override void OnPropertyChanged(Avalonia.AvaloniaPropertyChangedEventArgs change) { }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("Name = {FontFamily.Name}, Weight = {Weight}, Style = {Style}")]
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct Typeface : System.IEquatable<Avalonia.Media.Typeface>
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public Typeface(Avalonia.Media.FontFamily fontFamily, Avalonia.Media.FontStyle style = Avalonia.Media.FontStyle.Normal, Avalonia.Media.FontWeight weight = Avalonia.Media.FontWeight.Normal, Avalonia.Media.FontStretch stretch = Avalonia.Media.FontStretch.Normal) { throw null; }
        public Typeface(string fontFamilyName, Avalonia.Media.FontStyle style = Avalonia.Media.FontStyle.Normal, Avalonia.Media.FontWeight weight = Avalonia.Media.FontWeight.Normal, Avalonia.Media.FontStretch stretch = Avalonia.Media.FontStretch.Normal) { throw null; }
        public static Avalonia.Media.Typeface Default { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.FontFamily FontFamily { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.IGlyphTypeface GlyphTypeface { get { throw null; } }
        public Avalonia.Media.FontStretch Stretch { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.FontStyle Style { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.FontWeight Weight { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.Media.Typeface other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Media.Typeface a, Avalonia.Media.Typeface b) { throw null; }
        public static bool operator !=(Avalonia.Media.Typeface a, Avalonia.Media.Typeface b) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct UnicodeRange : System.IEquatable<Avalonia.Media.UnicodeRange>
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public static readonly Avalonia.Media.UnicodeRange Default;
        public UnicodeRange(Avalonia.Media.UnicodeRangeSegment single) { throw null; }
        public UnicodeRange(System.Collections.Generic.IReadOnlyList<Avalonia.Media.UnicodeRangeSegment> segments) { throw null; }
        public UnicodeRange(int start, int end) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.UnicodeRange other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        public bool IsInRange(int value) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.UnicodeRange left, Avalonia.Media.UnicodeRange right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.UnicodeRange left, Avalonia.Media.UnicodeRange right) { throw null; }
        public static Avalonia.Media.UnicodeRange Parse(string s) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct UnicodeRangeSegment : System.IEquatable<Avalonia.Media.UnicodeRangeSegment>
    {
        private readonly int _dummyPrimitive;
        public UnicodeRangeSegment(int start, int end) { throw null; }
        public int End { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int Start { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.UnicodeRangeSegment other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        public bool IsInRange(int value) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.UnicodeRangeSegment left, Avalonia.Media.UnicodeRangeSegment right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.UnicodeRangeSegment left, Avalonia.Media.UnicodeRangeSegment right) { throw null; }
        public static Avalonia.Media.UnicodeRangeSegment Parse(string s) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public sealed partial class VisualBrush : Avalonia.Media.TileBrush, Avalonia.Media.IBrush, Avalonia.Media.ISceneBrush, Avalonia.Media.ITileBrush
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Visual?> VisualProperty;
        public VisualBrush() { }
        public VisualBrush(Avalonia.Visual visual) { }
        public Avalonia.Visual? Visual { get { throw null; } set { } }
        Avalonia.Media.ISceneBrushContent? Avalonia.Media.ISceneBrush.CreateContent() { throw null; }
        protected override void OnUnreferencedFromCompositor(Avalonia.Rendering.Composition.Compositor c) { }
    }
}
namespace Avalonia.Media.Fonts
{
    public partial class EmbeddedFontCollection : Avalonia.Media.Fonts.FontCollectionBase
    {
        public EmbeddedFontCollection(System.Uri key, System.Uri source) { }
        public override int Count { get { throw null; } }
        public override Avalonia.Media.FontFamily this[int index] { get { throw null; } }
        public override System.Uri Key { get { throw null; } }
        public override System.Collections.Generic.IEnumerator<Avalonia.Media.FontFamily> GetEnumerator() { throw null; }
        public override void Initialize(Avalonia.Platform.IFontManagerImpl fontManager) { }
        public override bool TryGetGlyphTypeface(string familyName, Avalonia.Media.FontStyle style, Avalonia.Media.FontWeight weight, Avalonia.Media.FontStretch stretch, [System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] out Avalonia.Media.IGlyphTypeface? glyphTypeface) { throw null; }
    }
    public sealed partial class FamilyNameCollection : System.Collections.Generic.IEnumerable<string>, System.Collections.Generic.IReadOnlyCollection<string>, System.Collections.Generic.IReadOnlyList<string>, System.Collections.IEnumerable
    {
        public FamilyNameCollection(string familyNames) { }
        public int Count { get { throw null; } }
        public bool HasFallbacks { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public string this[int index] { get { throw null; } }
        public string PrimaryFamilyName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override bool Equals(object? obj) { throw null; }
        public Avalonia.Utilities.ImmutableReadOnlyListStructEnumerator<string> GetEnumerator() { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Media.Fonts.FamilyNameCollection? a, Avalonia.Media.Fonts.FamilyNameCollection? b) { throw null; }
        public static bool operator !=(Avalonia.Media.Fonts.FamilyNameCollection? a, Avalonia.Media.Fonts.FamilyNameCollection? b) { throw null; }
        System.Collections.Generic.IEnumerator<string> System.Collections.Generic.IEnumerable<string>.GetEnumerator() { throw null; }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
        public override string ToString() { throw null; }
    }
    public abstract partial class FontCollectionBase : Avalonia.Media.Fonts.IFontCollection, System.Collections.Generic.IEnumerable<Avalonia.Media.FontFamily>, System.Collections.Generic.IReadOnlyCollection<Avalonia.Media.FontFamily>, System.Collections.Generic.IReadOnlyList<Avalonia.Media.FontFamily>, System.Collections.IEnumerable, System.IDisposable
    {
        protected readonly System.Collections.Concurrent.ConcurrentDictionary<string, System.Collections.Concurrent.ConcurrentDictionary<Avalonia.Media.Fonts.FontCollectionKey, Avalonia.Media.IGlyphTypeface?>> _glyphTypefaceCache;
        protected FontCollectionBase() { }
        public abstract int Count { get; }
        public abstract Avalonia.Media.FontFamily this[int index] { get; }
        public abstract System.Uri Key { get; }
        public abstract System.Collections.Generic.IEnumerator<Avalonia.Media.FontFamily> GetEnumerator();
        public abstract void Initialize(Avalonia.Platform.IFontManagerImpl fontManager);
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
        void System.IDisposable.Dispose() { }
        public abstract bool TryGetGlyphTypeface(string familyName, Avalonia.Media.FontStyle style, Avalonia.Media.FontWeight weight, Avalonia.Media.FontStretch stretch, [System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] out Avalonia.Media.IGlyphTypeface? glyphTypeface);
        public bool TryMatchCharacter(int codepoint, Avalonia.Media.FontStyle style, Avalonia.Media.FontWeight weight, Avalonia.Media.FontStretch stretch, string? familyName, System.Globalization.CultureInfo? culture, out Avalonia.Media.Typeface match) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct FontCollectionKey : System.IEquatable<Avalonia.Media.Fonts.FontCollectionKey>
    {
        private readonly int _dummyPrimitive;
        public FontCollectionKey(Avalonia.Media.FontStyle Style, Avalonia.Media.FontWeight Weight, Avalonia.Media.FontStretch Stretch) { throw null; }
        public Avalonia.Media.FontStretch Stretch { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Media.FontStyle Style { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Media.FontWeight Weight { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public void Deconstruct(out Avalonia.Media.FontStyle Style, out Avalonia.Media.FontWeight Weight, out Avalonia.Media.FontStretch Stretch) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.Fonts.FontCollectionKey other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.Fonts.FontCollectionKey left, Avalonia.Media.Fonts.FontCollectionKey right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.Fonts.FontCollectionKey left, Avalonia.Media.Fonts.FontCollectionKey right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public partial class FontFamilyKey
    {
        public FontFamilyKey(System.Uri source, System.Uri? baseUri = null) { }
        public System.Uri? BaseUri { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.Uri Source { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Media.Fonts.FontFamilyKey? a, Avalonia.Media.Fonts.FontFamilyKey? b) { throw null; }
        public static bool operator !=(Avalonia.Media.Fonts.FontFamilyKey? a, Avalonia.Media.Fonts.FontFamilyKey? b) { throw null; }
        public override string ToString() { throw null; }
    }
    public static partial class FontFamilyLoader
    {
        public static System.Collections.Generic.IEnumerable<System.Uri> LoadFontAssets(System.Uri source) { throw null; }
    }
    public partial interface IFontCollection : System.Collections.Generic.IEnumerable<Avalonia.Media.FontFamily>, System.Collections.Generic.IReadOnlyCollection<Avalonia.Media.FontFamily>, System.Collections.Generic.IReadOnlyList<Avalonia.Media.FontFamily>, System.Collections.IEnumerable, System.IDisposable
    {
        System.Uri Key { get; }
        void Initialize(Avalonia.Platform.IFontManagerImpl fontManager);
        bool TryGetGlyphTypeface(string familyName, Avalonia.Media.FontStyle style, Avalonia.Media.FontWeight weight, Avalonia.Media.FontStretch stretch, [System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] out Avalonia.Media.IGlyphTypeface? glyphTypeface);
        bool TryMatchCharacter(int codepoint, Avalonia.Media.FontStyle fontStyle, Avalonia.Media.FontWeight fontWeight, Avalonia.Media.FontStretch fontStretch, string? familyName, System.Globalization.CultureInfo? culture, out Avalonia.Media.Typeface typeface);
    }
}
namespace Avalonia.Media.Imaging
{
    public partial class Bitmap : Avalonia.Media.IImage, Avalonia.Media.IImageBrushSource, System.IDisposable
    {
        protected Bitmap(Avalonia.Platform.IBitmapImpl impl) { }
        public Bitmap(Avalonia.Platform.PixelFormat format, Avalonia.Platform.AlphaFormat alphaFormat, System.IntPtr data, Avalonia.PixelSize size, Avalonia.Vector dpi, int stride) { }
        public Bitmap(System.IO.Stream stream) { }
        public Bitmap(string fileName) { }
        public Avalonia.Vector Dpi { get { throw null; } }
        public virtual Avalonia.Platform.PixelFormat? Format { get { throw null; } }
        public Avalonia.PixelSize PixelSize { get { throw null; } }
        public Avalonia.Size Size { get { throw null; } }
        void Avalonia.Media.IImage.Draw(Avalonia.Media.DrawingContext context, Avalonia.Rect sourceRect, Avalonia.Rect destRect) { }
        public virtual void CopyPixels(Avalonia.PixelRect sourceRect, System.IntPtr buffer, int bufferSize, int stride) { }
        public Avalonia.Media.Imaging.Bitmap CreateScaledBitmap(Avalonia.PixelSize destinationSize, Avalonia.Media.Imaging.BitmapInterpolationMode interpolationMode = Avalonia.Media.Imaging.BitmapInterpolationMode.HighQuality) { throw null; }
        public static Avalonia.Media.Imaging.Bitmap DecodeToHeight(System.IO.Stream stream, int height, Avalonia.Media.Imaging.BitmapInterpolationMode interpolationMode = Avalonia.Media.Imaging.BitmapInterpolationMode.HighQuality) { throw null; }
        public static Avalonia.Media.Imaging.Bitmap DecodeToWidth(System.IO.Stream stream, int width, Avalonia.Media.Imaging.BitmapInterpolationMode interpolationMode = Avalonia.Media.Imaging.BitmapInterpolationMode.HighQuality) { throw null; }
        public virtual void Dispose() { }
        public void Save(System.IO.Stream stream, int? quality = default(int?)) { }
        public void Save(string fileName, int? quality = default(int?)) { }
    }
    public enum BitmapBlendingMode : byte
    {
        Unspecified = (byte)0,
        SourceOver = (byte)1,
        Source = (byte)2,
        Destination = (byte)3,
        DestinationOver = (byte)4,
        SourceIn = (byte)5,
        DestinationIn = (byte)6,
        SourceOut = (byte)7,
        DestinationOut = (byte)8,
        SourceAtop = (byte)9,
        DestinationAtop = (byte)10,
        Xor = (byte)11,
        Plus = (byte)12,
    }
    public enum BitmapInterpolationMode : byte
    {
        Unspecified = (byte)0,
        None = (byte)1,
        LowQuality = (byte)2,
        MediumQuality = (byte)3,
        HighQuality = (byte)4,
    }
    public partial class CroppedBitmap : Avalonia.AvaloniaObject, Avalonia.Media.IImage, System.IDisposable
    {
        public static readonly Avalonia.StyledProperty<Avalonia.Media.IImage?> SourceProperty;
        public static readonly Avalonia.StyledProperty<Avalonia.PixelRect> SourceRectProperty;
        public CroppedBitmap() { }
        public CroppedBitmap(Avalonia.Media.IImage source, Avalonia.PixelRect sourceRect) { }
        public Avalonia.Size Size { get { throw null; } }
        public Avalonia.Media.IImage? Source { get { throw null; } set { } }
        public Avalonia.PixelRect SourceRect { get { throw null; } set { } }
        public event System.EventHandler? Invalidated { add { } remove { } }
        public virtual void Dispose() { }
        public void Draw(Avalonia.Media.DrawingContext context, Avalonia.Rect sourceRect, Avalonia.Rect destRect) { }
    }
    public partial class RenderTargetBitmap : Avalonia.Media.Imaging.Bitmap
    {
        public RenderTargetBitmap(Avalonia.PixelSize pixelSize) : base (default(string)) { }
        public RenderTargetBitmap(Avalonia.PixelSize pixelSize, Avalonia.Vector dpi) : base (default(string)) { }
        public Avalonia.Media.DrawingContext CreateDrawingContext() { throw null; }
        public override void Dispose() { }
        public void Render(Avalonia.Visual visual) { }
    }
    public partial class WriteableBitmap : Avalonia.Media.Imaging.Bitmap
    {
        public WriteableBitmap(Avalonia.PixelSize size, Avalonia.Vector dpi, Avalonia.Platform.PixelFormat? format = default(Avalonia.Platform.PixelFormat?), Avalonia.Platform.AlphaFormat? alphaFormat = default(Avalonia.Platform.AlphaFormat?)) : base (default(string)) { }
        public WriteableBitmap(Avalonia.Platform.PixelFormat format, Avalonia.Platform.AlphaFormat alphaFormat, System.IntPtr data, Avalonia.PixelSize size, Avalonia.Vector dpi, int stride) : base (default(string)) { }
        public override Avalonia.Platform.PixelFormat? Format { get { throw null; } }
        public override void CopyPixels(Avalonia.PixelRect sourceRect, System.IntPtr buffer, int bufferSize, int stride) { }
        public static Avalonia.Media.Imaging.WriteableBitmap Decode(System.IO.Stream stream) { throw null; }
        public static new Avalonia.Media.Imaging.WriteableBitmap DecodeToHeight(System.IO.Stream stream, int height, Avalonia.Media.Imaging.BitmapInterpolationMode interpolationMode = Avalonia.Media.Imaging.BitmapInterpolationMode.HighQuality) { throw null; }
        public static new Avalonia.Media.Imaging.WriteableBitmap DecodeToWidth(System.IO.Stream stream, int width, Avalonia.Media.Imaging.BitmapInterpolationMode interpolationMode = Avalonia.Media.Imaging.BitmapInterpolationMode.HighQuality) { throw null; }
        public Avalonia.Platform.ILockedFramebuffer Lock() { throw null; }
    }
}
namespace Avalonia.Media.Immutable
{
    public partial class ImmutableConicGradientBrush : Avalonia.Media.Immutable.ImmutableGradientBrush, Avalonia.Media.IBrush, Avalonia.Media.IConicGradientBrush, Avalonia.Media.IGradientBrush
    {
        public ImmutableConicGradientBrush(Avalonia.Media.ConicGradientBrush source) : base (default(System.Collections.Generic.IReadOnlyList<Avalonia.Media.Immutable.ImmutableGradientStop>), default(double), default(Avalonia.Media.Immutable.ImmutableTransform), default(Avalonia.RelativePoint?), default(Avalonia.Media.GradientSpreadMethod)) { }
        public ImmutableConicGradientBrush(System.Collections.Generic.IReadOnlyList<Avalonia.Media.Immutable.ImmutableGradientStop> gradientStops, double opacity = 1, Avalonia.Media.Immutable.ImmutableTransform? transform = null, Avalonia.RelativePoint? transformOrigin = default(Avalonia.RelativePoint?), Avalonia.Media.GradientSpreadMethod spreadMethod = Avalonia.Media.GradientSpreadMethod.Pad, Avalonia.RelativePoint? center = default(Avalonia.RelativePoint?), double angle = 0) : base (default(System.Collections.Generic.IReadOnlyList<Avalonia.Media.Immutable.ImmutableGradientStop>), default(double), default(Avalonia.Media.Immutable.ImmutableTransform), default(Avalonia.RelativePoint?), default(Avalonia.Media.GradientSpreadMethod)) { }
        public double Angle { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.RelativePoint Center { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class ImmutableDashStyle : Avalonia.Media.IDashStyle, System.IEquatable<Avalonia.Media.IDashStyle>
    {
        public ImmutableDashStyle(System.Collections.Generic.IEnumerable<double>? dashes, double offset) { }
        public System.Collections.Generic.IReadOnlyList<double> Dashes { get { throw null; } }
        public double Offset { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.Media.IDashStyle? other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    public abstract partial class ImmutableGradientBrush : Avalonia.Media.IBrush, Avalonia.Media.IGradientBrush, Avalonia.Media.IImmutableBrush
    {
        protected ImmutableGradientBrush(Avalonia.Media.GradientBrush source) { }
        protected ImmutableGradientBrush(System.Collections.Generic.IReadOnlyList<Avalonia.Media.Immutable.ImmutableGradientStop> gradientStops, double opacity, Avalonia.Media.Immutable.ImmutableTransform? transform, Avalonia.RelativePoint? transformOrigin, Avalonia.Media.GradientSpreadMethod spreadMethod) { }
        public System.Collections.Generic.IReadOnlyList<Avalonia.Media.IGradientStop> GradientStops { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double Opacity { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.GradientSpreadMethod SpreadMethod { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.ITransform? Transform { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.RelativePoint TransformOrigin { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class ImmutableGradientStop : Avalonia.Media.IGradientStop
    {
        public ImmutableGradientStop(double offset, Avalonia.Media.Color color) { }
        public Avalonia.Media.Color Color { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double Offset { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class ImmutableLinearGradientBrush : Avalonia.Media.Immutable.ImmutableGradientBrush, Avalonia.Media.IBrush, Avalonia.Media.IGradientBrush, Avalonia.Media.ILinearGradientBrush
    {
        public ImmutableLinearGradientBrush(Avalonia.Media.LinearGradientBrush source) : base (default(System.Collections.Generic.IReadOnlyList<Avalonia.Media.Immutable.ImmutableGradientStop>), default(double), default(Avalonia.Media.Immutable.ImmutableTransform), default(Avalonia.RelativePoint?), default(Avalonia.Media.GradientSpreadMethod)) { }
        public ImmutableLinearGradientBrush(System.Collections.Generic.IReadOnlyList<Avalonia.Media.Immutable.ImmutableGradientStop> gradientStops, double opacity = 1, Avalonia.Media.Immutable.ImmutableTransform? transform = null, Avalonia.RelativePoint? transformOrigin = default(Avalonia.RelativePoint?), Avalonia.Media.GradientSpreadMethod spreadMethod = Avalonia.Media.GradientSpreadMethod.Pad, Avalonia.RelativePoint? startPoint = default(Avalonia.RelativePoint?), Avalonia.RelativePoint? endPoint = default(Avalonia.RelativePoint?)) : base (default(System.Collections.Generic.IReadOnlyList<Avalonia.Media.Immutable.ImmutableGradientStop>), default(double), default(Avalonia.Media.Immutable.ImmutableTransform), default(Avalonia.RelativePoint?), default(Avalonia.Media.GradientSpreadMethod)) { }
        public Avalonia.RelativePoint EndPoint { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.RelativePoint StartPoint { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class ImmutablePen : Avalonia.Media.IPen, System.IEquatable<Avalonia.Media.IPen>
    {
        public ImmutablePen(Avalonia.Media.IImmutableBrush? brush, double thickness = 1, Avalonia.Media.Immutable.ImmutableDashStyle? dashStyle = null, Avalonia.Media.PenLineCap lineCap = Avalonia.Media.PenLineCap.Flat, Avalonia.Media.PenLineJoin lineJoin = Avalonia.Media.PenLineJoin.Miter, double miterLimit = 10) { }
        public ImmutablePen(uint color, double thickness = 1, Avalonia.Media.Immutable.ImmutableDashStyle? dashStyle = null, Avalonia.Media.PenLineCap lineCap = Avalonia.Media.PenLineCap.Flat, Avalonia.Media.PenLineJoin lineJoin = Avalonia.Media.PenLineJoin.Miter, double miterLimit = 10) { }
        public Avalonia.Media.IBrush? Brush { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.IDashStyle? DashStyle { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.PenLineCap LineCap { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.PenLineJoin LineJoin { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double MiterLimit { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double Thickness { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.Media.IPen? other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    public partial class ImmutableRadialGradientBrush : Avalonia.Media.Immutable.ImmutableGradientBrush, Avalonia.Media.IBrush, Avalonia.Media.IGradientBrush, Avalonia.Media.IRadialGradientBrush
    {
        public ImmutableRadialGradientBrush(Avalonia.Media.RadialGradientBrush source) : base (default(System.Collections.Generic.IReadOnlyList<Avalonia.Media.Immutable.ImmutableGradientStop>), default(double), default(Avalonia.Media.Immutable.ImmutableTransform), default(Avalonia.RelativePoint?), default(Avalonia.Media.GradientSpreadMethod)) { }
        public ImmutableRadialGradientBrush(System.Collections.Generic.IReadOnlyList<Avalonia.Media.Immutable.ImmutableGradientStop> gradientStops, double opacity = 1, Avalonia.Media.Immutable.ImmutableTransform? transform = null, Avalonia.RelativePoint? transformOrigin = default(Avalonia.RelativePoint?), Avalonia.Media.GradientSpreadMethod spreadMethod = Avalonia.Media.GradientSpreadMethod.Pad, Avalonia.RelativePoint? center = default(Avalonia.RelativePoint?), Avalonia.RelativePoint? gradientOrigin = default(Avalonia.RelativePoint?), double radius = 0.5) : base (default(System.Collections.Generic.IReadOnlyList<Avalonia.Media.Immutable.ImmutableGradientStop>), default(double), default(Avalonia.Media.Immutable.ImmutableTransform), default(Avalonia.RelativePoint?), default(Avalonia.Media.GradientSpreadMethod)) { }
        public Avalonia.RelativePoint Center { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.RelativePoint GradientOrigin { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double Radius { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class ImmutableSolidColorBrush : Avalonia.Media.IBrush, Avalonia.Media.IImmutableBrush, Avalonia.Media.IImmutableSolidColorBrush, Avalonia.Media.ISolidColorBrush, System.IEquatable<Avalonia.Media.Immutable.ImmutableSolidColorBrush>
    {
        public ImmutableSolidColorBrush(Avalonia.Media.Color color, double opacity = 1, Avalonia.Media.Immutable.ImmutableTransform? transform = null) { }
        public ImmutableSolidColorBrush(Avalonia.Media.ISolidColorBrush source) { }
        public ImmutableSolidColorBrush(uint color) { }
        public Avalonia.Media.Color Color { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double Opacity { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.ITransform? Transform { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.RelativePoint TransformOrigin { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.Media.Immutable.ImmutableSolidColorBrush? other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Media.Immutable.ImmutableSolidColorBrush left, Avalonia.Media.Immutable.ImmutableSolidColorBrush right) { throw null; }
        public static bool operator !=(Avalonia.Media.Immutable.ImmutableSolidColorBrush left, Avalonia.Media.Immutable.ImmutableSolidColorBrush right) { throw null; }
        public override string ToString() { throw null; }
    }
    public partial class ImmutableTextDecoration
    {
        public ImmutableTextDecoration(Avalonia.Media.TextDecorationLocation location, Avalonia.Media.Immutable.ImmutablePen pen, Avalonia.Media.TextDecorationUnit penThicknessUnit, double penOffset, Avalonia.Media.TextDecorationUnit penOffsetUnit) { }
        public Avalonia.Media.TextDecorationLocation Location { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.Immutable.ImmutablePen Pen { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double PenOffset { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.TextDecorationUnit PenOffsetUnit { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.TextDecorationUnit PenThicknessUnit { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public abstract partial class ImmutableTileBrush : Avalonia.Media.IBrush, Avalonia.Media.IImmutableBrush, Avalonia.Media.ITileBrush
    {
        protected ImmutableTileBrush(Avalonia.Media.ITileBrush source) { }
        public Avalonia.Media.AlignmentX AlignmentX { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.AlignmentY AlignmentY { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.RelativeRect DestinationRect { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double Opacity { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.RelativeRect SourceRect { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.Stretch Stretch { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.TileMode TileMode { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.ITransform? Transform { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.RelativePoint TransformOrigin { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class ImmutableTransform : Avalonia.Media.ITransform
    {
        public ImmutableTransform(Avalonia.Matrix matrix) { }
        public Avalonia.Matrix Value { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
}
namespace Avalonia.Media.TextFormatting
{
    public abstract partial class DrawableTextRun : Avalonia.Media.TextFormatting.TextRun
    {
        protected DrawableTextRun() { }
        public abstract double Baseline { get; }
        public abstract Avalonia.Size Size { get; }
        public abstract void Draw(Avalonia.Media.DrawingContext drawingContext, Avalonia.Point origin);
    }
    public sealed partial class GenericTextParagraphProperties : Avalonia.Media.TextFormatting.TextParagraphProperties
    {
        public GenericTextParagraphProperties(Avalonia.Media.FlowDirection flowDirection, Avalonia.Media.TextAlignment textAlignment, bool firstLineInParagraph, bool alwaysCollapsible, Avalonia.Media.TextFormatting.TextRunProperties defaultTextRunProperties, Avalonia.Media.TextWrapping textWrap, double lineHeight, double indent, double letterSpacing) { }
        public GenericTextParagraphProperties(Avalonia.Media.TextFormatting.TextParagraphProperties textParagraphProperties) { }
        public GenericTextParagraphProperties(Avalonia.Media.TextFormatting.TextRunProperties defaultTextRunProperties, Avalonia.Media.TextAlignment textAlignment = Avalonia.Media.TextAlignment.Left, Avalonia.Media.TextWrapping textWrap = Avalonia.Media.TextWrapping.NoWrap, double lineHeight = 0, double letterSpacing = 0) { }
        public override bool AlwaysCollapsible { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override Avalonia.Media.TextFormatting.TextRunProperties DefaultTextRunProperties { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override bool FirstLineInParagraph { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override Avalonia.Media.FlowDirection FlowDirection { get { throw null; } }
        public override double Indent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override double LetterSpacing { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override double LineHeight { get { throw null; } }
        public override Avalonia.Media.TextAlignment TextAlignment { get { throw null; } }
        public override Avalonia.Media.TextWrapping TextWrapping { get { throw null; } }
    }
    public partial class GenericTextRunProperties : Avalonia.Media.TextFormatting.TextRunProperties
    {
        public GenericTextRunProperties(Avalonia.Media.Typeface typeface, double fontRenderingEmSize = 12, Avalonia.Media.TextDecorationCollection? textDecorations = null, Avalonia.Media.IBrush? foregroundBrush = null, Avalonia.Media.IBrush? backgroundBrush = null, Avalonia.Media.BaselineAlignment baselineAlignment = Avalonia.Media.BaselineAlignment.Baseline, System.Globalization.CultureInfo? cultureInfo = null) { }
        public override Avalonia.Media.IBrush? BackgroundBrush { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override Avalonia.Media.BaselineAlignment BaselineAlignment { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override System.Globalization.CultureInfo? CultureInfo { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override double FontRenderingEmSize { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override Avalonia.Media.IBrush? ForegroundBrush { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override Avalonia.Media.TextDecorationCollection? TextDecorations { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override Avalonia.Media.Typeface Typeface { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct GlyphInfo : System.IEquatable<Avalonia.Media.TextFormatting.GlyphInfo>
    {
        private readonly int _dummyPrimitive;
        public GlyphInfo(ushort GlyphIndex, int GlyphCluster, double GlyphAdvance, Avalonia.Vector GlyphOffset = default(Avalonia.Vector)) { throw null; }
        public double GlyphAdvance { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int GlyphCluster { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public ushort GlyphIndex { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Vector GlyphOffset { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public void Deconstruct(out ushort GlyphIndex, out int GlyphCluster, out double GlyphAdvance, out Avalonia.Vector GlyphOffset) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.TextFormatting.GlyphInfo other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.TextFormatting.GlyphInfo left, Avalonia.Media.TextFormatting.GlyphInfo right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.TextFormatting.GlyphInfo left, Avalonia.Media.TextFormatting.GlyphInfo right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public partial interface ITextSource
    {
        Avalonia.Media.TextFormatting.TextRun? GetTextRun(int textSourceIndex);
    }
    public abstract partial class JustificationProperties
    {
        protected JustificationProperties() { }
        public abstract double Width { get; }
        public abstract void Justify(Avalonia.Media.TextFormatting.TextLine textLine);
    }
    public enum LogicalDirection
    {
        Backward = 0,
        Forward = 1,
    }
    public sealed partial class ShapedBuffer : System.Collections.Generic.IEnumerable<Avalonia.Media.TextFormatting.GlyphInfo>, System.Collections.Generic.IReadOnlyCollection<Avalonia.Media.TextFormatting.GlyphInfo>, System.Collections.Generic.IReadOnlyList<Avalonia.Media.TextFormatting.GlyphInfo>, System.Collections.IEnumerable, System.IDisposable
    {
        public ShapedBuffer(System.ReadOnlyMemory<char> text, int bufferLength, Avalonia.Media.IGlyphTypeface glyphTypeface, double fontRenderingEmSize, sbyte bidiLevel) { }
        public sbyte BidiLevel { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double FontRenderingEmSize { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.IGlyphTypeface GlyphTypeface { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsLeftToRight { get { throw null; } }
        public Avalonia.Media.TextFormatting.GlyphInfo this[int index] { [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]get { throw null; } [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]set { } }
        public int Length { get { throw null; } }
        int System.Collections.Generic.IReadOnlyCollection<Avalonia.Media.TextFormatting.GlyphInfo>.Count { get { throw null; } }
        public System.ReadOnlyMemory<char> Text { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public void Dispose() { }
        public System.Collections.Generic.IEnumerator<Avalonia.Media.TextFormatting.GlyphInfo> GetEnumerator() { throw null; }
        public void Reverse() { }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
    }
    public sealed partial class ShapedTextRun : Avalonia.Media.TextFormatting.DrawableTextRun, System.IDisposable
    {
        public ShapedTextRun(Avalonia.Media.TextFormatting.ShapedBuffer shapedBuffer, Avalonia.Media.TextFormatting.TextRunProperties properties) { }
        public override double Baseline { get { throw null; } }
        public sbyte BidiLevel { get { throw null; } }
        public Avalonia.Media.GlyphRun GlyphRun { get { throw null; } }
        public bool IsReversed { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override int Length { get { throw null; } }
        public override Avalonia.Media.TextFormatting.TextRunProperties Properties { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.TextFormatting.ShapedBuffer ShapedBuffer { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override Avalonia.Size Size { get { throw null; } }
        public override System.ReadOnlyMemory<char> Text { get { throw null; } }
        public Avalonia.Media.TextFormatting.TextMetrics TextMetrics { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public void Dispose() { }
        public override void Draw(Avalonia.Media.DrawingContext drawingContext, Avalonia.Point origin) { }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct SplitResult<T>
    {
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        private readonly T _First_k__BackingField;
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        private readonly T _Second_k__BackingField;
        public SplitResult(T first, T? second) { throw null; }
        public T First { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public T? Second { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public void Deconstruct(out T first, out T? second) { throw null; }
    }
    public sealed partial class TextBounds
    {
        internal TextBounds() { }
        public Avalonia.Media.FlowDirection FlowDirection { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Rect Rectangle { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.Collections.Generic.IList<Avalonia.Media.TextFormatting.TextRunBounds> TextRunBounds { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class TextCharacters : Avalonia.Media.TextFormatting.TextRun
    {
        public TextCharacters(System.ReadOnlyMemory<char> text, Avalonia.Media.TextFormatting.TextRunProperties textRunProperties) { }
        public TextCharacters(string text, Avalonia.Media.TextFormatting.TextRunProperties textRunProperties) { }
        public override int Length { get { throw null; } }
        public override Avalonia.Media.TextFormatting.TextRunProperties Properties { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override System.ReadOnlyMemory<char> Text { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public abstract partial class TextCollapsingProperties
    {
        protected TextCollapsingProperties() { }
        public abstract Avalonia.Media.FlowDirection FlowDirection { get; }
        public abstract Avalonia.Media.TextFormatting.TextRun Symbol { get; }
        public abstract double Width { get; }
        public abstract Avalonia.Media.TextFormatting.TextRun[]? Collapse(Avalonia.Media.TextFormatting.TextLine textLine);
    }
    public partial class TextEndOfLine : Avalonia.Media.TextFormatting.TextRun
    {
        public TextEndOfLine(int textSourceLength = 1) { }
        public override int Length { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class TextEndOfParagraph : Avalonia.Media.TextFormatting.TextEndOfLine
    {
        public TextEndOfParagraph() : base (default(int)) { }
        public TextEndOfParagraph(int textSourceLength) : base (default(int)) { }
    }
    public abstract partial class TextFormatter
    {
        protected TextFormatter() { }
        public static Avalonia.Media.TextFormatting.TextFormatter Current { get { throw null; } }
        public abstract Avalonia.Media.TextFormatting.TextLine? FormatLine(Avalonia.Media.TextFormatting.ITextSource textSource, int firstTextSourceIndex, double paragraphWidth, Avalonia.Media.TextFormatting.TextParagraphProperties paragraphProperties, Avalonia.Media.TextFormatting.TextLineBreak? previousLineBreak = null);
    }
    public partial class TextLayout : System.IDisposable
    {
        public TextLayout(Avalonia.Media.TextFormatting.ITextSource textSource, Avalonia.Media.TextFormatting.TextParagraphProperties paragraphProperties, Avalonia.Media.TextTrimming? textTrimming = null, double maxWidth = 1.0 / 0.0, double maxHeight = 1.0 / 0.0, int maxLines = 0) { }
        public TextLayout(string? text, Avalonia.Media.Typeface typeface, double fontSize, Avalonia.Media.IBrush? foreground, Avalonia.Media.TextAlignment textAlignment = Avalonia.Media.TextAlignment.Left, Avalonia.Media.TextWrapping textWrapping = Avalonia.Media.TextWrapping.NoWrap, Avalonia.Media.TextTrimming? textTrimming = null, Avalonia.Media.TextDecorationCollection? textDecorations = null, Avalonia.Media.FlowDirection flowDirection = Avalonia.Media.FlowDirection.LeftToRight, double maxWidth = 1.0 / 0.0, double maxHeight = 1.0 / 0.0, double lineHeight = 0.0 / 0.0, double letterSpacing = 0, int maxLines = 0, System.Collections.Generic.IReadOnlyList<Avalonia.Utilities.ValueSpan<Avalonia.Media.TextFormatting.TextRunProperties>>? textStyleOverrides = null) { }
        public double Baseline { get { throw null; } }
        public double Extent { get { throw null; } }
        public double Height { get { throw null; } }
        public double LetterSpacing { get { throw null; } }
        public double LineHeight { get { throw null; } }
        public double MaxHeight { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int MaxLines { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double MaxWidth { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double OverhangAfter { get { throw null; } }
        public double OverhangLeading { get { throw null; } }
        public double OverhangTrailing { get { throw null; } }
        public System.Collections.Generic.IReadOnlyList<Avalonia.Media.TextFormatting.TextLine> TextLines { get { throw null; } }
        public double Width { get { throw null; } }
        public double WidthIncludingTrailingWhitespace { get { throw null; } }
        public void Dispose() { }
        public void Draw(Avalonia.Media.DrawingContext context, Avalonia.Point origin) { }
        public int GetLineIndexFromCharacterIndex(int charIndex, bool trailingEdge) { throw null; }
        public Avalonia.Media.TextHitTestResult HitTestPoint(in Avalonia.Point point) { throw null; }
        public Avalonia.Rect HitTestTextPosition(int textPosition) { throw null; }
        public System.Collections.Generic.IEnumerable<Avalonia.Rect> HitTestTextRange(int start, int length) { throw null; }
    }
    public sealed partial class TextLeadingPrefixCharacterEllipsis : Avalonia.Media.TextFormatting.TextCollapsingProperties
    {
        public TextLeadingPrefixCharacterEllipsis(string ellipsis, int prefixLength, double width, Avalonia.Media.TextFormatting.TextRunProperties textRunProperties, Avalonia.Media.FlowDirection flowDirection) { }
        public override Avalonia.Media.FlowDirection FlowDirection { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override Avalonia.Media.TextFormatting.TextRun Symbol { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override double Width { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override Avalonia.Media.TextFormatting.TextRun[]? Collapse(Avalonia.Media.TextFormatting.TextLine textLine) { throw null; }
    }
    public abstract partial class TextLine : System.IDisposable
    {
        protected TextLine() { }
        public abstract double Baseline { get; }
        public abstract double Extent { get; }
        public abstract int FirstTextSourceIndex { get; }
        public abstract bool HasCollapsed { get; }
        public abstract bool HasOverflowed { get; }
        public abstract double Height { get; }
        public abstract int Length { get; }
        public abstract int NewLineLength { get; }
        public abstract double OverhangAfter { get; }
        public abstract double OverhangLeading { get; }
        public abstract double OverhangTrailing { get; }
        public abstract double Start { get; }
        public abstract Avalonia.Media.TextFormatting.TextLineBreak? TextLineBreak { get; }
        public abstract System.Collections.Generic.IReadOnlyList<Avalonia.Media.TextFormatting.TextRun> TextRuns { get; }
        public abstract int TrailingWhitespaceLength { get; }
        public abstract double Width { get; }
        public abstract double WidthIncludingTrailingWhitespace { get; }
        public abstract Avalonia.Media.TextFormatting.TextLine Collapse(params Avalonia.Media.TextFormatting.TextCollapsingProperties?[] collapsingPropertiesList);
        public abstract void Dispose();
        public abstract void Draw(Avalonia.Media.DrawingContext drawingContext, Avalonia.Point lineOrigin);
        public abstract Avalonia.Media.CharacterHit GetBackspaceCaretCharacterHit(Avalonia.Media.CharacterHit characterHit);
        public abstract Avalonia.Media.CharacterHit GetCharacterHitFromDistance(double distance);
        public abstract double GetDistanceFromCharacterHit(Avalonia.Media.CharacterHit characterHit);
        public abstract Avalonia.Media.CharacterHit GetNextCaretCharacterHit(Avalonia.Media.CharacterHit characterHit);
        public abstract Avalonia.Media.CharacterHit GetPreviousCaretCharacterHit(Avalonia.Media.CharacterHit characterHit);
        public abstract System.Collections.Generic.IReadOnlyList<Avalonia.Media.TextFormatting.TextBounds> GetTextBounds(int firstTextSourceCharacterIndex, int textLength);
        public abstract void Justify(Avalonia.Media.TextFormatting.JustificationProperties justificationProperties);
    }
    public partial class TextLineBreak
    {
        public TextLineBreak(Avalonia.Media.TextFormatting.TextEndOfLine? textEndOfLine = null, Avalonia.Media.FlowDirection flowDirection = Avalonia.Media.FlowDirection.LeftToRight, bool isSplit = false) { }
        public Avalonia.Media.FlowDirection FlowDirection { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsSplit { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.TextFormatting.TextEndOfLine? TextEndOfLine { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TextLineMetrics : System.IEquatable<Avalonia.Media.TextFormatting.TextLineMetrics>
    {
        private readonly int _dummyPrimitive;
        public double Extent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public bool HasOverflowed { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public double Height { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int NewlineLength { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public double OverhangAfter { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public double OverhangLeading { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public double OverhangTrailing { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public double Start { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public double TextBaseline { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int TrailingWhitespaceLength { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public double Width { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public double WidthIncludingTrailingWhitespace { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.TextFormatting.TextLineMetrics other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.TextFormatting.TextLineMetrics left, Avalonia.Media.TextFormatting.TextLineMetrics right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.TextFormatting.TextLineMetrics left, Avalonia.Media.TextFormatting.TextLineMetrics right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TextMetrics : System.IEquatable<Avalonia.Media.TextFormatting.TextMetrics>
    {
        private readonly int _dummyPrimitive;
        public TextMetrics(Avalonia.Media.IGlyphTypeface glyphTypeface, double fontRenderingEmSize) { throw null; }
        public double Ascent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double Descent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double FontRenderingEmSize { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double LineGap { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double LineHeight { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double StrikethroughPosition { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double StrikethroughThickness { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double UnderlinePosition { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double UnderlineThickness { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.TextFormatting.TextMetrics other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.TextFormatting.TextMetrics left, Avalonia.Media.TextFormatting.TextMetrics right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.TextFormatting.TextMetrics left, Avalonia.Media.TextFormatting.TextMetrics right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public abstract partial class TextParagraphProperties
    {
        protected TextParagraphProperties() { }
        public virtual bool AlwaysCollapsible { get { throw null; } }
        public virtual double DefaultIncrementalTab { get { throw null; } }
        public abstract Avalonia.Media.TextFormatting.TextRunProperties DefaultTextRunProperties { get; }
        public abstract bool FirstLineInParagraph { get; }
        public abstract Avalonia.Media.FlowDirection FlowDirection { get; }
        public abstract double Indent { get; }
        public virtual double LetterSpacing { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public abstract double LineHeight { get; }
        public virtual double ParagraphIndent { get { throw null; } }
        public abstract Avalonia.Media.TextAlignment TextAlignment { get; }
        public virtual Avalonia.Media.TextDecorationCollection? TextDecorations { get { throw null; } }
        public abstract Avalonia.Media.TextWrapping TextWrapping { get; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TextRange : System.IEquatable<Avalonia.Media.TextFormatting.TextRange>
    {
        private readonly int _dummyPrimitive;
        public TextRange(int start, int length) { throw null; }
        public int End { get { throw null; } }
        public int Length { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int Start { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.TextFormatting.TextRange other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.TextFormatting.TextRange left, Avalonia.Media.TextFormatting.TextRange right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.TextFormatting.TextRange left, Avalonia.Media.TextFormatting.TextRange right) { throw null; }
        public Avalonia.Media.TextFormatting.TextRange Skip(int length) { throw null; }
        public Avalonia.Media.TextFormatting.TextRange Take(int length) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public abstract partial class TextRun
    {
        public const int DefaultTextSourceLength = 1;
        protected TextRun() { }
        public virtual int Length { get { throw null; } }
        public virtual Avalonia.Media.TextFormatting.TextRunProperties? Properties { get { throw null; } }
        public virtual System.ReadOnlyMemory<char> Text { get { throw null; } }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TextRunBounds : System.IEquatable<Avalonia.Media.TextFormatting.TextRunBounds>
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public int Length { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Rect Rectangle { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.TextFormatting.TextRun TextRun { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int TextSourceCharacterIndex { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.TextFormatting.TextRunBounds other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.TextFormatting.TextRunBounds left, Avalonia.Media.TextFormatting.TextRunBounds right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.TextFormatting.TextRunBounds left, Avalonia.Media.TextFormatting.TextRunBounds right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public abstract partial class TextRunProperties : System.IEquatable<Avalonia.Media.TextFormatting.TextRunProperties>
    {
        protected TextRunProperties() { }
        public abstract Avalonia.Media.IBrush? BackgroundBrush { get; }
        public virtual Avalonia.Media.BaselineAlignment BaselineAlignment { get { throw null; } }
        public abstract System.Globalization.CultureInfo? CultureInfo { get; }
        public abstract double FontRenderingEmSize { get; }
        public abstract Avalonia.Media.IBrush? ForegroundBrush { get; }
        public abstract Avalonia.Media.TextDecorationCollection? TextDecorations { get; }
        public abstract Avalonia.Media.Typeface Typeface { get; }
        public bool Equals(Avalonia.Media.TextFormatting.TextRunProperties? other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Media.TextFormatting.TextRunProperties left, Avalonia.Media.TextFormatting.TextRunProperties right) { throw null; }
        public static bool operator !=(Avalonia.Media.TextFormatting.TextRunProperties left, Avalonia.Media.TextFormatting.TextRunProperties right) { throw null; }
    }
    public partial class TextShaper
    {
        public TextShaper(Avalonia.Platform.ITextShaperImpl platformImpl) { }
        public static Avalonia.Media.TextFormatting.TextShaper Current { get { throw null; } }
        public Avalonia.Media.TextFormatting.ShapedBuffer ShapeText(System.ReadOnlyMemory<char> text, Avalonia.Media.TextFormatting.TextShaperOptions options = default(Avalonia.Media.TextFormatting.TextShaperOptions)) { throw null; }
        public Avalonia.Media.TextFormatting.ShapedBuffer ShapeText(string text, Avalonia.Media.TextFormatting.TextShaperOptions options = default(Avalonia.Media.TextFormatting.TextShaperOptions)) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TextShaperOptions : System.IEquatable<Avalonia.Media.TextFormatting.TextShaperOptions>
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public TextShaperOptions(Avalonia.Media.IGlyphTypeface typeface, double fontRenderingEmSize = 12, sbyte bidiLevel = (sbyte)0, System.Globalization.CultureInfo? culture = null, double incrementalTabWidth = 0, double letterSpacing = 0) { throw null; }
        public sbyte BidiLevel { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.Globalization.CultureInfo? Culture { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double FontRenderingEmSize { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double IncrementalTabWidth { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public double LetterSpacing { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Media.IGlyphTypeface Typeface { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.TextFormatting.TextShaperOptions other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.TextFormatting.TextShaperOptions left, Avalonia.Media.TextFormatting.TextShaperOptions right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.TextFormatting.TextShaperOptions left, Avalonia.Media.TextFormatting.TextShaperOptions right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public sealed partial class TextTrailingCharacterEllipsis : Avalonia.Media.TextFormatting.TextCollapsingProperties
    {
        public TextTrailingCharacterEllipsis(string ellipsis, double width, Avalonia.Media.TextFormatting.TextRunProperties textRunProperties, Avalonia.Media.FlowDirection flowDirection) { }
        public override Avalonia.Media.FlowDirection FlowDirection { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override Avalonia.Media.TextFormatting.TextRun Symbol { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override double Width { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override Avalonia.Media.TextFormatting.TextRun[]? Collapse(Avalonia.Media.TextFormatting.TextLine textLine) { throw null; }
    }
    public sealed partial class TextTrailingWordEllipsis : Avalonia.Media.TextFormatting.TextCollapsingProperties
    {
        public TextTrailingWordEllipsis(string ellipsis, double width, Avalonia.Media.TextFormatting.TextRunProperties textRunProperties, Avalonia.Media.FlowDirection flowDirection) { }
        public override Avalonia.Media.FlowDirection FlowDirection { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override Avalonia.Media.TextFormatting.TextRun Symbol { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override double Width { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override Avalonia.Media.TextFormatting.TextRun[]? Collapse(Avalonia.Media.TextFormatting.TextLine textLine) { throw null; }
    }
    public sealed partial class UnshapedTextRun : Avalonia.Media.TextFormatting.TextRun
    {
        public UnshapedTextRun(System.ReadOnlyMemory<char> text, Avalonia.Media.TextFormatting.TextRunProperties properties, sbyte biDiLevel) { }
        public sbyte BidiLevel { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override int Length { get { throw null; } }
        public override Avalonia.Media.TextFormatting.TextRunProperties Properties { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public override System.ReadOnlyMemory<char> Text { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
}
namespace Avalonia.Media.TextFormatting.Unicode
{
    public enum BidiClass
    {
        LeftToRight = 0,
        ArabicLetter = 1,
        ArabicNumber = 2,
        ParagraphSeparator = 3,
        BoundaryNeutral = 4,
        CommonSeparator = 5,
        EuropeanNumber = 6,
        EuropeanSeparator = 7,
        EuropeanTerminator = 8,
        FirstStrongIsolate = 9,
        LeftToRightEmbedding = 10,
        LeftToRightIsolate = 11,
        LeftToRightOverride = 12,
        NonspacingMark = 13,
        OtherNeutral = 14,
        PopDirectionalFormat = 15,
        PopDirectionalIsolate = 16,
        RightToLeft = 17,
        RightToLeftEmbedding = 18,
        RightToLeftIsolate = 19,
        RightToLeftOverride = 20,
        SegmentSeparator = 21,
        WhiteSpace = 22,
    }
    public enum BidiPairedBracketType
    {
        None = 0,
        Close = 1,
        Open = 2,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct Codepoint : System.IEquatable<Avalonia.Media.TextFormatting.Unicode.Codepoint>
    {
        private readonly int _dummyPrimitive;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public Codepoint(uint value) { throw null; }
        public Avalonia.Media.TextFormatting.Unicode.BidiClass BiDiClass { get { throw null; } }
        public Avalonia.Media.TextFormatting.Unicode.GeneralCategory GeneralCategory { get { throw null; } }
        public Avalonia.Media.TextFormatting.Unicode.GraphemeBreakClass GraphemeBreakClass { get { throw null; } }
        public bool IsBreakChar { get { throw null; } }
        public bool IsWhiteSpace { [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]get { throw null; } }
        public Avalonia.Media.TextFormatting.Unicode.LineBreakClass LineBreakClass { get { throw null; } }
        public Avalonia.Media.TextFormatting.Unicode.BidiPairedBracketType PairedBracketType { get { throw null; } }
        public static Avalonia.Media.TextFormatting.Unicode.Codepoint ReplacementCodepoint { [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]get { throw null; } }
        public Avalonia.Media.TextFormatting.Unicode.Script Script { get { throw null; } }
        public uint Value { get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.TextFormatting.Unicode.Codepoint other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public static bool IsInRangeInclusive(Avalonia.Media.TextFormatting.Unicode.Codepoint cp, uint lowerBound, uint upperBound) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.TextFormatting.Unicode.Codepoint left, Avalonia.Media.TextFormatting.Unicode.Codepoint right) { throw null; }
        public static implicit operator int (Avalonia.Media.TextFormatting.Unicode.Codepoint codepoint) { throw null; }
        public static implicit operator uint (Avalonia.Media.TextFormatting.Unicode.Codepoint codepoint) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.TextFormatting.Unicode.Codepoint left, Avalonia.Media.TextFormatting.Unicode.Codepoint right) { throw null; }
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public static Avalonia.Media.TextFormatting.Unicode.Codepoint ReadAt(System.ReadOnlySpan<char> text, int index, out int count) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public bool TryGetPairedBracket(out Avalonia.Media.TextFormatting.Unicode.Codepoint codepoint) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public ref partial struct CodepointEnumerator
    {
        private object _dummy;
        private int _dummyPrimitive;
        public CodepointEnumerator(System.ReadOnlySpan<char> text) { throw null; }
        public bool MoveNext(out Avalonia.Media.TextFormatting.Unicode.Codepoint codepoint) { throw null; }
    }
    public enum GeneralCategory
    {
        Other = 0,
        Control = 1,
        Format = 2,
        Unassigned = 3,
        PrivateUse = 4,
        Surrogate = 5,
        Letter = 6,
        CasedLetter = 7,
        LowercaseLetter = 8,
        ModifierLetter = 9,
        OtherLetter = 10,
        TitlecaseLetter = 11,
        UppercaseLetter = 12,
        Mark = 13,
        SpacingMark = 14,
        EnclosingMark = 15,
        NonspacingMark = 16,
        Number = 17,
        DecimalNumber = 18,
        LetterNumber = 19,
        OtherNumber = 20,
        Punctuation = 21,
        ConnectorPunctuation = 22,
        DashPunctuation = 23,
        ClosePunctuation = 24,
        FinalPunctuation = 25,
        InitialPunctuation = 26,
        OtherPunctuation = 27,
        OpenPunctuation = 28,
        Symbol = 29,
        CurrencySymbol = 30,
        ModifierSymbol = 31,
        MathSymbol = 32,
        OtherSymbol = 33,
        Separator = 34,
        LineSeparator = 35,
        ParagraphSeparator = 36,
        SpaceSeparator = 37,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly ref partial struct Grapheme
    {
        private readonly int _dummyPrimitive;
        public Grapheme(Avalonia.Media.TextFormatting.Unicode.Codepoint firstCodepoint, int offset, int length) { throw null; }
        public Avalonia.Media.TextFormatting.Unicode.Codepoint FirstCodepoint { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int Length { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int Offset { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public enum GraphemeBreakClass
    {
        Other = 0,
        Control = 1,
        CR = 2,
        EBase = 3,
        EBaseGAZ = 4,
        EModifier = 5,
        Extend = 6,
        GlueAfterZwj = 7,
        L = 8,
        LF = 9,
        LV = 10,
        LVT = 11,
        Prepend = 12,
        RegionalIndicator = 13,
        SpacingMark = 14,
        T = 15,
        V = 16,
        ZWJ = 17,
        ExtendedPictographic = 18,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public ref partial struct GraphemeEnumerator
    {
        private object _dummy;
        private int _dummyPrimitive;
        public GraphemeEnumerator(System.ReadOnlySpan<char> text) { throw null; }
        public bool MoveNext(out Avalonia.Media.TextFormatting.Unicode.Grapheme grapheme) { throw null; }
    }
    [System.Diagnostics.DebuggerDisplayAttribute("{PositionMeasure}/{PositionWrap} @ {Required}")]
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct LineBreak : System.IEquatable<Avalonia.Media.TextFormatting.Unicode.LineBreak>
    {
        private readonly int _dummyPrimitive;
        public LineBreak(int positionMeasure, int positionWrap, bool required = false) { throw null; }
        public int PositionMeasure { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int PositionWrap { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Required { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.TextFormatting.Unicode.LineBreak other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.TextFormatting.Unicode.LineBreak left, Avalonia.Media.TextFormatting.Unicode.LineBreak right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.TextFormatting.Unicode.LineBreak left, Avalonia.Media.TextFormatting.Unicode.LineBreak right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public enum LineBreakClass
    {
        OpenPunctuation = 0,
        ClosePunctuation = 1,
        CloseParenthesis = 2,
        Quotation = 3,
        Glue = 4,
        Nonstarter = 5,
        Exclamation = 6,
        BreakSymbols = 7,
        InfixNumeric = 8,
        PrefixNumeric = 9,
        PostfixNumeric = 10,
        Numeric = 11,
        Alphabetic = 12,
        HebrewLetter = 13,
        Ideographic = 14,
        Inseparable = 15,
        Hyphen = 16,
        BreakAfter = 17,
        BreakBefore = 18,
        BreakBoth = 19,
        ZWSpace = 20,
        CombiningMark = 21,
        WordJoiner = 22,
        H2 = 23,
        H3 = 24,
        JL = 25,
        JV = 26,
        JT = 27,
        RegionalIndicator = 28,
        EBase = 29,
        EModifier = 30,
        ZWJ = 31,
        ContingentBreak = 32,
        Unknown = 33,
        Ambiguous = 34,
        MandatoryBreak = 35,
        ConditionalJapaneseStarter = 36,
        CarriageReturn = 37,
        LineFeed = 38,
        NextLine = 39,
        ComplexContext = 40,
        Surrogate = 41,
        Space = 42,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public ref partial struct LineBreakEnumerator
    {
        private object _dummy;
        private int _dummyPrimitive;
        public LineBreakEnumerator(System.ReadOnlySpan<char> text) { throw null; }
        public bool MoveNext(out Avalonia.Media.TextFormatting.Unicode.LineBreak lineBreak) { throw null; }
    }
    public enum Script
    {
        Unknown = 0,
        Common = 1,
        Inherited = 2,
        Adlam = 3,
        CaucasianAlbanian = 4,
        Ahom = 5,
        Arabic = 6,
        ImperialAramaic = 7,
        Armenian = 8,
        Avestan = 9,
        Balinese = 10,
        Bamum = 11,
        BassaVah = 12,
        Batak = 13,
        Bengali = 14,
        Bhaiksuki = 15,
        Bopomofo = 16,
        Brahmi = 17,
        Braille = 18,
        Buginese = 19,
        Buhid = 20,
        Chakma = 21,
        CanadianAboriginal = 22,
        Carian = 23,
        Cham = 24,
        Cherokee = 25,
        Chorasmian = 26,
        Coptic = 27,
        CyproMinoan = 28,
        Cypriot = 29,
        Cyrillic = 30,
        Devanagari = 31,
        DivesAkuru = 32,
        Dogra = 33,
        Deseret = 34,
        Duployan = 35,
        EgyptianHieroglyphs = 36,
        Elbasan = 37,
        Elymaic = 38,
        Ethiopic = 39,
        Georgian = 40,
        Glagolitic = 41,
        GunjalaGondi = 42,
        MasaramGondi = 43,
        Gothic = 44,
        Grantha = 45,
        Greek = 46,
        Gujarati = 47,
        Gurmukhi = 48,
        Hangul = 49,
        Han = 50,
        Hanunoo = 51,
        Hatran = 52,
        Hebrew = 53,
        Hiragana = 54,
        AnatolianHieroglyphs = 55,
        PahawhHmong = 56,
        NyiakengPuachueHmong = 57,
        KatakanaOrHiragana = 58,
        OldHungarian = 59,
        OldItalic = 60,
        Javanese = 61,
        KayahLi = 62,
        Katakana = 63,
        Kawi = 64,
        Kharoshthi = 65,
        Khmer = 66,
        Khojki = 67,
        KhitanSmallScript = 68,
        Kannada = 69,
        Kaithi = 70,
        TaiTham = 71,
        Lao = 72,
        Latin = 73,
        Lepcha = 74,
        Limbu = 75,
        LinearA = 76,
        LinearB = 77,
        Lisu = 78,
        Lycian = 79,
        Lydian = 80,
        Mahajani = 81,
        Makasar = 82,
        Mandaic = 83,
        Manichaean = 84,
        Marchen = 85,
        Medefaidrin = 86,
        MendeKikakui = 87,
        MeroiticCursive = 88,
        MeroiticHieroglyphs = 89,
        Malayalam = 90,
        Modi = 91,
        Mongolian = 92,
        Mro = 93,
        MeeteiMayek = 94,
        Multani = 95,
        Myanmar = 96,
        NagMundari = 97,
        Nandinagari = 98,
        OldNorthArabian = 99,
        Nabataean = 100,
        Newa = 101,
        Nko = 102,
        Nushu = 103,
        Ogham = 104,
        OlChiki = 105,
        OldTurkic = 106,
        Oriya = 107,
        Osage = 108,
        Osmanya = 109,
        OldUyghur = 110,
        Palmyrene = 111,
        PauCinHau = 112,
        OldPermic = 113,
        PhagsPa = 114,
        InscriptionalPahlavi = 115,
        PsalterPahlavi = 116,
        Phoenician = 117,
        Miao = 118,
        InscriptionalParthian = 119,
        Rejang = 120,
        HanifiRohingya = 121,
        Runic = 122,
        Samaritan = 123,
        OldSouthArabian = 124,
        Saurashtra = 125,
        SignWriting = 126,
        Shavian = 127,
        Sharada = 128,
        Siddham = 129,
        Khudawadi = 130,
        Sinhala = 131,
        Sogdian = 132,
        OldSogdian = 133,
        SoraSompeng = 134,
        Soyombo = 135,
        Sundanese = 136,
        SylotiNagri = 137,
        Syriac = 138,
        Tagbanwa = 139,
        Takri = 140,
        TaiLe = 141,
        NewTaiLue = 142,
        Tamil = 143,
        Tangut = 144,
        TaiViet = 145,
        Telugu = 146,
        Tifinagh = 147,
        Tagalog = 148,
        Thaana = 149,
        Thai = 150,
        Tibetan = 151,
        Tirhuta = 152,
        Tangsa = 153,
        Toto = 154,
        Ugaritic = 155,
        Vai = 156,
        Vithkuqi = 157,
        WarangCiti = 158,
        Wancho = 159,
        OldPersian = 160,
        Cuneiform = 161,
        Yezidi = 162,
        Yi = 163,
        ZanabazarSquare = 164,
    }
}
namespace Avalonia.Media.Transformation
{
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct TransformOperation : System.IEquatable<Avalonia.Media.Transformation.TransformOperation>
    {
        public Avalonia.Media.Transformation.TransformOperation.DataLayout Data;
        public Avalonia.Matrix Matrix;
        public Avalonia.Media.Transformation.TransformOperation.OperationType Type;
        public static Avalonia.Media.Transformation.TransformOperation Identity { get { throw null; } }
        public bool IsIdentity { get { throw null; } }
        public void Bake() { }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Media.Transformation.TransformOperation other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Media.Transformation.TransformOperation left, Avalonia.Media.Transformation.TransformOperation right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Media.Transformation.TransformOperation left, Avalonia.Media.Transformation.TransformOperation right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
        public static bool TryInterpolate(Avalonia.Media.Transformation.TransformOperation? from, Avalonia.Media.Transformation.TransformOperation? to, double progress, ref Avalonia.Media.Transformation.TransformOperation result) { throw null; }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit)]
        public partial struct DataLayout : System.IEquatable<Avalonia.Media.Transformation.TransformOperation.DataLayout>
        {
            [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
            public Avalonia.Media.Transformation.TransformOperation.DataLayout.RotateLayout Rotate;
            [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
            public Avalonia.Media.Transformation.TransformOperation.DataLayout.ScaleLayout Scale;
            [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
            public Avalonia.Media.Transformation.TransformOperation.DataLayout.SkewLayout Skew;
            [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
            public Avalonia.Media.Transformation.TransformOperation.DataLayout.TranslateLayout Translate;
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public bool Equals(Avalonia.Media.Transformation.TransformOperation.DataLayout other) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override bool Equals(object obj) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override int GetHashCode() { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public static bool operator ==(Avalonia.Media.Transformation.TransformOperation.DataLayout left, Avalonia.Media.Transformation.TransformOperation.DataLayout right) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public static bool operator !=(Avalonia.Media.Transformation.TransformOperation.DataLayout left, Avalonia.Media.Transformation.TransformOperation.DataLayout right) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override string ToString() { throw null; }
            [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
            public partial struct RotateLayout : System.IEquatable<Avalonia.Media.Transformation.TransformOperation.DataLayout.RotateLayout>
            {
                public double Angle;
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public bool Equals(Avalonia.Media.Transformation.TransformOperation.DataLayout.RotateLayout other) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public override bool Equals(object obj) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public override int GetHashCode() { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public static bool operator ==(Avalonia.Media.Transformation.TransformOperation.DataLayout.RotateLayout left, Avalonia.Media.Transformation.TransformOperation.DataLayout.RotateLayout right) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public static bool operator !=(Avalonia.Media.Transformation.TransformOperation.DataLayout.RotateLayout left, Avalonia.Media.Transformation.TransformOperation.DataLayout.RotateLayout right) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public override string ToString() { throw null; }
            }
            [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
            public partial struct ScaleLayout : System.IEquatable<Avalonia.Media.Transformation.TransformOperation.DataLayout.ScaleLayout>
            {
                public double X;
                public double Y;
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public bool Equals(Avalonia.Media.Transformation.TransformOperation.DataLayout.ScaleLayout other) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public override bool Equals(object obj) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public override int GetHashCode() { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public static bool operator ==(Avalonia.Media.Transformation.TransformOperation.DataLayout.ScaleLayout left, Avalonia.Media.Transformation.TransformOperation.DataLayout.ScaleLayout right) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public static bool operator !=(Avalonia.Media.Transformation.TransformOperation.DataLayout.ScaleLayout left, Avalonia.Media.Transformation.TransformOperation.DataLayout.ScaleLayout right) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public override string ToString() { throw null; }
            }
            [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
            public partial struct SkewLayout : System.IEquatable<Avalonia.Media.Transformation.TransformOperation.DataLayout.SkewLayout>
            {
                public double X;
                public double Y;
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public bool Equals(Avalonia.Media.Transformation.TransformOperation.DataLayout.SkewLayout other) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public override bool Equals(object obj) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public override int GetHashCode() { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public static bool operator ==(Avalonia.Media.Transformation.TransformOperation.DataLayout.SkewLayout left, Avalonia.Media.Transformation.TransformOperation.DataLayout.SkewLayout right) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public static bool operator !=(Avalonia.Media.Transformation.TransformOperation.DataLayout.SkewLayout left, Avalonia.Media.Transformation.TransformOperation.DataLayout.SkewLayout right) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public override string ToString() { throw null; }
            }
            [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
            public partial struct TranslateLayout : System.IEquatable<Avalonia.Media.Transformation.TransformOperation.DataLayout.TranslateLayout>
            {
                public double X;
                public double Y;
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public bool Equals(Avalonia.Media.Transformation.TransformOperation.DataLayout.TranslateLayout other) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public override bool Equals(object obj) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public override int GetHashCode() { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public static bool operator ==(Avalonia.Media.Transformation.TransformOperation.DataLayout.TranslateLayout left, Avalonia.Media.Transformation.TransformOperation.DataLayout.TranslateLayout right) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public static bool operator !=(Avalonia.Media.Transformation.TransformOperation.DataLayout.TranslateLayout left, Avalonia.Media.Transformation.TransformOperation.DataLayout.TranslateLayout right) { throw null; }
                [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
                public override string ToString() { throw null; }
            }
        }
        public enum OperationType
        {
            Translate = 0,
            Rotate = 1,
            Scale = 2,
            Skew = 3,
            Matrix = 4,
            Identity = 5,
        }
    }
    public sealed partial class TransformOperations : Avalonia.Media.ITransform
    {
        internal TransformOperations() { }
        public static Avalonia.Media.Transformation.TransformOperations Identity { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool IsIdentity { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.Collections.Generic.IReadOnlyList<Avalonia.Media.Transformation.TransformOperation> Operations { get { throw null; } }
        public Avalonia.Matrix Value { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Media.Transformation.TransformOperations.Builder CreateBuilder(int capacity) { throw null; }
        public static Avalonia.Media.Transformation.TransformOperations Interpolate(Avalonia.Media.Transformation.TransformOperations from, Avalonia.Media.Transformation.TransformOperations to, double progress) { throw null; }
        public static Avalonia.Media.Transformation.TransformOperations Parse(string s) { throw null; }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public readonly partial struct Builder : System.IEquatable<Avalonia.Media.Transformation.TransformOperations.Builder>
        {
            private readonly object _dummy;
            private readonly int _dummyPrimitive;
            public Builder(int capacity) { throw null; }
            public void Append(Avalonia.Media.Transformation.TransformOperation toAdd) { }
            public void AppendIdentity() { }
            public void AppendMatrix(Avalonia.Matrix matrix) { }
            public void AppendRotate(double angle) { }
            public void AppendScale(double x, double y) { }
            public void AppendSkew(double x, double y) { }
            public void AppendTranslate(double x, double y) { }
            public Avalonia.Media.Transformation.TransformOperations Build() { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public bool Equals(Avalonia.Media.Transformation.TransformOperations.Builder other) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override bool Equals(object obj) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override int GetHashCode() { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public static bool operator ==(Avalonia.Media.Transformation.TransformOperations.Builder left, Avalonia.Media.Transformation.TransformOperations.Builder right) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public static bool operator !=(Avalonia.Media.Transformation.TransformOperations.Builder left, Avalonia.Media.Transformation.TransformOperations.Builder right) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override string ToString() { throw null; }
        }
    }
}
namespace Avalonia.Metadata
{
    [System.AttributeUsageAttribute(System.AttributeTargets.Class | System.AttributeTargets.Property, Inherited=true)]
    public sealed partial class AmbientAttribute : System.Attribute
    {
        public AmbientAttribute() { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=true)]
    public sealed partial class AvaloniaListAttribute : System.Attribute
    {
        public AvaloniaListAttribute() { }
        public string[]? Separators { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.StringSplitOptions SplitOptions { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Property)]
    public sealed partial class ContentAttribute : System.Attribute
    {
        public ContentAttribute() { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Property)]
    public sealed partial class DataTypeAttribute : System.Attribute
    {
        public DataTypeAttribute() { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Method | System.AttributeTargets.Property, Inherited=true, AllowMultiple=true)]
    public sealed partial class DependsOnAttribute : System.Attribute
    {
        public DependsOnAttribute(string propertyName) { }
        public string Name { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial interface IAddChild
    {
        void AddChild(object child);
    }
    public partial interface IAddChild<T>
    {
        void AddChild(T child);
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Property, AllowMultiple=false, Inherited=true)]
    public sealed partial class InheritDataTypeFromItemsAttribute : System.Attribute
    {
        public InheritDataTypeFromItemsAttribute(string ancestorItemsProperty) { }
        public string AncestorItemsProperty { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.Type? AncestorType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Property, AllowMultiple=false)]
    public sealed partial class MarkupExtensionDefaultOptionAttribute : System.Attribute
    {
        public MarkupExtensionDefaultOptionAttribute() { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Property, AllowMultiple=false)]
    public sealed partial class MarkupExtensionOptionAttribute : System.Attribute
    {
        public MarkupExtensionOptionAttribute(object value) { }
        public int Priority { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public object Value { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Interface)]
    public sealed partial class NotClientImplementableAttribute : System.Attribute
    {
        public NotClientImplementableAttribute() { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Class | System.AttributeTargets.Constructor | System.AttributeTargets.Field | System.AttributeTargets.Interface | System.AttributeTargets.Method | System.AttributeTargets.Property | System.AttributeTargets.Struct)]
    public sealed partial class PrivateApiAttribute : System.Attribute
    {
        public PrivateApiAttribute() { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Property)]
    public sealed partial class TemplateContentAttribute : System.Attribute
    {
        public TemplateContentAttribute() { }
        public System.Type? TemplateResultType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=true)]
    public sealed partial class TrimSurroundingWhitespaceAttribute : System.Attribute
    {
        public TrimSurroundingWhitespaceAttribute() { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.All)]
    public sealed partial class UnstableAttribute : System.Attribute
    {
        public UnstableAttribute() { }
        public UnstableAttribute(string? message) { }
        public string? Message { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Class)]
    public sealed partial class UsableDuringInitializationAttribute : System.Attribute
    {
        public UsableDuringInitializationAttribute() { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=true)]
    public sealed partial class WhitespaceSignificantCollectionAttribute : System.Attribute
    {
        public WhitespaceSignificantCollectionAttribute() { }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Assembly, AllowMultiple=true)]
    public sealed partial class XmlnsDefinitionAttribute : System.Attribute
    {
        public XmlnsDefinitionAttribute(string xmlNamespace, string clrNamespace) { }
        public string ClrNamespace { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public string XmlNamespace { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    [System.AttributeUsageAttribute(System.AttributeTargets.Assembly, AllowMultiple=true)]
    public sealed partial class XmlnsPrefixAttribute : System.Attribute
    {
        public XmlnsPrefixAttribute(string xmlNamespace, string prefix) { }
        public string Prefix { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public string XmlNamespace { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
}
namespace Avalonia.Platform
{
    public enum AlphaFormat
    {
        Premul = 0,
        Unpremul = 1,
        Opaque = 2,
    }
    public static partial class AssetLoader
    {
        public static bool Exists(System.Uri uri, System.Uri? baseUri = null) { throw null; }
        public static System.Reflection.Assembly? GetAssembly(System.Uri uri, System.Uri? baseUri = null) { throw null; }
        public static System.Collections.Generic.IEnumerable<System.Uri> GetAssets(System.Uri uri, System.Uri? baseUri) { throw null; }
        public static System.IO.Stream Open(System.Uri uri, System.Uri? baseUri = null) { throw null; }
        public static (System.IO.Stream stream, System.Reflection.Assembly assembly) OpenAndGetAssembly(System.Uri uri, System.Uri? baseUri = null) { throw null; }
        public static void SetDefaultAssembly(System.Reflection.Assembly assembly) { }
    }
    public enum ColorContrastPreference
    {
        NoPreference = 0,
        High = 1,
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class DefaultPlatformSettings : Avalonia.Platform.IPlatformSettings
    {
        public DefaultPlatformSettings() { }
        public virtual System.TimeSpan HoldWaitDuration { get { throw null; } }
        public virtual event System.EventHandler<Avalonia.Platform.PlatformColorValues>? ColorValuesChanged { add { } remove { } }
        public virtual Avalonia.Platform.PlatformColorValues GetColorValues() { throw null; }
        public virtual Avalonia.Size GetDoubleTapSize(Avalonia.Input.PointerType type) { throw null; }
        public virtual System.TimeSpan GetDoubleTapTime(Avalonia.Input.PointerType type) { throw null; }
        public virtual Avalonia.Size GetTapSize(Avalonia.Input.PointerType type) { throw null; }
        protected void OnColorValuesChanged(Avalonia.Platform.PlatformColorValues colorValues) { }
    }
    public static partial class DrawingContextImplExtensions
    {
        public static T? GetFeature<T>(this Avalonia.Platform.IDrawingContextImpl context) where T : class { throw null; }
    }
    [Avalonia.Metadata.UnstableAttribute]
    public enum FormFactorType
    {
        Unknown = 0,
        Desktop = 1,
        Mobile = 2,
    }
    [Avalonia.Metadata.UnstableAttribute("IAssetLoader interface and AvaloniaLocator usage is considered unstable. Please use AssetLoader static class instead.")]
    public partial interface IAssetLoader
    {
        bool Exists(System.Uri uri, System.Uri? baseUri = null);
        System.Reflection.Assembly? GetAssembly(System.Uri uri, System.Uri? baseUri = null);
        System.Collections.Generic.IEnumerable<System.Uri> GetAssets(System.Uri uri, System.Uri? baseUri);
        System.IO.Stream Open(System.Uri uri, System.Uri? baseUri = null);
        (System.IO.Stream stream, System.Reflection.Assembly assembly) OpenAndGetAssembly(System.Uri uri, System.Uri? baseUri = null);
        void SetDefaultAssembly(System.Reflection.Assembly assembly);
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial interface IBitmapImpl : System.IDisposable
    {
        Avalonia.Vector Dpi { get; }
        Avalonia.PixelSize PixelSize { get; }
        int Version { get; }
        void Save(System.IO.Stream stream, int? quality = default(int?));
        void Save(string fileName, int? quality = default(int?));
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial interface ICursorFactory
    {
        Avalonia.Platform.ICursorImpl CreateCursor(Avalonia.Platform.IBitmapImpl cursor, Avalonia.PixelPoint hotSpot);
        Avalonia.Platform.ICursorImpl GetCursor(Avalonia.Input.StandardCursorType cursorType);
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface ICursorImpl : System.IDisposable
    {
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IDrawingContextImpl : System.IDisposable
    {
        Avalonia.Media.RenderOptions RenderOptions { get; set; }
        Avalonia.Matrix Transform { get; set; }
        void Clear(Avalonia.Media.Color color);
        Avalonia.Platform.IDrawingContextLayerImpl CreateLayer(Avalonia.Size size);
        void DrawBitmap(Avalonia.Platform.IBitmapImpl source, Avalonia.Media.IBrush opacityMask, Avalonia.Rect opacityMaskRect, Avalonia.Rect destRect);
        void DrawBitmap(Avalonia.Platform.IBitmapImpl source, double opacity, Avalonia.Rect sourceRect, Avalonia.Rect destRect);
        void DrawEllipse(Avalonia.Media.IBrush? brush, Avalonia.Media.IPen? pen, Avalonia.Rect rect);
        void DrawGeometry(Avalonia.Media.IBrush? brush, Avalonia.Media.IPen? pen, Avalonia.Platform.IGeometryImpl geometry);
        void DrawGlyphRun(Avalonia.Media.IBrush? foreground, Avalonia.Platform.IGlyphRunImpl glyphRun);
        void DrawLine(Avalonia.Media.IPen? pen, Avalonia.Point p1, Avalonia.Point p2);
        void DrawRectangle(Avalonia.Media.IBrush? brush, Avalonia.Media.IPen? pen, Avalonia.RoundedRect rect, Avalonia.Media.BoxShadows boxShadows = default(Avalonia.Media.BoxShadows));
        object? GetFeature(System.Type t);
        void PopClip();
        void PopGeometryClip();
        void PopOpacity();
        void PopOpacityMask();
        void PushClip(Avalonia.Rect clip);
        void PushClip(Avalonia.RoundedRect clip);
        void PushGeometryClip(Avalonia.Platform.IGeometryImpl clip);
        void PushOpacity(double opacity, Avalonia.Rect? bounds);
        void PushOpacityMask(Avalonia.Media.IBrush mask, Avalonia.Rect bounds);
    }
    public partial interface IDrawingContextImplWithEffects
    {
        void PopEffect();
        void PushEffect(Avalonia.Media.IEffect effect);
    }
    public partial interface IDrawingContextLayerImpl : Avalonia.Platform.IBitmapImpl, Avalonia.Platform.IRenderTarget, Avalonia.Platform.IRenderTargetBitmapImpl, System.IDisposable
    {
        bool CanBlit { get; }
        void Blit(Avalonia.Platform.IDrawingContextImpl context);
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial interface IDrawingContextWithAcrylicLikeSupport
    {
        void DrawRectangle(Avalonia.Media.IExperimentalAcrylicMaterial material, Avalonia.RoundedRect rect);
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IExternalObjectsRenderInterfaceContextFeature
    {
        byte[]? DeviceLuid { get; }
        byte[]? DeviceUuid { get; }
        System.Collections.Generic.IReadOnlyList<string> SupportedImageHandleTypes { get; }
        System.Collections.Generic.IReadOnlyList<string> SupportedSemaphoreTypes { get; }
        Avalonia.Rendering.Composition.CompositionGpuImportedImageSynchronizationCapabilities GetSynchronizationCapabilities(string imageHandleType);
        Avalonia.Platform.IPlatformRenderInterfaceImportedImage ImportImage(Avalonia.Platform.IPlatformHandle handle, Avalonia.Platform.PlatformGraphicsExternalImageProperties properties);
        Avalonia.Platform.IPlatformRenderInterfaceImportedImage ImportImage(Avalonia.Rendering.Composition.ICompositionImportableSharedGpuContextImage image);
        Avalonia.Platform.IPlatformRenderInterfaceImportedSemaphore ImportSemaphore(Avalonia.Platform.IPlatformHandle handle);
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IFontManagerImpl
    {
        string GetDefaultFontFamilyName();
        string[] GetInstalledFontFamilyNames(bool checkForUpdates = false);
        bool TryCreateGlyphTypeface(System.IO.Stream stream, [System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] out Avalonia.Media.IGlyphTypeface? glyphTypeface);
        bool TryCreateGlyphTypeface(string familyName, Avalonia.Media.FontStyle style, Avalonia.Media.FontWeight weight, Avalonia.Media.FontStretch stretch, [System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] out Avalonia.Media.IGlyphTypeface? glyphTypeface);
        bool TryMatchCharacter(int codepoint, Avalonia.Media.FontStyle fontStyle, Avalonia.Media.FontWeight fontWeight, Avalonia.Media.FontStretch fontStretch, System.Globalization.CultureInfo? culture, out Avalonia.Media.Typeface typeface);
    }
    public partial interface IGeometryContext : System.IDisposable
    {
        void ArcTo(Avalonia.Point point, Avalonia.Size size, double rotationAngle, bool isLargeArc, Avalonia.Media.SweepDirection sweepDirection);
        void BeginFigure(Avalonia.Point startPoint, bool isFilled = true);
        void CubicBezierTo(Avalonia.Point point1, Avalonia.Point point2, Avalonia.Point point3);
        void EndFigure(bool isClosed);
        void LineTo(Avalonia.Point point);
        void QuadraticBezierTo(Avalonia.Point control, Avalonia.Point endPoint);
        void SetFillRule(Avalonia.Media.FillRule fillRule);
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IGeometryImpl
    {
        Avalonia.Rect Bounds { get; }
        double ContourLength { get; }
        bool FillContains(Avalonia.Point point);
        Avalonia.Rect GetRenderBounds(Avalonia.Media.IPen? pen);
        Avalonia.Platform.IGeometryImpl? Intersect(Avalonia.Platform.IGeometryImpl geometry);
        bool StrokeContains(Avalonia.Media.IPen? pen, Avalonia.Point point);
        bool TryGetPointAndTangentAtDistance(double distance, out Avalonia.Point point, out Avalonia.Point tangent);
        bool TryGetPointAtDistance(double distance, out Avalonia.Point point);
        bool TryGetSegment(double startDistance, double stopDistance, bool startOnBeginFigure, [System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] out Avalonia.Platform.IGeometryImpl? segmentGeometry);
        Avalonia.Platform.ITransformedGeometryImpl WithTransform(Avalonia.Matrix transform);
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IGlyphRunImpl : System.IDisposable
    {
        Avalonia.Point BaselineOrigin { get; }
        Avalonia.Rect Bounds { get; }
        double FontRenderingEmSize { get; }
        Avalonia.Media.IGlyphTypeface GlyphTypeface { get; }
        System.Collections.Generic.IReadOnlyList<float> GetIntersections(float lowerLimit, float upperLimit);
    }
    public partial interface ILockedFramebuffer : System.IDisposable
    {
        System.IntPtr Address { get; }
        Avalonia.Vector Dpi { get; }
        Avalonia.Platform.PixelFormat Format { get; }
        int RowBytes { get; }
        Avalonia.PixelSize Size { get; }
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IMacOSTopLevelPlatformHandle
    {
        System.IntPtr NSView { get; }
        System.IntPtr NSWindow { get; }
        System.IntPtr GetNSViewRetained();
        System.IntPtr GetNSWindowRetained();
    }
    public partial interface IOptionalFeatureProvider
    {
        object? TryGetFeature(System.Type featureType);
    }
    public partial interface IPlatformBehaviorInhibition
    {
        System.Threading.Tasks.Task SetInhibitAppSleep(bool inhibitAppSleep, string reason);
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IPlatformGraphics
    {
        bool UsesSharedContext { get; }
        Avalonia.Platform.IPlatformGraphicsContext CreateContext();
        Avalonia.Platform.IPlatformGraphicsContext GetSharedContext();
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IPlatformGraphicsContext : Avalonia.Platform.IOptionalFeatureProvider, System.IDisposable
    {
        bool IsLost { get; }
        System.IDisposable EnsureCurrent();
    }
    public partial interface IPlatformHandle
    {
        System.IntPtr Handle { get; }
        string? HandleDescriptor { get; }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IPlatformRenderInterface
    {
        Avalonia.Platform.AlphaFormat DefaultAlphaFormat { get; }
        Avalonia.Platform.PixelFormat DefaultPixelFormat { get; }
        bool SupportsIndividualRoundRects { get; }
        Avalonia.Platform.IGeometryImpl BuildGlyphRunGeometry(Avalonia.Media.GlyphRun glyphRun);
        Avalonia.Platform.IPlatformRenderInterfaceContext CreateBackendContext(Avalonia.Platform.IPlatformGraphicsContext? graphicsApiContext);
        Avalonia.Platform.IGeometryImpl CreateCombinedGeometry(Avalonia.Media.GeometryCombineMode combineMode, Avalonia.Platform.IGeometryImpl g1, Avalonia.Platform.IGeometryImpl g2);
        Avalonia.Platform.IGeometryImpl CreateEllipseGeometry(Avalonia.Rect rect);
        Avalonia.Platform.IGeometryImpl CreateGeometryGroup(Avalonia.Media.FillRule fillRule, System.Collections.Generic.IReadOnlyList<Avalonia.Platform.IGeometryImpl> children);
        Avalonia.Platform.IGlyphRunImpl CreateGlyphRun(Avalonia.Media.IGlyphTypeface glyphTypeface, double fontRenderingEmSize, System.Collections.Generic.IReadOnlyList<Avalonia.Media.TextFormatting.GlyphInfo> glyphInfos, Avalonia.Point baselineOrigin);
        Avalonia.Platform.IGeometryImpl CreateLineGeometry(Avalonia.Point p1, Avalonia.Point p2);
        Avalonia.Platform.IGeometryImpl CreateRectangleGeometry(Avalonia.Rect rect);
        Avalonia.Platform.IRenderTargetBitmapImpl CreateRenderTargetBitmap(Avalonia.PixelSize size, Avalonia.Vector dpi);
        Avalonia.Platform.IStreamGeometryImpl CreateStreamGeometry();
        Avalonia.Platform.IWriteableBitmapImpl CreateWriteableBitmap(Avalonia.PixelSize size, Avalonia.Vector dpi, Avalonia.Platform.PixelFormat format, Avalonia.Platform.AlphaFormat alphaFormat);
        bool IsSupportedBitmapPixelFormat(Avalonia.Platform.PixelFormat format);
        Avalonia.Platform.IBitmapImpl LoadBitmap(Avalonia.Platform.PixelFormat format, Avalonia.Platform.AlphaFormat alphaFormat, System.IntPtr data, Avalonia.PixelSize size, Avalonia.Vector dpi, int stride);
        Avalonia.Platform.IBitmapImpl LoadBitmap(System.IO.Stream stream);
        Avalonia.Platform.IBitmapImpl LoadBitmap(string fileName);
        Avalonia.Platform.IBitmapImpl LoadBitmapToHeight(System.IO.Stream stream, int height, Avalonia.Media.Imaging.BitmapInterpolationMode interpolationMode = Avalonia.Media.Imaging.BitmapInterpolationMode.HighQuality);
        Avalonia.Platform.IBitmapImpl LoadBitmapToWidth(System.IO.Stream stream, int width, Avalonia.Media.Imaging.BitmapInterpolationMode interpolationMode = Avalonia.Media.Imaging.BitmapInterpolationMode.HighQuality);
        Avalonia.Platform.IWriteableBitmapImpl LoadWriteableBitmap(System.IO.Stream stream);
        Avalonia.Platform.IWriteableBitmapImpl LoadWriteableBitmap(string fileName);
        Avalonia.Platform.IWriteableBitmapImpl LoadWriteableBitmapToHeight(System.IO.Stream stream, int height, Avalonia.Media.Imaging.BitmapInterpolationMode interpolationMode = Avalonia.Media.Imaging.BitmapInterpolationMode.HighQuality);
        Avalonia.Platform.IWriteableBitmapImpl LoadWriteableBitmapToWidth(System.IO.Stream stream, int width, Avalonia.Media.Imaging.BitmapInterpolationMode interpolationMode = Avalonia.Media.Imaging.BitmapInterpolationMode.HighQuality);
        Avalonia.Platform.IBitmapImpl ResizeBitmap(Avalonia.Platform.IBitmapImpl bitmapImpl, Avalonia.PixelSize destinationSize, Avalonia.Media.Imaging.BitmapInterpolationMode interpolationMode = Avalonia.Media.Imaging.BitmapInterpolationMode.HighQuality);
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IPlatformRenderInterfaceContext : Avalonia.Platform.IOptionalFeatureProvider, System.IDisposable
    {
        bool IsLost { get; }
        Avalonia.Platform.IRenderTarget CreateRenderTarget(System.Collections.Generic.IEnumerable<object> surfaces);
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IPlatformRenderInterfaceImportedImage : Avalonia.Platform.IPlatformRenderInterfaceImportedObject, System.IDisposable
    {
        Avalonia.Platform.IBitmapImpl SnapshotWithAutomaticSync();
        Avalonia.Platform.IBitmapImpl SnapshotWithKeyedMutex(uint acquireIndex, uint releaseIndex);
        Avalonia.Platform.IBitmapImpl SnapshotWithSemaphores(Avalonia.Platform.IPlatformRenderInterfaceImportedSemaphore waitForSemaphore, Avalonia.Platform.IPlatformRenderInterfaceImportedSemaphore signalSemaphore);
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IPlatformRenderInterfaceImportedObject : System.IDisposable
    {
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IPlatformRenderInterfaceImportedSemaphore : Avalonia.Platform.IPlatformRenderInterfaceImportedObject, System.IDisposable
    {
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IPlatformSettings
    {
        System.TimeSpan HoldWaitDuration { get; }
        event System.EventHandler<Avalonia.Platform.PlatformColorValues>? ColorValuesChanged;
        Avalonia.Platform.PlatformColorValues GetColorValues();
        Avalonia.Size GetDoubleTapSize(Avalonia.Input.PointerType type);
        System.TimeSpan GetDoubleTapTime(Avalonia.Input.PointerType type);
        Avalonia.Size GetTapSize(Avalonia.Input.PointerType type);
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial interface IPlatformThreadingInterface
    {
        bool CurrentThreadIsLoopThread { get; }
        event System.Action<Avalonia.Threading.DispatcherPriority?>? Signaled;
        void Signal(Avalonia.Threading.DispatcherPriority priority);
        System.IDisposable StartTimer(Avalonia.Threading.DispatcherPriority priority, System.TimeSpan interval, System.Action tick);
    }
    public partial interface IReadableBitmapImpl
    {
        Avalonia.Platform.PixelFormat? Format { get; }
        Avalonia.Platform.ILockedFramebuffer Lock();
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial interface IRenderTarget : System.IDisposable
    {
        bool IsCorrupted { get; }
        Avalonia.Platform.IDrawingContextImpl CreateDrawingContext();
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IRenderTargetBitmapImpl : Avalonia.Platform.IBitmapImpl, Avalonia.Platform.IRenderTarget, System.IDisposable
    {
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IRuntimePlatform
    {
        Avalonia.Platform.IUnmanagedBlob AllocBlob(int size);
        Avalonia.Platform.RuntimePlatformInfo GetRuntimeInfo();
        System.IDisposable StartSystemTimer(System.TimeSpan interval, System.Action tick);
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IStreamGeometryContextImpl : Avalonia.Platform.IGeometryContext, System.IDisposable
    {
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IStreamGeometryImpl : Avalonia.Platform.IGeometryImpl
    {
        Avalonia.Platform.IStreamGeometryImpl Clone();
        Avalonia.Platform.IStreamGeometryContextImpl Open();
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface ISystemNavigationManagerImpl
    {
        event System.EventHandler<Avalonia.Interactivity.RoutedEventArgs>? BackRequested;
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface ITextShaperImpl
    {
        Avalonia.Media.TextFormatting.ShapedBuffer ShapeText(System.ReadOnlyMemory<char> text, Avalonia.Media.TextFormatting.TextShaperOptions options);
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface ITransformedGeometryImpl : Avalonia.Platform.IGeometryImpl
    {
        Avalonia.Platform.IGeometryImpl SourceGeometry { get; }
        Avalonia.Matrix Transform { get; }
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IUnmanagedBlob : System.IDisposable
    {
        System.IntPtr Address { get; }
        bool IsDisposed { get; }
        int Size { get; }
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface IWriteableBitmapImpl : Avalonia.Platform.IBitmapImpl, Avalonia.Platform.IReadableBitmapImpl, System.IDisposable
    {
    }
    public static partial class KnownPlatformGraphicsExternalImageHandleTypes
    {
        public const string D3D11TextureGlobalSharedHandle = "D3D11TextureGlobalSharedHandle";
        public const string D3D11TextureNtHandle = "D3D11TextureNtHandle";
        public const string VulkanOpaquePosixFileDescriptor = "VulkanOpaquePosixFileDescriptor";
    }
    public static partial class KnownPlatformGraphicsExternalSemaphoreHandleTypes
    {
        public const string Direct3D12FenceNtHandle = "Direct3D12FenceNtHandle";
        public const string VulkanOpaqueKmtHandle = "VulkanOpaqueKmtHandle";
        public const string VulkanOpaqueNtHandle = "VulkanOpaqueNtHandle";
        public const string VulkanOpaquePosixFileDescriptor = "VulkanOpaquePosixFileDescriptor";
    }
    public partial class LockedFramebuffer : Avalonia.Platform.ILockedFramebuffer, System.IDisposable
    {
        public LockedFramebuffer(System.IntPtr address, Avalonia.PixelSize size, int rowBytes, Avalonia.Vector dpi, Avalonia.Platform.PixelFormat format, System.Action? onDispose) { }
        public System.IntPtr Address { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Vector Dpi { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Platform.PixelFormat Format { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int RowBytes { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.PixelSize Size { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public void Dispose() { }
    }
    public static partial class OptionalFeatureProviderExtensions
    {
        public static T? TryGetFeature<T>(this Avalonia.Platform.IOptionalFeatureProvider provider) where T : class { throw null; }
        public static bool TryGetFeature<T>(this Avalonia.Platform.IOptionalFeatureProvider provider, [System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute(false)] out T rv) where T : class { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct PixelFormat : System.IEquatable<Avalonia.Platform.PixelFormat>
    {
        private int _dummyPrimitive;
        public static Avalonia.Platform.PixelFormat Bgra8888 { get { throw null; } }
        public int BitsPerPixel { get { throw null; } }
        public static Avalonia.Platform.PixelFormat Rgb565 { get { throw null; } }
        public static Avalonia.Platform.PixelFormat Rgba8888 { get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Platform.PixelFormat other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Platform.PixelFormat left, Avalonia.Platform.PixelFormat right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Platform.PixelFormat left, Avalonia.Platform.PixelFormat right) { throw null; }
        public override string ToString() { throw null; }
    }
    public static partial class PixelFormats
    {
        public static Avalonia.Platform.PixelFormat Bgr24 { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.PixelFormat Bgra8888 { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.PixelFormat BlackWhite { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.PixelFormat Gray16 { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.PixelFormat Gray2 { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.PixelFormat Gray32Float { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.PixelFormat Gray4 { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.PixelFormat Gray8 { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.PixelFormat Rgb24 { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.PixelFormat Rgb565 { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.PixelFormat Rgba64 { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.PixelFormat Rgba8888 { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class PlatformColorValues : System.IEquatable<Avalonia.Platform.PlatformColorValues>
    {
        public PlatformColorValues() { }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        protected PlatformColorValues(Avalonia.Platform.PlatformColorValues original) { }
        public Avalonia.Media.Color AccentColor1 { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Media.Color AccentColor2 { get { throw null; } set { } }
        public Avalonia.Media.Color AccentColor3 { get { throw null; } set { } }
        public Avalonia.Platform.ColorContrastPreference ContrastPreference { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        protected virtual System.Type EqualityContract { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Platform.PlatformThemeVariant ThemeVariant { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public virtual bool Equals(Avalonia.Platform.PlatformColorValues? other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object? obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Platform.PlatformColorValues? left, Avalonia.Platform.PlatformColorValues? right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Platform.PlatformColorValues? left, Avalonia.Platform.PlatformColorValues? right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        protected virtual bool PrintMembers(System.Text.StringBuilder builder) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public virtual Avalonia.Platform.PlatformColorValues <Clone>$() { throw null; }
    }
    public partial class PlatformGraphicsContextLostException : System.Exception
    {
        public PlatformGraphicsContextLostException() { }
    }
    public enum PlatformGraphicsExternalImageFormat
    {
        R8G8B8A8UNorm = 0,
        B8G8R8A8UNorm = 1,
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct PlatformGraphicsExternalImageProperties : System.IEquatable<Avalonia.Platform.PlatformGraphicsExternalImageProperties>
    {
        private int _dummyPrimitive;
        public Avalonia.Platform.PlatformGraphicsExternalImageFormat Format { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int Height { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public ulong MemoryOffset { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public ulong MemorySize { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public bool TopLeftOrigin { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int Width { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Platform.PlatformGraphicsExternalImageProperties other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Platform.PlatformGraphicsExternalImageProperties left, Avalonia.Platform.PlatformGraphicsExternalImageProperties right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Platform.PlatformGraphicsExternalImageProperties left, Avalonia.Platform.PlatformGraphicsExternalImageProperties right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public partial class PlatformHandle : Avalonia.Platform.IPlatformHandle
    {
        public PlatformHandle(System.IntPtr handle, string? descriptor) { }
        public System.IntPtr Handle { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public string? HandleDescriptor { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public enum PlatformThemeVariant
    {
        Light = 0,
        Dark = 1,
    }
    [Avalonia.Metadata.UnstableAttribute]
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct RuntimePlatformInfo : System.IEquatable<Avalonia.Platform.RuntimePlatformInfo>
    {
        private int _dummyPrimitive;
        public Avalonia.Platform.FormFactorType FormFactor { get { throw null; } }
        public bool IsDesktop { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public bool IsMobile { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Platform.RuntimePlatformInfo other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Platform.RuntimePlatformInfo left, Avalonia.Platform.RuntimePlatformInfo right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Platform.RuntimePlatformInfo left, Avalonia.Platform.RuntimePlatformInfo right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    [Avalonia.Metadata.UnstableAttribute("StandardAssetLoader is considered unstable. Please use AssetLoader static class instead.")]
    public partial class StandardAssetLoader : Avalonia.Platform.IAssetLoader
    {
        public StandardAssetLoader(System.Reflection.Assembly? assembly = null) { }
        public bool Exists(System.Uri uri, System.Uri? baseUri = null) { throw null; }
        public System.Reflection.Assembly? GetAssembly(System.Uri uri, System.Uri? baseUri) { throw null; }
        public System.Collections.Generic.IEnumerable<System.Uri> GetAssets(System.Uri uri, System.Uri? baseUri) { throw null; }
        public System.IO.Stream Open(System.Uri uri, System.Uri? baseUri = null) { throw null; }
        public (System.IO.Stream stream, System.Reflection.Assembly assembly) OpenAndGetAssembly(System.Uri uri, System.Uri? baseUri = null) { throw null; }
        public static void RegisterResUriParsers() { }
        public void SetDefaultAssembly(System.Reflection.Assembly assembly) { }
    }
    public partial class StandardRuntimePlatform : Avalonia.Platform.IRuntimePlatform
    {
        public StandardRuntimePlatform() { }
        public Avalonia.Platform.IUnmanagedBlob AllocBlob(int size) { throw null; }
        public virtual Avalonia.Platform.RuntimePlatformInfo GetRuntimeInfo() { throw null; }
        public System.IDisposable StartSystemTimer(System.TimeSpan interval, System.Action tick) { throw null; }
    }
    public static partial class StandardRuntimePlatformServices
    {
        public static void Register(System.Reflection.Assembly? assembly = null) { }
    }
}
namespace Avalonia.Platform.Interop
{
    public partial class DynamicLibraryLoaderException : System.Exception
    {
        public DynamicLibraryLoaderException(string message) { }
        public DynamicLibraryLoaderException(string message, System.Exception innerException) { }
    }
    public partial interface IDynamicLibraryLoader
    {
        System.IntPtr GetProcAddress(System.IntPtr dll, string proc, bool optional);
        System.IntPtr LoadLibrary(string dll);
    }
}
namespace Avalonia.Platform.Storage
{
    public sealed partial class FilePickerFileType
    {
        public FilePickerFileType(string? name) { }
        public System.Collections.Generic.IReadOnlyList<string>? AppleUniformTypeIdentifiers { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.IReadOnlyList<string>? MimeTypes { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public string Name { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.Collections.Generic.IReadOnlyList<string>? Patterns { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    public static partial class FilePickerFileTypes
    {
        public static Avalonia.Platform.Storage.FilePickerFileType All { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.Storage.FilePickerFileType ImageAll { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.Storage.FilePickerFileType ImageJpg { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.Storage.FilePickerFileType ImagePng { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.Storage.FilePickerFileType Pdf { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Platform.Storage.FilePickerFileType TextPlain { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class FilePickerOpenOptions : Avalonia.Platform.Storage.PickerOptions
    {
        public FilePickerOpenOptions() { }
        public bool AllowMultiple { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.IReadOnlyList<Avalonia.Platform.Storage.FilePickerFileType>? FileTypeFilter { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    public partial class FilePickerSaveOptions : Avalonia.Platform.Storage.PickerOptions
    {
        public FilePickerSaveOptions() { }
        public string? DefaultExtension { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Collections.Generic.IReadOnlyList<Avalonia.Platform.Storage.FilePickerFileType>? FileTypeChoices { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public bool? ShowOverwritePrompt { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public string? SuggestedFileName { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    public partial class FolderPickerOpenOptions : Avalonia.Platform.Storage.PickerOptions
    {
        public FolderPickerOpenOptions() { }
        public bool AllowMultiple { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IStorageBookmarkFile : Avalonia.Platform.Storage.IStorageBookmarkItem, Avalonia.Platform.Storage.IStorageFile, Avalonia.Platform.Storage.IStorageItem, System.IDisposable
    {
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IStorageBookmarkFolder : Avalonia.Platform.Storage.IStorageBookmarkItem, Avalonia.Platform.Storage.IStorageFolder, Avalonia.Platform.Storage.IStorageItem, System.IDisposable
    {
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IStorageBookmarkItem : Avalonia.Platform.Storage.IStorageItem, System.IDisposable
    {
        System.Threading.Tasks.Task ReleaseBookmarkAsync();
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IStorageFile : Avalonia.Platform.Storage.IStorageItem, System.IDisposable
    {
        System.Threading.Tasks.Task<System.IO.Stream> OpenReadAsync();
        System.Threading.Tasks.Task<System.IO.Stream> OpenWriteAsync();
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IStorageFolder : Avalonia.Platform.Storage.IStorageItem, System.IDisposable
    {
        System.Threading.Tasks.Task<Avalonia.Platform.Storage.IStorageFile?> CreateFileAsync(string name);
        System.Threading.Tasks.Task<Avalonia.Platform.Storage.IStorageFolder?> CreateFolderAsync(string name);
        System.Collections.Generic.IAsyncEnumerable<Avalonia.Platform.Storage.IStorageItem> GetItemsAsync();
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IStorageItem : System.IDisposable
    {
        bool CanBookmark { get; }
        string Name { get; }
        System.Uri Path { get; }
        System.Threading.Tasks.Task DeleteAsync();
        System.Threading.Tasks.Task<Avalonia.Platform.Storage.StorageItemProperties> GetBasicPropertiesAsync();
        System.Threading.Tasks.Task<Avalonia.Platform.Storage.IStorageFolder?> GetParentAsync();
        System.Threading.Tasks.Task<Avalonia.Platform.Storage.IStorageItem?> MoveAsync(Avalonia.Platform.Storage.IStorageFolder destination);
        System.Threading.Tasks.Task<string?> SaveBookmarkAsync();
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IStorageProvider
    {
        bool CanOpen { get; }
        bool CanPickFolder { get; }
        bool CanSave { get; }
        System.Threading.Tasks.Task<Avalonia.Platform.Storage.IStorageBookmarkFile?> OpenFileBookmarkAsync(string bookmark);
        System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<Avalonia.Platform.Storage.IStorageFile>> OpenFilePickerAsync(Avalonia.Platform.Storage.FilePickerOpenOptions options);
        System.Threading.Tasks.Task<Avalonia.Platform.Storage.IStorageBookmarkFolder?> OpenFolderBookmarkAsync(string bookmark);
        System.Threading.Tasks.Task<System.Collections.Generic.IReadOnlyList<Avalonia.Platform.Storage.IStorageFolder>> OpenFolderPickerAsync(Avalonia.Platform.Storage.FolderPickerOpenOptions options);
        System.Threading.Tasks.Task<Avalonia.Platform.Storage.IStorageFile?> SaveFilePickerAsync(Avalonia.Platform.Storage.FilePickerSaveOptions options);
        System.Threading.Tasks.Task<Avalonia.Platform.Storage.IStorageFile?> TryGetFileFromPathAsync(System.Uri filePath);
        System.Threading.Tasks.Task<Avalonia.Platform.Storage.IStorageFolder?> TryGetFolderFromPathAsync(System.Uri folderPath);
        System.Threading.Tasks.Task<Avalonia.Platform.Storage.IStorageFolder?> TryGetWellKnownFolderAsync(Avalonia.Platform.Storage.WellKnownFolder wellKnownFolder);
    }
    public partial class PickerOptions
    {
        public PickerOptions() { }
        public Avalonia.Platform.Storage.IStorageFolder? SuggestedStartLocation { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public string? Title { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    public partial class StorageItemProperties
    {
        public StorageItemProperties(ulong? size = default(ulong?), System.DateTimeOffset? dateCreated = default(System.DateTimeOffset?), System.DateTimeOffset? dateModified = default(System.DateTimeOffset?)) { }
        public System.DateTimeOffset? DateCreated { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.DateTimeOffset? DateModified { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public ulong? Size { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public static partial class StorageProviderExtensions
    {
        public static System.Threading.Tasks.Task<Avalonia.Platform.Storage.IStorageFile?> TryGetFileFromPathAsync(this Avalonia.Platform.Storage.IStorageProvider provider, string filePath) { throw null; }
        public static System.Threading.Tasks.Task<Avalonia.Platform.Storage.IStorageFolder?> TryGetFolderFromPathAsync(this Avalonia.Platform.Storage.IStorageProvider provider, string folderPath) { throw null; }
        public static string? TryGetLocalPath(this Avalonia.Platform.Storage.IStorageItem item) { throw null; }
    }
    public enum WellKnownFolder
    {
        Desktop = 0,
        Documents = 1,
        Downloads = 2,
        Music = 3,
        Pictures = 4,
        Videos = 5,
    }
}
namespace Avalonia.Reactive
{
    public partial class AnonymousObserver<T> : System.IObserver<T>
    {
        public AnonymousObserver(System.Action<T> onNext) { }
        public AnonymousObserver(System.Action<T> onNext, System.Action onCompleted) { }
        public AnonymousObserver(System.Action<T> onNext, System.Action<System.Exception> onError) { }
        public AnonymousObserver(System.Action<T> onNext, System.Action<System.Exception> onError, System.Action onCompleted) { }
        public AnonymousObserver(System.Threading.Tasks.TaskCompletionSource<T> tcs) { }
        public void OnCompleted() { }
        public void OnError(System.Exception error) { }
        public void OnNext(T value) { }
    }
}
namespace Avalonia.Rendering
{
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class DefaultRenderTimer : Avalonia.Rendering.IRenderTimer
    {
        public DefaultRenderTimer(int framesPerSecond) { }
        public int FramesPerSecond { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public virtual bool RunsInBackground { get { throw null; } }
        public event System.Action<System.TimeSpan> Tick { add { } remove { } }
        protected void Start() { }
        protected virtual System.IDisposable StartCore(System.Action<System.TimeSpan> tick) { throw null; }
        protected void Stop() { }
    }
    public partial interface ICustomHitTest
    {
        bool HitTest(Avalonia.Point point);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IRenderRoot
    {
        Avalonia.Size ClientSize { get; }
        double RenderScaling { get; }
        Avalonia.Point PointToClient(Avalonia.PixelPoint point);
        Avalonia.PixelPoint PointToScreen(Avalonia.Point point);
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial interface IRenderTimer
    {
        bool RunsInBackground { get; }
        event System.Action<System.TimeSpan> Tick;
    }
    [System.FlagsAttribute]
    public enum RendererDebugOverlays
    {
        None = 0,
        Fps = 1,
        DirtyRects = 2,
        LayoutTimeGraph = 4,
        RenderTimeGraph = 8,
    }
    public partial class RendererDiagnostics : System.ComponentModel.INotifyPropertyChanged
    {
        public RendererDiagnostics() { }
        public Avalonia.Rendering.RendererDebugOverlays DebugOverlays { get { throw null; } set { } }
        public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged { add { } remove { } }
        protected virtual void OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs args) { }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class SleepLoopRenderTimer : Avalonia.Rendering.IRenderTimer
    {
        public SleepLoopRenderTimer(int fps) { }
        public bool RunsInBackground { get { throw null; } }
        public event System.Action<System.TimeSpan> Tick { add { } remove { } }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial class UiThreadRenderTimer : Avalonia.Rendering.DefaultRenderTimer
    {
        public UiThreadRenderTimer(int framesPerSecond) : base (default(int)) { }
        public override bool RunsInBackground { get { throw null; } }
        protected override System.IDisposable StartCore(System.Action<System.TimeSpan> tick) { throw null; }
    }
}
namespace Avalonia.Rendering.Composition
{
    public partial class BooleanKeyFrameAnimation : Avalonia.Rendering.Composition.Animations.KeyFrameAnimation
    {
        public BooleanKeyFrameAnimation(Avalonia.Rendering.Composition.Compositor compositor) { }
        public void InsertKeyFrame(float normalizedProgressKey, bool value) { }
        public void InsertKeyFrame(float normalizedProgressKey, bool value, Avalonia.Animation.Easings.IEasing easingFunction) { }
    }
    public partial class ColorKeyFrameAnimation : Avalonia.Rendering.Composition.Animations.KeyFrameAnimation
    {
        public ColorKeyFrameAnimation(Avalonia.Rendering.Composition.Compositor compositor) { }
        public void InsertKeyFrame(float normalizedProgressKey, Avalonia.Media.Color value) { }
        public void InsertKeyFrame(float normalizedProgressKey, Avalonia.Media.Color value, Avalonia.Animation.Easings.IEasing easingFunction) { }
    }
    public enum CompositionBlendMode
    {
        Clear = 0,
        Src = 1,
        Dst = 2,
        SrcOver = 3,
        DstOver = 4,
        SrcIn = 5,
        DstIn = 6,
        SrcOut = 7,
        DstOut = 8,
        SrcATop = 9,
        DstATop = 10,
        Xor = 11,
        Plus = 12,
        Modulate = 13,
        Screen = 14,
        Overlay = 15,
        Darken = 16,
        Lighten = 17,
        ColorDodge = 18,
        ColorBurn = 19,
        HardLight = 20,
        SoftLight = 21,
        Difference = 22,
        Exclusion = 23,
        Multiply = 24,
        Hue = 25,
        Saturation = 26,
        Color = 27,
        Luminosity = 28,
    }
    public partial class CompositionContainerVisual : Avalonia.Rendering.Composition.CompositionVisual
    {
        internal CompositionContainerVisual() { }
        public Avalonia.Rendering.Composition.CompositionVisualCollection Children { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class CompositionCustomVisual : Avalonia.Rendering.Composition.CompositionContainerVisual
    {
        internal CompositionCustomVisual() { }
        public void SendHandlerMessage(object message) { }
    }
    public abstract partial class CompositionCustomVisualHandler
    {
        protected CompositionCustomVisualHandler() { }
        protected System.TimeSpan CompositionNow { get { throw null; } }
        protected System.Numerics.Vector2 EffectiveSize { get { throw null; } }
        public virtual Avalonia.Rect GetRenderBounds() { throw null; }
        protected void Invalidate() { }
        public virtual void OnAnimationFrameUpdate() { }
        public virtual void OnMessage(object message) { }
        public abstract void OnRender(Avalonia.Media.ImmediateDrawingContext drawingContext);
        protected void RegisterForNextAnimationFrameUpdate() { }
    }
    public partial class CompositionDrawingSurface : Avalonia.Rendering.Composition.CompositionSurface, System.IDisposable
    {
        internal CompositionDrawingSurface() { }
        public new void Dispose() { }
        ~CompositionDrawingSurface() { }
        public System.Threading.Tasks.Task UpdateAsync(Avalonia.Rendering.Composition.ICompositionImportedGpuImage image) { throw null; }
        public System.Threading.Tasks.Task UpdateWithKeyedMutexAsync(Avalonia.Rendering.Composition.ICompositionImportedGpuImage image, uint acquireIndex, uint releaseIndex) { throw null; }
        public System.Threading.Tasks.Task UpdateWithSemaphoresAsync(Avalonia.Rendering.Composition.ICompositionImportedGpuImage image, Avalonia.Rendering.Composition.ICompositionImportedGpuSemaphore waitForSemaphore, Avalonia.Rendering.Composition.ICompositionImportedGpuSemaphore signalSemaphore) { throw null; }
    }
    public enum CompositionGetValueStatus
    {
        Succeeded = 0,
        TypeMismatch = 1,
        NotFound = 2,
    }
    [System.FlagsAttribute]
    public enum CompositionGpuImportedImageSynchronizationCapabilities
    {
        Semaphores = 1,
        KeyedMutex = 2,
        Automatic = 4,
    }
    public enum CompositionGradientExtendMode
    {
        Clamp = 0,
        Wrap = 1,
        Mirror = 2,
    }
    public abstract partial class CompositionObject
    {
        internal CompositionObject() { }
        public Avalonia.Rendering.Composition.Compositor Compositor { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Rendering.Composition.Animations.ImplicitAnimationCollection? ImplicitAnimations { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public bool IsDisposed { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        protected internal void Dispose() { }
        protected void RegisterForSerialization() { }
        public void StartAnimation(string propertyName, Avalonia.Rendering.Composition.Animations.CompositionAnimation animation) { }
        public void StartAnimationGroup(Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase grp) { }
    }
    public partial class CompositionPropertySet : Avalonia.Rendering.Composition.CompositionObject
    {
        internal CompositionPropertySet() { }
        public void InsertBoolean(string propertyName, bool value) { }
        public void InsertColor(string propertyName, Avalonia.Media.Color value) { }
        public void InsertMatrix3x2(string propertyName, System.Numerics.Matrix3x2 value) { }
        public void InsertMatrix4x4(string propertyName, System.Numerics.Matrix4x4 value) { }
        public void InsertQuaternion(string propertyName, System.Numerics.Quaternion value) { }
        public void InsertScalar(string propertyName, float value) { }
        public void InsertVector2(string propertyName, System.Numerics.Vector2 value) { }
        public void InsertVector3(string propertyName, System.Numerics.Vector3 value) { }
        public void InsertVector4(string propertyName, System.Numerics.Vector4 value) { }
        public Avalonia.Rendering.Composition.CompositionGetValueStatus TryGetBoolean(string propertyName, out bool value) { throw null; }
        public Avalonia.Rendering.Composition.CompositionGetValueStatus TryGetColor(string propertyName, out Avalonia.Media.Color value) { throw null; }
        public Avalonia.Rendering.Composition.CompositionGetValueStatus TryGetMatrix3x2(string propertyName, out System.Numerics.Matrix3x2 value) { throw null; }
        public Avalonia.Rendering.Composition.CompositionGetValueStatus TryGetMatrix4x4(string propertyName, out System.Numerics.Matrix4x4 value) { throw null; }
        public Avalonia.Rendering.Composition.CompositionGetValueStatus TryGetQuaternion(string propertyName, out System.Numerics.Quaternion value) { throw null; }
        public Avalonia.Rendering.Composition.CompositionGetValueStatus TryGetScalar(string propertyName, out float value) { throw null; }
        public Avalonia.Rendering.Composition.CompositionGetValueStatus TryGetVector2(string propertyName, out System.Numerics.Vector2 value) { throw null; }
        public Avalonia.Rendering.Composition.CompositionGetValueStatus TryGetVector3(string propertyName, out System.Numerics.Vector3 value) { throw null; }
        public Avalonia.Rendering.Composition.CompositionGetValueStatus TryGetVector4(string propertyName, out System.Numerics.Vector4 value) { throw null; }
    }
    public partial class CompositionSolidColorVisual : Avalonia.Rendering.Composition.CompositionContainerVisual
    {
        internal CompositionSolidColorVisual() { }
        public Avalonia.Media.Color Color { get { throw null; } set { } }
    }
    public enum CompositionStretch
    {
        None = 0,
        Fill = 1,
    }
    public partial class CompositionSurface : Avalonia.Rendering.Composition.CompositionObject
    {
        internal CompositionSurface() { }
    }
    public partial class CompositionSurfaceVisual : Avalonia.Rendering.Composition.CompositionContainerVisual
    {
        internal CompositionSurfaceVisual() { }
        public Avalonia.Rendering.Composition.CompositionSurface? Surface { get { throw null; } set { } }
    }
    [System.FlagsAttribute]
    public enum CompositionTileMode
    {
        None = 0,
        TileX = 1,
        TileY = 2,
        Tile = 3,
        FlipX = 4,
        FlipY = 8,
        Flip = 12,
    }
    public abstract partial class CompositionVisual : Avalonia.Rendering.Composition.CompositionObject
    {
        internal CompositionVisual() { }
        public System.Numerics.Vector2 AnchorPoint { get { throw null; } set { } }
        public System.Numerics.Vector3 CenterPoint { get { throw null; } set { } }
        public bool ClipToBounds { get { throw null; } set { } }
        public System.Numerics.Vector3 Offset { get { throw null; } set { } }
        public float Opacity { get { throw null; } set { } }
        public Avalonia.Media.IBrush? OpacityMask { get { throw null; } set { } }
        public System.Numerics.Quaternion Orientation { get { throw null; } set { } }
        public Avalonia.Media.RenderOptions RenderOptions { get { throw null; } set { } }
        public float RotationAngle { get { throw null; } set { } }
        public System.Numerics.Vector3 Scale { get { throw null; } set { } }
        public System.Numerics.Vector2 Size { get { throw null; } set { } }
        public System.Numerics.Matrix4x4 TransformMatrix { get { throw null; } set { } }
        public bool Visible { get { throw null; } set { } }
    }
    public partial class CompositionVisualCollection : Avalonia.Rendering.Composition.CompositionObject, System.Collections.Generic.ICollection<Avalonia.Rendering.Composition.CompositionVisual>, System.Collections.Generic.IEnumerable<Avalonia.Rendering.Composition.CompositionVisual>, System.Collections.Generic.IList<Avalonia.Rendering.Composition.CompositionVisual>, System.Collections.IEnumerable
    {
        internal CompositionVisualCollection() { }
        public int Count { get { throw null; } }
        public bool IsReadOnly { get { throw null; } }
        public Avalonia.Rendering.Composition.CompositionVisual this[int index] { get { throw null; } set { } }
        public void Add(Avalonia.Rendering.Composition.CompositionVisual item) { }
        public void Clear() { }
        public bool Contains(Avalonia.Rendering.Composition.CompositionVisual item) { throw null; }
        public void CopyTo(Avalonia.Rendering.Composition.CompositionVisual[] array, int arrayIndex) { }
        public System.Collections.Generic.List<Avalonia.Rendering.Composition.CompositionVisual>.Enumerator GetEnumerator() { throw null; }
        public int IndexOf(Avalonia.Rendering.Composition.CompositionVisual item) { throw null; }
        public void Insert(int index, Avalonia.Rendering.Composition.CompositionVisual item) { }
        public void InsertAbove(Avalonia.Rendering.Composition.CompositionVisual newChild, Avalonia.Rendering.Composition.CompositionVisual sibling) { }
        public void InsertAtBottom(Avalonia.Rendering.Composition.CompositionVisual newChild) { }
        public void InsertAtTop(Avalonia.Rendering.Composition.CompositionVisual newChild) { }
        public void InsertBelow(Avalonia.Rendering.Composition.CompositionVisual newChild, Avalonia.Rendering.Composition.CompositionVisual sibling) { }
        public bool Remove(Avalonia.Rendering.Composition.CompositionVisual item) { throw null; }
        public void RemoveAll() { }
        public void RemoveAt(int index) { }
        System.Collections.Generic.IEnumerator<Avalonia.Rendering.Composition.CompositionVisual> System.Collections.Generic.IEnumerable<Avalonia.Rendering.Composition.CompositionVisual>.GetEnumerator() { throw null; }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
    }
    public partial class Compositor
    {
        [Avalonia.Metadata.PrivateApiAttribute]
        public Compositor(Avalonia.Platform.IPlatformGraphics? gpu, bool useUiThreadForSynchronousCommits = false) { }
        public Avalonia.Rendering.Composition.Animations.CompositionAnimationGroup CreateAnimationGroup() { throw null; }
        public Avalonia.Rendering.Composition.BooleanKeyFrameAnimation CreateBooleanKeyFrameAnimation() { throw null; }
        public Avalonia.Rendering.Composition.ColorKeyFrameAnimation CreateColorKeyFrameAnimation() { throw null; }
        public Avalonia.Rendering.Composition.CompositionContainerVisual CreateContainerVisual() { throw null; }
        public Avalonia.Rendering.Composition.CompositionCustomVisual CreateCustomVisual(Avalonia.Rendering.Composition.CompositionCustomVisualHandler handler) { throw null; }
        public Avalonia.Rendering.Composition.CompositionDrawingSurface CreateDrawingSurface() { throw null; }
        public Avalonia.Rendering.Composition.Animations.ExpressionAnimation CreateExpressionAnimation() { throw null; }
        public Avalonia.Rendering.Composition.Animations.ExpressionAnimation CreateExpressionAnimation(string expression) { throw null; }
        public Avalonia.Rendering.Composition.Animations.ImplicitAnimationCollection CreateImplicitAnimationCollection() { throw null; }
        public Avalonia.Rendering.Composition.QuaternionKeyFrameAnimation CreateQuaternionKeyFrameAnimation() { throw null; }
        public Avalonia.Rendering.Composition.ScalarKeyFrameAnimation CreateScalarKeyFrameAnimation() { throw null; }
        public Avalonia.Rendering.Composition.CompositionSolidColorVisual CreateSolidColorVisual() { throw null; }
        public Avalonia.Rendering.Composition.CompositionSurfaceVisual CreateSurfaceVisual() { throw null; }
        public Avalonia.Rendering.Composition.Vector2KeyFrameAnimation CreateVector2KeyFrameAnimation() { throw null; }
        public Avalonia.Rendering.Composition.Vector3KeyFrameAnimation CreateVector3KeyFrameAnimation() { throw null; }
        public Avalonia.Rendering.Composition.Vector4KeyFrameAnimation CreateVector4KeyFrameAnimation() { throw null; }
        public System.Threading.Tasks.Task RequestCommitAsync() { throw null; }
        public void RequestCompositionUpdate(System.Action action) { }
        public System.Threading.Tasks.ValueTask<Avalonia.Rendering.Composition.ICompositionGpuInterop?> TryGetCompositionGpuInterop() { throw null; }
        public System.Threading.Tasks.ValueTask<object?> TryGetRenderInterfaceFeature(System.Type featureType) { throw null; }
    }
    public static partial class ElementComposition
    {
        public static Avalonia.Rendering.Composition.CompositionVisual? GetElementChildVisual(Avalonia.Visual visual) { throw null; }
        public static Avalonia.Rendering.Composition.CompositionVisual? GetElementVisual(Avalonia.Visual visual) { throw null; }
        public static void SetElementChildVisual(Avalonia.Visual visual, Avalonia.Rendering.Composition.CompositionVisual? compositionVisual) { }
    }
    public partial interface ICompositionGpuImportedObject : System.IAsyncDisposable
    {
        System.Threading.Tasks.Task ImportCompeted { get; }
        bool IsLost { get; }
    }
    public partial interface ICompositionGpuInterop
    {
        byte[]? DeviceLuid { get; set; }
        byte[]? DeviceUuid { get; set; }
        bool IsLost { get; }
        System.Collections.Generic.IReadOnlyList<string> SupportedImageHandleTypes { get; }
        System.Collections.Generic.IReadOnlyList<string> SupportedSemaphoreTypes { get; }
        Avalonia.Rendering.Composition.CompositionGpuImportedImageSynchronizationCapabilities GetSynchronizationCapabilities(string imageHandleType);
        Avalonia.Rendering.Composition.ICompositionImportedGpuImage ImportImage(Avalonia.Platform.IPlatformHandle handle, Avalonia.Platform.PlatformGraphicsExternalImageProperties properties);
        Avalonia.Rendering.Composition.ICompositionImportedGpuImage ImportImage(Avalonia.Rendering.Composition.ICompositionImportableSharedGpuContextImage image);
        Avalonia.Rendering.Composition.ICompositionImportedGpuSemaphore ImportSemaphore(Avalonia.Platform.IPlatformHandle handle);
        Avalonia.Rendering.Composition.ICompositionImportedGpuImage ImportSemaphore(Avalonia.Rendering.Composition.ICompositionImportableSharedGpuContextSemaphore image);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ICompositionImportableSharedGpuContextImage : System.IDisposable
    {
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ICompositionImportableSharedGpuContextObject : System.IDisposable
    {
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ICompositionImportableSharedGpuContextSemaphore : System.IDisposable
    {
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ICompositionImportedGpuImage : Avalonia.Rendering.Composition.ICompositionGpuImportedObject, System.IAsyncDisposable
    {
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface ICompositionImportedGpuSemaphore : Avalonia.Rendering.Composition.ICompositionGpuImportedObject, System.IAsyncDisposable
    {
    }
    public partial class QuaternionKeyFrameAnimation : Avalonia.Rendering.Composition.Animations.KeyFrameAnimation
    {
        public QuaternionKeyFrameAnimation(Avalonia.Rendering.Composition.Compositor compositor) { }
        public void InsertKeyFrame(float normalizedProgressKey, System.Numerics.Quaternion value) { }
        public void InsertKeyFrame(float normalizedProgressKey, System.Numerics.Quaternion value, Avalonia.Animation.Easings.IEasing easingFunction) { }
    }
    public partial class ScalarKeyFrameAnimation : Avalonia.Rendering.Composition.Animations.KeyFrameAnimation
    {
        public ScalarKeyFrameAnimation(Avalonia.Rendering.Composition.Compositor compositor) { }
        public void InsertKeyFrame(float normalizedProgressKey, float value) { }
        public void InsertKeyFrame(float normalizedProgressKey, float value, Avalonia.Animation.Easings.IEasing easingFunction) { }
    }
    public partial class Vector2KeyFrameAnimation : Avalonia.Rendering.Composition.Animations.KeyFrameAnimation
    {
        public Vector2KeyFrameAnimation(Avalonia.Rendering.Composition.Compositor compositor) { }
        public void InsertKeyFrame(float normalizedProgressKey, System.Numerics.Vector2 value) { }
        public void InsertKeyFrame(float normalizedProgressKey, System.Numerics.Vector2 value, Avalonia.Animation.Easings.IEasing easingFunction) { }
    }
    public partial class Vector3KeyFrameAnimation : Avalonia.Rendering.Composition.Animations.KeyFrameAnimation
    {
        public Vector3KeyFrameAnimation(Avalonia.Rendering.Composition.Compositor compositor) { }
        public void InsertKeyFrame(float normalizedProgressKey, System.Numerics.Vector3 value) { }
        public void InsertKeyFrame(float normalizedProgressKey, System.Numerics.Vector3 value, Avalonia.Animation.Easings.IEasing easingFunction) { }
    }
    public partial class Vector4KeyFrameAnimation : Avalonia.Rendering.Composition.Animations.KeyFrameAnimation
    {
        public Vector4KeyFrameAnimation(Avalonia.Rendering.Composition.Compositor compositor) { }
        public void InsertKeyFrame(float normalizedProgressKey, System.Numerics.Vector4 value) { }
        public void InsertKeyFrame(float normalizedProgressKey, System.Numerics.Vector4 value, Avalonia.Animation.Easings.IEasing easingFunction) { }
    }
}
namespace Avalonia.Rendering.Composition.Animations
{
    public enum AnimationDelayBehavior
    {
        SetInitialValueAfterDelay = 0,
        SetInitialValueBeforeDelay = 1,
    }
    public enum AnimationIterationBehavior
    {
        Count = 0,
        Forever = 1,
    }
    public enum AnimationStopBehavior
    {
        LeaveCurrentValue = 0,
        SetToInitialValue = 1,
        SetToFinalValue = 2,
    }
    public abstract partial class CompositionAnimation : Avalonia.Rendering.Composition.CompositionObject, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase
    {
        internal CompositionAnimation() { }
        public string? Target { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public void ClearAllParameters() { }
        public void ClearParameter(string key) { }
        public void SetColorParameter(string key, Avalonia.Media.Color value) { }
        public void SetMatrix3x2Parameter(string key, System.Numerics.Matrix3x2 value) { }
        public void SetMatrix4x4Parameter(string key, System.Numerics.Matrix4x4 value) { }
        public void SetQuaternionParameter(string key, System.Numerics.Quaternion value) { }
        public void SetReferenceParameter(string key, Avalonia.Rendering.Composition.CompositionObject compositionObject) { }
        public void SetScalarParameter(string key, float value) { }
        public void SetVector2Parameter(string key, System.Numerics.Vector2 value) { }
        public void SetVector3Parameter(string key, System.Numerics.Vector3 value) { }
        public void SetVector4Parameter(string key, System.Numerics.Vector4 value) { }
    }
    public partial class CompositionAnimationGroup : Avalonia.Rendering.Composition.CompositionObject, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase
    {
        public CompositionAnimationGroup(Avalonia.Rendering.Composition.Compositor compositor) { }
        public void Add(Avalonia.Rendering.Composition.Animations.CompositionAnimation value) { }
        public void Remove(Avalonia.Rendering.Composition.Animations.CompositionAnimation value) { }
        public void RemoveAll() { }
    }
    public partial class ExpressionAnimation : Avalonia.Rendering.Composition.Animations.CompositionAnimation
    {
        internal ExpressionAnimation() { }
        public string? Expression { get { throw null; } set { } }
    }
    public partial interface ICompositionAnimationBase
    {
    }
    public partial class ImplicitAnimationCollection : Avalonia.Rendering.Composition.CompositionObject, System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>>, System.Collections.Generic.IDictionary<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>>, System.Collections.IEnumerable
    {
        internal ImplicitAnimationCollection() { }
        public int Count { get { throw null; } }
        public Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase this[string key] { get { throw null; } set { } }
        public uint Size { get { throw null; } }
        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>>.IsReadOnly { get { throw null; } }
        System.Collections.Generic.ICollection<string> System.Collections.Generic.IDictionary<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>.Keys { get { throw null; } }
        System.Collections.Generic.ICollection<Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase> System.Collections.Generic.IDictionary<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>.Values { get { throw null; } }
        public void Add(string key, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase value) { }
        public void Clear() { }
        public bool ContainsKey(string key) { throw null; }
        public System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>> GetEnumerator() { throw null; }
        public System.Collections.Generic.IReadOnlyDictionary<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase> GetView() { throw null; }
        public bool HasKey(string key) { throw null; }
        public void Insert(string key, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase animation) { }
        public Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase? Lookup(string key) { throw null; }
        public bool Remove(string key) { throw null; }
        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>>.Add(System.Collections.Generic.KeyValuePair<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase> item) { }
        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>>.Contains(System.Collections.Generic.KeyValuePair<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase> item) { throw null; }
        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>>.CopyTo(System.Collections.Generic.KeyValuePair<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>[] array, int arrayIndex) { }
        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase>>.Remove(System.Collections.Generic.KeyValuePair<string, Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase> item) { throw null; }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
        public bool TryGetValue(string key, [System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute(false)] out Avalonia.Rendering.Composition.Animations.ICompositionAnimationBase value) { throw null; }
    }
    public abstract partial class KeyFrameAnimation : Avalonia.Rendering.Composition.Animations.CompositionAnimation
    {
        internal KeyFrameAnimation() { }
        public Avalonia.Rendering.Composition.Animations.AnimationDelayBehavior DelayBehavior { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.TimeSpan DelayTime { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Animation.PlaybackDirection Direction { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.TimeSpan Duration { get { throw null; } set { } }
        public Avalonia.Rendering.Composition.Animations.AnimationIterationBehavior IterationBehavior { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int IterationCount { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public Avalonia.Rendering.Composition.Animations.AnimationStopBehavior StopBehavior { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public void InsertExpressionKeyFrame(float normalizedProgressKey, string value, Avalonia.Animation.Easings.Easing? easingFunction = null) { }
    }
}
namespace Avalonia.Rendering.Composition.Transport
{
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct BatchStreamSegment<TData> : System.IEquatable<Avalonia.Rendering.Composition.Transport.BatchStreamSegment<TData>>
    {
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        private TData _Data_k__BackingField;
        private int _dummyPrimitive;
        public TData Data { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int ElementCount { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Rendering.Composition.Transport.BatchStreamSegment<TData> other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Rendering.Composition.Transport.BatchStreamSegment<TData> left, Avalonia.Rendering.Composition.Transport.BatchStreamSegment<TData> right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Rendering.Composition.Transport.BatchStreamSegment<TData> left, Avalonia.Rendering.Composition.Transport.BatchStreamSegment<TData> right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
}
namespace Avalonia.Rendering.SceneGraph
{
    public partial interface ICustomDrawOperation : System.IDisposable, System.IEquatable<Avalonia.Rendering.SceneGraph.ICustomDrawOperation>
    {
        Avalonia.Rect Bounds { get; }
        bool HitTest(Avalonia.Point p);
        void Render(Avalonia.Media.ImmediateDrawingContext context);
    }
}
namespace Avalonia.Styling
{
    public partial class ControlTheme : Avalonia.Styling.StyleBase
    {
        public ControlTheme() { }
        public ControlTheme(System.Type targetType) { }
        public Avalonia.Styling.ControlTheme? BasedOn { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public System.Type? TargetType { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public override string ToString() { throw null; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IGlobalStyles : Avalonia.Styling.IStyleHost
    {
        event System.Action<System.Collections.Generic.IReadOnlyList<Avalonia.Styling.IStyle>>? GlobalStylesAdded;
        event System.Action<System.Collections.Generic.IReadOnlyList<Avalonia.Styling.IStyle>>? GlobalStylesRemoved;
    }
    [Avalonia.Metadata.UnstableAttribute]
    public partial interface ISetterInstance
    {
    }
    public partial interface ISetterValue
    {
        void Initialize(Avalonia.Styling.SetterBase setter);
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IStyle : Avalonia.Controls.IResourceNode
    {
        System.Collections.Generic.IReadOnlyList<Avalonia.Styling.IStyle> Children { get; }
    }
    [System.ObsoleteAttribute("This interface may be removed in 12.0. Use StyledElement, or override StyledElement.StyleKeyOverride to override the StyleKey for a class.")]
    public partial interface IStyleable : Avalonia.INamed
    {
        Avalonia.Collections.IAvaloniaReadOnlyList<string> Classes { get; }
        [System.ObsoleteAttribute("Override StyledElement.StyleKeyOverride instead.")]
        System.Type StyleKey { get; }
        Avalonia.AvaloniaObject? TemplatedParent { get; }
    }
    [Avalonia.Metadata.NotClientImplementableAttribute]
    public partial interface IStyleHost
    {
        bool IsStylesInitialized { get; }
        Avalonia.Styling.Styles Styles { get; }
        Avalonia.Styling.IStyleHost? StylingParent { get; }
        void StylesAdded(System.Collections.Generic.IReadOnlyList<Avalonia.Styling.IStyle> styles);
        void StylesRemoved(System.Collections.Generic.IReadOnlyList<Avalonia.Styling.IStyle> styles);
    }
    public partial interface ITemplate
    {
        object? Build();
    }
    public partial interface IThemeVariantHost : Avalonia.Controls.IResourceHost, Avalonia.Controls.IResourceNode
    {
        Avalonia.Styling.ThemeVariant ActualThemeVariant { get; }
        event System.EventHandler? ActualThemeVariantChanged;
    }
    public abstract partial class Selector
    {
        protected Selector() { }
        internal abstract bool InTemplate { get; }
        internal abstract bool IsCombinator { get; }
        internal abstract System.Type? TargetType { get; }
        private protected abstract Avalonia.Styling.SelectorMatch Evaluate(Avalonia.StyledElement control, Avalonia.Styling.IStyle? parent, bool subscribe);
        private protected abstract Avalonia.Styling.Selector? MovePrevious();
        private protected abstract Avalonia.Styling.Selector? MovePreviousOrParent();
        public override string ToString() { throw null; }
        public abstract string ToString(Avalonia.Styling.Style? owner);
    }
    public static partial class Selectors
    {
        public static Avalonia.Styling.Selector Child(this Avalonia.Styling.Selector previous) { throw null; }
        public static Avalonia.Styling.Selector Class(this Avalonia.Styling.Selector? previous, string name) { throw null; }
        public static Avalonia.Styling.Selector Descendant(this Avalonia.Styling.Selector? previous) { throw null; }
        public static Avalonia.Styling.Selector Is(this Avalonia.Styling.Selector? previous, System.Type type) { throw null; }
        public static Avalonia.Styling.Selector Is<T>(this Avalonia.Styling.Selector? previous) where T : Avalonia.StyledElement { throw null; }
        public static Avalonia.Styling.Selector Name(this Avalonia.Styling.Selector? previous, string name) { throw null; }
        public static Avalonia.Styling.Selector Nesting(this Avalonia.Styling.Selector? previous) { throw null; }
        public static Avalonia.Styling.Selector Not(this Avalonia.Styling.Selector? previous, Avalonia.Styling.Selector argument) { throw null; }
        public static Avalonia.Styling.Selector Not(this Avalonia.Styling.Selector? previous, System.Func<Avalonia.Styling.Selector?, Avalonia.Styling.Selector> argument) { throw null; }
        public static Avalonia.Styling.Selector NthChild(this Avalonia.Styling.Selector? previous, int step, int offset) { throw null; }
        public static Avalonia.Styling.Selector NthLastChild(this Avalonia.Styling.Selector? previous, int step, int offset) { throw null; }
        public static Avalonia.Styling.Selector OfType(this Avalonia.Styling.Selector? previous, System.Type type) { throw null; }
        public static Avalonia.Styling.Selector OfType<T>(this Avalonia.Styling.Selector? previous) where T : Avalonia.StyledElement { throw null; }
        public static Avalonia.Styling.Selector Or(params Avalonia.Styling.Selector[] selectors) { throw null; }
        public static Avalonia.Styling.Selector Or(System.Collections.Generic.IReadOnlyList<Avalonia.Styling.Selector> selectors) { throw null; }
        public static Avalonia.Styling.Selector PropertyEquals(this Avalonia.Styling.Selector? previous, Avalonia.AvaloniaProperty property, object? value) { throw null; }
        public static Avalonia.Styling.Selector PropertyEquals<T>(this Avalonia.Styling.Selector? previous, Avalonia.AvaloniaProperty<T> property, object? value) { throw null; }
        public static Avalonia.Styling.Selector Template(this Avalonia.Styling.Selector previous) { throw null; }
    }
    public partial class Setter : Avalonia.Styling.SetterBase, Avalonia.Animation.IAnimationSetter, Avalonia.Styling.ISetterInstance
    {
        public Setter() { }
        public Setter(Avalonia.AvaloniaProperty property, object? value) { }
        public Avalonia.AvaloniaProperty? Property { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        [Avalonia.Data.AssignBindingAttribute]
        [Avalonia.Metadata.ContentAttribute]
        [Avalonia.Metadata.DependsOnAttribute("Property")]
        public object? Value { get { throw null; } set { } }
        public override string ToString() { throw null; }
    }
    public abstract partial class SetterBase
    {
        protected SetterBase() { }
        internal abstract Avalonia.Styling.ISetterInstance Instance(Avalonia.Styling.IStyleInstance styleInstance, Avalonia.StyledElement target);
    }
    public partial class Style : Avalonia.Styling.StyleBase
    {
        public Style() { }
        public Style(System.Func<Avalonia.Styling.Selector?, Avalonia.Styling.Selector> selector) { }
        public Avalonia.Styling.Selector? Selector { get { throw null; } set { } }
        public override string ToString() { throw null; }
    }
    public abstract partial class StyleBase : Avalonia.AvaloniaObject, Avalonia.Controls.IResourceNode, Avalonia.Controls.IResourceProvider, Avalonia.Styling.IStyle
    {
        protected StyleBase() { }
        public System.Collections.Generic.IList<Avalonia.Animation.IAnimation> Animations { get { throw null; } }
        bool Avalonia.Controls.IResourceNode.HasResources { get { throw null; } }
        System.Collections.Generic.IReadOnlyList<Avalonia.Styling.IStyle> Avalonia.Styling.IStyle.Children { get { throw null; } }
        public System.Collections.Generic.IList<Avalonia.Styling.IStyle> Children { get { throw null; } }
        public Avalonia.Controls.IResourceHost? Owner { get { throw null; } }
        public Avalonia.Styling.IStyle? Parent { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Controls.IResourceDictionary Resources { get { throw null; } set { } }
        public System.Collections.Generic.IList<Avalonia.Styling.SetterBase> Setters { get { throw null; } }
        public event System.EventHandler? OwnerChanged { add { } remove { } }
        public void Add(Avalonia.Styling.IStyle style) { }
        public void Add(Avalonia.Styling.SetterBase setter) { }
        void Avalonia.Controls.IResourceProvider.AddOwner(Avalonia.Controls.IResourceHost owner) { }
        void Avalonia.Controls.IResourceProvider.RemoveOwner(Avalonia.Controls.IResourceHost owner) { }
        public bool TryGetResource(object key, Avalonia.Styling.ThemeVariant? themeVariant, out object? result) { throw null; }
    }
    public partial class Styles : Avalonia.AvaloniaObject, Avalonia.Collections.IAvaloniaList<Avalonia.Styling.IStyle>, Avalonia.Collections.IAvaloniaReadOnlyList<Avalonia.Styling.IStyle>, Avalonia.Controls.IResourceNode, Avalonia.Controls.IResourceProvider, Avalonia.Styling.IStyle, System.Collections.Generic.ICollection<Avalonia.Styling.IStyle>, System.Collections.Generic.IEnumerable<Avalonia.Styling.IStyle>, System.Collections.Generic.IList<Avalonia.Styling.IStyle>, System.Collections.Generic.IReadOnlyCollection<Avalonia.Styling.IStyle>, System.Collections.Generic.IReadOnlyList<Avalonia.Styling.IStyle>, System.Collections.IEnumerable, System.Collections.Specialized.INotifyCollectionChanged, System.ComponentModel.INotifyPropertyChanged
    {
        public Styles() { }
        public Styles(Avalonia.Controls.IResourceHost owner) { }
        bool Avalonia.Controls.IResourceNode.HasResources { get { throw null; } }
        System.Collections.Generic.IReadOnlyList<Avalonia.Styling.IStyle> Avalonia.Styling.IStyle.Children { get { throw null; } }
        public int Count { get { throw null; } }
        public Avalonia.Styling.IStyle this[int index] { get { throw null; } set { } }
        public Avalonia.Controls.IResourceHost? Owner { get { throw null; } }
        public Avalonia.Controls.IResourceDictionary Resources { get { throw null; } set { } }
        bool System.Collections.Generic.ICollection<Avalonia.Styling.IStyle>.IsReadOnly { get { throw null; } }
        Avalonia.Styling.IStyle System.Collections.Generic.IReadOnlyList<Avalonia.Styling.IStyle>.this[int index] { get { throw null; } }
        public event System.Collections.Specialized.NotifyCollectionChangedEventHandler? CollectionChanged { add { } remove { } }
        public event System.EventHandler? OwnerChanged { add { } remove { } }
        public void Add(Avalonia.Styling.IStyle item) { }
        public void AddRange(System.Collections.Generic.IEnumerable<Avalonia.Styling.IStyle> items) { }
        void Avalonia.Controls.IResourceProvider.AddOwner(Avalonia.Controls.IResourceHost owner) { }
        void Avalonia.Controls.IResourceProvider.RemoveOwner(Avalonia.Controls.IResourceHost owner) { }
        public void Clear() { }
        public bool Contains(Avalonia.Styling.IStyle item) { throw null; }
        public void CopyTo(Avalonia.Styling.IStyle[] array, int arrayIndex) { }
        public Avalonia.Collections.AvaloniaList<Avalonia.Styling.IStyle>.Enumerator GetEnumerator() { throw null; }
        public int IndexOf(Avalonia.Styling.IStyle item) { throw null; }
        public void Insert(int index, Avalonia.Styling.IStyle item) { }
        public void InsertRange(int index, System.Collections.Generic.IEnumerable<Avalonia.Styling.IStyle> items) { }
        public void Move(int oldIndex, int newIndex) { }
        public void MoveRange(int oldIndex, int count, int newIndex) { }
        public bool Remove(Avalonia.Styling.IStyle item) { throw null; }
        public void RemoveAll(System.Collections.Generic.IEnumerable<Avalonia.Styling.IStyle> items) { }
        public void RemoveAt(int index) { }
        public void RemoveRange(int index, int count) { }
        System.Collections.Generic.IEnumerator<Avalonia.Styling.IStyle> System.Collections.Generic.IEnumerable<Avalonia.Styling.IStyle>.GetEnumerator() { throw null; }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
        public bool TryGetResource(object key, Avalonia.Styling.ThemeVariant? theme, out object? value) { throw null; }
    }
    [System.ComponentModel.TypeConverterAttribute(typeof(Avalonia.Styling.ThemeVariantTypeConverter))]
    public sealed partial class ThemeVariant : System.IEquatable<Avalonia.Styling.ThemeVariant>
    {
        public ThemeVariant(object key, Avalonia.Styling.ThemeVariant? inheritVariant) { }
        public static Avalonia.Styling.ThemeVariant Dark { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Styling.ThemeVariant Default { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Styling.ThemeVariant? InheritVariant { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public object Key { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public static Avalonia.Styling.ThemeVariant Light { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Equals(Avalonia.Styling.ThemeVariant? other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Styling.ThemeVariant? left, Avalonia.Styling.ThemeVariant? right) { throw null; }
        public static explicit operator Avalonia.Styling.ThemeVariant (Avalonia.Platform.PlatformThemeVariant themeVariant) { throw null; }
        public static explicit operator Avalonia.Platform.PlatformThemeVariant? (Avalonia.Styling.ThemeVariant themeVariant) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Styling.ThemeVariant? left, Avalonia.Styling.ThemeVariant? right) { throw null; }
        public override string ToString() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public Avalonia.Styling.ThemeVariant <Clone>$() { throw null; }
    }
    public partial class ThemeVariantTypeConverter : System.ComponentModel.TypeConverter
    {
        public ThemeVariantTypeConverter() { }
        public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Type sourceType) { throw null; }
        public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object value) { throw null; }
    }
}
namespace Avalonia.Threading
{
    public partial class AvaloniaSynchronizationContext : System.Threading.SynchronizationContext
    {
        public AvaloniaSynchronizationContext() { }
        public AvaloniaSynchronizationContext(Avalonia.Threading.DispatcherPriority priority) { }
        public static bool AutoInstall { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public static Avalonia.Threading.AvaloniaSynchronizationContext.RestoreContext Ensure(Avalonia.Threading.DispatcherPriority priority) { throw null; }
        public static void InstallIfNeeded() { }
        public override void Post(System.Threading.SendOrPostCallback d, object? state) { }
        public override void Send(System.Threading.SendOrPostCallback d, object? state) { }
        public override int Wait(System.IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout) { throw null; }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public partial struct RestoreContext : System.IDisposable, System.IEquatable<Avalonia.Threading.AvaloniaSynchronizationContext.RestoreContext>
        {
            private object _dummy;
            private int _dummyPrimitive;
            public void Dispose() { }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public bool Equals(Avalonia.Threading.AvaloniaSynchronizationContext.RestoreContext other) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override bool Equals(object obj) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override int GetHashCode() { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public static bool operator ==(Avalonia.Threading.AvaloniaSynchronizationContext.RestoreContext left, Avalonia.Threading.AvaloniaSynchronizationContext.RestoreContext right) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public static bool operator !=(Avalonia.Threading.AvaloniaSynchronizationContext.RestoreContext left, Avalonia.Threading.AvaloniaSynchronizationContext.RestoreContext right) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override string ToString() { throw null; }
        }
    }
    public partial class Dispatcher : Avalonia.Threading.IDispatcher
    {
        internal Dispatcher() { }
        public bool SupportsRunLoops { get { throw null; } }
        public static Avalonia.Threading.Dispatcher UIThread { get { throw null; } }
        public event System.EventHandler? ShutdownFinished { add { } remove { } }
        public event System.EventHandler? ShutdownStarted { add { } remove { } }
        public void BeginInvokeShutdown(Avalonia.Threading.DispatcherPriority priority) { }
        public bool CheckAccess() { throw null; }
        public Avalonia.Threading.Dispatcher.DispatcherProcessingDisabled DisableProcessing() { throw null; }
        public void ExitAllFrames() { }
        public bool HasJobsWithPriority(Avalonia.Threading.DispatcherPriority priority) { throw null; }
        public void Invoke(System.Action callback) { }
        public void Invoke(System.Action callback, Avalonia.Threading.DispatcherPriority priority) { }
        public void Invoke(System.Action callback, Avalonia.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken) { }
        public void Invoke(System.Action callback, Avalonia.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, System.TimeSpan timeout) { }
        public Avalonia.Threading.DispatcherOperation InvokeAsync(System.Action callback) { throw null; }
        public Avalonia.Threading.DispatcherOperation InvokeAsync(System.Action callback, Avalonia.Threading.DispatcherPriority priority) { throw null; }
        public Avalonia.Threading.DispatcherOperation InvokeAsync(System.Action callback, Avalonia.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken) { throw null; }
        public System.Threading.Tasks.Task InvokeAsync(System.Func<System.Threading.Tasks.Task> callback) { throw null; }
        public System.Threading.Tasks.Task InvokeAsync(System.Func<System.Threading.Tasks.Task> callback, Avalonia.Threading.DispatcherPriority priority) { throw null; }
        public System.Threading.Tasks.Task<TResult> InvokeAsync<TResult>(System.Func<System.Threading.Tasks.Task<TResult>> action) { throw null; }
        public System.Threading.Tasks.Task<TResult> InvokeAsync<TResult>(System.Func<System.Threading.Tasks.Task<TResult>> action, Avalonia.Threading.DispatcherPriority priority) { throw null; }
        public Avalonia.Threading.DispatcherOperation<TResult> InvokeAsync<TResult>(System.Func<TResult> callback) { throw null; }
        public Avalonia.Threading.DispatcherOperation<TResult> InvokeAsync<TResult>(System.Func<TResult> callback, Avalonia.Threading.DispatcherPriority priority) { throw null; }
        public Avalonia.Threading.DispatcherOperation<TResult> InvokeAsync<TResult>(System.Func<TResult> callback, Avalonia.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken) { throw null; }
        public void InvokeShutdown() { }
        public TResult Invoke<TResult>(System.Func<TResult> callback) { throw null; }
        public TResult Invoke<TResult>(System.Func<TResult> callback, Avalonia.Threading.DispatcherPriority priority) { throw null; }
        public TResult Invoke<TResult>(System.Func<TResult> callback, Avalonia.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken) { throw null; }
        public TResult Invoke<TResult>(System.Func<TResult> callback, Avalonia.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, System.TimeSpan timeout) { throw null; }
        public void MainLoop(System.Threading.CancellationToken cancellationToken) { }
        public void Post(System.Action action, Avalonia.Threading.DispatcherPriority priority = default(Avalonia.Threading.DispatcherPriority)) { }
        public void Post(System.Threading.SendOrPostCallback action, object? arg, Avalonia.Threading.DispatcherPriority priority = default(Avalonia.Threading.DispatcherPriority)) { }
        public void PushFrame(Avalonia.Threading.DispatcherFrame frame) { }
        public void RunJobs(Avalonia.Threading.DispatcherPriority? priority = default(Avalonia.Threading.DispatcherPriority?)) { }
        public void VerifyAccess() { }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public partial struct DispatcherProcessingDisabled : System.IDisposable, System.IEquatable<Avalonia.Threading.Dispatcher.DispatcherProcessingDisabled>
        {
            private object _dummy;
            private int _dummyPrimitive;
            public void Dispose() { }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public bool Equals(Avalonia.Threading.Dispatcher.DispatcherProcessingDisabled other) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override bool Equals(object obj) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override int GetHashCode() { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public static bool operator ==(Avalonia.Threading.Dispatcher.DispatcherProcessingDisabled left, Avalonia.Threading.Dispatcher.DispatcherProcessingDisabled right) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public static bool operator !=(Avalonia.Threading.Dispatcher.DispatcherProcessingDisabled left, Avalonia.Threading.Dispatcher.DispatcherProcessingDisabled right) { throw null; }
            [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
            public override string ToString() { throw null; }
        }
    }
    public partial class DispatcherFrame
    {
        public DispatcherFrame() { }
        public DispatcherFrame(bool exitWhenRequested) { }
        public bool Continue { get { throw null; } set { } }
        public Avalonia.Threading.Dispatcher Dispatcher { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
    }
    public partial class DispatcherOperation
    {
        internal DispatcherOperation() { }
        protected object? Callback;
        protected object? TaskSource;
        protected readonly bool ThrowOnUiThread;
        public Avalonia.Threading.Dispatcher Dispatcher { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Threading.DispatcherPriority Priority { get { throw null; } set { } }
        public Avalonia.Threading.DispatcherOperationStatus Status { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] protected set { } }
        public event System.EventHandler Aborted { add { } remove { } }
        public event System.EventHandler Completed { add { } remove { } }
        public bool Abort() { throw null; }
        protected virtual void AbortTask() { }
        [System.ComponentModel.BrowsableAttribute(false)]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() { throw null; }
        public System.Threading.Tasks.Task GetTask() { throw null; }
        protected virtual System.Threading.Tasks.Task GetTaskCore() { throw null; }
        protected virtual void InvokeCore() { }
        public void Wait() { }
        public void Wait(System.TimeSpan timeout) { }
    }
    public enum DispatcherOperationStatus
    {
        Pending = 0,
        Aborted = 1,
        Completed = 2,
        Executing = 3,
    }
    public partial class DispatcherOperation<T> : Avalonia.Threading.DispatcherOperation
    {
        public DispatcherOperation(Avalonia.Threading.Dispatcher dispatcher, Avalonia.Threading.DispatcherPriority priority, System.Func<T> callback) { }
        public T Result { get { throw null; } }
        protected override void AbortTask() { }
        public new System.Runtime.CompilerServices.TaskAwaiter<T> GetAwaiter() { throw null; }
        public new System.Threading.Tasks.Task<T> GetTask() { throw null; }
        protected override System.Threading.Tasks.Task GetTaskCore() { throw null; }
        protected override void InvokeCore() { }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct DispatcherPriority : System.IComparable<Avalonia.Threading.DispatcherPriority>, System.IEquatable<Avalonia.Threading.DispatcherPriority>
    {
        private readonly int _dummyPrimitive;
        public static readonly Avalonia.Threading.DispatcherPriority ApplicationIdle;
        [Avalonia.Metadata.PrivateApiAttribute]
        public static readonly Avalonia.Threading.DispatcherPriority AsyncRenderTargetResize;
        public static readonly Avalonia.Threading.DispatcherPriority Background;
        [Avalonia.Metadata.PrivateApiAttribute]
        public static readonly Avalonia.Threading.DispatcherPriority BeforeRender;
        public static readonly Avalonia.Threading.DispatcherPriority ContextIdle;
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.ObsoleteAttribute("WPF compatibility")]
        public static readonly Avalonia.Threading.DispatcherPriority DataBind;
        public static readonly Avalonia.Threading.DispatcherPriority Default;
        public static readonly Avalonia.Threading.DispatcherPriority Inactive;
        public static readonly Avalonia.Threading.DispatcherPriority Input;
        public static readonly Avalonia.Threading.DispatcherPriority Invalid;
        public static readonly Avalonia.Threading.DispatcherPriority Loaded;
        public static readonly Avalonia.Threading.DispatcherPriority MaxValue;
        public static readonly Avalonia.Threading.DispatcherPriority Normal;
        public static readonly Avalonia.Threading.DispatcherPriority Render;
        public static readonly Avalonia.Threading.DispatcherPriority Send;
        public static readonly Avalonia.Threading.DispatcherPriority SystemIdle;
        [Avalonia.Metadata.PrivateApiAttribute]
        public static readonly Avalonia.Threading.DispatcherPriority UiThreadRender;
        public int Value { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int CompareTo(Avalonia.Threading.DispatcherPriority other) { throw null; }
        public bool Equals(Avalonia.Threading.DispatcherPriority other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public static Avalonia.Threading.DispatcherPriority FromValue(int value) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.Threading.DispatcherPriority left, Avalonia.Threading.DispatcherPriority right) { throw null; }
        public static bool operator >(Avalonia.Threading.DispatcherPriority left, Avalonia.Threading.DispatcherPriority right) { throw null; }
        public static bool operator >=(Avalonia.Threading.DispatcherPriority left, Avalonia.Threading.DispatcherPriority right) { throw null; }
        public static implicit operator int (Avalonia.Threading.DispatcherPriority priority) { throw null; }
        public static implicit operator Avalonia.Threading.DispatcherPriority (int value) { throw null; }
        public static bool operator !=(Avalonia.Threading.DispatcherPriority left, Avalonia.Threading.DispatcherPriority right) { throw null; }
        public static bool operator <(Avalonia.Threading.DispatcherPriority left, Avalonia.Threading.DispatcherPriority right) { throw null; }
        public static bool operator <=(Avalonia.Threading.DispatcherPriority left, Avalonia.Threading.DispatcherPriority right) { throw null; }
        public override string ToString() { throw null; }
        public static void Validate(Avalonia.Threading.DispatcherPriority priority, string parameterName) { }
    }
    public partial class DispatcherTimer
    {
        public DispatcherTimer() { }
        public DispatcherTimer(Avalonia.Threading.DispatcherPriority priority) { }
        public DispatcherTimer(System.TimeSpan interval, Avalonia.Threading.DispatcherPriority priority, System.EventHandler callback) { }
        public Avalonia.Threading.Dispatcher Dispatcher { get { throw null; } }
        public System.TimeSpan Interval { get { throw null; } set { } }
        public bool IsEnabled { get { throw null; } set { } }
        public object? Tag { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public event System.EventHandler? Tick { add { } remove { } }
        public static System.IDisposable Run(System.Func<bool> action, System.TimeSpan interval, Avalonia.Threading.DispatcherPriority priority = default(Avalonia.Threading.DispatcherPriority)) { throw null; }
        public static System.IDisposable RunOnce(System.Action action, System.TimeSpan interval, Avalonia.Threading.DispatcherPriority priority = default(Avalonia.Threading.DispatcherPriority)) { throw null; }
        public void Start() { }
        public void Stop() { }
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial interface IControlledDispatcherImpl : Avalonia.Threading.IDispatcherImpl, Avalonia.Threading.IDispatcherImplWithPendingInput
    {
        void RunLoop(System.Threading.CancellationToken token);
    }
    public partial interface IDispatcher
    {
        bool CheckAccess();
        void Post(System.Action action, Avalonia.Threading.DispatcherPriority priority = default(Avalonia.Threading.DispatcherPriority));
        void VerifyAccess();
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial interface IDispatcherImpl
    {
        bool CurrentThreadIsLoopThread { get; }
        long Now { get; }
        event System.Action Signaled;
        event System.Action Timer;
        void Signal();
        void UpdateTimer(long? dueTimeInMs);
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial interface IDispatcherImplWithExplicitBackgroundProcessing : Avalonia.Threading.IDispatcherImpl
    {
        event System.Action ReadyForBackgroundProcessing;
        void RequestBackgroundProcessing();
    }
    [Avalonia.Metadata.PrivateApiAttribute]
    public partial interface IDispatcherImplWithPendingInput : Avalonia.Threading.IDispatcherImpl
    {
        bool CanQueryPendingInput { get; }
        bool HasPendingInput { get; }
    }
}
namespace Avalonia.Utilities
{
    public partial class AvaloniaResourcesIndexEntry
    {
        public AvaloniaResourcesIndexEntry() { }
        public int Offset { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public string? Path { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
        public int Size { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute] set { } }
    }
    public static partial class AvaloniaResourcesIndexReaderWriter
    {
        public static System.Collections.Generic.List<Avalonia.Utilities.AvaloniaResourcesIndexEntry> ReadIndex(System.IO.Stream stream) { throw null; }
        public static void WriteIndex(System.IO.Stream output, System.Collections.Generic.List<Avalonia.Utilities.AvaloniaResourcesIndexEntry> entries) { }
        public static void WriteResources(System.IO.Stream output, System.Collections.Generic.List<(string Path, int Size, System.Func<System.IO.Stream> Open)> resources) { }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public ref partial struct CharacterReader
    {
        private object _dummy;
        private int _dummyPrimitive;
        public CharacterReader(System.ReadOnlySpan<char> s) { throw null; }
        public bool End { get { throw null; } }
        public char Peek { get { throw null; } }
        public int Position { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public System.ReadOnlySpan<char> PeekWhitespace() { throw null; }
        public void Skip(int count) { }
        public void SkipWhitespace() { }
        public char Take() { throw null; }
        public bool TakeIf(char c) { throw null; }
        public bool TakeIf(System.Func<char, bool> condition) { throw null; }
        public System.ReadOnlySpan<char> TakeUntil(char c) { throw null; }
        public System.ReadOnlySpan<char> TakeWhile(System.Func<char, bool> condition) { throw null; }
        public System.ReadOnlySpan<char> TryPeek(int count) { throw null; }
    }
    public static partial class IdentifierParser
    {
        public static System.ReadOnlySpan<char> ParseIdentifier(this ref Avalonia.Utilities.CharacterReader r) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct ImmutableReadOnlyListStructEnumerator<T> : System.Collections.Generic.IEnumerator<T>, System.Collections.IEnumerator, System.IDisposable
    {
        private T _current;
        private object _dummy;
        private int _dummyPrimitive;
        public ImmutableReadOnlyListStructEnumerator(System.Collections.Generic.IReadOnlyList<T> readOnlyList) { throw null; }
        public T Current { get { throw null; } }
        object? System.Collections.IEnumerator.Current { get { throw null; } }
        public void Dispose() { }
        public bool MoveNext() { throw null; }
        public void Reset() { }
    }
    public partial interface IWeakEventSubscriber<in TEventArgs> where TEventArgs : System.EventArgs
    {
        void OnEvent(object? sender, Avalonia.Utilities.WeakEvent ev, TEventArgs e);
    }
    public static partial class KeywordParser
    {
        public static bool CheckKeyword(this ref Avalonia.Utilities.CharacterReader r, string keyword) { throw null; }
        public static bool TakeIfKeyword(this ref Avalonia.Utilities.CharacterReader r, string keyword) { throw null; }
    }
    public static partial class MathUtilities
    {
        public static bool AreClose(double value1, double value2) { throw null; }
        public static bool AreClose(double value1, double value2, double eps) { throw null; }
        public static bool AreClose(float value1, float value2) { throw null; }
        public static decimal Clamp(decimal val, decimal min, decimal max) { throw null; }
        public static double Clamp(double val, double min, double max) { throw null; }
        public static int Clamp(int val, int min, int max) { throw null; }
        public static float Clamp(float value, float min, float max) { throw null; }
        public static double Deg2Rad(double angle) { throw null; }
        public static Avalonia.Point GetEllipsePoint(Avalonia.Point centre, double radiusX, double radiusY, double angle) { throw null; }
        public static (double min, double max) GetMinMax(double a, double b) { throw null; }
        public static (double min, double max) GetMinMaxFromDelta(double initialValue, double delta) { throw null; }
        public static double Grad2Rad(double angle) { throw null; }
        public static bool GreaterThan(double value1, double value2) { throw null; }
        public static bool GreaterThan(float value1, float value2) { throw null; }
        public static bool GreaterThanOrClose(double value1, double value2) { throw null; }
        public static bool GreaterThanOrClose(float value1, float value2) { throw null; }
        public static bool IsOne(double value) { throw null; }
        public static bool IsOne(float value) { throw null; }
        public static bool IsZero(double value) { throw null; }
        public static bool IsZero(float value) { throw null; }
        public static bool LessThan(double value1, double value2) { throw null; }
        public static bool LessThan(float value1, float value2) { throw null; }
        public static bool LessThanOrClose(double value1, double value2) { throw null; }
        public static bool LessThanOrClose(float value1, float value2) { throw null; }
        public static double Turn2Rad(double angle) { throw null; }
    }
    public static partial class SpanHelpers
    {
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public static bool TryParseByte(this System.ReadOnlySpan<char> span, System.Globalization.NumberStyles style, System.IFormatProvider provider, out byte value) { throw null; }
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public static bool TryParseDouble(this System.ReadOnlySpan<char> span, System.Globalization.NumberStyles style, System.IFormatProvider provider, out double value) { throw null; }
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public static bool TryParseInt(this System.ReadOnlySpan<char> span, out int value) { throw null; }
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public static bool TryParseUInt(this System.ReadOnlySpan<char> span, System.Globalization.NumberStyles style, System.IFormatProvider provider, out uint value) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct StringTokenizer : System.IDisposable, System.IEquatable<Avalonia.Utilities.StringTokenizer>
    {
        private object _dummy;
        private int _dummyPrimitive;
        public StringTokenizer(string s, char separator = ',', string? exceptionMessage = null) { throw null; }
        public StringTokenizer(string s, System.IFormatProvider formatProvider, string? exceptionMessage = null) { throw null; }
        public string? CurrentToken { get { throw null; } }
        public void Dispose() { }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Utilities.StringTokenizer other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Utilities.StringTokenizer left, Avalonia.Utilities.StringTokenizer right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Utilities.StringTokenizer left, Avalonia.Utilities.StringTokenizer right) { throw null; }
        public double ReadDouble(char? separator = default(char?)) { throw null; }
        public int ReadInt32(char? separator = default(char?)) { throw null; }
        public string ReadString(char? separator = default(char?)) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
        public bool TryReadDouble(out double result, char? separator = default(char?)) { throw null; }
        public bool TryReadInt32(out int result, char? separator = default(char?)) { throw null; }
        public bool TryReadString([System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute(false)] out string result, char? separator = default(char?)) { throw null; }
    }
    public static partial class StyleClassParser
    {
        public static System.ReadOnlySpan<char> ParseStyleClass(this ref Avalonia.Utilities.CharacterReader r) { throw null; }
    }
    public partial class SynchronousCompletionAsyncResultSource<T>
    {
        public SynchronousCompletionAsyncResultSource() { }
        public Avalonia.Utilities.SynchronousCompletionAsyncResult<T> AsyncResult { get { throw null; } }
        public void SetResult(T result) { }
        public void TrySetResult(T result) { }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct SynchronousCompletionAsyncResult<T> : System.IEquatable<Avalonia.Utilities.SynchronousCompletionAsyncResult<T>>, System.Runtime.CompilerServices.INotifyCompletion
    {
        private readonly T _result;
        private object _dummy;
        private int _dummyPrimitive;
        public SynchronousCompletionAsyncResult(T result) { throw null; }
        public bool IsCompleted { get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Utilities.SynchronousCompletionAsyncResult<T> other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        public Avalonia.Utilities.SynchronousCompletionAsyncResult<T> GetAwaiter() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        public T GetResult() { throw null; }
        public void OnCompleted(System.Action continuation) { }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Utilities.SynchronousCompletionAsyncResult<T> left, Avalonia.Utilities.SynchronousCompletionAsyncResult<T> right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Utilities.SynchronousCompletionAsyncResult<T> left, Avalonia.Utilities.SynchronousCompletionAsyncResult<T> right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public sealed partial class TargetWeakEventSubscriber<TTarget, TEventArgs> : Avalonia.Utilities.IWeakEventSubscriber<TEventArgs> where TEventArgs : System.EventArgs
    {
        public TargetWeakEventSubscriber(TTarget target, System.Action<TTarget, object?, Avalonia.Utilities.WeakEvent, TEventArgs> dispatchFunc) { }
        void Avalonia.Utilities.IWeakEventSubscriber<TEventArgs>.OnEvent(object? sender, Avalonia.Utilities.WeakEvent ev, TEventArgs e) { }
    }
    public static partial class TypeUtilities
    {
        public static bool AcceptsNull(System.Type type) { throw null; }
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]public static bool AcceptsNull<T>() { throw null; }
        public static bool CanCast<T>(object? value) { throw null; }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("Implicit conversion methods are required for type conversion.")]
        public static object? ConvertImplicitOrDefault(object? value, System.Type type) { throw null; }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("Implicit conversion methods are required for type conversion.")]
        public static T ConvertImplicit<T>(object? value) { throw null; }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("Conversion methods are required for type conversion, including op_Implicit, op_Explicit, Parse and TypeConverter.")]
        public static object? ConvertOrDefault(object? value, System.Type type, System.Globalization.CultureInfo culture) { throw null; }
        [System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute("Trimming", "IL2067", Justification="We don't care about public ctors for the value types, and always return null for the ref types.")]
        public static object? Default(System.Type type) { throw null; }
        public static bool IsNumeric(System.Type type) { throw null; }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("Conversion methods are required for type conversion, including op_Implicit, op_Explicit, Parse and TypeConverter.")]
        public static bool TryConvert(System.Type to, object? value, System.Globalization.CultureInfo? culture, out object? result) { throw null; }
        [System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute("Implicit conversion methods are required for type conversion.")]
        public static bool TryConvertImplicit(System.Type to, object? value, out object? result) { throw null; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct ValueSpan<T> : System.IEquatable<Avalonia.Utilities.ValueSpan<T>>
    {
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        private readonly T _Value_k__BackingField;
        private readonly int _dummyPrimitive;
        public ValueSpan(int start, int length, T value) { throw null; }
        public int Length { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public int Start { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public T Value { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public bool Equals(Avalonia.Utilities.ValueSpan<T> other) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override bool Equals(object obj) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override int GetHashCode() { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator ==(Avalonia.Utilities.ValueSpan<T> left, Avalonia.Utilities.ValueSpan<T> right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public static bool operator !=(Avalonia.Utilities.ValueSpan<T> left, Avalonia.Utilities.ValueSpan<T> right) { throw null; }
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute]
        public override string ToString() { throw null; }
    }
    public partial class WeakEvent
    {
        public WeakEvent() { }
        public static Avalonia.Utilities.WeakEvent<TSender, System.EventArgs> Register<TSender>(System.Action<TSender, System.EventHandler> subscribe, System.Action<TSender, System.EventHandler> unsubscribe) where TSender : class { throw null; }
        public static Avalonia.Utilities.WeakEvent<TSender, TEventArgs> Register<TSender, TEventArgs>(System.Action<TSender, System.EventHandler<TEventArgs>> subscribe, System.Action<TSender, System.EventHandler<TEventArgs>> unsubscribe) where TSender : class where TEventArgs : System.EventArgs { throw null; }
        public static Avalonia.Utilities.WeakEvent<TSender, TEventArgs> Register<TSender, TEventArgs>(System.Func<TSender, System.EventHandler<TEventArgs>, System.Action> subscribe) where TSender : class where TEventArgs : System.EventArgs { throw null; }
    }
    public static partial class WeakEventHandlerManager
    {
        public static void Subscribe<TTarget, TEventArgs, TSubscriber>(TTarget target, string eventName, System.EventHandler<TEventArgs> subscriber) where TEventArgs : System.EventArgs where TSubscriber : class { }
        public static void Unsubscribe<TEventArgs, TSubscriber>(object target, string eventName, System.EventHandler<TEventArgs> subscriber) where TEventArgs : System.EventArgs where TSubscriber : class { }
    }
    public partial class WeakEvents
    {
        public static readonly Avalonia.Utilities.WeakEvent<Avalonia.AvaloniaObject, Avalonia.AvaloniaPropertyChangedEventArgs> AvaloniaPropertyChanged;
        public static readonly Avalonia.Utilities.WeakEvent<System.Collections.Specialized.INotifyCollectionChanged, System.Collections.Specialized.NotifyCollectionChangedEventArgs> CollectionChanged;
        public static readonly Avalonia.Utilities.WeakEvent<System.Windows.Input.ICommand, System.EventArgs> CommandCanExecuteChanged;
        public static readonly Avalonia.Utilities.WeakEvent<System.ComponentModel.INotifyPropertyChanged, System.ComponentModel.PropertyChangedEventArgs> ThreadSafePropertyChanged;
        public WeakEvents() { }
    }
    public sealed partial class WeakEventSubscriber<TEventArgs> : Avalonia.Utilities.IWeakEventSubscriber<TEventArgs> where TEventArgs : System.EventArgs
    {
        public WeakEventSubscriber() { }
        public event System.Action<object?, Avalonia.Utilities.WeakEvent, TEventArgs>? Event { add { } remove { } }
        void Avalonia.Utilities.IWeakEventSubscriber<TEventArgs>.OnEvent(object? sender, Avalonia.Utilities.WeakEvent ev, TEventArgs e) { }
    }
    public partial class WeakEvent<TSender, TEventArgs> : Avalonia.Utilities.WeakEvent where TSender : class where TEventArgs : System.EventArgs
    {
        internal WeakEvent() { }
        public void Subscribe(TSender target, Avalonia.Utilities.IWeakEventSubscriber<TEventArgs> subscriber) { }
        public void Unsubscribe(TSender target, Avalonia.Utilities.IWeakEventSubscriber<TEventArgs> subscriber) { }
    }
}
namespace Avalonia.Visuals.Platform
{
    public partial class PathGeometryContext : Avalonia.Platform.IGeometryContext, System.IDisposable
    {
        public PathGeometryContext(Avalonia.Media.PathGeometry pathGeometry) { }
        public void ArcTo(Avalonia.Point point, Avalonia.Size size, double rotationAngle, bool isLargeArc, Avalonia.Media.SweepDirection sweepDirection) { }
        public void BeginFigure(Avalonia.Point startPoint, bool isFilled) { }
        public void CubicBezierTo(Avalonia.Point point1, Avalonia.Point point2, Avalonia.Point point3) { }
        public void Dispose() { }
        public void EndFigure(bool isClosed) { }
        public void LineTo(Avalonia.Point point) { }
        public void QuadraticBezierTo(Avalonia.Point control, Avalonia.Point endPoint) { }
        public void SetFillRule(Avalonia.Media.FillRule fillRule) { }
    }
}
namespace Avalonia.VisualTree
{
    public partial interface IHostedVisualTreeRoot
    {
        Avalonia.Visual? Host { get; }
    }
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TransformedBounds : System.IEquatable<Avalonia.VisualTree.TransformedBounds>
    {
        private readonly int _dummyPrimitive;
        public TransformedBounds(Avalonia.Rect bounds, Avalonia.Rect clip, Avalonia.Matrix transform) { throw null; }
        public Avalonia.Rect Bounds { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Rect Clip { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public Avalonia.Matrix Transform { [System.Runtime.CompilerServices.CompilerGeneratedAttribute] get { throw null; } }
        public bool Contains(Avalonia.Point point) { throw null; }
        public bool Equals(Avalonia.VisualTree.TransformedBounds other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Avalonia.VisualTree.TransformedBounds left, Avalonia.VisualTree.TransformedBounds right) { throw null; }
        public static bool operator !=(Avalonia.VisualTree.TransformedBounds left, Avalonia.VisualTree.TransformedBounds right) { throw null; }
        public override string ToString() { throw null; }
    }
    public static partial class VisualExtensions
    {
        public static int CalculateDistanceFromAncestor(this Avalonia.Visual visual, Avalonia.Visual? ancestor) { throw null; }
        public static int CalculateDistanceFromRoot(Avalonia.Visual visual) { throw null; }
        public static T? FindAncestorOfType<T>(this Avalonia.Visual? visual, bool includeSelf = false) where T : class { throw null; }
        public static Avalonia.Visual? FindCommonVisualAncestor(this Avalonia.Visual? visual, Avalonia.Visual? target) { throw null; }
        public static T? FindDescendantOfType<T>(this Avalonia.Visual? visual, bool includeSelf = false) where T : class { throw null; }
        public static System.Collections.Generic.IEnumerable<Avalonia.Visual> GetSelfAndVisualAncestors(this Avalonia.Visual visual) { throw null; }
        public static System.Collections.Generic.IEnumerable<Avalonia.Visual> GetSelfAndVisualDescendants(this Avalonia.Visual visual) { throw null; }
        public static Avalonia.VisualTree.TransformedBounds? GetTransformedBounds(this Avalonia.Visual visual) { throw null; }
        public static System.Collections.Generic.IEnumerable<Avalonia.Visual> GetVisualAncestors(this Avalonia.Visual visual) { throw null; }
        public static Avalonia.Visual? GetVisualAt(this Avalonia.Visual visual, Avalonia.Point p) { throw null; }
        public static Avalonia.Visual? GetVisualAt(this Avalonia.Visual visual, Avalonia.Point p, System.Func<Avalonia.Visual, bool> filter) { throw null; }
        public static System.Collections.Generic.IEnumerable<Avalonia.Visual> GetVisualChildren(this Avalonia.Visual visual) { throw null; }
        public static System.Collections.Generic.IEnumerable<Avalonia.Visual> GetVisualDescendants(this Avalonia.Visual visual) { throw null; }
        public static Avalonia.Visual? GetVisualParent(this Avalonia.Visual visual) { throw null; }
        public static T? GetVisualParent<T>(this Avalonia.Visual visual) where T : class { throw null; }
        public static Avalonia.Rendering.IRenderRoot? GetVisualRoot(this Avalonia.Visual visual) { throw null; }
        public static System.Collections.Generic.IEnumerable<Avalonia.Visual> GetVisualsAt(this Avalonia.Visual visual, Avalonia.Point p) { throw null; }
        public static System.Collections.Generic.IEnumerable<Avalonia.Visual> GetVisualsAt(this Avalonia.Visual visual, Avalonia.Point p, System.Func<Avalonia.Visual, bool> filter) { throw null; }
        public static bool IsAttachedToVisualTree(this Avalonia.Visual visual) { throw null; }
        public static bool IsVisualAncestorOf(this Avalonia.Visual? visual, Avalonia.Visual? target) { throw null; }
        public static System.Collections.Generic.IEnumerable<Avalonia.Visual> SortByZIndex(this System.Collections.Generic.IEnumerable<Avalonia.Visual> elements) { throw null; }
    }
    public partial class VisualLocator
    {
        public VisualLocator() { }
        public static System.IObservable<Avalonia.Visual?> Track(Avalonia.Visual relativeTo, int ancestorLevel, System.Type? ancestorType = null) { throw null; }
    }
}
